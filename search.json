[{"title":"自己在家理寸头，全网最详细教程！","path":"/2025/02/09/自己在家理寸头，全网最详细教程！/","content":"寸头象征着阳刚与正气，是许多男性的理想发型。然而，理发店的师傅往往不按要求剪，导致最终效果令人失望。因此，自己在家理寸头成为一个不错的选择。本文将为你提供一份详尽的DIY寸头教程，助你轻松掌握这项技能。 准备工作在开始前，你需要准备以下工具： 一面可立镜子（最好是全身镜） 一面手持小镜子（方便检查后脑勺） 一把推子（电动理发器） 一副和推子配套的卡尺（3mm—21mm，限位开关梳） 关于卡尺的重要性卡尺（限位梳）的作用是提高容错率。有了卡尺的毫米级限制，无论你如何推，都不会翻车。只需设置好长度，放心推即可。 理寸头的步骤第一步：理后脑勺 12mm：推全面积的后脑勺。 9mm：推6&#x2F;8的面积。 6mm：推4&#x2F;8的面积。 5mm：推3&#x2F;8的面积。 3mm：推最下面的部分。 小技巧：选用较大的卡尺可以增加后脑勺的丰满度，使扁头显得更圆润。如果你的头型本来就很好，可以直接从9mm开始递减。 第二步：推正中间 需要头型修饰的人：推荐18mm，全推完，仅推正中间。 头型较好的人：推荐12mm（仅适用于头小、头圆的人，宽头、扁头慎选）。 推法：贴着头皮推，均匀操作。 第三步：理两侧两侧的头发决定了整体脸型的观感，因此需要谨慎操作。 9mm：先全推一遍，随时照镜子确认。 6mm：推下面2&#x2F;3的面积（上方暂时不动）。 3mm：理最下面的部分，确保干净、工整。 1.5mm：修饰轮廓，剔除杂毛（务必小心）。 针对太阳穴凹陷型头型：建议选用较大的卡尺，使头型更显丰满。 第四步：处理交界处交界处的处理决定了整体发型的层次感。 若中间留18mm，后脑勺12mm，则用15mm过渡。 若两侧最上方留9mm，中间18mm，则用13mm推交界处。 推法：推交界处时，要沿着切线推，不能顺着头皮直接推。 收尾及注意事项多拍视频确认剪的效果如何，理两侧的时候注意不要剪到交界处，卡尺设置的越小的时候需要越谨慎。 整个过程初学者可能需要40分钟左右，但务必保证推干净、整齐，避免出现“狗啃”效果。每个区域都可以多推几次，以确保均匀。 希望这份教程能帮助到想自己理寸头的朋友们，祝你成功剪出满意的发型！"},{"title":"计数排序（Counting Sort）详解","path":"/2025/02/08/计数排序（Counting-Sort）详解/","content":"计数排序是一种非比较排序算法，它的基本思想是利用数组下标来确定元素的位置，从而实现排序。它适合于排序范围较小的正整数集合，在某些特定场景中可以达到线性时间复杂度。 一、计数排序的基本原理计数排序通过以下步骤实现排序： 统计频次： 创建一个额外的计数数组 count，用于存储每个元素的出现次数。计数数组的下标表示输入数据的值。 累积计数： 将计数数组变成累积计数数组，用于确定每个元素的最终位置。 填充输出数组： 根据累积计数数组，将原数组的元素放入正确的位置，从而构建有序数组。 二、计数排序的特点优点： 时间复杂度为 **O(n + k)**，其中 n 是待排序数组的长度，k 是数据的范围（最大值与最小值之间的差值）。 适合于整数范围较小的数据集。 是一种稳定排序算法（相同值的元素在排序后保持原有位置）。 缺点： 需要额外的计数数组和输出数组，占用 O(n + k) 的额外空间。 不适用于元素范围较大的数据集（如浮点数或负数），因为会导致计数数组空间浪费。 只能处理非负整数。如果需要支持负数或浮点数，需要额外的改进。 三、计数排序的实现步骤算法步骤： 找出数组中的最大值和最小值，确定计数数组的大小。 初始化计数数组，将所有元素的计数置为 0。 遍历原数组，统计每个元素的出现次数。 计算计数数组的累积和，用于确定每个元素在结果数组中的位置。 倒序遍历原数组，将每个元素放到结果数组的正确位置，同时更新计数数组。 返回结果数组。 关键点： 倒序遍历：确保算法的稳定性。 累积计数：累积计数数组用于确定元素的最终位置。 四、计数排序代码实现（Python）下面是计数排序的完整实现代码： 1234567891011121314151617181920212223242526272829def counting_sort(arr): # 1. 找到最大值和最小值 max_val = max(arr) min_val = min(arr) range_of_elements = max_val - min_val + 1 # 2. 创建计数数组并初始化为 0 count = [0] * range_of_elements # 3. 统计每个元素的出现频率 for num in arr: count[num - min_val] += 1 # 4. 累积计数 for i in range(1, len(count)): count[i] += count[i - 1] # 5. 倒序遍历原数组，填充输出数组 output = [0] * len(arr) for num in reversed(arr): count[num - min_val] -= 1 output[count[num - min_val]] = num return output# 示例数组arr = [4, 2, 2, 8, 3, 3, 1]sorted_arr = counting_sort(arr)print(&quot;排序后的数组：&quot;, sorted_arr) 运行结果：输入：[4, 2, 2, 8, 3, 3, 1]输出：[1, 2, 2, 3, 3, 4, 8] 五、计数排序的可视化讲解假设我们有一个数组：[4, 2, 2, 8, 3, 3, 1]，对其进行计数排序： 步骤 1：统计频次找到数组的最小值为 1，最大值为 8，构造计数数组 count，初始为： 1count = [0, 0, 0, 0, 0, 0, 0, 0] （长度为 8） 遍历数组，统计每个元素的频次： 12arr = [4, 2, 2, 8, 3, 3, 1]count = [1, 0, 2, 2, 1, 0, 0, 1] 步骤 2：累积计数将计数数组变为累积计数数组： 1count = [1, 1, 3, 5, 6, 6, 6, 7] 步骤 3：倒序填充输出数组根据累积计数数组，倒序遍历原数组，将元素放入正确位置： 倒序遍历 arr = [4, 2, 2, 8, 3, 3, 1] 每次将元素放入 output 数组，并更新 count： 1output = [1, 2, 2, 3, 3, 4, 8] 最终得到排序后的数组。 六、计数排序的改进1. 支持负数计数排序可以通过调整偏移量来支持负数。例如，如果数组的最小值为 -5，最大值为 5，则偏移量为 5，即所有元素加 5 后再进行计数。 2. 多关键字排序计数排序可以用于多关键字排序（如基数排序中的每位排序）。 七、计数排序的应用场景计数排序适合以下场景： 数据范围较小（如考试成绩排序）。 数据是整数（或可以映射为整数）。 对排序稳定性有要求。 八、总结计数排序是一种高效且简单的非比较排序算法，尤其在数据范围较小时，性能优于许多复杂的排序算法。它的时间复杂度为 **O(n + k)**，空间复杂度也为 **O(n + k)**，但由于额外的空间需求，不适用于非常大的数据范围。通过适当改进，计数排序可以支持负数和多关键字排序，在实际中具有广泛的应用价值。 关键点复习： 计数排序是稳定排序。 时间复杂度为线性，但空间复杂度较高。 核心在于“统计”和“累积”两个步骤。 希望这篇文章能帮助你掌握计数排序！ 😊"},{"title":"JavaScript 常用 API 总结","path":"/2025/02/08/JavaScript-常用-API-总结/","content":"在 JavaScript 开发中，掌握一些常用的 API 可以极大地提高代码的效率和可读性。今天我们来总结两个非常实用的方法：includes 和 toFixed。这两个方法分别用于字符串&#x2F;数组的检查和数字格式化，是日常开发中的高频工具。 1. includes 方法includes 是 JavaScript 中用于检查字符串或数组是否包含某个元素的方法。它返回一个布尔值（true 或 false），表示目标是否存在于字符串或数组中。 语法：12345// 字符串str.includes(searchValue, startIndex);// 数组arr.includes(searchElement, fromIndex); 参数： searchValue &#x2F; searchElement：需要查找的值或元素。 startIndex &#x2F; fromIndex（可选）：从哪个位置开始查找，默认为 0。 示例：123456789// 字符串let str = &quot;Hello, world!&quot;;console.log(str.includes(&quot;world&quot;)); // trueconsole.log(str.includes(&quot;JavaScript&quot;)); // false// 数组let arr = [1, 2, 3, 4, 5];console.log(arr.includes(3)); // trueconsole.log(arr.includes(10)); // false 特点： 区分大小写。 适用于字符串和数组。 可以指定起始查找位置。 2. toFixed 方法toFixed 是 JavaScript 中用于格式化数字的方法，可以将数字保留指定的小数位数，并返回一个字符串。 语法：1num.toFixed(digits); 参数： digits：需要保留的小数位数，范围是 0 到 20。 示例：1234let num = 123.456789;console.log(num.toFixed(2)); // &quot;123.46&quot;console.log(num.toFixed(0)); // &quot;123&quot;console.log(num.toFixed(5)); // &quot;123.45679&quot; 特点： 返回的结果是字符串类型。 如果小数位数不足，会自动补零。 如果小数位数超过指定值，会进行四舍五入。 JavaScript 常用 API 列表除了 includes 和 toFixed，JavaScript 还有许多其他常用的 API，以下是一些高频使用的工具： 字符串相关： split()：将字符串按指定分隔符拆分为数组。 substring()：提取字符串的子串。 replace()：替换字符串中的内容。 trim()：去除字符串两端的空白字符。 数组相关： map()：对数组中的每个元素执行操作，并返回新数组。 filter()：过滤数组中的元素，返回符合条件的元素组成的新数组。 reduce()：将数组中的元素累积为一个值。 slice()：提取数组的一部分，返回新数组。 数字相关： parseInt()：将字符串解析为整数。 parseFloat()：将字符串解析为浮点数。 Math.round()：四舍五入。 Math.random()：生成随机数。 其他常用 API： JSON.parse()：将 JSON 字符串解析为对象。 JSON.stringify()：将对象转换为 JSON 字符串。 setTimeout()：延迟执行函数。 setInterval()：定时执行函数。 总结includes 和 toFixed 是 JavaScript 中非常实用的方法，分别用于检查元素是否存在和格式化数字。掌握这些 API 可以让你的代码更加简洁高效。除此之外，JavaScript 还提供了丰富的内置方法，熟练使用它们可以极大地提升开发效率。希望这篇博客能帮助你更好地理解和使用这些工具！ 🚀"},{"title":"如何克服完美主义，提高刷题效率？","path":"/2025/02/08/如何克服完美主义，提高刷题效率？/","content":"在编程学习和刷题过程中，我们常常会遇到一些心理障碍，而 完美主义 就是其中之一。很多人（包括我自己）会在解题前犹豫不决，担心自己的方案不够优雅，或者一旦出错就影响了整体表现。这种追求“完美”的心理，反而会降低效率，甚至让我们逐渐产生抵触情绪。 那么，完美主义如何影响我们的解题过程？我们又该如何克服它呢？ 完美主义如何影响刷题效率？1. 对错误的过度敏感完美主义者往往对错误异常敏感，生怕代码不够“完美”或会犯错。于是，在真正开始解题前，我们可能会反复斟酌各种可能的陷阱，导致迟迟不敢动手。 但其实，编程本就是一个不断试错的过程。大部分情况下，我们并不需要一开始就写出完美的代码，而是先完成一个可运行的版本，再进行优化。 2. 害怕失败，导致自我怀疑完美主义者的自尊心往往与成功高度绑定，一旦遇到困难或错误，就容易产生强烈的自我怀疑。长此以往，每次看到新的题目，我们都会不自觉地预设自己可能失败，从而抗拒挑战。 然而，真正的高手并不是从不犯错，而是能够从错误中快速调整，并找到更优解。 3. 过度关注细节，忽略全局思路在刷题过程中，我们可能会花费大量时间在代码的某个细节上，试图让它更加“完美”，而忽略了整体思路。最终，不仅解题速度慢，可能还会因为深陷细节而卡住，导致效率低下。 有效的方法是 先找到一个“够用”的解法，再逐步优化，而不是一开始就追求极致。 4. 拖延与优柔寡断完美主义者往往在没有找到“最佳方案”前，不愿意贸然动手，生怕代码不够优雅。这种拖延可能会导致刷题变成一种心理负担，甚至让人产生畏难情绪，久而久之，越刷越累，甚至完全放弃。 实际上，许多算法竞赛的选手都会采取 “先写出来，再优化” 的策略，而不是从一开始就想出最优解。 5. 负面情绪和自我强化循环每当我们因为追求完美而拖慢解题速度，或者因为害怕错误而逃避刷题，我们的内心就会积累负面情绪，并进一步加深“我不擅长刷题”的刻板印象。久而久之，我们可能会越来越焦虑，甚至对编程失去兴趣。 如何克服完美主义，提高刷题效率？1. 允许自己犯错，降低完美标准要接受这样一个事实：任何高手都是从试错中成长起来的。错误并不意味着失败，而是改进的机会。 你可以试着给自己设定一个“容错率”，比如：✅ 如果 80% 的题目都能通过，就算完成任务。✅ 如果代码能运行，就算初步成功，优化可以放到后面。 2. 设定“分阶段目标”，不要一开始就追求完美许多人在解题时习惯性想“一步到位”，但现实是：大多数算法题的最佳解法并不会一下子就浮现出来。 更有效的方式是： 第一阶段：先写一个“能跑通的”解法，即使是暴力解，也不要紧。 第二阶段：思考如何优化，比如降低时间复杂度或减少冗余代码。 第三阶段：优化代码风格，考虑边界情况，提升可读性。 这种 渐进式优化 的方法，可以减少心理压力，同时保持解题效率。 3. 限时思考，不纠结细节如果你发现自己在同一个地方卡住太久，不妨给自己设定一个时间限制：⏳ “10 分钟内想不出优化方案，就先提交再说”。⏳ “如果 30 分钟还没有头绪，就去看题解，理解思路再自己实现”。 这样可以帮助你跳出“思维卡死”的状态，提高刷题节奏。 4. 参加讨论，看看别人的思考过程完美主义者通常会觉得“自己的代码必须独立完成，不能参考别人”。但在现实中，即使是顶级程序员，也会参考别人的代码风格，吸收新的思维方式。 你可以尝试： 在 LeetCode、牛客等平台看别人是怎么解题的，学习不同的解法。 和朋友或社区讨论，看看别人如何思考问题。 写一篇自己的题解，总结不同的思路，帮助自己摆脱“必须完美”的束缚。 5. 记住：比完美更重要的是持续进步与其想着“一次性把题目做到完美”，不如考虑“如何让自己每一天比昨天进步一点点”。 你可以尝试建立一个“成长日志”，记录：📌 今天刷了哪些题？📌 遇到了哪些困难？📌 学到了哪些新的解法？📌 下次可以怎么改进？ 当你回顾这些记录时，你会发现自己的进步远比一两次解题的完美程度更重要。 总结完美主义会让我们在刷题时产生拖延、害怕失败、关注细节过多等问题，最终影响效率和兴趣。 但如果我们能够 接受不完美、设定阶段目标、限时思考、借助外部资源，并关注长期成长，就能慢慢克服这种心理障碍，提高刷题效率，同时享受编程的乐趣。 🌟 记住：编程的本质不是“完美”，而是“不断进步”！ 🚀"},{"title":"AI 降低编程门槛，但业务理解依然是核心竞争力","path":"/2025/02/07/AI-降低编程门槛，但业务理解依然是核心竞争力/","content":"近年来，人工智能在编程领域的应用日益广泛。从自动代码生成、代码补全到智能调试工具，AI 正在不断改变我们写代码的方式，大大降低了编程的入门门槛。然而，编程的本质并不仅仅在于写出“正确”的代码，而是通过技术手段解决现实中的业务问题。因此，深入理解业务逻辑、掌握需求本质依然是程序员不可或缺的核心竞争力。 AI 技术：效率提升与门槛降低人工智能工具的出现，使得许多重复性和低层次的编程任务得到了有效的自动化。新手可以借助这些工具快速上手、实现基本功能；老手也能借此提高开发效率，更多地关注系统架构和业务需求。然而，这些工具只能辅助编程，而无法替代对复杂业务场景的深入理解和逻辑分析。正因为如此，在享受 AI 带来的便利时，我们依然需要不断加强自身的业务敏感度和分析能力。 业务理解：编程的“灵魂”无论是开发企业级应用还是构建互联网产品，业务需求都是我们最终要解决的核心问题。业务场景通常复杂多变，涉及市场、用户、流程等多个层面。只有真正理解业务逻辑，才能设计出既高效又符合实际需求的解决方案。编程工具再强大，如果脱离了对业务本质的把握，也只能生产出“表面”上看似完美、但实则难以应对真实场景的代码。 LeetCode 题目：锻炼逻辑思维与问题解决能力刷 LeetCode 等算法题目的过程，其实也是在不断训练我们对问题本质的抽象、分解和逻辑推演能力。虽然这些题目大多是纯粹的算法问题，但在解题过程中，我们往往需要思考问题的约束、寻找高效的解决方案，并验证答案的正确性。这一系列训练不仅能帮助我们打牢基础的编程逻辑，也能为面对复杂业务场景时提供思维工具。 可以说，LeetCode 题目和实际业务场景虽有差异，但它们在培养我们解决问题的能力上有着共通之处。在编程过程中，我们既需要具备扎实的算法基础，也要学会将这些思维方式应用到具体的业务逻辑分析中。只有两者结合，才能真正做到技术与业务的无缝融合。 平衡 AI 辅助与业务理解的挑战在实际项目开发中，如何平衡利用 AI 提高开发效率和加强业务理解，是每个开发者需要面对的挑战。我们可以从以下几个方面着手： 不断学习与实践：在借助 AI 工具提升效率的同时，不忘深入了解业务领域的知识。通过项目实践、与业务部门的沟通交流，真正理解用户需求与市场变化。 培养逻辑思维：利用 LeetCode 等平台训练问题抽象和解决能力。虽然算法题目与业务问题存在一定差异，但它们都在锻炼我们的逻辑思考和问题拆解能力，这对于解决实际问题非常有帮助。 跨领域合作：技术团队与业务部门之间应建立良好的沟通机制。技术人员不仅要学会用工具提高效率，更要学会倾听业务需求，从而设计出符合实际场景的技术解决方案。 持续迭代与优化：业务场景是不断变化的，技术方案也需要不断迭代。保持对新技术、新业务模式的敏感性，及时调整和优化系统架构，才能在激烈的市场竞争中立于不败之地。 结语AI 正在改变我们的编程方式，为开发工作带来前所未有的便利。然而，技术永远只是工具，理解和把握业务需求才是解决问题的根本。LeetCode 题目在培养逻辑思维和问题解决能力方面具有不可替代的作用，但这仅仅是技术修炼的一部分。只有将 AI 的高效与对业务深刻的理解相结合，我们才能真正做到用技术解决实际问题，实现技术与业务的完美融合。"},{"title":"Conda vs Pip：Python 包管理的区别与选择","path":"/2025/02/05/Conda-vs-Pip：Python-包管理的区别与选择/","content":"在 Python 开发和深度学习研究中，包管理是不可避免的任务。conda 和 pip 是最常见的两个包管理工具，但它们在工作原理、适用场景和管理方式上有明显区别。本文将对比 conda 和 pip 的主要差异，并给出最佳实践建议。 1. Conda vs Pip：核心区别 特性 Conda Pip 管理范围 Python 及非 Python 依赖 仅 Python 包 依赖解析 严格，避免冲突 可能发生冲突 包来源 Anaconda、Conda Forge PyPI 安装速度 快，二进制包 可能编译源码，较慢 适用场景 科学计算、深度学习 一般 Python 开发 1.1 管理范围 **conda**：管理 Python 包、C&#x2F;C++ 库、编译工具，甚至 Python 解释器本身，是一个完整的环境管理工具。 **pip**：专注于 Python 生态，只能管理 Python 语言的包，无法管理底层依赖，如 C&#x2F;C++ 代码。 1.2 依赖管理 conda 通过 conda solve 解析依赖，确保所有库兼容，防止包冲突。 pip 依赖解析能力较弱，可能导致多个库的版本冲突。 1.3 安装速度 conda 提供预编译的二进制包，安装速度更快。 pip 可能需要从源码编译（如 pip install pandas），安装时间较长。 2. Conda vs Pip：适用场景适用于 Conda 的场景 科学计算（NumPy、SciPy、Pandas 等） 深度学习（TensorFlow、PyTorch） 需要不同 Python 版本的环境管理 安装依赖较多的项目 适用于 Pip 的场景 轻量级 Python 项目（如 Web 开发） 仅需要 Python 生态内的库 Conda 仓库中找不到的特殊 Python 包 3. 最佳实践：如何选择？ 优先使用 Conda：如果项目涉及科学计算或深度学习，建议使用 Conda 创建环境，避免依赖冲突。 conda create -n my_env python=3.8 numpy pandas conda activate my_env 混合使用 Pip：如果 Conda 没有需要的包，可以使用 Pip 进行补充，但要小心依赖冲突。 conda install numpy pandas pip install some_package_not_in_conda 避免 Conda 和 Pip 交叉安装：如果必须混合使用，建议先用 conda install 安装核心依赖，再用 pip install 安装额外包。 4. 总结 conda 适用于科学计算和深度学习，可管理 Python 及非 Python 依赖，安装速度快，依赖管理更可靠。 pip 更适用于一般 Python 开发，安装轻量级 Python 包，但在复杂依赖管理上较弱。 最佳实践：先用 conda 安装大部分包，再用 pip 补充特殊包，避免依赖冲突。 选择合适的包管理工具可以大大提高 Python 开发的效率，尤其是在处理复杂的依赖关系时。希望这篇文章能帮助你更好地理解 conda 和 pip 的区别，并在合适的场景下做出最佳选择！"},{"title":"Git 配置文件详解：.gitconfig 与 .git-credentials 的区别","path":"/2025/02/01/Git-配置文件详解：-gitconfig-与-git-credentials-的区别/","content":"在使用 Git 进行版本控制时，我们经常需要配置用户名、邮箱、凭据等信息。Git 提供了多个配置文件来管理这些设置，其中 .gitconfig 和 .git-credentials 是最常见的两个文件。本文将深入介绍它们的作用、存储位置以及如何正确使用。 1. .gitconfig —— Git 全局与项目级配置.gitconfig 是 Git 的配置文件，主要用于存储 Git 的全局或项目级配置，比如用户名、邮箱、别名、自定义编辑器等。 .gitconfig 的作用 设定 Git 用户名和邮箱 自定义 Git 命令别名 配置换行符、编辑器等行为 设定 Git 远程仓库的协议和代理 .gitconfig 的存储位置 级别 位置 适用范围 全局 ~/.gitconfig（Linux&#x2F;macOS）C:\\Users\\用户名\\.gitconfig（Windows） 影响所有 Git 仓库 项目级 .git/config（Git 仓库根目录） 仅影响当前仓库 .gitconfig 示例123456789101112[user] name = Your Name email = your.email@example.com[core] editor = vim # 设置 Git 默认编辑器为 Vim[alias] co = checkout # 别名：git co 等同于 git checkout br = branch ci = commit st = status 在终端中，可以使用以下命令设置这些配置： 1234git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;your.email@example.com&quot;git config --global core.editor vimgit config --global alias.co checkout 如果要设置仅适用于当前仓库的配置，则去掉 --global： 1git config --local user.name &quot;Project Name&quot; 2. .git-credentials —— Git 身份认证存储.git-credentials 主要用于存储 Git 的身份认证信息（用户名和密码），以便 Git 访问远程仓库时无需重复输入凭据。 .git-credentials 的作用 让 Git 自动使用存储的用户名和密码进行身份验证 适用于 HTTPS 认证方式（SSH 认证不需要此文件） 避免频繁输入密码，提高效率 .git-credentials 的存储位置默认情况下，Git 在用户主目录下存储该文件： Linux&#x2F;macOS：~/.git-credentials Windows：C:\\Users\\用户名\\.git-credentials .git-credentials 示例1https://username:password@github.com ⚠️ 注意：此文件存储的是明文密码，可能存在安全风险！ 3. Git 凭据管理方法Git 提供了不同的凭据管理助手（Credential Helper），可以安全存储认证信息： 3.1 使用 store（明文存储，风险较大）Git 会将用户名和密码存储在 .git-credentials 文件中，每次访问远程仓库时自动使用： 1git config --global credential.helper store 但由于 .git-credentials 明文存储密码，安全性较低，不推荐在公开或多人使用的环境下使用。 3.2 使用 cache（内存缓存，默认 15 分钟）Git 会在内存中缓存凭据，过一段时间后自动清除： 1git config --global credential.helper cache 可以修改缓存时间（单位：秒），如缓存 1 小时： 1git config --global credential.helper &quot;cache --timeout=3600&quot; 这种方式相对安全，因为密码不会长期存储在文件中。 3.3 使用 manager（Windows 专用，推荐）在 Windows 上，可以使用 manager，Git 会将凭据存储到 Windows 凭据管理器中： 1git config --global credential.helper manager 这种方法比明文存储更安全，推荐 Windows 用户使用。 4. 如何安全地管理 Git 认证？由于 .git-credentials 直接存储密码，存在较大的安全隐患，因此更推荐以下方式进行身份认证： 使用 SSH 认证（推荐）： 生成 SSH 密钥：1ssh-keygen -t rsa -b 4096 -C &quot;your.email@example.com&quot; 将公钥添加到 GitHub&#x2F;GitLab：1cat ~/.ssh/id_rsa.pub 以后使用 SSH 方式克隆仓库：1git clone git@github.com:your_username/repository.git 使用个人访问令牌（PAT）（适用于 HTTPS）： 在 GitHub 生成 PAT（GitHub 个人访问令牌） 使用 PAT 替代密码：1git clone https://your_username:PAT@github.com/your_username/repository.git 使用 Git Credential Manager（推荐 Windows 用户）： 自动管理凭据，避免手动输入密码 适用于 GitHub、GitLab、Bitbucket 等平台 5. .gitconfig vs .git-credentials 对比总结 文件 作用 存储位置 是否包含敏感信息 .gitconfig Git 配置（用户名、别名、编辑器等） ~/.gitconfig 或 .git/config 否 .git-credentials 存储 Git 认证凭据（用户名和密码） ~/.git-credentials 是（明文存储，需谨慎） 最佳实践： 使用 .gitconfig 设置用户名、别名和编辑器等，避免存储敏感信息。 尽量使用 SSH 认证或 Git Credential Manager，避免明文存储密码。 **如需缓存凭据，使用 credential.helper cache 而非 store**，提升安全性。 结论.gitconfig 和 .git-credentials 都是 Git 重要的配置文件，但用途不同： .gitconfig 主要用于 Git 的全局或项目级配置，不涉及密码存储。 .git-credentials 用于存储 Git 认证信息，但由于明文存储密码，存在安全隐患，建议使用更安全的方法（如 SSH 认证或 PAT）。 在日常 Git 使用中，安全性至关重要，推荐优先使用 SSH 认证，或者在 Windows 上使用 Git Credential Manager 来管理凭据，确保代码仓库的安全性。","tags":["Git"]},{"title":"cursor使用技巧总结","path":"/2025/01/30/cursor使用技巧总结/","content":"https://zhuanlan.zhihu.com/p/19886296883 AI编程的三条重要经验：如何更高效地使用 Cursor在使用 Cursor 进行编程以及帮助群友解答问题的过程中，我总结出了三条关键经验，希望能帮助大家更好地利用 AI 提升编程效率。 现象分析在分享经验之前，我们先来看两个常见的现象： AI 的输出是有限的如果在一次对话中提出了过多的需求，AI 可能只能满足其中一部分，甚至有时一个都无法实现。 AI 可能会陷入死循环有些情况下，AI 可能会反复输出错误的代码，无论怎么修改都无法正确实现。这往往是因为上下文信息干扰了 AI 的判断，或者 AI 在服务端缓存了相似的提示词，导致多次命中同一片段，形成循环。 三条关键经验基于上述现象，我总结了三条经验，帮助大家更高效地使用 Cursor 进行 AI 编程。 1. 小型项目适合 AI 处理，但要避免一次性提出过多需求AI 在开发 静态网站、小程序、Python 脚本 等小型项目时，能够显著提高效率，不论是零基础用户还是经验丰富的程序员，都可以借助 AI 事半功倍。 但要注意： 避免在一个提示词中提出过多需求，否则 AI 可能无法完全满足要求。 一次提出一个需求，逐步解决问题，再继续下一个优化点。 有些人认为，一个强大的提示词可以让 AI 直接完成整个项目，实际上这种方式的体验往往很差。过分依赖 AI 一步到位，反而会走弯路。 2. 复杂项目需要拆解，逐步优化目前的 AI 仍然难以处理 复杂项目中各部分代码的逻辑关系，这需要我们人为地拆分任务，逐步优化。 建议： 先梳理项目结构，确保 AI 能理解各个模块之间的关系。 让 AI 只处理某个小模块，这样它往往能提供比人类更优的方案。 修复 Bug 是 AI 最擅长的，我们可以借助它快速调试代码。 如果是为一个复杂项目进行 二次开发，AI 可能很难一开始就掌握整个项目的逻辑。此时，先让 AI 了解项目结构，再逐步优化某些功能，会更加高效。 3. 复杂项目仍然需要一定的编程基础如果你完全没有编程经验，AI 可以帮助你完成一些简单项目，比如自动化脚本、小工具等。但是对于 复杂项目，如果你无法精准指出问题所在，单纯依赖 AI 让它自行解决，可能会耗费大量时间和精力。 所以，想要在 AI 辅助下开发更复杂的项目，你至少需要具备以下能力： 能够 读懂 AI 生成的代码，理解它的逻辑。 能够 明确定位 Bug，描述代码问题，而不是仅仅说“程序运行不对”。 简单来说，5 分钟编写一个小应用只是你入门 AI 编程的第一步，如果想做更复杂的项目，仍然需要掌握一些基础的编程知识。 结语AI 编程最重要的不是各种技巧，而是如何与 AI 更好地协作、沟通。只有通过不断实践，从完成第一个“垃圾”应用开始，才能真正找到 AI 编程的感觉，提升开发效率。 与 AI 并肩作战，让编程变得更高效！ 🚀","tags":["AI工具效率提升"]},{"title":"JavaScript ACM模式","path":"/2025/01/26/JavaScript-ACM模式/","content":"1234567891011121314151617const readline = require(&#x27;readline&#x27;);const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout&#125;);function processInput() &#123; rl.on(&#x27;line&#x27;, (input) =&gt; &#123; //const [a,b] = input.split(&#x27; &#x27;).map(Number); //const sum = a + b; //console.log(sum); &#125;)&#125;processInput();"},{"title":"sharedchat会话管理工具总结","path":"/2025/01/25/sharedchat会话管理工具总结/","content":"由技术变化产生的新需求，基于L站sharedchat的拓展，技术没有太高门槛，成熟的技术团队要么不愿意做要么没有看到技术变革产生的新用户群体。"},{"title":"如何在软件开发中平衡时间与文档效益成本","path":"/2025/01/24/如何在软件开发中平衡时间与文档效益成本/","content":"在软件开发过程中，文档常常是容易被忽视但又非常重要的环节。由于时间紧张或图省事，许多开发者倾向于简略甚至不写文档，导致后续遇到同样问题时浪费大量时间。如何高效记录关键问题和解决方案，同时避免浪费过多时间？以下是一些建议。 1. 明确文档的目标和范围 目标导向：不是所有内容都需要详细记录，文档的重点应该是能解决实际问题。例如，记录复杂的系统架构、重要的设计决策、容易复现的错误及解决方法。 适度详细：避免面面俱到，只记录对团队或自己最重要的信息。例如，技术决策只需记录“为什么选择这个方案”，而不是每个细节。 2. 使用高效的文档工具 简单易用：选择适合团队的工具，比如 Notion、Confluence、GitHub 的 README 或 Issues，甚至是本地的 Markdown 文档。 模板化：准备好通用模板（例如问题描述、复现步骤、解决方法），减少每次记录时的重复工作。 自动化记录：通过自动化工具捕获关键信息，比如集成 Git hooks，在提交时自动生成变更说明。 3. 文档撰写与开发同步 “随手写”文化：在开发过程中，把时间碎片化，随时记录问题的解决思路，而不是事后补充。 在重要节点更新文档：比如在功能完成、Bug 修复或者迭代结束时，将这些知识点简洁记录下来。 4. 团队协作与分享 定期回顾文档：定期组织团队成员讨论文档中内容，避免重复踩坑，同时也能改进文档的质量。 知识共享：将重要文档标记为知识库的一部分，方便团队后续查阅。 5. 快速迭代与精简 初稿优先：文档不必一开始就完善，哪怕是简单的要点式记录，后续可以补充完善。 定期清理：对过时的文档内容定期清理或归档，避免后期内容臃肿。 6. 引入文档相关指标 设置轻量化的考核指标（如：关键功能的文档覆盖率、复现 Bug 的解决率等）提升文档编写的主动性，但要避免过于形式化。 7. 经验总结 问题积累表：定期将问题与解决方法分类整理，形成一个可快速查询的“问题与解决方案”库。 复盘机制：项目结束后，梳理过程中遇到的坑和经验，形成长期价值的技术沉淀。 总结好的文档不是负担，而是投资。通过建立简洁高效的文档体系，可以为团队节省大量时间，同时避免重复劳动。关键在于培养“轻量化记录”的习惯，用最少的精力产出最大效益。"},{"title":"vue组件通信","path":"/2025/01/24/vue组件通信/","content":"Vue组件需要通信的几个原因： 数据共享：在一个应用中，不同组件可能需要访问相同的数据。例如，一个购物车组件可能需要访问商品列表组件中的商品数据。 状态管理：随着应用的增长，状态管理变得复杂。组件之间可能需要共享状态，如用户登录状态、应用配置等。 事件传递：组件可能需要通知其他组件某些事件的发生，例如用户点击按钮、数据更新完成等。 解耦：良好的组件设计应该是低耦合的，这意味着它们应该是相互独立的。组件间通信机制可以帮助实现这一点，使得组件可以独立开发和测试。 重用性：通过定义良好的通信接口，组件可以更容易地在不同的上下文中重用。 以下是一些区分父子组件的方法： 模板中的使用关系： 父组件：在父组件的模板中，你可以看到子组件的标签 &lt;ChildComponent /&gt;。 子组件：子组件是在父组件的模板中被调用的，它不知道父组件的具体实现。 组件定义： 父组件：通常会在一个较大的视图中定义，它可能包含多个子组件。 子组件：通常是为了重用而创建的，它可能被多个父组件使用。 数据传递： 父组件：通过props向子组件传递数据。 子组件：可以通过props接收来自父组件的数据。 事件通信： 父组件：可以监听子组件发出的事件。 子组件：可以通过$emit方法触发事件，通知父组件某些事情发生了。 组件生命周期： 父组件：在创建和挂载时，会先于子组件。 子组件：在父组件的mounted生命周期钩子之后，子组件才会被挂载。 组件实例关系： 父组件：可以通过this.$children访问所有子组件的实例。 子组件：可以通过this.$parent访问父组件的实例。 props和events是组件通信的两种主要机制，它们分别用于父组件向子组件传递数据和子组件向父组件发送消息。下面是它们的区别： Props（属性）Props 是父组件向子组件传递数据的方式。Props 是子组件的属性，允许父组件将数据传递给子组件。 用途：用于数据传递，通常用于配置子组件的初始状态或传递静态数据。 方向：单向数据流，从父组件流向子组件。 数据类型：可以是任何类型的数据，包括数字、字符串、对象、数组、函数等。 特点： 子组件通过定义props选项来声明它期望从父组件接收的数据。 父组件在模板中通过属性的方式将数据传递给子组件。 子组件不能直接修改props，这是Vue.js的单一数据流原则的一部分。 Events（事件）Events 是子组件向父组件发送消息的方式。在Vue.js中，通常使用$emit方法来触发事件。 用途：用于通知父组件某些事件的发生，例如用户操作、数据更新等。 方向：从子组件向父组件传递消息。 数据类型：通常是字符串，表示事件的名称。 特点： 子组件可以在需要时通过$emit方法触发事件，并将数据作为参数传递给父组件。 父组件可以在模板中通过v-on指令监听子组件触发的事件，并执行相应的操作。 事件可以携带任意数据作为参数，父组件可以在事件处理函数中接收这些数据。"},{"title":"理解深度学习中的过拟合","path":"/2025/01/22/理解深度学习中的过拟合/","content":"在深度学习和机器学习中，过拟合是一个常见且重要的问题。尤其对于研究人员和工程师来说，理解过拟合的成因以及如何防止它，是实现模型泛化能力的关键。本篇文章将从基本概念出发，帮助你理解什么是过拟合，以及如何有效应对这一问题。 什么是过拟合？过拟合（Overfitting）是指模型在训练数据上表现得非常好，但在测试数据（或新数据）上的表现差，说明模型过度“记忆”了训练数据中的特征，而不是学到了能够普遍适用的规律。换句话说，模型不仅学习了数据中的真实模式，还学习了训练数据中的噪声和无关因素，这使得它无法有效地泛化到新的数据。 过拟合的直观例子假设我们有一组房屋数据，包含房屋的面积和价格。如果我们用一个非常复杂的模型（例如多项式回归）来拟合数据，可能会得到一条非常复杂的曲线，它几乎完美地通过了每个数据点。但是，这种曲线可能只是“记住”了训练数据的具体点，而没有学习到“房屋面积与价格之间的一般规律”。当我们将模型应用于新的房屋数据时，这条复杂的曲线就可能不再有效，预测结果也会变得不准确。这就是过拟合的典型表现。 过拟合的原因过拟合主要由以下几个因素引起： 模型复杂度过高：当模型的参数过多时，它有能力学习训练数据中的所有细节（包括噪声）。这对于训练集可能是有利的，但对于测试集却是灾难性的。 训练数据不足：如果训练数据量太小，模型可能无法学到数据的普遍规律，而是依赖于训练集中的偶然性特征。 数据噪声：训练数据中的噪声（即非规律性的信息）可能会干扰模型的学习，导致模型过拟合。 如何防止过拟合？ 正则化（Regularization） 正则化是防止过拟合的常见技术。它通过在损失函数中加入一个惩罚项来限制模型的复杂度。常见的正则化方法包括： L1正则化：通过惩罚模型中权重的绝对值来促使某些特征的权重变为零，实现特征选择。 L2正则化：通过惩罚权重的平方，防止模型过度依赖某些特定的特征。 Dropout Dropout是一种通过随机“丢弃”神经网络中部分神经元的技术。它有效地防止了模型对某些特征的过度依赖，从而增强了模型的泛化能力。 数据增强 增加训练数据的多样性是防止过拟合的另一种有效方法。通过对原始数据进行变换（例如旋转、平移、缩放等），可以生成更多的训练样本，帮助模型学习到更加一般化的特征。 交叉验证 交叉验证是一种用于评估模型泛化能力的技术。它将训练数据分成多个子集，每次训练时选择一个子集作为验证集，其他子集作为训练集。通过这种方法，能够获得更加稳健的性能评估，防止模型在某一特定训练集上表现过好。 简化模型 如果模型过于复杂，可以尝试简化它。使用较少的神经元、较浅的网络结构或者更简单的算法，通常可以减少过拟合的风险。 早停（Early Stopping） 在训练过程中，早停方法会监控验证集的误差，并在验证误差不再下降时停止训练。这样可以防止模型在训练集上过度拟合，保持泛化能力。 总结过拟合是深度学习中必须关注的一个问题，它会导致模型在新数据上表现不佳。为了防止过拟合，我们可以使用正则化、数据增强、交叉验证等技术，同时也要关注模型的复杂度和训练数据的质量。只有通过不断调整和优化，才能找到既能在训练集上学习到规律，又能在测试集上良好表现的模型。 通过理解过拟合，并采取适当的防治措施，研究人员和工程师能够设计出更加稳健和有效的深度学习模型。这也是深度学习研究中的一个核心目标。"},{"title":"vue中slot总结","path":"/2025/01/21/vue中slot总结/","content":""},{"title":"hexo博客中插入图片语法","path":"/2025/01/21/hexo博客中插入图片语法/","content":"1&#123;% asset_img xxx.png xxx %&#125;"},{"title":"vue中props传值总结","path":"/2025/01/21/vue中props传值总结/","content":""},{"title":"软件开发中的业务理解与技术实现：从开发人员到架构师的思维转变","path":"/2025/01/17/软件开发中的业务理解与技术实现：从开发人员到架构师的思维转变/","content":"在软件开发的过程中，很多时候我们习惯性地将注意力集中在技术上，尤其是对于普通开发人员而言，技术能力的提升常常是日常工作的重要目标。然而，若从长远发展和项目成功的角度来看，业务理解与技术的结合才是推动软件项目顺利进展的关键。本文将深入探讨如何在开发过程中既理解业务，又结合架构师的思维来实现高效的软件开发。 1. 业务驱动软件开发软件开发的最终目的是服务于业务需求，解决实际问题。在许多情况下，开发人员容易陷入纯技术的思维框架中，而忽视了业务本身的需求与逻辑。实际上，理解和解决业务问题是软件开发的首要任务。无论开发的系统是面向用户的应用程序，还是企业内部的工具，最终的设计和实现都应该是基于业务需求来进行的。 一个典型的误区是，开发人员仅仅关注技术上的“能不能做”，而忽略了“应该做什么”的问题。比如，在开发过程中，我们会面临很多选择：使用何种技术栈、如何设计架构、如何拆分功能模块等。这时，单纯的技术判断往往会忽视了项目的业务目标。只有深入理解业务需求，才能做出合理的技术决策，保证技术架构与业务目标的一致性。 2. 将架构师思维融入业务理解虽然普通开发人员和架构师的角色有所不同，但在工作中我们可以从架构师的角度思考问题，这对推动软件项目进展极为重要。架构师不仅要理解技术，还要能够从全局角度审视业务和技术的结合。对于普通开发人员来说，学习架构师的思维方式有助于提升整体问题的解决能力。 架构师思维的核心是系统性思考，即从整体上把握业务需求并将其转化为技术方案。普通开发人员如果能够从这个角度思考，会对代码的设计、模块间的交互、系统的可扩展性、可维护性等方面有更深的理解。这不仅能提升开发效率，减少后期的重构，还能避免技术债务的累积。 例如，假设你在开发一个客户管理系统，业务需求涉及多个部门的协同工作。架构师可能会提出将系统分为多个微服务，按需提供不同的数据访问层和业务处理模块。对于开发人员来说，了解这个架构设计背后的业务逻辑和需求，会让你在具体实现时更加清楚每个模块的职责，避免过度设计或者实现的功能与业务目标不符。 3. 技术栈与业务需求的结合每个开发人员都有自己擅长的技术栈，这为日常开发提供了便利。然而，单纯依赖某个技术栈可能会限制解决问题的思路。业务需求的变化常常要求开发人员灵活运用技术，而不是固守某一技术栈。通过深入理解业务需求，开发人员可以选择最适合的技术解决方案。 举个例子，假如你正在开发一个大数据处理系统，业务需求可能是需要对大量用户行为数据进行实时分析。如果你对大数据领域有所了解，可能会想到使用分布式计算框架，如Apache Spark。然而，如果你不了解业务需求背后的数据分析目的，可能会选择一些不适合的技术，导致项目进度延误或者系统性能不佳。 因此，技术栈的选择应与业务需求紧密结合。每个技术决策都应考虑到业务目标，选择最适合的工具来实现需求，而不仅仅是使用自己熟悉的技术。 4. 长期影响：从开发人员到架构师的成长理解业务、结合架构师思维、灵活应用技术栈，这些不仅能帮助你在当前项目中解决问题，更能为你的职业生涯带来积极影响。开发人员在项目中积累了对业务的深入理解，能更好地与产品经理、设计师等非技术人员沟通协作，从而提升团队的整体效能。与此同时，这也为你晋升为架构师打下了基础。 架构师不仅需要技术能力，还需要深入理解业务，能够将复杂的业务需求转化为可执行的技术方案。对于开发人员来说，逐渐将业务理解与技术实践相结合，可以培养出面向全局的视野，这有助于提升系统设计能力、问题解决能力和跨团队协作能力。 5. 结语总结来说，软件开发的成功不仅仅依赖于技术的实现，更多的是通过深刻理解业务需求来指导技术决策。普通开发人员通过结合架构师的思维方式，能够更好地与业务需求对接，在技术上做出合理的选择，并为团队和项目的成功贡献力量。从业务需求出发，结合架构师的系统思维，将极大地推动软件项目的进展，并帮助你在职业发展中走得更远。 在未来的开发过程中，我们不仅要提升技术能力，更要通过深度理解业务需求，培养架构师的思维方式，真正做到技术与业务的有机结合，为企业创造更大的价值。"},{"title":"JavaScript数组引用陷阱","path":"/2025/01/13/JavaScript数组引用陷阱/","content":"JavaScript数组引用陷阱问题描述在使用回溯算法时，我们经常需要保存中间结果。看似简单的数组操作可能藏着一个常见陷阱： 12345678let result = [];let path = [];// 错误示例result.push(path);// 正确示例result.push(path.slice()); 为什么会出错？JavaScript中的数组是引用类型。当我们直接将path加入result时： 1result.push(path) // 存储的是引用 这意味着result中的每个元素都指向同一个path数组。当path被修改时，result中所有的记录都会改变。 实际效果假设有这样的回溯过程： 123path = [1,2] → result = [[1,2]]path = [1,3] → result = [[1,3], [1,3]] // 注意第一个组合也变了path = [2,3] → result = [[2,3], [2,3], [2,3]] // 全部变成了相同的值 解决方案使用slice()创建数组副本： 1result.push(path.slice()) // 存储独立副本 这样每次存储的都是当前path的独立复制，后续对path的修改不会影响已存储的结果。 其他方法 展开运算符：[...path] Array.from：Array.from(path) concat：[].concat(path) 关键是要理解：什么时候需要副本，什么时候可以用引用。在需要保存状态的场景中，创建副本是更安全的选择。"},{"title":"代码设计中的通用性与特殊性思考","path":"/2025/01/13/代码设计中的通用性与特殊性思考/","content":"在软件开发中，我们经常需要在代码的通用性和特殊性处理之间寻找平衡。本文将探讨这个话题中的几个关键问题，以及它们给我们的启发。 通用性与特殊处理的平衡问题的本质写通用代码和处理特殊情况是否存在冲突？这个问题需要我们先理解通用性的本质： 代码能够处理大多数常见情况 具有良好的可扩展性和可维护性 逻辑清晰，易于理解 同时，我们也要认识到特殊情况处理的必要性： 现实世界中总会有边界情况和异常情况 忽略特殊情况可能导致程序出错或不稳定 某些特殊情况可能是业务需求的一部分 如何优雅地处理让我们看一个具体的例子来说明如何平衡这两者： 12345678910111213141516171819# 不太好的做法def calculate_discount(price, user_type): if user_type == &quot;VIP&quot;: return price * 0.8 if user_type == &quot;SVIP&quot;: return price * 0.7 if user_type == &quot;普通用户&quot;: return price # 堆积了很多if，难以维护# 更好的做法DISCOUNT_RATES = &#123; &quot;VIP&quot;: 0.8, &quot;SVIP&quot;: 0.7, &quot;普通用户&quot;: 1.0&#125;def calculate_discount(price, user_type): return price * DISCOUNT_RATES.get(user_type, 1.0) 在这个优化后的方案中，我们可以看到几个关键的处理策略： 使用配置文件或数据库存储特殊规则，避免硬编码 运用设计模式（如策略模式、装饰器模式）来处理变化 将特殊情况的处理逻辑封装在专门的类或模块中 算法选择与通用性的深层思考从循环到回溯的启示在算法设计中，我们经常会发现一些有趣的现象：有些问题用简单的循环难以解决，但使用回溯等看似更复杂的方法却能实现更好的通用性。这给我们带来了几点重要启示： 解决方案的层次性 循环这种基础控制结构有其局限性 回溯这种算法模式可以处理更复杂的问题空间 有时需要跳出当前思维层次，用更高级的抽象来解决问题 “通用性”的本质 真正的通用性不在于代码写法的简单 而在于是否能够覆盖问题空间的各种情况 有时”看似复杂”的解法反而更通用 实例分析：括号生成问题让我们看一个具体的例子 - 生成所有合法的括号对： 1234567891011121314151617def generateParenthesis(n): def backtrack(s, left, right): if len(s) == 2 * n: result.append(&#x27;&#x27;.join(s)) return if left &lt; n: s.append(&#x27;(&#x27;) backtrack(s, left + 1, right) s.pop() if right &lt; left: s.append(&#x27;)&#x27;) backtrack(s, left, right + 1) s.pop() result = [] backtrack([], 0, 0) return result 这个例子完美展示了为什么有时候我们需要选择看似更复杂的解决方案。 核心启示 不要被表面的复杂度吓到 选择解决方案时要着眼于问题的本质 有时需要用看似”复杂”的方法才能实现真正的通用性 算法范式的选择比具体实现细节更重要 结论在软件开发中，通用性和特殊性处理并不是对立的。关键在于如何用恰当的方式来组织代码，使特殊情况的处理也成为代码整体结构中优雅的一部分。有时为了实现更好的抽象和通用性，我们需要付出一定的复杂度成本。但只要这种复杂度是”必要的复杂度”，能带来足够的收益，这种权衡就是值得的。 好的设计应该既能处理通用情况，又能优雅地适应特殊情况，这正是我们在软件开发中需要不断追求的目标。 为了程序必要的精确度不要省那一点在代码上消耗的精力及代码洁癖。"},{"title":"修复 “Can't write images with one color channel” 错误的完整指南","path":"/2025/01/05/修复-“Can-t-write-images-with-one-color-channel”-错误的完整指南/","content":"在进行图像处理和保存时，我们可能会遇到以下错误： 1ValueError: Can&#x27;t write images with one color channel. 这是一个常见的问题，尤其是在使用 Python 的图像处理库（如 skimage 或 imageio）时。如果你也遇到了类似的错误，这篇博客将为你提供解决方法，并解释问题的原因。 背景用户 @wern44 在运行其深度学习推理脚本时，尝试保存生成的图像，却触发了以下错误： 1ValueError: Can&#x27;t write images with one color channel. 错误发生在以下代码中： 12io.imsave(os.path.join(result_path, im_name+&quot;.png&quot;), (result*255).permute(1, 2, 0).cpu().data.numpy().astype(np.uint8)) 这段代码试图将单通道图像保存为 PNG 文件，但 skimage.io.imsave 或 imageio 的底层实现不支持单通道图像的直接保存。 错误原因该错误的核心问题在于 单通道图像的保存。许多图像处理库（如 skimage 或 imageio）在保存灰度图像时会出现问题，因为它们期望图像的形状为以下两种之一： 多通道彩色图像：形状为 (height, width, 3)，每个像素点有 3 个通道（如 RGB）。 单通道灰度图像：形状为 (height, width)。 导致错误的原因在于，传递给 imsave 的图像虽然是单通道，但形状却为 (height, width, 1)，即多了一个冗余的通道维度。这种形状无法被正确解析，因此抛出了 ValueError。 解决方法针对该问题，推荐使用 OpenCV 替代 skimage 或 imageio 来保存图像。以下是修改后的代码： 12345import cv2# 保存图像cv2.imwrite(os.path.join(result_path, im_name + &quot;.png&quot;), (result * 255).permute(1, 2, 0).cpu().data.numpy().astype(np.uint8)) 为什么 OpenCV 可行？OpenCV 的 cv2.imwrite 方法能够处理形状为 (height, width) 或 (height, width, channels) 的图像： 如果图像是单通道灰度图（形状为 (height, width)），OpenCV 会自动将其存储为灰度图。 如果图像是多通道（如 RGB），OpenCV 会正确保存为彩色图像。 替代方案如果你仍希望使用 io.imsave 或其他工具，可以在保存前将图像的形状调整为 (height, width)： 12345678from skimage import ioimport numpy as np# 将单通道图像的形状从 (height, width, 1) 调整为 (height, width)gray_image = (result * 255).permute(1, 2, 0).cpu().data.numpy().astype(np.uint8).squeeze()# 保存图像io.imsave(os.path.join(result_path, im_name + &quot;.png&quot;), gray_image) np.squeeze() 方法会移除多余的维度 (height, width, 1) 中的最后一个通道，使图像变为 (height, width) 的灰度图。 总结问题复现如果你遇到以下错误： 1ValueError: Can&#x27;t write images with one color channel. 这是因为单通道图像的形状为 (height, width, 1)，而非 (height, width)，导致库无法正确处理。 快速修复 使用 OpenCV： 12import cv2cv2.imwrite(&quot;output.png&quot;, single_channel_image) 调整图像形状（如果继续使用 io.imsave）： 123import numpy as npgray_image = single_channel_image.squeeze() # 从 (height, width, 1) 变为 (height, width)io.imsave(&quot;output.png&quot;, gray_image) 选择更适合的工具 OpenCV 是一个强大且灵活的计算机视觉库，建议在需要保存图像时优先选择它。 skimage 和 imageio 虽然功能强大，但在某些情况下对输入数据的形状要求更严格。 参考内容 官方错误说明 讨论与解决方法示例 这篇文章希望能帮助你快速解决该问题，并对图像处理库的行为有更深入的理解！如果你有其他问题，欢迎留言交流！ 🎉"},{"title":"技术开发：从业务出发还是技术热爱？","path":"/2025/01/03/技术开发：从业务出发还是技术热爱？/","content":"在技术开发的世界里，我们经常会遇到两种不同的驱动力：基于业务的技术开发和基于技术热爱的开发。这两种方式看似对立，但实际上可以互补。然而，如果对技术盲目崇拜，可能会陷入“为了技术而技术”的陷阱。本文将从目标、方法、评价标准等方面，探讨这两种开发方式的异同，并分析如何避免技术崇拜，找到平衡点。 1. 基于业务的技术开发：解决问题是核心基于业务的技术开发以实际需求为导向，其核心目标是解决问题、创造价值。 目标明确：技术的使用围绕业务需求展开，强调可行性和稳定性。例如，开发一套推荐系统，其首要任务是提升用户转化率，而不是使用最复杂的算法。 注重结果：选择技术时，成熟度和可靠性往往优先于创新性。这种开发方式更像是在“盖房子”，需要的是稳扎稳打，而非“造火箭”。 评价标准：成功的标志是用户满意度、业务增长或成本降低，而非技术本身有多“酷”。 然而，这种方式可能带来技术保守的问题。如果过分强调短期效益，团队可能会忽视技术积累和创新的机会。 2. 基于技术热爱的开发：探索未知的乐趣基于技术热爱的开发更多是兴趣驱动，技术本身成为了目的。 创新驱动：技术爱好者喜欢尝试新技术、解决高难度问题。例如，一个程序员可能因为对分布式系统感兴趣，而尝试设计一种全新的数据库架构。 自由灵活：没有业务压力的束缚，开发者可以尽情探索和试验，享受技术带来的纯粹乐趣。 评价标准：技术的优雅性、创新性或学习收获是衡量成功的主要标准，而不是直接的商业价值。 但这种方式也有隐患：脱离实际需求。如果开发者忽视了技术的应用场景，最终可能浪费时间，甚至造出“无人问津”的成果。 3. 技术崇拜的陷阱：避免“为了技术而技术”盲目崇拜技术，往往表现为对新技术的追逐，而忽视其实际意义。这种行为可能导致以下问题： 资源浪费：团队花费大量时间学习和实现新技术，却未能带来实际收益。 复杂性增加：使用不必要的技术堆叠，导致系统难以维护。 忽视用户需求：过于关注技术细节，而忘记产品的最终目的是服务用户。 例如，在开发一款简单的企业内部工具时，团队可能执意使用微服务架构，尽管单体架构已经足够满足需求。这种“过度设计”不仅拖慢了项目进度，还增加了维护成本。 4. 找到平衡点：技术与业务的结合技术开发的最佳实践，是在业务需求和技术热爱之间找到平衡点。以下是一些建议： 从业务出发，评估技术价值：选择技术时，优先考虑它能否解决当前问题，而不是盲目追求“新潮”。 保留探索精神：在满足业务需求的前提下，为团队留出一定时间探索新技术。这既能激发创造力，也能为未来业务提供更多选择。 培养用户视角：无论技术多么先进，最终服务的对象是用户。理解用户需求，才能让技术真正发挥价值。 鼓励技术沉淀：将技术热爱转化为长期积累，而不是一次性尝试。通过文档化、开源等方式，让探索成果对团队或行业产生更大影响。 5. 案例分析：技术热爱与业务需求的结合一个经典的例子是Netflix的推荐系统。最初，Netflix的技术团队出于对机器学习的兴趣，尝试了复杂的深度学习模型。然而，经过业务验证，他们发现简单的协同过滤算法在实际场景中效果更好。最终，团队选择在基础模型的框架下逐步优化，同时为未来技术升级做好准备。这一案例表明：技术的选择必须服务于业务目标，但技术热爱可以驱动持续改进。 6. 总结：让技术为价值服务技术本身并非目标，而是一种工具。无论是基于业务还是技术热爱，最终都应该服务于价值创造。避免盲目崇拜技术的关键在于： 明确技术的应用场景和价值。 保持对用户需求的敏感度。 在创新和实用之间找到平衡。 正如一句话所说：“技术是实现梦想的桥梁，但梦想的核心始终是为人类创造更好的生活。” 在技术开发的道路上，让我们既保持探索的热情，又不忘价值的初心！"},{"title":"NDVI总结","path":"/2025/01/01/NDVI总结/","content":"NDVI是一种由不同光谱计算而来的指数，具体来说用NIR-RED 比上 NIR + RED, 这个比值可以让植区域尽可能值接近1, 非植被区域的值尽可能小，NDVI可以衡量植被的健康程度，比如寻找农作物的病虫害。生态学家可以用NDVI来检测森林覆盖率变化，遥感专家可以利用NDVI来提取城市绿地。"},{"title":"理解 Class 和 对象的关系：从抽象到具体","path":"/2024/12/30/理解-Class-和-对象的关系：从抽象到具体/","content":"在学习面向对象编程（OOP）时，很多人都会遇到一个常见的问题：为什么 class 显得如此重要，而对象却容易被忽略？为什么阅读代码时，总觉得 class 是操作的主体，而不是对象？这些困惑让代码阅读变得费劲，尤其是面对复杂的类设计时。 本文将从多个角度分析这些现象的根源，并提供解决方法，帮助你更轻松地理解和应用 OOP 的核心概念。 1. 为什么会觉得 class 是主体？1.1 class 是代码的入口在阅读代码时，class 是定义行为和属性的地方，所有逻辑都从这里开始。我们首先看到的是 class 的定义，而不是对象的使用。这种结构让人不自觉地将注意力集中在 class 上。 1.2 英文单词 “class” 听起来很“抽象”“Class” 这个词本身有“类别”或“等级”的意思，容易让人联想到它是主导的、统治的概念。这种抽象的命名会让人觉得它很重要甚至“神秘”，而忽略了它只是一个蓝图。 1.3 OOP 强调 class 的设计面向对象编程本质上是关于设计模式和抽象的，很多初学者会被引导过度关注类的设计，而不是它的实际用途。例如，教程中常说“类是一切的核心”，但实际上，对象才是实际工作的主体。 1.4 初学者容易忽略实例化的过程当你在代码中看到 MyClass.method() 时（比如静态方法或类方法），会更容易误以为直接操作的是类，而不是对象。 2. 为什么会觉得阅读代码费劲？2.1 缺少“对象”视角如果你总是从 class 的角度看代码，而没有想象出“对象”是如何被实例化和操作的，代码会显得抽象且不直观。你可能会困惑于方法的定义，却忽略了这些方法是通过对象调用的。 2.2 方法和属性的绑定不明确在类中定义的方法和属性是模板的一部分，而对象是实际使用它们的地方。如果没有清晰地理解两者的关系，阅读代码时会感觉不连贯。 2.3 面向对象思维的切换需要时间如果你习惯了过程式编程，突然切换到面向对象编程，理解 class 和 对象 的角色需要一些时间。 3. 如何克服这些问题？3.1 换个视角：把 class 想象成“幕后设计师”class 就像一个幕后设计师，设计了操作规则，但真正工作的是“演员”——也就是对象。阅读代码时，多问自己：“这个类的对象会做什么？” 而不是“这个类定义了什么？” 3.2 强调实例化和调用每次看到 class，都主动去找它的实例化代码，明确对象是如何被创建的。例如： 123456class Car: def drive(self): print(&quot;Driving...&quot;)my_car = Car() # 这里是实例化my_car.drive() # 这里是操作对象 阅读代码时，多关注 my_car，因为它才是“实际操作”的主体。 3.3 想象对象的生命周期每当看到一个 class，试着想象它的对象是如何被创建、使用和销毁的。这样可以把注意力从抽象的 class 转移到具体的 对象 上。 3.4 简化对 class 的认知不要把 class 想得太复杂，它只是一个模板或工具。例如，用类生成对象的过程可以简单理解为： “我有一个模具（class），用它造了一个杯子（对象），杯子才是我喝水的工具。” 3.5 多练习阅读对象为主的代码找一些以对象操作为主的代码，比如： 123456car1 = Car(&quot;Toyota&quot;, &quot;red&quot;)car2 = Car(&quot;Honda&quot;, &quot;blue&quot;)cars = [car1, car2]for car in cars: car.drive() 这种代码会让你更容易把注意力放在对象上，而不是类的定义。 4. 英文“class”的“神秘感”如何化解？ 英文“class”确实容易让人觉得抽象，但可以试着用更形象的词代替理解，比如： class &#x3D; 模板（template） object &#x3D; 实物（instance） 在脑海中用这些替代词替换“class”，可以降低其神秘感。 5. 总结你的困惑来源于把 class 当作主体，而忽略了对象的作用。调整视角，强调对象的实例化和操作，可以帮助你更轻松地阅读代码。 面向对象编程的核心是“类定义规则，对象执行任务”。一旦你把重点放在对象上，代码会变得更加直观。 class可能非常复杂，但对象交互可能只用了其中个别方法，就像量子物理学和宏观物理学，都属于物理学，但宏观物理学就能够解决问题何必非要把量子力学的部分看懂才来解决问题呢。知道你想提升自己，但也要积极地优化学习方法啊，不是每个成功的人都是靠蛮力成功的。 如果你也有类似的困惑，试试这些方法吧！多练习对象为主的代码操作，你会发现代码阅读的乐趣大大提升。"},{"title":"debugger系统总结","path":"/2024/12/30/debugger系统总结/","content":"运行Debugger本身不会直接修改源代码。 理解 Python 调试器系统：从基础到现代化调试工具调试是程序开发中不可或缺的一部分。在 Python 中，调试器系统的设计大大简化了程序员的工作流程，让开发者不仅能够快速定位问题，还能动态控制程序的执行。本文将带你从基础调试方法出发，深入理解调试器的设计初衷、功能演进以及现代调试工具的实现原理。 1. 什么是调试以及 Python 原生调试能力？调试是指通过分析和修复代码中的错误（Bug）来确保程序正常运行的过程。在 Python 中，最基础的调试手段包括： (1) 使用 print 输出print 是程序员最原始且常用的调试工具。通过在代码中插入 print 语句，我们可以观察程序中变量的值和运行状态。例如： 123456def add(a, b): print(f&quot;Adding &#123;a&#125; and &#123;b&#125;&quot;) return a + bresult = add(3, 5)print(f&quot;Result: &#123;result&#125;&quot;) 虽然简单直接，但 print 调试的缺点也非常明显： 繁琐：每次需要手动插入和删除 print 语句。 静态：无法动态控制程序执行流程，只能被动观察输出。 低效：对于复杂程序，无法清晰展现代码逻辑和上下文关系。 (2) 使用 pdb 模块Python 提供了自带的调试模块 pdb，它是一种交互式调试工具。通过在代码中插入 import pdb; pdb.set_trace()，可以暂停程序并进入调试模式。例如： 1234567891011def add(a, b): return a + bdef main(): x = 5 y = 10 import pdb; pdb.set_trace() # 暂停程序并进入调试模式 result = add(x, y) print(f&quot;Result: &#123;result&#125;&quot;)main() 在调试模式下，你可以执行以下操作： 查看变量值：p x（打印变量 x 的值）。 逐行单步执行：n（next）。 跳出当前函数：r（return）。 继续运行程序：c（continue）。 虽然 pdb 提供了交互式功能，但其基于命令行的界面体验不够友好，尤其在调试复杂程序时显得力不从心。 2. 为什么需要调试器系统？随着程序复杂度的增加，传统的调试方法（如 print 和 pdb）暴露出了诸多局限性。这时，调试器系统应运而生。设计调试器的初衷主要有以下几点： (1) 提高效率 手动插入和删除 print 语句是一个繁琐且低效的过程。 调试器允许开发者在程序运行时动态查看变量值、函数调用栈和代码执行流程，无需修改代码。 (2) 动态控制程序执行调试器让开发者可以随时暂停、继续运行程序，甚至动态修改变量值来测试不同的逻辑，极大地提升了调试灵活性。 (3) 适应复杂场景现代软件开发中，程序可能涉及多线程、多进程甚至分布式架构。调试器可以帮助开发者跟踪这些复杂场景中的问题。 (4) 可视化调试传统的命令行调试难以直观地展示程序状态，而现代调试工具（如 VSCode 和 PyCharm）提供了图形化界面，显著降低了调试成本。 3. 调试器系统的工作原理调试器本质上是一个运行在用户程序之上的工具，通过拦截和控制程序的执行流程，帮助开发者调试代码。以下是调试器的核心工作原理： (1) 插入断点开发者在调试器中标记程序的某些行作为断点（breakpoint）。当程序运行到这些断点时，调试器会暂停程序，并将控制权交给开发者。 (2) 动态查看和修改变量调试器会拦截程序的运行时上下文（包括变量值、函数调用栈等），并将这些信息展示给开发者。开发者可以动态修改变量值，测试不同的逻辑分支。 (3) 单步执行调试器允许开发者逐行执行代码，观察程序的执行流程，帮助快速定位问题。 (4) 捕获异常当程序出现未处理的异常时，调试器会捕获异常并展示详细的错误信息，帮助开发者定位问题。 4. Python 调试器的实现(1) Python 自带的调试接口Python 提供了 sys.settrace() 接口，允许开发者监控和控制程序的执行流程。调试器通过挂钩这些接口，可以拦截程序的每一行代码。 (2) debugpy 模块debugpy 是一个专门为 Python 开发的现代化调试模块，由微软开发并集成到 VSCode 的 Python 插件中。它是 VSCode 调试 Python 程序的核心工具。 当你在 VSCode 中调试 Python 程序时，debugpy 会通过与 Python 解释器的交互来实现断点、单步执行、异常捕获等功能。 (3) 图形化调试界面调试器的用户界面（如 VSCode 的调试面板和 PyCharm 的调试工具）与底层调试器模块（如 debugpy）通信，为开发者提供直观的操作方式。例如： 可视化断点设置。 变量值的实时显示。 函数调用栈的展开查看。 5. 调试器系统的演进调试器并不是 Python 独有的工具，它在编程语言的发展历程中扮演了重要角色： (1) 早期调试工具最初的调试工具大多基于命令行，例如 Unix 系统中的 gdb（GNU 调试器）。开发者需要通过命令行手动设置断点、查看内存和变量值。 (2) 图形化调试工具随着图形用户界面的普及，调试器开始提供直观的图形界面。例如： Eclipse 集成的 Java 调试工具。 Visual Studio 提供的强大调试器。 (3) 现代调试器现代调试器不仅支持多语言、多线程、多进程，还注重与开发流程的集成。例如： VSCode 和 PyCharm 提供的调试器支持可视化操作。 分布式调试工具可用于调试机器学习或微服务项目。 6. 示例：如何在 VSCode 中调试 Python 程序以下是一个简单的例子，帮助你快速上手 VSCode 的调试工具： 代码示例假设我们有一个名为 example.py 的脚本： 1234567891011def add(a, b): return a + bdef main(): x = 5 y = 10 result = add(x, y) print(f&quot;Result: &#123;result&#125;&quot;)if __name__ == &quot;__main__&quot;: main() 调试步骤 安装 Python 插件确保 VSCode 安装了官方的 Python 插件。 选择 Python 解释器按 Ctrl+Shift+P，选择 Python: Select Interpreter，然后选择你的 Python 环境。 设置断点在 result = add(x, y) 行单击，添加断点。 启动调试按 F5 或点击调试面板中的绿色箭头，启动调试。 查看调试信息程序会在断点处暂停，你可以： 查看变量值（在调试面板中）。 单步执行代码。 修改变量值并继续运行程序。 7. 总结调试器系统的设计初衷是为了简化程序调试过程，让开发者更高效地定位和解决问题。在 Python 中，调试器从最原始的 print 和 pdb，发展到现代化的工具（如 debugpy 和图形界面调试器），极大地提升了开发体验。 现代调试器不仅支持断点和单步执行，还能适应复杂的多线程、多进程场景，成为开发者不可或缺的工具。无论你是初学者还是资深开发者，掌握调试器的使用技巧都将显著提升你的开发效率。"},{"title":"二叉树的深度与高度","path":"/2024/12/28/二叉树的深度与高度/","content":"在数据结构与算法的学习中，二叉树是一种非常重要的结构。理解二叉树的深度和高度是深入掌握二叉树的关键。本篇博客将围绕二叉树的深度与高度展开讨论，详细介绍它们的定义、区别、计算方法以及在实际问题中的应用。 一、基本定义1. 深度（Depth）深度是从树的根节点到当前节点所经历的边的数量。换句话说，根节点的深度为0，其子节点的深度为1，依此类推。 2. 高度（Height）高度是从当前节点到其最远叶子节点所经历的边的数量。叶子节点的高度为0，其父节点的高度为1，依此类推。 3. 树的深度与高度 树的深度是指从根节点到最远叶子节点所经历的边的数量。 树的高度是指根节点的高度，等价于树的深度。 4. 区别 节点的深度描述的是节点距离根节点的远近。 节点的高度描述的是节点距离叶子节点的远近。 树的深度和树的高度在定义上是相同的，通常是从根节点到最远叶子节点的边数。 二、深度与高度的计算1. 递归计算节点深度假设我们需要计算二叉树中某个节点的深度，可以采用递归方法： 123456789101112# 计算节点深度class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = rightdef get_depth(node, current_depth=0): if node is None: return current_depth - 1 return max(get_depth(node.left, current_depth + 1), get_depth(node.right, current_depth + 1)) 2. 递归计算节点高度二叉树的节点高度可以通过递归计算左右子树的高度，然后取最大值加1： 12345678910111213# 计算节点高度class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = rightdef get_height(node): if node is None: return -1 # 空节点高度为-1 left_height = get_height(node.left) right_height = get_height(node.right) return max(left_height, right_height) + 1 3. 非递归实现树的高度我们也可以使用层序遍历来计算树的高度。每遍历一层，计数器加1，最终计数器的值就是树的高度。 12345678910111213141516from collections import dequedef get_tree_height(root): if not root: return -1 queue = deque([root]) height = -1 while queue: height += 1 for _ in range(len(queue)): node = queue.popleft() if node.left: queue.append(node.left) if node.right: queue.append(node.right) return height 三、深度与高度的应用1. 判断二叉树是否平衡平衡二叉树的定义是任意节点的左右子树高度差不超过1。可以通过递归计算左右子树高度并进行比较。 2. 寻找最近公共祖先在二叉树中，两个节点的最近公共祖先是深度最深的公共节点。通过比较节点的深度，可以逐步向上找到公共祖先。 3. 最长路径计算二叉树的最长路径（直径）是左右子树高度之和加1。通过递归计算左右子树高度，可以轻松求得。 四、总结深度与高度是二叉树中两个重要且容易混淆的概念： 深度从根节点向下计算，描述节点距离根节点的远近。 高度从叶子节点向上计算，描述节点距离叶子节点的远近。 理解这两个概念及其计算方法，对于解决二叉树相关问题至关重要。希望本文能帮助你更好地掌握二叉树的深度与高度。"},{"title":"AI只能成为Copilot-副驾驶","path":"/2024/12/25/AI只能成为Copilot-副驾驶/","content":"随着人工智能（AI）技术的快速发展，从自动驾驶到智能助理，从生成式AI到决策支持系统，AI似乎无处不在。越来越多的人开始讨论一个问题：AI是否可以完全替代人类，成为主导者？答案很清楚：AI只能是Copilot（副驾驶），而不是Pilot（主驾驶）。 什么是Copilot角色？副驾驶的角色是协助主驾驶完成任务，提供信息支持和应急响应，但不会取代主驾驶的核心决策权。在人工智能的应用中，AI作为Copilot的角色，意味着它可以： 辅助决策：通过分析大量数据，提供有价值的洞察。 执行重复任务：解放人类的时间和精力，用于更有创造力的工作。 实时提醒与监控：在复杂系统中，及时提示潜在问题，防止事故发生。 然而，最终的控制权和责任仍然在于人类。这种定位既是技术的局限性所决定的，也是伦理与社会责任的需求。 为什么AI不能成为主驾驶？ 缺乏全面理解能力 尽管AI可以在特定领域表现出色，但它缺乏人类对世界的整体理解能力。例如，AI可以根据历史数据预测市场趋势，但它无法理解经济政策变化或社会事件对市场的深远影响。 无法承担责任 AI没有道德观念，也无法承担法律责任。在重大决策中，责任归属是不可回避的问题。让AI承担主导角色，可能导致责任真空，最终对社会造成无法弥补的损失。 对偏差的敏感性 AI的行为基于训练数据，如果数据中存在偏差，AI可能会放大这些偏差。例如，在招聘系统中，AI可能因为历史数据的不平衡而做出歧视性的决策。 缺乏创造力与灵活性 AI擅长执行规则，但在面对未定义的问题时，往往束手无策。人类的创造力和灵活性是AI无法复制的，这也是人类在复杂环境中能够脱颖而出的关键。 Copilot模式的优势AI作为Copilot的模式并不意味着它的能力受限，而是体现了一种更健康、更可持续的协作关系： 增强人类能力 AI可以帮助人类完成以往难以实现的任务。例如，在医疗领域，AI可以通过分析成千上万的病例，协助医生快速诊断疑难杂症。 提高效率 在工业生产中，AI可以实时监控设备运行状况，预测故障并提前维护，大幅降低停机时间和维修成本。 减少人为失误 在航空和自动驾驶等高风险领域，AI可以实时监控环境并发出警报，降低人为失误带来的风险。 Copilot模式的挑战尽管AI作为Copilot模式具有诸多优势，但也面临以下挑战： 信任问题 人类是否愿意完全信任AI？特别是在高风险领域，如金融和医疗，信任问题尤为突出。 边界划分 AI的职责范围如何界定？如果AI提供的建议有误，人类是否有能力及时识别并纠正？ 技术与伦理的平衡 如何确保AI的行为符合伦理规范？这需要技术开发者和监管机构共同努力，建立明确的规则和标准。 未来展望AI作为Copilot的角色并不是一种妥协，而是一种战略选择。人类和AI各自的优势决定了这种协作模式的必要性和可行性。在未来，我们需要更加关注以下几个方向： 增强协作机制 开发更加智能的交互界面，让人类和AI的协作更加高效、自然。 完善监管框架 建立清晰的责任分配和问责机制，确保AI在各个领域的应用安全可靠。 提升人类素养 在AI逐渐融入社会的过程中，人类需要不断提升自身的技术素养，以便更好地与AI协作。 结语AI只能成为Copilot，而不是Pilot。这不仅是技术发展的必然，也是社会对安全、责任和伦理的基本需求。人类与AI的关系，应该是相互成就，而非取代。只有在人类的引领下，AI才能真正发挥其潜力，推动社会的进步。"},{"title":"Vue3中的ref和reactive总结","path":"/2024/12/21/Vue3中的ref和reactive总结/","content":"引言在Vue3中，响应式系统是框架的核心特性之一。其中，ref和reactive是两个最基础且重要的响应式API。本文将全面剖析这两个API的使用方法、区别及最佳实践。 1. 基础概念1.1 ref的基本使用ref主要用于处理基本数据类型（如字符串、数字、布尔值等）的响应式，但也可以处理对象类型。它会将传入的值包装在一个带有value属性的对象中。 1234567891011121314import &#123; ref &#125; from &#x27;vue&#x27;// 创建一个refconst count = ref(0)// 访问或修改值需要使用.valueconsole.log(count.value) // 0count.value++console.log(count.value) // 1// 在模板中使用时不需要.value// &lt;template&gt;// &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;// &lt;/template&gt; 1.2 reactive的基本使用reactive主要用于处理对象类型的响应式数据，它直接返回对象的响应式代理。 123456789101112import &#123; reactive &#125; from &#x27;vue&#x27;const state = reactive(&#123; name: &#x27;张三&#x27;, age: 25, hobbies: [&#x27;读书&#x27;, &#x27;跑步&#x27;]&#125;)// 直接访问和修改属性console.log(state.name) // 张三state.age = 26state.hobbies.push(&#x27;游泳&#x27;) 2. ref vs reactive：深度对比2.1 处理对象时的区别当ref接收一个对象作为参数时，Vue会在内部自动调用reactive来处理这个对象，但两者的使用方式和行为有显著区别： 访问方式差异12345678910111213// ref方式const user = ref(&#123; name: &#x27;张三&#x27;, age: 25&#125;)console.log(user.value.name) // 需要.value// reactive方式const user = reactive(&#123; name: &#x27;张三&#x27;, age: 25&#125;)console.log(user.name) // 直接访问 重新赋值行为12345678910111213141516171819// ref可以整体替换对象，保持响应性const user = ref(&#123; name: &#x27;张三&#x27;, age: 25&#125;)user.value = &#123; name: &#x27;李四&#x27;, age: 30&#125; // ✅ 正确// reactive不能整体替换对象const user = reactive(&#123; name: &#x27;张三&#x27;, age: 25&#125;)user = &#123; name: &#x27;李四&#x27;, age: 30&#125; // ❌ 错误，会丢失响应性 2.2 解构行为1234567891011121314// ref的解构const user = ref(&#123; name: &#x27;张三&#x27;, age: 25&#125;)const &#123; value &#125; = user // 保持响应性const &#123; value: &#123; name, age &#125; &#125; = user // 失去响应性// reactive的解构const user = reactive(&#123; name: &#x27;张三&#x27;, age: 25&#125;)const &#123; name, age &#125; = user // 直接失去响应性 3. 实际应用场景3.1 使用ref的最佳场景 基本数据类型的响应式 需要将响应式对象作为函数参数传递 可能需要整体替换对象的情况 在组合式函数中返回响应式对象 123456789101112131415function useUser() &#123; const user = ref(&#123; name: &#x27;张三&#x27;, age: 25 &#125;) const updateUser = (newUser) =&gt; &#123; user.value = newUser // 可以整体替换 &#125; return &#123; user, updateUser &#125;&#125; 3.2 使用reactive的最佳场景 复杂对象的响应式处理 对象结构相对稳定，不需要整体替换 直接在组件内部使用，不需要在函数间传递 需要更简洁的访问语法 1234567891011121314151617181920function useUserState() &#123; const state = reactive(&#123; user: &#123; name: &#x27;张三&#x27;, age: 25, address: &#123; city: &#x27;北京&#x27;, street: &#x27;朝阳区&#x27; &#125; &#125;, settings: &#123; theme: &#x27;dark&#x27;, notifications: true &#125; &#125;) return &#123; state &#125;&#125; 4. 最佳实践4.1 使用toRefs保持响应性123456789101112131415import &#123; reactive, toRefs &#125; from &#x27;vue&#x27;function useUser() &#123; const state = reactive(&#123; name: &#x27;张三&#x27;, age: 25 &#125;) return &#123; ...toRefs(state) &#125;&#125;// 使用const &#123; name, age &#125; = useUser() 4.2 组合多个ref1234567import &#123; ref, computed &#125; from &#x27;vue&#x27;const firstName = ref(&#x27;张&#x27;)const lastName = ref(&#x27;三&#x27;)const fullName = computed(() =&gt; &#123; return firstName.value + lastName.value&#125;) 4.3 选择建议 简单数据优先使用ref 基本类型数据 需要在函数间传递的响应式数据 复杂数据优先使用reactive 嵌套的对象结构 组件内部的状态管理 保持一致性 在同一项目中保持统一的使用方式 在组合式函数中明确响应式数据的来源 5. 注意事项 ref注意点： 在setup中访问需要.value 模板中会自动解包 解构时需要考虑响应性问题 reactive注意点： 不能直接赋新值 解构会失去响应性 建议使用toRefs保持响应性 总结 ref和reactive都是Vue3中核心的响应式API 虽然ref可以处理对象，但其行为和reactive有明显区别 根据具体场景选择合适的API 在实际开发中保持代码风格的一致性 合理使用工具函数（如toRefs）来处理响应性问题 延伸阅读 深入理解Vue3的响应式原理 Composition API的最佳实践 性能优化考虑 响应式系统的调试技巧"},{"title":"Vue 3组合式API中的状态与方法管理：不仅仅是属性","path":"/2024/12/21/Vue-3组合式API中的状态与方法管理：不仅仅是属性/","content":"在Vue 3的组合式API中，我们经常需要管理组件的状态。但仅仅暴露状态变量是不够的，为了实现更复杂的交互逻辑，我们还需要暴露操作这些状态的方法。本文将详细探讨如何在组合式API中优雅地管理状态与方法。 基础概念在组合式API中，我们使用ref来创建响应式状态： 123import &#123; ref &#125; from &#x27;vue&#x27;const count = ref(0) 但是，如果我们只是简单地暴露这个状态变量，组件的功能会非常受限。为了实现更丰富的交互，我们需要同时暴露操作这个状态的方法。 完整示例让我们看一个完整的计数器组件示例： 1234567891011121314151617181920212223242526272829import &#123; ref &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; // 状态声明 const count = ref(0) // 方法声明 function increment() &#123; count.value++ &#125; function decrement() &#123; count.value-- &#125; function reset() &#123; count.value = 0 &#125; // 同时暴露状态和方法 return &#123; count, increment, decrement, reset &#125; &#125;&#125; 模板中的使用： 12345678&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;reset&quot;&gt;重置&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 为什么要这样做？ 封装性：将状态变更的逻辑封装在方法中，而不是直接在模板中修改状态，这样可以保持代码的清晰和可维护性。 复用性：这些方法可以在组件的不同地方重用，甚至可以被其他组件调用。 可测试性：独立的方法更容易进行单元测试。 可扩展性：当需要在状态变更时添加额外逻辑（如日志记录、验证等），只需要修改相应的方法即可。 最佳实践 命名清晰：方法名应该清晰地表达其功能，比如increment、decrement、reset等。 单一职责：每个方法应该只负责一个具体的功能。 状态验证：在方法中可以添加必要的状态验证逻辑： 12345function increment() &#123; if (count.value &lt; maxValue) &#123; count.value++ &#125;&#125; 错误处理：适当添加错误处理逻辑： 1234567function updateCount(newValue) &#123; try &#123; count.value = Number(newValue) &#125; catch (error) &#123; console.error(&#x27;Invalid value:&#x27;, error) &#125;&#125; 结论在Vue 3的组合式API中，正确管理状态和方法的关系是构建可维护组件的关键。通过同时暴露状态和操作方法，我们可以构建出更加健壮和灵活的组件。这种模式不仅提高了代码的可维护性，也为组件的扩展提供了更大的空间。 记住：好的组件设计不仅要考虑数据的存储，更要考虑数据的操作方式。通过合理的封装和抽象，我们可以构建出更加优雅和可维护的Vue应用。"},{"title":"深度学习中的特征图与注意力图：全面解析与对比","path":"/2024/12/21/深度学习中的特征图与注意力图：全面解析与对比/","content":"在深度学习中，特征图（Feature Map） 和 注意力图（Attention Map） 是两个常见且重要的概念，尤其是在卷积神经网络（CNN）和注意力机制（如 Transformer）中。虽然它们经常出现在各种任务中，但两者的本质、生成方式和用途却有着很大的区别。这篇博客将带你全面解析这两个概念，并通过简单的语言和实例，帮助你理解它们的核心差异。 一、什么是特征图？特征图是深度学习，尤其是卷积神经网络（CNN）中的关键概念。它是通过卷积操作提取输入数据（如图像）的特征后得到的中间结果。 特征图的本质： 提取特征：特征图可以看作是输入数据的某些模式或特征的表示。比如，一张图像通过卷积核后，特征图可能捕捉到边缘、纹理或更复杂的模式。 数据的压缩版本：特征图将输入数据从高维空间压缩为更紧凑的表示，保留重要信息，去掉冗余内容。 分层特征： 浅层特征图：提取简单的低级特征（例如边缘、颜色）。 深层特征图：提取复杂的高级特征（例如物体的形状、语义信息）。 举个例子：在图像分类任务中，假设我们要区分猫和狗： 浅层特征图可能会提取出毛发的纹理。 深层特征图可能会识别出耳朵或尾巴的形状。 特征图的生成方式：特征图是卷积操作的结果，其计算公式为：特征图 &#x3D; 卷积核 * 输入数据 + 偏置这里的卷积核是模型通过训练学习到的参数，用于对输入数据进行特定特征的提取。 二、什么是注意力图？注意力图则是深度学习中另一种常见的工具，尤其在解释模型行为和注意力机制的任务中。它用来表示模型在做决策时，关注了输入数据的哪些部分。 注意力图的本质： 关注重点：注意力图直观地反映了模型在任务中“看重”的区域或部分。比如，在一个图像分类任务中，注意力图可能显示模型更关注猫的脸，而不是背景。 解释模型：注意力图常用于可视化和解释模型的行为，帮助我们理解模型在决策时是基于哪些信息。 引导模型：在某些任务中，注意力图还可以引导模型更关注关键区域，提升模型性能。 举个例子：仍以猫狗分类任务为例： 注意力图可能显示，模型在判断“猫”时，主要关注了图片中猫的脸部，而忽略了背景的草地。 注意力图的生成方式：注意力图通常通过注意力机制（如 Transformer 的 Self-Attention）或结合梯度信息（如 Grad-CAM）生成。其具体计算方式因模型而异，但核心思想是：根据输入数据的特定权重分布，计算出各部分对模型最终决策的贡献程度。 三、特征图与注意力图的区别虽然特征图和注意力图都与深度学习模型的数据处理密切相关，但它们的本质和用途却有很大不同。以下从多个角度对两者进行对比。 1. 说白了，两者的区别： 特征图说白了就是模型“看到了什么”。它是输入数据经过卷积操作后提取的特征，是模型用来完成任务的“原料”。 注意力图说白了就是模型“看重了什么”。它显示了模型在决策过程中关注的重点区域，是模型工作的“关注点”。 2. 生成方式： 特征图：通过卷积核与输入数据计算得到，是模型的中间计算结果。公式：特征图 &#x3D; 卷积核 * 输入数据 + 偏置 注意力图：通常通过注意力机制或结合梯度信息生成，反映模型对输入数据各部分的重要性。 3. 表现形式： 特征图：是一组二维或三维矩阵，表示输入数据的特征表示，数值反映了特定位置的特征强度。需要进一步可视化才能直观理解。 注意力图：是一个直观的热力图，显示模型对输入数据不同区域的关注程度。值越高的区域，模型越关注。 4. 功能和用途： 特征图： 提取输入数据的特征，供后续网络层使用。 用于特征提取、模式表示，是模型的核心计算结果。 注意力图： 可视化模型行为，帮助解释模型决策。 在部分任务中引导模型更关注核心区域。 5. 应用场景： 特征图 注意力图 图像分类：提取浅层和深层特征 可视化模型对分类任务的关注区域 目标检测：生成候选区域，提取目标特征 引导模型更关注目标区域 风格迁移：匹配内容和风格图像的特征 不常用于风格迁移 自然语言处理：不直接使用 表示词与词之间的相关性 四、特征图和注意力图的关系1. 功能上的互补性： 特征图是模型提取的核心特征，是模型工作的“基础材料”。 注意力图则是对模型行为的直观反映，是分析模型是否正确利用特征图的重要工具。 2. 结合使用的可能性：在深度学习任务中，特征图和注意力图可以结合使用。例如，通过注意力图分析模型是否正确聚焦在特征图中的关键信息。 五、总结特征图： 是深度学习模型处理数据时提取出来的特征表示，是模型理解输入数据的核心中间结果。 它更像是“原料”，供模型进一步处理。 注意力图： 是模型在决策过程中关注区域的可视化表示，帮助我们理解模型的行为。 它更像是“放大镜”，告诉我们模型的关注重点。 两者虽然有很大的区别，但它们在深度学习中都扮演着重要角色。特征图是模型运行的基础，而注意力图则是分析和优化模型的重要工具。理解两者的本质和区别，不仅能帮助我们更好地调试模型，还能让我们从更高的层面理解深度学习的运行机制。 你可以这样记住它们：特征图是“看到了什么”，注意力图是“看重了什么”。"},{"title":"用少数高效指标快速验证开发工作的正确性","path":"/2024/12/16/用少数高效指标快速验证开发工作的正确性/","content":"引言 开发过程中，验证工作是不可或缺的一环。 验证方法的效率和准确性直接影响开发周期和质量。 本文将分享如何通过选择少数关键指标快速验证工作成果，降低犯错率。 为什么选择少数指标？ 节省时间：在项目开发中，时间往往是最宝贵的资源。过多的验证步骤会拖慢开发进度。 提升精度：少数指标可以避免“指标过载”，专注于关键问题，提升验证结果的可信度。 降低犯错率：简化的验证流程更容易重复和自动化，减少人为操作失误。 如何选择关键指标？ 目标导向： 确定工作成果的核心目标。 例如：在图像分割任务中，核心目标可能是分割精度，而非计算速度。 衡量效果的敏感性： 选择对问题变化敏感的指标。 例如：在分类问题中，F1-score比单纯的准确率更能反映模型性能。 成本与可操作性： 考虑获取指标的成本，选择计算成本低、实现简单的指标。 例如：在开发Web应用时，使用页面加载时间和API响应时间作为初步验证指标。 可重复性： 确保选择的指标可以在不同环境下重复验证。 例如：通过单元测试验证函数输出。 实践中的案例分享案例 1：图像分割任务 常见验证指标：像素级准确率、IoU（交并比）、F1-score。 快速验证的关键指标：IoU（Intersection over Union）。 理由：IoU对模型预测区域与真实区域的重叠情况非常敏感，能快速发现问题。 实践方法：随机抽取几张测试集图片，计算IoU。 案例 2：Web应用性能优化 常见验证指标：页面加载时间、API响应时间、内存占用、用户留存率。 快速验证的关键指标：页面加载时间。 理由：页面加载时间直接影响用户体验，是性能优化的核心指标。 实践方法：使用浏览器开发者工具或性能监控工具如Lighthouse。 案例 3：算法优化 常见验证指标：算法复杂度、运行时间、内存占用。 快速验证的关键指标：运行时间。 理由：运行时间是优化效果最直观的体现。 实践方法：对比优化前后的运行时间，观察变化趋势。 注意事项 指标间的平衡：少数指标虽然高效，但不能忽略其他潜在问题。 动态调整：开发阶段不同，验证重点也会变化。例如，初期关注正确性，后期关注性能。 自动化验证：尽量将验证流程自动化，减少人为干预。 结论 通过选择少数高效指标，可以快速验证开发工作的正确性。 这一方法不仅节省时间，还能提高开发效率和成果质量。 希望本文的方法论和案例分享能为您的开发工作提供借鉴。"},{"title":"程序员如何全面分析软件产品：优点与缺点","path":"/2024/12/15/程序员如何全面分析软件产品：优点与缺点/","content":"在软件开发的世界里，一个产品的好坏往往不是非黑即白的。作为程序员，我们需要具备综合思维，全面地分析软件产品的优点和缺点。这不仅有助于我们更好地理解产品，还能指导我们如何改进和优化。本文将探讨为什么这种思维方式至关重要，以及我们可以从哪些方面进行分析。 为什么需要综合思维在软件开发中，综合思维是不可或缺的。它允许我们： 全面理解产品：深入了解产品的所有方面，包括功能、性能和用户体验。 风险管理：提前识别和规划解决方案，以减少未来可能出现的问题。 持续改进：通过识别缺点，我们可以持续改进产品，提高性能和用户体验。 客户满意度：了解产品的优点和缺点有助于我们更好地向客户展示产品的价值，并管理他们的期望。 团队协作：促进团队成员之间的沟通和协作，因为每个人都需要对产品的各个方面有所了解。 从哪些方面分析功能性 优点：产品是否满足用户需求，是否包含所有必要的功能。 缺点：是否存在缺失的功能，或者某些功能是否不够完善。 性能 优点：响应时间快，处理能力强，资源消耗低。 缺点：响应时间长，处理能力不足，资源消耗高。 可用性 优点：用户界面友好，易于学习和使用。 缺点：界面复杂，用户学习曲线陡峭。 可维护性 优点：代码质量高，文档齐全，易于维护和升级。 缺点：代码混乱，文档缺失，难以维护和升级。 可扩展性 优点：系统设计允许轻松添加新功能或扩展现有功能。 缺点：系统设计僵化，难以扩展。 安全性 优点：安全措施到位，如加密、认证和授权机制。 缺点：安全漏洞，如未加密的数据传输，弱密码政策。 兼容性 优点：与不同的操作系统、浏览器和其他软件兼容。 缺点：兼容性问题，如不支持某些操作系统或设备。 可靠性 优点：系统稳定，故障率低。 缺点：系统不稳定，频繁出现故障。 可测试性 优点：易于编写和执行测试，有自动化测试支持。 缺点：测试困难，缺乏自动化测试。 用户体验（UX） 优点：用户满意度高，用户反馈正面。 缺点：用户满意度低，用户反馈负面。 成本效益 优点：开发和维护成本低，性价比高。 缺点：开发和维护成本高，性价比低。 市场适应性 优点：能够快速适应市场变化和用户需求。 缺点：对市场变化反应慢，难以满足新兴需求。 法律和合规性 优点：符合所有相关法律和行业标准。 缺点：存在法律风险或不符合某些标准。 环境影响 优点：对环境友好，如节能。 缺点：对环境有负面影响，如高能耗。 社会和文化适应性 优点：能够适应不同社会和文化的需求。 缺点：可能与某些社会或文化价值观冲突。 结语综合思维对于程序员来说是一种宝贵的能力。它不仅帮助我们更全面地理解我们所工作的软件产品，还能指导我们如何改进和优化产品。通过从多个维度分析软件产品的优点和缺点，我们可以做出更合理的开发和维护决策，最终提升产品的质量和市场竞争力。让我们拥抱综合思维，成为更出色的软件开发者。"},{"title":"云服务器（Windows Server）与本地PC（Windows）的对比：程序员视角","path":"/2024/12/15/云服务器（Windows-Server）与本地PC（Windows）的对比：程序员视角/","content":"在现代软件开发和部署中，云服务器和本地PC是两种重要的计算资源，它们在特性、用途和配置上各有不同。为了帮助程序员更好地理解两者之间的关系，本文从操作系统、硬件资源、网络特性、管理方式以及典型使用场景等方面进行详细对比。 1. 操作系统对比 特性 云服务器（Windows Server） 本地PC（Windows） 目标用户 面向企业、开发者，支持高并发、高负载应用运行。 面向个人和办公用户，设计为通用操作系统。 优化方向 优化后台服务性能，如Web服务器、数据库运行。 优化桌面体验，如图形界面、娱乐和日常办公。 功能特性 强调服务端功能：IIS、远程桌面服务、域控制器等。 强调用户端功能：多媒体支持、应用兼容性等。 License 按核心数、用户数等收费，适合企业级部署。 通常按设备或个人用户授权，价格较低。 总结：Windows Server更关注后台服务和企业需求，而Windows PC则专注于用户体验和日常操作。 2. 硬件资源对比 特性 云服务器（Windows Server） 本地PC（Windows） 硬件配置 可按需选择CPU、内存、存储等，弹性扩展。 固定硬件配置，扩展性受物理限制。 性能 通常使用高性能硬件，支持企业级负载。 性能受限于本地硬件，适合个人和小型任务。 存储 支持分布式存储、高速SSD、备份和快照功能。 主要依赖本地硬盘，扩展需要外接设备。 成本 按使用量计费，灵活但长期成本可能较高。 一次性购置成本，后续运行几乎无额外费用。 总结：云服务器在资源灵活性和性能上更具优势，而本地PC适合需要长期固定性能的任务。 3. 网络特性对比 特性 云服务器（Windows Server） 本地PC（Windows） 网络带宽 高带宽，支持大规模并发访问。 依赖本地网络，通常为家庭或办公级别带宽。 IP地址 提供公网IP，可直接访问。 通常使用局域网IP，公网访问需要端口映射或动态域名。 延迟 更适合全球访问，延迟低。 适合本地操作，网络延迟视ISP而定。 安全性 依赖防火墙、VPN等保护，默认暴露在公网。 通常较安全，主要依赖路由器防火墙。 总结：云服务器更适合需要全球访问或高带宽的任务，而本地PC在安全性和低延迟的本地操作上更具优势。 4. 管理方式对比 特性 云服务器（Windows Server） 本地PC（Windows） 访问方式 主要通过远程桌面（RDP）、SSH等管理。 直接物理访问，或通过远程桌面管理。 维护 云服务商负责硬件维护，用户仅需管理系统。 用户需自行维护硬件和系统。 监控 提供丰富的监控工具，如Azure Monitor、CloudWatch。 需借助第三方工具监控性能。 自动化 支持自动化部署（如CI&#x2F;CD）、弹性伸缩等。 自动化程度较低，需额外配置。 总结：云服务器在管理和自动化方面有更多工具支持，而本地PC的管理更直接。 5. 典型使用场景对比 场景 云服务器（Windows Server） 本地PC（Windows） Web开发与部署 部署生产环境，支持高并发。 开发和测试环境，性能有限。 数据存储与备份 企业级存储和备份，支持容灾恢复。 本地存储，备份需手动或使用外部设备。 多用户协作 支持多用户远程访问，资源隔离性强。 主要适合单用户操作，多用户需额外配置权限。 成本敏感任务 短期任务成本低，长期使用可能昂贵。 长期使用成本低，扩展性差。 6. 两者关系与互补性云服务器和本地PC并不是对立的，而是互补的关系。通常，程序员会选择以下方式结合两者的优势： 开发与测试：在本地PC完成代码开发和初步测试。 部署与生产：将最终版本部署到云服务器，利用其高性能和高可用性支持用户访问。 远程访问：通过本地PC远程连接云服务器，管理和调试线上环境。 资源优化：将高性能任务放在云端，低成本任务在本地运行。 7. 总结 对比维度 云服务器（Windows Server） 本地PC（Windows） 灵活性 高，可动态调整资源。 低，硬件固定。 成本 按需计费，适合短期任务。 一次性投资，适合长期使用。 管理 专业化管理，自动化工具多。 简单直接，适合个人使用。 性能 高性能，支持大规模并发。 适合单机任务，性能受限于硬件。 选择云服务器还是本地PC，取决于具体的项目需求和预算。通过合理利用两者的优势，程序员可以在开发效率和成本之间找到最佳平衡。"},{"title":"乒乓球：锻炼大脑敏锐性的重要运动","path":"/2024/12/15/乒乓球：锻炼大脑敏锐性的重要运动/","content":"乒乓球不仅是一项让人挥汗如雨的运动，更是一种有效提升大脑敏锐性和反应能力的方式。作为一项需要高度专注、快速决策和身体协调的运动，乒乓球对大脑的锻炼效果得到了科学研究和实践的支持。本文将从神经科学、运动特点以及实际效果三个方面，探讨乒乓球如何帮助提升大脑的敏锐性。 一、乒乓球对大脑的刺激机制 快速反应与神经传导乒乓球的球速极快，往往需要在几毫秒内做出反应。大脑必须迅速处理视觉系统传递的信息，例如球的速度、旋转和方向，同时下达指令让身体完成协调动作。这种快速反应训练能够提升神经传导效率，加强神经元之间的连接。 多任务处理与决策能力在乒乓球比赛中，选手不仅需要接住对手的球，还需要预测下一步的攻防策略。这种多任务处理对大脑前额叶皮层（负责决策和计划）是一种良好的锻炼，有助于提高日常生活中的决策能力。 增强记忆与专注力乒乓球要求选手记住对手的习惯打法和自己的战术安排，同时保持高度专注。这种记忆与专注的训练，能够帮助大脑更高效地管理信息。 二、乒乓球的运动特点如何锻炼敏锐性 高频动作一场激烈的乒乓球比赛可能会有上千次击球，每次击球都需要身体和大脑的高度配合。高频率的动作要求大脑快速分析和反应，从而强化运动神经元的敏捷性。 不可预测性球的旋转、速度和落点充满变化，选手需要随时调整策略和动作。这种不可预测性迫使大脑保持灵活性，提升应变能力。 空间感知与身体协调乒乓球的球台虽然较小，但球的运动轨迹却复杂多变。大脑需要不断计算球的飞行路线，并指挥身体精确完成击球动作，这对空间感知和身体协调能力是一种良好的锻炼。 三、科学研究支持乒乓球对大脑的益处多项研究表明，乒乓球对大脑的锻炼效果显著。以下是几个研究发现： 提升认知能力日本的一项研究显示，长期打乒乓球的人在注意力和短期记忆测试中的表现优于不参与运动的人。 延缓大脑老化美国国家老龄化研究所的一项研究表明，乒乓球等需要快速反应的运动能够延缓老年痴呆症的发病，甚至改善患者的认知功能。 促进神经可塑性乒乓球运动能够刺激脑细胞的生长和连接，增强神经可塑性，这对于提高学习能力和记忆力尤为重要。 四、如何通过乒乓球提升大脑敏锐性？ 培养习惯每周打2-3次乒乓球，坚持30分钟以上，既能锻炼身体，又能提升大脑的敏锐性。 加入策略思考不仅仅是简单地击球，而是尝试分析对手的弱点、制定战术，让比赛更具挑战性。 提高专注度在比赛中保持专注，不被外界干扰，有助于将这种专注力延续到工作和学习中。 适应不同的对手和不同风格的对手对战，可以训练大脑快速适应新环境和新挑战的能力。 五、结语乒乓球不仅是一项娱乐性强、容易上手的运动，更是一种有效锻炼大脑敏锐性和反应能力的方式。从快速反应到多任务处理，从专注力提升到神经可塑性增强，乒乓球对大脑的益处是全方位的。如果你希望在工作和学习中保持头脑灵活，不妨拿起球拍，打一场酣畅淋漓的乒乓球吧！"},{"title":"程序员如何像神经网络一样高效学习：GPT 工具的使用与思考","path":"/2024/12/15/程序员如何像神经网络一样高效学习：GPT-工具的使用与思考/","content":"在 GPT 等生成式 AI 工具的加持下，程序员的工作效率得到了前所未有的提升。从代码生成到调试优化，再到技术学习，GPT 似乎可以成为编程路上的“全能助手”。然而，正如神经网络需要通过残差学习避免退化，程序员在使用 GPT 时，也需要找到合适的方式，将工具的增益与自身能力结合，确保效率提升的同时避免能力退化。 本文将探讨如何像神经网络一样，在 GPT 的辅助下高效学习与成长。 GPT 提高程序员效率的方式 快速代码生成与优化GPT 可以生成高质量代码片段，帮助程序员减少重复性工作，如实现算法模板、创建框架配置文件或优化已有代码。 实时技术支持在开发中遇到技术难题时，GPT 能提供解决方案或学习资源，减少搜索文档的时间。 文档与注释生成GPT 可自动生成注释或 API 文档，帮助程序员更快地整理代码逻辑。 辅助调试与错误排查通过分析错误日志和上下文，GPT 能提供可能的修复方案，加速调试过程。 促进学习与创新程序员可以借助 GPT 学习新技术、尝试新方法，快速掌握新的编程语言或框架。 问题：认识不足导致效率不升反降尽管 GPT 是强大的工具，但错误的使用方式可能带来以下问题： 过度依赖，忽视基础能力如果程序员完全依赖 GPT，而不主动理解生成代码的逻辑，可能导致基础能力退化。 需求描述不清晰GPT 的输出质量取决于输入的清晰度。如果程序员无法准确描述需求，生成的结果可能偏离预期。 忽视验证与调试直接使用 GPT 生成的代码而不验证，可能引入潜在的错误或性能问题。 误解工具局限性GPT 的知识来源于训练数据，对于特定领域的深度问题可能会出错。如果程序员不了解这些局限性，可能误用工具。 团队协作问题过度依赖 GPT 独立完成任务，可能降低与团队协作的能力。 解决方案：像神经网络一样学习为了让程序员在使用 GPT 时既提升效率，又确保能力不退化，可以借鉴神经网络的残差学习机制，采取以下策略： 1. 保留核心能力：基础技能是“原始信号”神经网络通过残差连接保留原始特征，程序员也应确保基础能力不被替代。 主动练习基础知识经常练习算法、数据结构、设计模式等核心技能，确保基础能力扎实。 分析与反思使用 GPT 提供的代码后，主动分析其逻辑，理解解决方案的优缺点。 独立完成部分任务在简单场景中，尝试独立完成任务，减少对工具的依赖。 2. 持续反馈学习：像梯度更新一样成长神经网络通过梯度下降不断优化模型，程序员也需要通过反馈不断提升能力。 记录与复盘每次使用 GPT 后，记录解决过程，定期复盘学习到的知识点。 错误驱动学习如果 GPT 提供了错误代码，主动分析问题，理解错误的来源与解决方法。 知识迁移将 GPT 的优质解决方案转化为自己的知识储备，例如整理为笔记或模板。 3. 正则化使用：避免过度依赖正则化防止神经网络过拟合，程序员也需要避免对 GPT 的过度依赖。 限制使用场景对 GPT 的使用设定规则，例如复杂问题或重复性任务时才使用，基础问题优先自己解决。 脱离工具练习定期设置“无工具日”，完全依靠自己的能力解决问题。 团队协作在团队讨论中，优先分享个人思路，再结合 GPT 的辅助建议。 4. 拓展能力：模拟多任务学习多任务学习增强了神经网络的泛化能力，程序员也应通过多领域学习提高技术广度。 跨领域学习利用 GPT 学习不同领域的技术（如前端、后端、AI），提升综合能力。 挑战高难度任务主动选择具有挑战性的任务，保持学习的动力。 真实场景应用在项目中应用 GPT 生成的代码，并尝试扩展功能或优化性能。 5. 保持批判性思维：认识工具的局限性神经网络的残差路径需要人为设计，程序员也需要清楚工具的优势与不足。 深刻理解 GPT 的原理学习 GPT 的生成逻辑和局限性，避免盲目信任。 验证与优化对 GPT 的输出进行验证，确保代码的正确性和性能。 辅助而非决策将 GPT 作为辅助工具，最终决策依赖程序员的判断。 总结：让工具成为增益，而非替代像神经网络的残差学习一样，程序员在使用 GPT 时，应该通过保留核心能力、持续反馈学习、限制工具依赖、拓展技术广度以及保持批判性思维，将 GPT 的增益与自身能力结合起来。 在 AI 工具日益普及的今天，程序员的核心竞争力不仅在于能高效使用工具，更在于能通过工具不断成长。只有将工具转化为学习和成长的助力，程序员才能在技术浪潮中立于不败之地。"},{"title":"关于技术学习、代码细节和技术崇拜的讨论","path":"/2024/12/14/关于技术学习、代码细节和技术崇拜的讨论/","content":"1. 为什么有人学编程时总想看懂每一个细节？ 求知欲驱动：对新知识的强烈好奇心，希望了解代码中每一个细节的意义。 害怕遗漏关键逻辑：担心忽略某些细节会导致对整体理解出错。 缺乏全局观：经验不足的人容易陷入“细节陷阱”，难以从整体上把握代码。 快速提升能力：认为通过细致研究可以学到更多编程技巧和知识点。 责任感驱动：在工作场景中，维护代码的人需要确保完全理解细节以避免问题。 编程风格学习：通过阅读他人代码学习最佳实践和设计模式。 完美主义倾向：追求对代码的“完全理解”，即使是用不到的部分也不放过。 缺乏代码阅读技巧：不会抓重点，导致逐行阅读，效率低下。 解决建议： 先理解代码整体逻辑，再逐步深入。 带着问题阅读，避免逐行分析。 通过实践自然理解细节，抓大放小，提高效率。 2. 技术“盲目崇拜”的现象和原因 社会宣传影响：新闻媒体长期将计算机技术与“高薪”“前沿”挂钩，塑造了技术“高人一等”的形象。 技术神秘化：编程在外行人眼中显得复杂，增加了技术的神秘感。 即时成就感：编程提供了快速反馈的成就感，让人更容易沉浸其中。 行业地位：技术被认为是推动社会发展的核心力量，进一步放大了其光环。 3. GPT等AI工具对技术价值的影响 降低技术门槛：AI工具让很多过去复杂的任务变得简单，降低了编程的稀缺性。 重新定义技术价值：从“能写代码”转向“能用技术解决实际问题”。 削弱技术光环：AI工具帮助人们理解技术细节，减少了技术的神秘感。 推动跨领域融合：技术与其他学科（艺术、教育、医学等）的结合可能成为新的价值增长点。 4. 技术溢出价值的变化 基础性地位不变：技术仍是推动社会进步的核心，但溢出价值可能会降低。 从稀缺资源到普遍工具：编程技能普及后，其高薪光环可能被削弱。 创造新价值：未来的重点可能是技术与领域知识的结合，而非单纯的技术实现。 5. 技术崇拜是否会回归理性？ 从“工具崇拜”到“问题导向”：技术将更多被视为解决问题的手段，而非目标。 技术人的重新定位：技术工作者的价值将更多体现在创造力和跨领域合作上。 教育方式的转变：编程教育可能从“教写代码”转向“教逻辑思维”和“教工具使用”。 总结 对代码细节的关注源于好奇心、责任感和学习方式，但需要平衡全局与细节以提高效率。 技术的“盲目崇拜”是社会环境和心理因素的产物，但AI工具（如GPT）正逐步去神秘化，降低技术门槛。 技术的溢出价值在降低，但其基础地位和跨领域的潜力仍然重要。 未来，人们对技术的态度可能更加理性，重视问题解决能力和跨领域创新。"},{"title":"一个符合审美的系统美化对前端程序员的重要性","path":"/2024/12/14/一个符合审美的系统美化对前端程序员的重要性/","content":"在前端开发的世界里，代码的整洁性和UI的美感总是被提及，但很少有人关注工作环境本身的视觉体验。其实，一个符合审美的系统美化不仅能提升工作效率，还能极大地影响程序员的心情和工作积极性。 默认主题的“疲惫感”我们经常会遇到这样的情况：打开电脑，面对一成不变的默认系统主题，心里会生出一丝抗拒感。对前端程序员而言，这种感觉尤为明显。因为我们对色彩、布局、字体等细节非常敏感，一个设计平庸甚至难看的系统主题很容易消磨我们对任务的热情。 试想，当你需要整理一堆散乱的文件时，如果系统界面枯燥无味，操作起来的心情就像在翻一堆旧报纸——无聊且机械。反之，如果系统主题是你喜欢的风格，比如清新的渐变色、干净的图标设计，甚至是符合个人审美的自定义主题，那么这些琐碎的工作也能变得有趣起来。 审美与效率的正向循环对前端程序员来说，系统美化并不仅仅是“看起来好看”，它更是一种对美感的追求和表达。这种审美能力可以直接迁移到我们日常的开发工作中，比如设计用户友好的界面、选择合适的配色方案、优化交互体验等。 此外，符合审美的系统环境还能帮助我们更专注地工作。例如： 清晰的界面布局：让我们更容易找到文件和工具。 柔和的配色方案：减少长时间盯着屏幕的视觉疲劳。 一致的设计语言：让操作更加流畅，减少“找不到感觉”的困扰。 当系统美化带来的舒适感提升了我们的心情，效率自然也会随之提高，这种正向循环在繁忙的开发过程中尤为重要。 如何进行系统美化？美化系统并不需要太多复杂的操作，可以从以下几个方面入手： 选择合适的主题：根据个人喜好选择一个符合审美的主题，Windows 和 macOS 都有丰富的主题选项，甚至可以使用第三方工具自定义主题。 优化字体与图标：更换清晰易读的字体（如 Fira Code、JetBrains Mono）和精美的图标包，让界面更加赏心悦目。 合理布局桌面：将文件和快捷方式按照类别分区，使用工具（如 Rainmeter 或 uBar）打造高效的桌面环境。 动态壁纸与色彩搭配：选择一个动态壁纸或渐变色背景，与系统主题搭配得当，让视觉体验更有层次感。 系统美化对职业发展的潜在帮助一个程序员对细节的关注，往往体现在工作中的方方面面。从系统美化开始，逐渐培养审美能力和细节意识，这些能力会在前端开发的职业道路上提供无形的助力。面试时，能展示出对设计的独到见解；工作中，能提出更具说服力的设计方案；甚至在和设计师合作时，也能用审美语言更高效地沟通。 结语系统美化不仅仅是为了让工作环境“好看”，更是为了让自己在日常开发中保持愉悦的心情和高效的状态。作为前端程序员，我们应该意识到美感的重要性，从系统的每一个细节开始，逐步培养对美的追求和把控能力。毕竟，热爱美的生活，也是一种提升工作的方式。 那么，今天就从更换一个喜欢的主题开始，让你的开发之旅更加美好吧！"},{"title":"程序员养成优秀习惯：文件整理、归类与定时清理的重要性","path":"/2024/12/14/程序员养成优秀习惯：文件整理、归类与定时清理的重要性/","content":"作为一名程序员，代码能力固然重要，但良好的工作习惯同样是提升效率、减少挫败感的重要因素。文件整理、归类与定时清理看似简单，却是许多人忽略的效率杀手。本文将探讨这些习惯如何帮助程序员更高效地工作，并分享一些实用技巧。 为什么文件整理如此重要？程序员日常工作中会接触到大量的文件：代码文件、配置文件、日志文件、文档、测试数据等。没有条理的文件管理会带来以下问题： 时间浪费：寻找文件时，可能要花费数分钟甚至更长时间，打断思路。 出错风险：使用错误的文件或覆盖关键文件，可能导致问题难以追溯。 占用存储：无序存储的文件堆积会占用磁盘空间，甚至拖慢开发环境。 一个良好的文件整理系统可以将这些问题最小化，让程序员专注于解决问题和写代码。 优秀文件管理习惯的具体表现 文件归类存放 项目级别分类：将每个项目的相关文件存放在独立的目录中，避免混淆。 功能模块分类：在项目内，根据功能模块（如frontend、backend、database）进一步划分子目录。 时间或版本分类：对于日志文件、备份文件，按日期或版本号命名存放，便于回溯。 示例目录结构： 12345678910├── MyProject│ ├── src│ │ ├── main.py│ │ └── utils.py│ ├── logs│ │ ├── 2024-12-01.log│ │ └── 2024-12-02.log│ ├── backups│ │ ├── v1.0.zip│ │ └── v1.1.zip 文件命名规范 清晰语义：避免使用final.doc或new_version.py这样的模糊名称，改用描述性强的名称，如invoice_parser_v1.2.py。 统一格式：采用统一的命名规则，例如[功能]_[版本号]_[日期]。 示例命名： user_auth_service_v1.2.py error_report_2024-12-14.log 定时清理文件 日志清理：开发中生成的调试日志往往占用大量存储，建议设定自动清理规则，例如保留最近30天的日志。 临时文件清理：如编译生成的中间文件（*.tmp、*.bak），可通过脚本或CI&#x2F;CD工具定期删除。 过期备份清理：保留重要版本的备份，删除无用的旧版本。 这些习惯如何提升效率？ 减少不必要的干扰良好的文件整理可以帮助你快速定位需要的文件，避免在混乱的文件夹中浪费时间。 降低沟通成本当需要与团队共享文件时，清晰的结构和命名可以减少解释时间，提升协作效率。 提升系统性能定时清理无用文件可以释放存储空间，避免开发环境因为磁盘不足而崩溃。 降低风险清晰的备份和日志管理让问题追踪更加简单，避免因文件混乱导致的不可逆错误。 工具与自动化实践 文件管理工具 Total Commander（Windows）：高效的文件管理工具，支持批量操作和文件搜索。 fdupes（Linux）：帮助查找重复文件，释放磁盘空间。 Finder + Automator（macOS）：结合Automator实现自动化整理。 自动化脚本使用Python脚本定期整理和清理文件。例如： 12345678910111213141516171819import osimport timefrom datetime import datetime, timedeltadef clean_old_logs(directory, days=30): now = time.time() cutoff = now - days * 86400 # 86400 seconds in a day for filename in os.listdir(directory): filepath = os.path.join(directory, filename) if os.path.isfile(filepath): file_mtime = os.path.getmtime(filepath) if file_mtime &lt; cutoff: print(f&quot;Deleting &#123;filepath&#125;&quot;) os.remove(filepath)# Example usagelog_dir = &quot;./logs&quot;clean_old_logs(log_dir, days=30) 版本控制系统Git等工具可以自动管理代码版本，减少手动备份的需求，同时提供清晰的文件历史。 案例分享：文件管理如何拯救我的工作日曾经在一个项目中，我的日志文件未及时清理，结果导致服务器磁盘空间耗尽，系统崩溃，花了数小时排查问题。后来我设置了自动清理脚本，每周定期清理无用日志，再也没有遇到类似问题。 另一次，由于文件命名不规范，团队在共享配置文件时出现了版本冲突，导致调试时间翻倍。吸取教训后，我们为所有配置文件制定了严格的命名规则，并且在README中明确了使用说明，极大地提升了协作效率。 总结程序员的效率不仅仅依赖于技术水平，还与日常习惯息息相关。通过养成良好的文件整理、归类和定时清理习惯，可以显著减少工作中的无效时间，提升团队协作的流畅度，并降低出错的风险。让我们从今天开始，整理好每一个文件夹，为更高效的编程生活打下坚实基础！"},{"title":"程序员命名的艺术：为什么清楚且不产生歧义的名字如此重要？","path":"/2024/12/14/程序员命名的艺术：为什么清楚且不产生歧义的名字如此重要？/","content":"在软件开发中，命名是程序员最常面对的挑战之一。你可能会花数小时写代码，但给变量、函数或类取一个清楚且不产生歧义的名字，可能需要更多的时间和思考。一个好的名字不仅能帮助当前的你快速理解代码，还能让未来维护代码的开发者少掉几根头发。本文将从几个方面探讨清楚且不产生歧义的命名为什么如此重要，以及如何做到这一点。 为什么清楚且不产生歧义的名字很重要？1. 代码的可读性编写代码的时间通常只占整个软件生命周期的一小部分，更多的时间花在阅读和维护代码上。如果命名清晰，代码逻辑就能直观地被理解，减少阅读的时间成本。 示例： 1234567# 模糊命名def calc(x, y): return x * y + x# 清晰命名def calculate_total_price(unit_price, quantity): return unit_price * quantity + unit_price 在第一个例子中，calc 和 x, y 让人完全摸不着头脑，而第二个例子则通过直观的命名，清楚表达了函数的用途和参数的意义。 2. 减少沟通成本清晰的命名可以让团队成员在讨论代码时，避免过多的解释和误解。模糊或歧义的命名可能导致开发者对同一段代码产生不同的理解，进而引发错误。 案例：一个变量命名为 data，而它实际上表示的是用户的登录信息。这样的命名不仅不准确，还可能让人误以为它是通用数据，导致在代码逻辑中被错误使用。 3. 降低错误发生的可能性模糊的命名往往是潜在 bug 的温床。一个名字如果不能准确表达它的意图，开发者可能会误用它。 示例： 1234567# 错误命名def get_info(): return &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25&#125;# 清晰命名def get_user_profile(): return &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25&#125; get_info 的命名范围太宽泛，可能导致调用者误解其返回值。而 get_user_profile 明确表明了它返回的是用户的个人资料。 4. 有助于代码复用清晰的命名可以让代码的用途一目了然，方便开发者在其他场景中直接复用，而无需深入研究其实现细节。 示例： 1234567# 不清晰def process(): pass# 清晰def process_image(image_path: str): pass process 这个名字让人摸不着头脑，而 process_image 明确表明了它是用于处理图像的函数。 如何做到清楚且不产生歧义？1. 遵循命名规范不同的编程语言有不同的命名约定，如 Python 中推荐使用 snake_case，而 Java 中则推荐使用 camelCase。遵循语言的命名规范可以提高代码的可读性。 2. 使用有意义的名字避免使用缩写或模糊的词汇，选择能够准确表达含义的单词。 示例： 1234567# 不推荐def calc_area(w, h): return w * h# 推荐def calculate_rectangle_area(width, height): return width * height 3. 保持一致性如果在代码中为某个概念选择了一个命名风格，就要始终如一地使用它。例如，如果你选择用 fetch 表示获取数据，就不要在其他地方用 get 或 retrieve 来表达同样的意思。 4. 避免歧义确保名字的含义是单一的，不会引起误解。 示例： 1234567# 容易产生歧义def handle(): pass# 更清晰def handle_user_input(): pass 5. 利用命名空间对于复杂的项目，可以通过模块、类或命名空间来组织名字，避免名字冲突。 示例： 123# 模块化命名user_service.get_user_profile()order_service.get_order_details() 总结清楚且不产生歧义的命名不仅是写好代码的基本功，更是一种责任心的体现。它可以让代码更易读、更易维护，并减少团队合作中的沟通成本。虽然好的命名可能需要花费更多时间，但从长远来看，这种投入绝对是值得的。 记住：代码是写给人看的，机器只是在执行它。用心命名，是每个程序员应有的追求。"},{"title":"卷积总结","path":"/2024/12/13/卷积总结/","content":"深入理解卷积神经网络中的卷积计算和 Padding卷积计算的数学模型基本符号定义设： 输入特征图尺寸：( H_{in} )（高度）× ( W_{in} )（宽度） 卷积核大小：( K \\times K ) 步长：( S ) 填充：( P ) 输出尺寸计算公式 输出特征图的高度：[H_{out} &#x3D; \\text{floor} \\left( \\frac{H_{in} + 2P - K}{S} \\right) + 1] 输出特征图的宽度：[W_{out} &#x3D; \\text{floor} \\left( \\frac{W_{in} + 2P - K}{S} \\right) + 1] Same Padding 的数学推导保持尺寸不变的条件要使输出尺寸与输入尺寸相同，需要满足：[H_{out} &#x3D; H_{in} \\quad \\text{且} \\quad W_{out} &#x3D; W_{in}] 推导过程将输出尺寸公式代入相等条件：[H_{in} &#x3D; \\text{floor} \\left( \\frac{H_{in} + 2P - K}{S} \\right) + 1] 对于步长 ( S &#x3D; 1 ) 的情况，公式化简为：[H_{in} &#x3D; H_{in} + 2P - K + 1]解得：[P &#x3D; \\frac{K - 1}{2}] 示例推导 3 × 3 卷积核，步长为 1 的情况 ( K &#x3D; 3, S &#x3D; 1 ) 解得 ( P &#x3D; \\frac{3 - 1}{2} &#x3D; 1 ) 5 × 5 卷积核，步长为 1 的情况 ( K &#x3D; 5, S &#x3D; 1 ) 解得 ( P &#x3D; \\frac{5 - 1}{2} &#x3D; 2 ) 一般性公式对于任意步长 ( S ) 和卷积核大小 ( K )，计算 Padding ( P ) 的公式为： 单侧填充：[P &#x3D; \\frac{(K - 1)}{2}]（仅适用于 ( K ) 为奇数的情况） 实际案例分析 示例 1：224 × 224 输入，3 × 3 卷积核 输入尺寸：( H_{in} &#x3D; 224 ) 卷积核大小：( K &#x3D; 3 ) 步长：( S &#x3D; 1 ) 计算 Padding：[P &#x3D; \\frac{3 - 1}{2} &#x3D; 1] 验证输出尺寸：[H_{out} &#x3D; \\text{floor} \\left( \\frac{224 + 2(1) - 3}{1} \\right) + 1 &#x3D; 224] 示例 2：112 × 112 输入，5 × 5 卷积核 输入尺寸：( H_{in} &#x3D; 112 ) 卷积核大小：( K &#x3D; 5 ) 步长：( S &#x3D; 1 ) 计算 Padding：[P &#x3D; \\frac{5 - 1}{2} &#x3D; 2] 验证输出尺寸：[H_{out} &#x3D; \\text{floor} \\left( \\frac{112 + 2(2) - 5}{1} \\right) + 1 &#x3D; 112] 关键 Insights Padding 的作用 Padding 不仅仅是为了填充边界，还可以保持特征图尺寸，避免信息丢失。 Same Padding 的精确性 对于奇数大小的卷积核，公式 ( P &#x3D; \\frac{K - 1}{2} ) 能直接计算单侧填充值。 对于偶数大小的卷积核，框架可能采用不对称填充方式（如 TensorFlow 的 tf.pad 或 PyTorch 的 F.pad）。 步长的影响 当 ( S &gt; 1 ) 时，输出尺寸公式会发生变化，Padding 的计算需要重新推导。 结论通过数学推导，我们可以精确计算保持特征图尺寸不变所需的 Padding 值。这种方法为卷积神经网络的设计提供了理论基础，使得我们能够精确控制特征提取过程中的空间信息。"},{"title":"MixVisionTransformer总结","path":"/2024/12/07/MixVisionTransformer总结/","content":"MixVision Transformer (简称 MViT) 是一种基于 Transformer 的视觉模型，最初由 SegFormer 提出（SegFormer 是一个高效的语义分割框架）。MViT 引入了一些关键改进，使得它在视觉任务中可以高效地建模全局上下文，同时保持较低的计算复杂度。 以下是 MixVision Transformer 的详细讲解： 1. 背景与动机Transformer 模型（例如 Vision Transformer, ViT）在视觉任务中取得了优异的表现，但它们存在一些问题，例如： 计算开销大：传统 Transformer 使用全局自注意力机制，计算复杂度为 (O(n^2))，n 是输入 token 数量。 局部特征建模不足：在视觉任务中，局部特征（如纹理、边缘等）非常重要，而标准 Transformer 没有专门设计来捕获这些特征。 MixVision Transformer 针对这些问题进行了改进，通过引入混合卷积和多尺度的设计，使得模型既高效又能捕获局部和全局上下文信息。 2. 架构设计MViT 的核心创新点包括以下几个方面： 2.1 混合卷积 + TransformerMViT 在 Transformer 的基础上引入了卷积操作。具体来说： 卷积操作 用于提取局部特征，并减少输入 token 数量（通过下采样）。 Transformer 模块 用于建模全局上下文信息。 这种结合能够有效地减少计算开销，同时保留局部和全局信息。 2.2 多尺度特征提取MViT 采用了分层设计（类似于 CNN 的金字塔结构），通过多次下采样和扩展特征图的通道数，逐步提取多尺度特征。 在每一层： 输入特征图经过卷积下采样（降低分辨率，增加通道数）。 Transformer 模块在下采样后的特征图上运行，建模全局上下文。 最终，输出的多尺度特征可用于下游任务（如语义分割）。 2.3 Transformer 块每个 Transformer 块的设计与标准 Transformer 类似，包括以下主要组件： 多头自注意力机制（Multi-Head Self-Attention, MHSA）：捕获全局上下文。 前馈网络（Feed-Forward Network, FFN）：非线性特征映射。 LayerNorm 和残差连接：稳定训练。 注意：MViT 的 MHSA 和 FFN 都经过优化，以适应视觉任务。 3. MViT 的分层结构MixVision Transformer 的分层结构可以概括为以下几个阶段： 输入与预处理 输入图像 (x \\in \\mathbb{R}^{H \\times W \\times C})。 使用卷积操作将图像分块为 patch，并降低分辨率（类似于 CNN 的下采样过程）。 分层处理MViT 包括多个阶段（例如 SegFormer 中有 4 个阶段），每个阶段包含以下内容： 卷积下采样：逐步降低特征图的分辨率（例如从 (H \\times W) 到 (H&#x2F;2 \\times W&#x2F;2)），同时增加通道数。 Transformer 模块：在每层的特征图上运行，用于增强全局上下文建模能力。 输出：每个阶段都会输出一个不同分辨率的特征图。 多尺度输出 每个阶段的输出特征图都可以被用于后续任务（例如语义分割中的解码模块）。 最终可以将多尺度特征进行融合或单独使用。 4. MixVision Transformer 的优点 高效性：通过卷积下采样减少了 Transformer 的计算复杂度，同时保留了重要的局部特征。 多尺度特征：分层设计能够提取多尺度特征，适合于需要精细和全局信息的任务（如语义分割）。 轻量化：相比于标准 Vision Transformer，MViT 的参数量和计算量更少，适合在各种设备上运行。 易于扩展：MViT 的分层设计可以灵活调整参数（层数、下采样率等），以适应不同大小的模型和任务。 5. 应用场景MixVision Transformer 已成功应用于多个任务，尤其是语义分割领域。例如： SegFormer：使用 MViT 作为编码器，表现优于传统 CNN 和标准 Transformer。 目标检测：MViT 作为主干网络（backbone），能够有效捕获目标的多尺度特征。 图像分类：虽然 MViT 主要针对密集预测任务，但也可以用于图像分类。 6. 和其他视觉 Transformer 的对比 模型类型 特点 优点 缺点 ViT 全局自注意力，固定大小的 patch 分割 全局建模能力强 对数据量依赖大，计算复杂 Swin Transformer 分层设计，基于滑动窗口的局部自注意力 高效，支持多尺度 局部建模略显不足 MixVision Transformer 混合卷积与 Transformer，多尺度特征提取 高效，兼顾局部和全局建模 仍需较大计算资源 7. 总结MixVision Transformer 是一种将卷积和 Transformer 优势结合的视觉模型，具有高效性和多尺度特征提取能力，非常适合密集预测任务（如语义分割）。其分层设计和混合卷积的引入，使得它在计算开销和性能之间实现了良好的平衡。 如果你对 SegFormer 感兴趣，可以深入了解其如何利用 MViT 编码器来实现高效的语义分割。"},{"title":"代码注释总结","path":"/2024/12/07/代码注释总结/","content":"代码注释总结在软件开发的世界中，代码注释不仅是开发者之间沟通的重要桥梁，更是让代码具备可读性、可维护性的重要手段。优质的注释可以帮助开发者快速理解复杂的逻辑，而糟糕的注释却有可能导致更多的困惑。在这篇博客中，我们将从多个角度探讨代码注释的意义、类型、最佳实践以及需要避免的常见问题。 为什么需要代码注释？尽管我们都希望代码是“自解释”的，然而现实世界中，代码并不总能清晰地表达其意图。以下是代码注释的重要性： 提高可读性： 注释可以帮助开发者快速理解代码的功能和意图，尤其是逻辑复杂的部分。 方便团队协作： 在团队开发中，不同开发者的思路各异，注释使得大家在协作时更高效。 减少维护成本： 良好的注释可以减少后续维护时的时间成本，降低理解代码的学习曲线。 历史记录： 注释可以记录代码的变更历史或某些设计选择的原因，避免重复踩坑。 代码注释的类型根据使用场景，代码注释可以分为以下几种类型： 1. 功能性注释功能性注释用于解释代码的功能或作用，通常出现在函数、类或模块的声明处。 1234567891011def calculate_area(radius): &quot;&quot;&quot; 计算圆的面积。 参数: radius (float): 圆的半径。 返回: float: 圆的面积。 &quot;&quot;&quot; return 3.14159 * radius ** 2 适用场景： 为函数、类或模块提供清晰的上下文信息。 描述输入输出、边界条件或特殊用法。 2. 实现性注释实现性注释用于解释代码的实现逻辑，通常出现在具体的代码段中。 123456789# 使用二分法查找目标值while left &lt;= right: mid = (left + right) // 2 if arr[mid] == target: return mid # 找到了目标值，返回索引 elif arr[mid] &lt; target: left = mid + 1 # 排除左半部分 else: right = mid - 1 # 排除右半部分 适用场景： 代码逻辑复杂，单靠代码本身难以理解。 包含特定算法或优化技巧。 3. 标记性注释标记性注释用来提示开发者注意某些特殊情况或未来需要处理的问题，常用的关键词包括 TODO、FIXME 等。 1234# TODO: 优化此处的算法，提升性能# FIXME: 修复当输入为空时的边界问题if data is None: raise ValueError(&quot;Input data cannot be None&quot;) 适用场景： 提醒未来需要改进或修复的地方。 暂时的解决方案或技术债务。 4. 文档注释文档注释通常用于大型项目中，为整个模块或文件提供概要信息。 12345678910111213&quot;&quot;&quot;模块名称: 数据处理模块作者: 张三创建时间: 2024-12-07功能:- 数据清洗- 特征工程- 数据导出注意事项:- 本模块依赖 pandas 和 numpy。&quot;&quot;&quot; 适用场景： 为模块或文件提供整体说明，便于快速理解文件内容。 记录模块的依赖关系、注意事项等。 注释的最佳实践为了让注释真正发挥作用，以下是一些值得遵循的最佳实践： 1. 注释要简洁明了注释的目的是帮助理解代码，而不是重复代码。避免写冗长无用的注释。 糟糕的例子： 1i = 0 # 将变量 i 初始化为 0 好的例子： 1i = 0 # 计数器，用于记录迭代次数 2. 注释要与代码保持同步过时的注释比没有注释更糟糕。代码修改后，请务必同步更新注释。 糟糕的例子： 123# 计算矩形的面积def calculate_area(length, width): return length + width # 实际是计算周长，但注释未更新 3. 避免过多注释注释应适度，不是每一行代码都需要注释。如果代码已经足够简单清晰，就不需要额外的注释。 糟糕的例子： 123x = 10 # 定义变量 x，值为 10y = 20 # 定义变量 y，值为 20z = x + y # 将 x 和 y 相加，结果赋值给 z 好的例子： 12# 计算商品的总价格（单价乘以数量）total_price = unit_price * quantity 4. 使用一致的注释风格在团队开发中，统一的注释风格可以提高代码的可读性和一致性。例如，使用公司或团队的注释规范。 常见风格： 使用完整的句子，首字母大写，句末加标点。 中文代码注释风格：保持简洁直白，避免中英文混杂。 英文代码注释风格：语法规范，避免拼写错误。 5. 避免注释显而易见的内容不要注释那些显而易见的代码，比如变量声明或简单的赋值操作。 糟糕的例子： 1x = 5 # 将变量 x 赋值为 5 好的例子： 12# 设置初始值为 5，表示起始节点的编号x = 5 常见的注释反模式 无用的注释： 注释毫无意义，甚至对代码理解造成误导。 过度依赖注释： 使用注释解释糟糕的代码，而不是简化代码。 过时的注释： 注释描述的内容与代码不符，容易导致误解。 写 “废话” 注释： 注释只是代码的重复，没有任何额外价值。 结语优秀的代码注释是开发者职业素养的体现，它不仅方便了自己，也帮助了团队中的其他人。在写注释时，始终记住以下几点： 注释是为人写的，不是为机器写的。 注释应描述“为什么”，而不是“如何”。 注释应清晰简洁，不拖泥带水。 当你写代码时，请始终记得，未来的你可能会感谢现在写下的那些清晰而有价值的注释。希望这篇总结能够帮助你写出更高质量的代码注释！"},{"title":"大小顶堆总结","path":"/2024/12/01/大小顶堆总结/","content":"大顶堆（Max Heap）和小顶堆（Min Heap）是两种基于完全二叉树的堆数据结构，它们用于实现高效的优先队列。 大顶堆（Max Heap）大顶堆是一种堆数据结构，其中每个节点的值都不小于其子节点的值。换句话说，根节点的值是整个堆中的最大值。 特点： 完全二叉树：大顶堆是一棵完全二叉树。 节点关系：对于堆中的每个节点，父节点的值总是大于或等于其任何一个子节点的值。 最大值在根节点：堆顶（根节点）是最大值，方便快速访问最大元素。 常见操作： 插入：在堆底添加一个新元素，然后向上调整以保持堆性质。 删除最大值：移除根节点，将最后一个节点放到根的位置，然后向下调整以保持堆性质。 堆排序：利用堆构建有序数据序列，通常通过构建大顶堆来实现升序排列。 小顶堆（Min Heap）小顶堆是一种堆数据结构，其中每个节点的值都不大于其子节点的值。换句话说，根节点的值是整个堆中的最小值。 特点： 完全二叉树：小顶堆也是一棵完全二叉树。 节点关系：对于堆中的每个节点，父节点的值总是小于或等于其任何一个子节点的值。 最小值在根节点：堆顶（根节点）是最小值，方便快速访问最小元素。 常见操作： 插入：在堆底添加一个新元素，然后向上调整以保持堆性质。 删除最小值：移除根节点，将最后一个节点放到根的位置，然后向下调整以保持堆性质。 优先队列：常用于实现优先队列，以快速访问和删除最小元素。 应用场景 优先队列：堆被广泛用于优先队列中，因为它能在 O(log n) 时间复杂度内插入元素和删除最大或最小元素。 堆排序：利用堆的特性实现排序算法。 图算法：如Dijkstra算法、Prim算法中用于高效获取当前最小（或最大）边。 这两种堆结构在具体实现中通常使用数组来实现，通过索引计算来找到父子节点的位置，从而节省内存和提高效率。"},{"title":"nextjs总结","path":"/2024/12/01/nextjs总结/","content":"在现代 Web 开发中，Next.js 作为一个强大的 React 框架，因其提供的服务器端渲染（SSR）、静态站点生成（SSG） 等功能受到广泛欢迎。尽管 SSR 具有显著的性能优势，但它也带来了服务器压力等新挑战。本文将深入探讨 SSR 的原理、优势及其应对高并发的优化策略。 1. 什么是服务器端渲染（SSR）？服务器端渲染（SSR，Server-Side Rendering） 是指在服务器上将 React 组件渲染成 HTML，然后将完整的 HTML 页面发送到客户端。这与传统的客户端渲染（CSR） 相对立。 SSR 与 CSR 的流程对比： 客户端渲染（CSR）流程： 服务器发送一个基本的 HTML 文件以及 JavaScript 文件。 浏览器下载并执行 JavaScript，然后生成页面内容。 用户通常在加载过程中看到空白或加载动画。 服务器端渲染（SSR）流程： 服务器生成完整的 HTML 页面（包含动态数据）。 浏览器直接显示完整内容，无需等待 JavaScript 执行。 JavaScript 加载后在后台继续处理交互逻辑（Hydration）。 2. 为什么 SSR 更快？首屏加载速度 SSR 优势：服务器直接发送完整的 HTML，用户几乎立即看到页面内容。 CSR 问题：首屏加载依赖 JavaScript 完成渲染，延迟较长。 SEO 友好 SSR 优势：搜索引擎爬虫能够直接读取页面内容，提高页面索引效率。 CSR 问题：爬虫可能无法执行复杂的 JavaScript，导致无法抓取内容。 3. SSR 的挑战：服务器压力SSR 需要服务器为每个请求生成完整的 HTML，这可能导致以下问题： 计算开销大：每个请求都需要服务器处理并渲染。 高并发挑战：当用户请求量大时，服务器可能无法快速响应。 如何优化 SSR 性能？1. 缓存策略（Caching） 页面缓存：将生成的 HTML 缓存，减少重复渲染。例如使用 Redis 缓存常访问的页面。 数据缓存：对数据库查询结果进行缓存，减少对数据库的压力。 CDN 缓存：将静态资源和部分动态内容分发到 CDN 节点，减少服务器负担。 2. 静态站点生成（SSG） 混合渲染：对不频繁更新的页面使用 SSG，而动态页面采用 SSR。 增量静态再生（ISR）：Next.js 提供的 ISR 功能可以在构建后定期更新静态页面。 3. 负载均衡（Load Balancing） 作用：将请求分发到多台服务器，提升并发处理能力。 实现方式： 使用 Nginx 或 HAProxy 进行负载分配。 云服务（如 AWS、Azure）提供内置负载均衡功能。 4. 局部服务器渲染（Partial SSR） 并非所有页面都需要 SSR，可以选择性地渲染关键内容。 例如，登录后的用户数据可以使用客户端渲染。 5. 异步数据加载 延迟加载非关键内容：例如评论区或推荐内容，可以在页面加载后通过 API 获取。 6. 选择合适的架构 Node.js 集群模式：利用多核服务器运行多个实例处理请求。 无服务器架构（Serverless）：按需扩展，避免资源浪费。例如使用 Vercel 部署 Next.js。 4. 总结：SSR 的最佳实践 结合多种渲染模式：根据页面需求选择 SSR、SSG 或 CSR。 利用缓存优化：使用页面缓存、数据缓存和 CDN 缓解服务器压力。 扩展服务器架构：通过负载均衡、无服务器技术提升并发能力。 关注性能监控：持续优化数据库查询、减少不必要的 SSR。 SSR 是否适合你的项目？适合 SSR 的场景： 需要良好 SEO 的内容站点（如博客、新闻站点）。 首屏加载速度要求高的应用（如电商、企业站点）。 适合 CSR 的场景： 高度交互的单页应用（SPA）。 用户动态数据较多的场景。 通过合理配置和优化，SSR 能够在提供优质用户体验的同时，保持高性能和稳定性。Next.js 使这一过程变得更加简单和高效，是开发现代 Web 应用的不二之选。"},{"title":"如何在 VPN 网络下配置 Git 代理解决 `git clone` 失败的问题","path":"/2024/11/26/在VPN网络下配置Git代理解决git_clone失败问题/","content":"在 VPN 环境下，有时你可能会遇到 Git 命令（如 git clone）无法正常工作的问题，通常这是由于网络配置问题或者 Git 无法正确通过代理服务器访问远程仓库。本文将介绍如何配置 Git 代理来解决这个问题。 1. 为什么会遇到 Git Clone 失败的问题？在使用 VPN 时，网络流量会被加密并通过代理服务器转发。这意味着 Git 可能无法直接访问 GitHub、GitLab 或其他 Git 仓库，特别是在 VPN 网络下。如果你没有正确配置代理，Git 就无法与远程仓库建立连接，导致 git clone 等命令失败。 2. 配置 Git 代理要解决这个问题，你需要告诉 Git 如何通过代理服务器来访问远程仓库。你可以通过配置 HTTP 或 HTTPS 代理来实现。 2.1 配置本地代理（127.0.0.1）假设你的代理服务器运行在本地（127.0.0.1），端口号为 1080（这常见于 SOCKS 代理），你可以通过以下命令为 Git 配置代理： 12git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080 在上面的命令中，127.0.0.1 是代理服务器的地址，1080 是代理端口号。如果你使用的是其他端口号，请相应地修改。 2.2 配置代理时需要认证如果你的代理服务器需要身份验证，你可以在代理 URL 中指定用户名和密码。格式如下： 12git config --global http.proxy http://username:password@127.0.0.1:1080git config --global https.proxy https://username:password@127.0.0.1:1080 将 username 和 password 替换为你的代理认证信息。 3. 使用 SOCKS 代理如果你的 VPN 软件提供的是 SOCKS 代理（通常是通过 127.0.0.1:1080 或类似的端口），Git 本身并不直接支持 SOCKS 代理，但你仍然可以通过一些工具间接实现这一点。 3.1 使用 tsocks 工具tsocks 是一个可以让不支持 SOCKS 代理的程序通过 SOCKS 代理进行网络访问的工具。你可以安装并配置 tsocks，然后在 tsocks 环境下执行 Git 命令。具体步骤如下： 安装 tsocks： 在 Linux 上，使用以下命令安装： 12sudo apt install tsocks # 对于 Debian/Ubuntu 系统sudo yum install tsocks # 对于 CentOS/RHEL 系统 配置 tsocks： 编辑 tsocks 配置文件 /etc/tsocks.conf，将其中的 server 和 server_port 配置为你的 SOCKS 代理地址（通常是 127.0.0.1 和端口 1080）： 12server = 127.0.0.1server_port = 1080 使用 tsocks 执行 Git 命令： 例如，执行 git clone： 1tsocks git clone https://github.com/username/repository.git 这样，Git 就会通过 SOCKS 代理进行操作。 3.2 使用 proxifier（Windows）如果你使用的是 Windows 系统，可以使用工具如 Proxifier，它可以强制任何程序（包括 Git）通过 SOCKS 代理进行网络连接。 4. 禁用 SSL 验证（可选）有时，VPN 连接可能会导致 SSL 证书问题。如果你确定网络安全没有问题，并且希望绕过 SSL 验证，可以暂时禁用 Git 的 SSL 验证： 1git config --global http.sslVerify false 注意，禁用 SSL 验证会降低安全性，建议只在完全信任的网络环境下使用。 5. 调试 Git 代理配置如果问题仍然存在，Git 提供了调试选项来帮助你查找问题。你可以使用 GIT_TRACE 和 GIT_CURL_VERBOSE 环境变量，输出更多调试信息： 1GIT_TRACE=1 GIT_CURL_VERBOSE=1 git clone https://github.com/username/repository.git 这将显示详细的请求日志，帮助你了解 Git 连接失败的原因。 6. 结语通过配置 Git 代理，你可以解决在 VPN 网络下使用 Git 时遇到的 git clone 失败问题。无论是通过 HTTP、HTTPS 代理，还是通过 SOCKS 代理，正确的配置都能帮助你顺利完成代码的克隆、推送和拉取操作。如果你遇到任何问题，可以通过调试命令获取更多信息，帮助定位问题根源。"},{"title":"itopmap系统开发复盘","path":"/2024/11/24/itopmap系统开发复盘/","content":"ChatGPT发挥了多大作用? 页面UI的调整 软件思维必须要独立弄懂，不然看不懂别人的代码，不知道如何prompt。 如何理解代码框架（OpenlayerJS）？为什么说调库简单？因为这是相较于实现库来说，实现库需要数学知识和算法思维，这往往是最考验智商的，专业且具有才华的程序员已经实现了这些功能将其封装为一个知识产品了，对于调库的程序员来说，只需要将精力放在看懂知识产品对应的说明书就行，这可能也需要花一些精力，但相对于实现哪些复杂的库来说难度要低很多，站在库构建者角度来说，肯定是希望用户不用花太多的学习成本就能用库方便的构建很多有价值的产品。作为公司，招聘程序员第一也应该是看应聘者将说明书看懂没有，然后才是看对底层实现细节理解的如何。现在的程序员能构建的软件相比于十年前已经复杂很多了，如果非要程序员从每个细节开始学习，那么就很难提高技术的转化率，技术是为社会服务的，脱离了这一前提的技术没有实际意义，只能称其为爱好，这也是专业程序员和以编程为爱好的极客的区别。","tags":["软件开发项目复盘"]},{"title":"如何平衡算法学习与Prompt工程能力的提升？","path":"/2024/11/23/如何平衡算法学习与Prompt工程能力的提升？/","content":"在AI技术蓬勃发展的今天，程序员和开发者不仅需要扎实的算法基础，还需要掌握有效与AI模型交互的Prompt设计能力。以下是一些平衡这两种技能提升的策略和实践经验： 1. 打牢基础：算法与Prompt的核心知识 算法：理解数据结构、经典算法（如排序、搜索、动态规划等），培养逻辑思维和问题解决能力。 Prompt工程：熟悉AI模型的工作原理，掌握基本的Prompt设计技巧，例如如何精确描述任务、调整模型输出风格等。 2. 实践项目驱动学习通过实际项目锻炼算法和Prompt能力： 结合型项目：选择既需要算法优化又涉及AI模型交互的项目，例如智能推荐系统、对话机器人等。 实验与迭代：在项目中设置不同阶段，专注于优化算法性能或改进Prompt设计，逐步提升综合能力。 3. 定期复习与更新知识 算法：参与LeetCode、HackerRank等平台的编程挑战，保持技能熟练度。 Prompt优化：关注AI和NLP领域的新进展，尝试不同模型如GPT、Claude等，探索新的Prompt技巧。 4. 团队合作与角色分配在团队项目中： 算法专家：负责性能优化、数据处理等核心算法任务。 Prompt设计师：负责与AI模型交互的任务，如对话设计、文本生成优化。 跨角色培训：鼓励团队成员相互学习，增加协作理解。 5. 敏捷学习与小步迭代 短期目标：设定可衡量的小目标，比如掌握一种算法或设计一个有效Prompt。 反馈循环：在实践中收集反馈，优化学习策略，逐步提高技能水平。 6. 保持兴趣与动力 项目驱动：选择感兴趣的项目领域，通过解决实际问题保持学习动力。 社区参与：加入技术社区、参与开源项目、参加Hackathon，获取激励和认可。 7. 应对信息过载 专注主题：每次学习时聚焦于特定主题，避免分散注意力。 休息与反思：合理安排学习与休息时间，定期复盘已学内容。","tags":["算法","prompt"]},{"title":"异或总结","path":"/2024/11/23/异或总结/","content":"在计算机科学中，异或运算（XOR）是一种非常常见的位运算，它有着独特的性质和广泛的应用，尤其是在数组问题和密码学中。本文将介绍如何利用异或运算高效地解决数组中的问题，并探讨其在密码学中的应用。 一、异或运算的基本概念异或运算（XOR）是一种对两个输入进行比较的逻辑运算，其规则如下： 如果两个输入相同（即 0 ⊕ 0 或 1 ⊕ 1），则结果为 0。 如果两个输入不同（即 0 ⊕ 1 或 1 ⊕ 0），则结果为 1。 异或的真值表 A B A ⊕ B 0 0 0 0 1 1 1 0 1 1 1 0 异或的基本性质 交换律：A ⊕ B &#x3D; B ⊕ A 结合律：A ⊕ (B ⊕ C) &#x3D; (A ⊕ B) ⊕ C 自反性：A ⊕ A &#x3D; 0 单位元：A ⊕ 0 &#x3D; A 无进位加法：A ⊕ B 类似于对二进制数进行加法运算，但没有进位。 这些性质使得异或运算在解决一些数组和加密问题时非常高效。 二、利用异或解决数组中的唯一数问题1. 题目描述给定一个整数数组，其中每个元素都出现了两次，只有一个元素出现了一次，要求找出这个唯一的元素。 2. 解决思路利用异或的特性，所有出现两次的元素都会互相抵消，因为 A ⊕ A = 0。最终剩下的就是那个唯一的元素。 3. 代码实现123456789def find_single_number(nums): result = 0 # 初始化结果为 0 for num in nums: result ^= num # 对数组中的每个数字进行异或 return result # 返回最终的结果# 示例nums = [2, 3, 2, 4, 4]print(find_single_number(nums)) # 输出 3 4. 解释 初始时，result = 0。 对数组中的每个元素进行异或运算：0 ⊕ 2 = 22 ⊕ 3 = 11 ⊕ 2 = 33 ⊕ 4 = 77 ⊕ 4 = 3 最终，result 的值是 3，即唯一出现一次的元素。 5. 时间与空间复杂度 时间复杂度：O(n)，需要遍历数组一次。 空间复杂度：O(1)，只用了一个额外的变量 result。 6. 应用场景该方法适用于需要找出唯一元素的问题，如数据流处理、传感器数据分析等。 三、异或运算在密码学中的应用异或运算在密码学中有着重要的应用，尤其是在加密算法和数据保护中。其特性使得异或成为许多密码学算法的核心操作。 1. 对称加密（XOR 加密）在对称加密算法中，明文数据与密钥进行异或操作，从而生成密文。解密时，只需要将密文与相同的密钥再进行一次异或操作，就能恢复出原始的明文。 基本原理 加密：明文 ⊕ 密钥 &#x3D; 密文 解密：密文 ⊕ 密钥 &#x3D; 明文 示例：XOR 加密与解密1234567891011def xor_encrypt_decrypt(data, key): return [chr(ord(c) ^ key) for c in data]# 示例plain_text = &quot;Hello, World!&quot;key = 123 # 一个简单的密钥cipher_text = xor_encrypt_decrypt(plain_text, key)print(&quot;加密后的文本:&quot;, &#x27;&#x27;.join(cipher_text))decrypted_text = xor_encrypt_decrypt(cipher_text, key)print(&quot;解密后的文本:&quot;, &#x27;&#x27;.join(decrypted_text)) 2. 流加密（如 RC4）流加密算法，如 RC4，利用异或运算和伪随机密钥流对数据进行加密。在 RC4 中，密钥流与明文数据逐位进行异或，生成密文。解密时，使用相同的密钥流再进行一次异或操作即可恢复明文。 3. 哈希函数许多哈希函数（如 SHA 系列）在内部使用异或运算。通过对数据的每一位进行异或操作，哈希函数能够将任意长度的输入映射到固定长度的输出，并尽可能避免哈希冲突。 4. HMAC（哈希消息认证码）HMAC（Hash-based Message Authentication Code）是一种基于哈希函数和密钥的消息认证码。在 HMAC 中，异或运算用来混合密钥和消息，确保消息的完整性和认证。 5. 数字签名与消息认证在消息认证和数字签名中，异或运算被用于确保消息的完整性。在基于密钥的消息认证码（HMAC）算法中，消息和密钥的组合通过异或运算生成唯一的认证码，验证消息是否被篡改。 6. 伪随机数生成在一些加密算法中，异或运算用于生成伪随机数。通过对不同的种子值进行异或操作，可以生成不可预测的密钥流或掩码，增强加密的安全性。 四、总结异或运算是一个非常强大的工具，不仅在解决数组问题时提供了高效的解决方案，还在密码学中发挥着至关重要的作用。通过其独特的性质，如自反性、交换律和结合律，异或能够在加密、哈希、消息认证和伪随机数生成等多个领域提供高效且安全的解决方案。 在数组问题中，异或的应用可以帮助我们快速找到唯一的元素，而在密码学中，它则成为许多加密算法的核心操作。随着对异或运算深入理解，我们能够在更多实际问题中发挥其强大的能力。","tags":["算法"]},{"title":"华为云Flexus L实例无法通过公网ip访问","path":"/2024/11/17/华为云Flexus-L实例无法通过公网ip访问/","content":"端口放行配置错了安全组然后服务器又绑定了另一个未未配置放行端口的安全组。","tags":["运维"]},{"title":"openai api调用格式","path":"/2024/11/16/openai-api调用格式/","content":"https://platform.openai.com/docs/quickstart?language-preference=python"},{"title":"什么是 HTTP 请求中的 Origin 头？如何在特殊场景下处理它？","path":"/2024/11/12/什么是-HTTP-请求中的-Origin-头？如何在特殊场景下处理它？/","content":"在 Web 开发中，跨域请求（Cross-Origin Requests）常常让开发者头疼，而 Origin 头是跨域资源共享（CORS）机制中必不可少的组成部分。本文将详细介绍 Origin 头的作用、为什么它与用户的 IP 不同，以及如何在特定场景下实现“不携带 Origin 头”的请求。 什么是 Origin 头？Origin 头是浏览器在发起 HTTP 请求时自动添加的，用于标识请求的来源。这一头部信息由协议（如 https）、域名（如 example.com）和端口组成。它的主要作用是帮助服务器判断请求的来源是否被允许访问资源，是浏览器实现同源策略和CORS的关键部分。 例如，当你在浏览器中打开 https://example.com 并访问 https://api.example.com 时，请求的 Origin 头可能会显示为： 1Origin: https://example.com 通过这个头部，服务器可以知道该请求来源于 https://example.com，并决定是否允许该跨域请求访问资源。 Origin 头 vs. 用户 IP很多人容易混淆 Origin 头和用户的 IP 地址。虽然请求确实是从用户的电脑发出的，但 Origin 头和用户 IP 是两个完全不同的概念： Origin 头表示网页来源：Origin 头标识的是网页的来源域（例如 https://example.com），而不是用户设备的地址。它主要用于同源策略的安全判断，帮助服务器控制跨域请求。 用户 IP 表示设备的网络位置：用户的 IP 地址则是用户设备在网络中的地址，与物理位置和网络连接有关，用于路由传输。IP 不包含网页来源的信息，因此服务器无法依赖 IP 来判断请求是从哪个网页发起的。 为什么需要 Origin 头？浏览器的同源策略（Same-Origin Policy）规定，网页脚本只能访问与其来源相同的资源，Origin 头正是这一机制的组成部分。通过 Origin 头，服务器能够明确请求来源，并决定是否允许跨域访问。这在防止跨站请求伪造（CSRF）等安全攻击上非常有效。 如何实现不携带 Origin 头的请求？在一些特殊场景中，可能需要发送不带 Origin 头的 HTTP 请求，跳过浏览器的同源策略检查。以下几种方法可以实现这一效果，但需谨慎使用，以免引入安全风险。 1. 使用非浏览器客户端发送请求浏览器会自动添加 Origin 头，但在使用非浏览器的 HTTP 客户端（如 Python 的 requests 库、Node.js 的 http 模块、cURL）时，可以手动控制请求头部，不携带 Origin 头。例如： 123import requestsresponse = requests.get(&#x27;https://example.com/api&#x27;, headers=&#123;&#125;) # 不携带 Origin 头 这种方法适用于后端环境或自定义客户端应用，但不适合浏览器环境。 2. 使用代理服务器如果需要从浏览器中发起不带 Origin 头的请求，可以设置一个代理服务器。通过代理转发请求，浏览器只会与代理通信，而代理则在将请求发送到目标服务器时省略 Origin 头。 示例：NGINX 配置 1234location /proxy/ &#123; proxy_pass https://example.com/api; proxy_hide_header Origin;&#125; 此方法允许浏览器请求先发送到代理服务器，由代理移除 Origin 后转发到目标服务器。 3. 利用 JSONP（仅限 GET 请求）在一些跨域 GET 请求中，可以通过 JSONP（JSON with Padding）技术绕过同源策略。JSONP 利用 &lt;script&gt; 标签加载目标资源，不需要 Origin 头，但只能用于 GET 请求，且要求目标服务器支持 JSONP。 123456&lt;script src=&quot;https://example.com/api?callback=myCallbackFunction&quot;&gt;&lt;/script&gt;&lt;script&gt; function myCallbackFunction(data) &#123; console.log(data); &#125;&lt;/script&gt; 4. 服务器端控制 CORS 配置如果你拥有服务器的控制权限，并希望允许不带 Origin 头的请求，可以调整服务器的 CORS 配置。不过，这种方法依赖服务器端控制，并不是绕过 Origin 的方式。 小结Origin 头是 HTTP 和浏览器安全机制的重要组成部分，用于识别请求来源，确保跨域请求的安全性。在特定场景下，可以通过使用非浏览器客户端、代理服务器、JSONP 等方法实现不携带 Origin 头的请求。不过，需要谨慎使用这些方法，避免绕过浏览器的安全策略带来的潜在风险。 跨域和安全控制始终是 Web 开发中的重点，理解 Origin 头的作用、区别它和用户 IP，将有助于更好地配置和管理跨域资源共享（CORS）。","tags":["前端开发","计算机网络与通信"]},{"title":"Vue 项目中的代码注释规范：提升可读性与可维护性","path":"/2024/11/11/Vue-项目中的代码注释规范：提升可读性与可维护性/","content":"在现代 JavaScript 开发中，Vue.js 因其灵活的组件化结构和易学易用的特性广受欢迎。随着项目的日益复杂，良好的代码注释规范变得尤为重要。在 Vue 项目中，注释不仅仅帮助开发人员理解代码逻辑，还能提升团队协作效率，减少沟通成本。本文将结合 Vue 项目，讨论如何编写清晰、简洁且有效的代码注释。 为什么注释很重要？代码注释的核心目标是提升代码的可读性、可维护性，并帮助开发人员理解代码的意图而非仅仅是实现。尤其是在 Vue 项目中，常常涉及复杂的组件交互、状态管理、路由控制等，良好的注释能让团队成员和未来的开发人员更容易理解代码背后的设计思想和业务逻辑。 良好的注释规范能帮助你： 解释“为什么”做某事，而不是“怎么做”：代码本身能说明“怎么做”，注释则应解释为何要这样做。 避免重复：注释不应重复代码，应该补充代码中无法直接表达的内容。 促进团队协作：多人协作的项目中，注释是沟通的桥梁。 注释的类型和使用场景在 Vue 项目中，常用的注释类型包括单行注释、多行注释和文档注释。不同类型的注释适用于不同的场景： 1. 单行注释单行注释适合对单行代码或某些简单逻辑进行简短说明。 12345data() &#123; return &#123; count: 0 // 用于存储计数器的初始值 &#125;;&#125; 2. 多行注释当某段逻辑较为复杂或需要详细解释时，可以使用多行注释。 1234567891011/* * 该方法处理用户登录逻辑： * 1. 检查用户名和密码的合法性 * 2. 通过 API 请求进行登录 * 3. 根据返回结果设置登录状态 */methods: &#123; login() &#123; // 登录逻辑 &#125;&#125; 3. 文档注释文档注释（如 JSDoc）用于描述函数、组件或模块的功能、参数及返回值。在 Vue 项目中，文档注释尤其对组件及其方法非常重要。 123456789101112131415161718192021222324252627/** * 用户登录组件 * * @component * @description 用于用户输入用户名和密码并进行登录 */export default &#123; name: &#x27;Login&#x27;, data() &#123; return &#123; username: &#x27;&#x27;, password: &#x27;&#x27; &#125;; &#125;, methods: &#123; /** * 登录函数，执行用户名和密码验证，并调用 API 进行登录 * * @param &#123;string&#125; username - 用户名 * @param &#123;string&#125; password - 密码 * @returns &#123;Promise&#125; 登录结果 */ login(username, password) &#123; // 登录逻辑 &#125; &#125;&#125;; Vue 项目中的注释规范在 Vue 项目中，代码注释的规范化非常关键，特别是在 Vue 的各个部分（如 data、methods、computed、watch、props 等）中。下面将介绍如何在这些常见的 Vue 代码部分中编写有效的注释。 1. data 和 props 注释在 Vue 中，data 和 props 通常需要注释，尤其是当项目中多个组件共享某些数据或属性时。注释可以帮助开发人员快速了解数据的来源和目的。 123456789101112131415161718192021222324252627props: &#123; /** * 用户名 * @type &#123;string&#125; */ username: &#123; type: String, required: true &#125;, /** * 登录成功后的回调函数 * @type &#123;Function&#125; */ onLoginSuccess: &#123; type: Function, default: () =&gt; &#123;&#125; &#125;&#125;,data() &#123; return &#123; /** * 存储当前输入的密码 * @type &#123;string&#125; */ password: &#x27;&#x27; &#125;;&#125; 2. methods 注释在 Vue 组件的 methods 中，注释帮助描述每个方法的功能、参数和返回值。这对于理解业务逻辑尤为重要。 123456789101112131415161718methods: &#123; /** * 用户注册 * * @param &#123;string&#125; username - 用户名 * @param &#123;string&#125; password - 密码 * @returns &#123;Promise&#125; 注册结果 */ register(username, password) &#123; return this.$axios.post(&#x27;/api/register&#x27;, &#123; username, password &#125;) .then(response =&gt; &#123; this.$router.push(&#x27;/login&#x27;); &#125;) .catch(error =&gt; &#123; console.error(error); &#125;); &#125;&#125; 3. computed 和 watch 注释对于计算属性 (computed) 和侦听器 (watch)，注释不仅能帮助描述计算逻辑，还能帮助理解为何监听某个状态的变化。 12345678910111213141516171819202122computed: &#123; /** * 获取用户的欢迎信息 * * @returns &#123;string&#125; 用户欢迎信息 */ welcomeMessage() &#123; return `欢迎，$&#123;this.username&#125;`; &#125;&#125;,watch: &#123; /** * 监听密码变化，验证密码长度是否合规 */ password(newVal) &#123; if (newVal.length &lt; 6) &#123; this.passwordError = &#x27;密码必须至少6个字符&#x27;; &#125; else &#123; this.passwordError = &#x27;&#x27;; &#125; &#125;&#125; 常见注释实践在开发过程中，除了普通的注释，以下几个注释标签也非常常见，能帮助团队更好地管理任务和提醒问题。 TODO：标记待办事项，提醒自己或团队成员某些功能尚未完成。 1// TODO: 完成注册流程的UI设计 FIXME：标记需要修复的错误或问题。 1// FIXME: 登录表单缺少验证码功能 NOTE：用于提供特别的提醒或说明。 1// NOTE: 使用异步组件加载时，确保相关模块已经编译完成 注释更新的重要性随着项目的推进，代码和功能会不断变化。为了避免代码与注释不一致，开发人员应养成同步更新注释的习惯。如果你修改了某个方法或组件的逻辑，记得更新相应的注释。过时的注释不仅无用，甚至可能误导团队成员。 结语在 Vue 项目中，良好的注释习惯是确保代码可读性和可维护性的关键。通过清晰的注释，团队成员能够更快速地理解业务逻辑和组件间的关系，减少沟通成本和维护难度。注释不仅能提升代码质量，还能促进团队协作和代码复用。 记住：注释是帮助他人理解代码的工具，而非为了取代代码的可读性。保持注释的简洁、清晰与准确，才能发挥其最大的价值。","tags":["前端开发","Vue"]},{"title":"leetcode 141. 环形链表","path":"/2024/11/11/leetcode-141-环形链表/","content":"1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; // 0 let slow = head; let fast = head; let ret = false; // 1 while(fast &amp;&amp; fast.next !== null)&#123; fast = fast.next.next slow = slow.next; if(fast === slow)&#123; ret = true; break; &#125; &#125; // 2 return ret;&#125;; 循环中有fast &#x3D; fast.next.next需要判断fast.next不为空容易想到，还需要判断fast不为空，一个是从外部进入循环时的判断，一个是执行了fast &#x3D; fast.next.next后的判断，也可以将fast是否为空的判断写到fast &#x3D; fast.next.next这行之后（如果fast为空则用break跳出循环）","tags":["leetcode","算法"]},{"title":"vue,typescript项目打包报错","path":"/2024/11/10/vue-typescript项目打包报错/","content":"&#x2F;&#x2F; @ts-ignore：无法被执行的代码的错误","tags":["前端开发","Vue"]},{"title":"工作汇报总结","path":"/2024/11/08/工作汇报总结/","content":"计算制作PPT和开会的产出比","tags":["软件项目复盘"]},{"title":"html,css,js和Vue，Vuetify的关系","path":"/2024/11/05/html-css-js和Vue，Vuetify的关系/","content":"在前端开发领域，Vue和Vuetify常常被组合使用，尤其是在希望快速构建出高质量的、具备一致性视觉效果的应用时。这两者之间的关系却并非那么直观。Vue 是一个框架，而 Vuetify 是一个 UI 组件库——二者的定位和功能有着明显的差异，但也存在紧密的协作关系。本文将带你深入了解 Vue 和 Vuetify 的相互关系，并解释为什么它们的结合能提升开发效率。 1. Vue 是框架，Vuetify 是 UI 组件库首先，我们来看看 Vue 和 Vuetify 各自的定位。 Vue：Vue.js 是一个渐进式的 JavaScript 框架，主要用来构建用户界面，核心功能是通过数据驱动的方式来渲染视图。Vue 提供了响应式数据绑定、组件化管理、路由控制、状态管理等功能，它的设计理念是简洁灵活，让开发者专注于应用的业务逻辑和数据流管理。 Vuetify：Vuetify 是一个基于 Material Design 的 Vue UI 组件库。它主要提供符合视觉设计规范的预定义组件，比如按钮、表单、导航栏、卡片等。这些组件是高度可自定义的，帮助开发者在 Vue 应用中快速实现一致性 UI，而不必自己设计和开发样式。 因此，Vue 更专注于应用逻辑和架构，而 Vuetify 专注于视觉和交互设计。Vue 的关注点在于实现应用的核心逻辑，而 Vuetify 则让我们专注于页面的美观与用户体验。 2. Vue 提供框架结构，Vuetify 提供视觉和交互设计Vue 和 Vuetify 可以被理解为“逻辑与视觉”的关系： Vue 负责应用逻辑，提供数据的双向绑定、生命周期管理等，让页面可以随数据动态更新。 Vuetify 提供了大量预定义的 UI 组件，开发者无需关心复杂的样式调整，只需在 Vue 的架构中引入这些 Vuetify 组件，即可快速实现高质量的界面。 Vue 搭建应用的逻辑框架，而 Vuetify 完成 UI 细节的展现。这种明确的分工大大提升了开发效率——我们可以专注于业务逻辑，而 Vuetify 则为我们完成了 UI 部分的视觉实现。 3. Vue 和 Vuetify 之间是解耦的关系Vue 和 Vuetify 之间没有强依赖关系。Vue 是一个独立的框架，可以结合其他 UI 库（如 Element、Ant Design Vue 等）来实现界面，也可以自己编写 CSS 和 HTML 模板；Vuetify 是 Vue 生态系统中的一个插件，因此使用它并非必需。 Vuetify 是一种可选的、灵活的 UI 解决方案。它只是 Vue 生态系统的一个补充部分，旨在提供高度自定义的、符合 Material Design 规范的组件库，帮助开发者快速搭建界面。如果项目需求有特殊的 UI 设计要求，开发者可以选择不使用 Vuetify，而是自行设计和实现。 这种解耦性赋予了开发者灵活性，让他们可以根据需求选择是否使用 Vuetify 作为 Vue 应用的 UI 库。 4. Vue 作为底层逻辑，Vuetify 作为视觉呈现Vue 和 Vuetify 的关系可以用“底层逻辑”与“视觉呈现”来描述： Vue 作为底层逻辑层，控制应用的状态、数据流、组件生命周期等核心机制，是应用的“内核”。 Vuetify 则利用 Vue 的组件机制构建了大量可复用的 UI 组件，使其成为上层的 UI 展现工具。Vuetify 的每一个组件实际上都是一个 Vue 组件，它依赖 Vue 的响应式系统和双向绑定功能来实现动态更新和数据渲染。 Vuetify 正是基于 Vue 的灵活机制构建出来的，可以通过 Vue 实现数据的动态绑定，同时让用户界面符合 Material Design 规范。Vue 处理的是逻辑和数据，Vuetify 负责将这些逻辑和数据以符合视觉规范的方式呈现给用户。 总结：Vue 与 Vuetify 的优势互补Vue 和 Vuetify 的关系可以理解为一个负责逻辑、一个负责视觉： Vue 是应用的逻辑骨架：它让我们可以用更少的代码实现复杂的应用逻辑，提供响应式、组件化的开发体验。 Vuetify 是 UI 层的组件库：它封装了丰富的 UI 组件，帮助我们快速构建视觉一致、功能完善的界面。 在 Vue 搭建的应用结构中引入 Vuetify，可以大大提升开发效率，让我们专注于业务逻辑，而不必担心 UI 的美观性和一致性。对于希望快速构建出美观、现代应用的开发者来说，Vue 和 Vuetify 的组合是一个很好的选择。","tags":["Vue","Vuetify","前端框架","UI组件库"]},{"title":"MMSegmentation进阶指南-数据流","path":"/2024/11/03/MMSegmentation进阶指南-数据流/","content":"Runner 相当于 MMEngine 中的“集成器”。它覆盖了框架的所有方面，并肩负着组织和调度几乎所有模块的责任，这意味着各模块之间的数据流也由 Runner 控制。Runner中实现上述不同颜色的传递（TrainLoop、ValLoop 和 TestLoop）MMSegmentation的DataLoader和Pytorch的DataLoader保持一致。","tags":["MMSegmentation"]},{"title":"从计算机线程中学习到的6个工作道理","path":"/2024/11/03/从计算机线程中学习到的6个工作道理/","content":"从计算机线程中学习到的6个工作道理在软件开发中，线程是让计算机执行多任务的基本机制。线程如何管理、分配和执行任务的原理，能启发我们如何有效地组织和管理日常工作。这篇博客将从计算机线程的工作方式中总结出6个可应用于工作的道理，帮助我们提升效率、优化流程。 1. 任务分解与并行执行线程原理：线程通过将复杂任务分解成多个可以并行处理的小任务，提高了执行效率。工作启示：在项目管理中，尝试将复杂的大任务拆分成可独立执行的小任务，并让团队成员并行处理。这不仅缩短了总任务完成时间，还让每个人更专注于具体任务。 示例：例如在开发一个产品时，可以让一个小组负责前端，另一个小组负责后端，再分配一组专门进行测试，这样不同小组可以同时展开工作，最终加快项目整体进度。 2. 资源共享与竞争管理线程原理：多线程环境下，线程之间共享计算机资源，必须避免资源竞争或死锁。工作启示：团队成员在共享资源时，必须避免冲突。明确各自资源的分配，合理安排资源使用，设定优先级和规则，能够帮助团队避免资源争夺，实现更高效的协作。 示例：在跨部门合作时，常会涉及共享数据或技术资源。可以制定共享资源的访问机制，例如规定各部门的数据提取时间和频率，确保资源得到合理利用。 3. 同步与协调线程原理：多线程工作中，通过同步来确保数据一致性。工作启示：工作中，团队成员需要定期沟通和同步进展，以保持任务的一致性。我们可以通过每日站会、每周例会等方式，确保大家在同一个步调上，有效地避免信息不对称。 示例：例如，项目管理中可以采用敏捷开发的每日站会形式，让每个成员汇报进展和遇到的问题，方便团队成员保持对项目的统一认识。 4. 负载均衡与优化线程原理：在多线程编程中，合理分配任务到各个线程避免超载，以优化整体性能。工作启示：在团队中，合理分配任务以避免某些成员过度负担，确保大家工作量适中。既能保证每个人的高效工作，也能防止人力资源浪费。 示例：在资源紧张的项目中，可以根据团队成员的专长和工作量，合理分配任务。避免让某个人承担过多工作，导致项目进度延误。 5. 容错与恢复机制线程原理：在多线程中，一个线程出错不会导致整个系统崩溃，它可以被独立恢复或重启。工作启示：在工作中，当某个环节出问题时，应该设立容错机制，快速修复而不影响整体进度。这样可以防止小问题演变成阻碍项目的瓶颈。 示例：在项目开发中，可以定期备份代码，或者采用版本控制系统（如Git）来管理代码，确保在某个功能模块出错时，能够快速恢复到上一个稳定版本。 6. 优先级与抢占式调度线程原理：多线程系统中，优先级高的任务会优先获得资源。工作启示：在工作中，我们需要对任务设定优先级，优先处理紧急或重要的任务，以确保关键任务得到及时处理。 示例：在接到多个任务时，可以采用优先级评估法（如“重要-紧急”矩阵），先处理重要且紧急的任务，确保不因次要任务延误核心工作。 总结计算机线程的工作原理，不仅能帮助我们理解程序的运行机制，也能为日常工作管理提供启发。将任务分解、管理资源、同步协调、负载优化、容错恢复和优先调度这些线程中的管理方式应用到工作中，有助于我们更高效地组织项目，提升团队协作效率。希望这些从线程中获得的道理，能够成为你工作中的小助手！"},{"title":"快速更新失效域名证书方法","path":"/2024/11/03/快速更新失效域名证书方法/","content":"服务器端如果是windows直接登录CA官网进行域名证书的更新替换"},{"title":"node版本号排序","path":"/2024/11/01/node版本号排序/","content":"const versions &#x3D; [‘1.10.2’, ‘1.3’, ‘2.0.1’, ‘1.5.1’, ‘1.5’, ‘1.4.1’]; 进行排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 测试数据集（无歧义版本号，所有版本号格式统一）const testCases = [ &#123; input: [&#x27;10.0&#x27;, &#x27;2.0&#x27;, &#x27;1.9&#x27;, &#x27;1.10&#x27;, &#x27;1.8&#x27;], expected: [&#x27;1.8&#x27;, &#x27;1.9&#x27;, &#x27;1.10&#x27;, &#x27;2.0&#x27;, &#x27;10.0&#x27;], description: &quot;主要版本不一致的情况，测试两位版本号的比较&quot; &#125;, &#123; input: [&#x27;1.10&#x27;, &#x27;1.3&#x27;, &#x27;2.0&#x27;, &#x27;1.5&#x27;, &#x27;1.4&#x27;], expected: [&#x27;1.3&#x27;, &#x27;1.4&#x27;, &#x27;1.5&#x27;, &#x27;1.10&#x27;, &#x27;2.0&#x27;], description: &quot;包含主版本和次版本，避免歧义&quot; &#125;, &#123; input: [&#x27;1.0&#x27;, &#x27;1.1&#x27;, &#x27;1.0.1&#x27;, &#x27;1.2&#x27;, &#x27;1.0.0&#x27;], expected: [&#x27;1.0&#x27;, &#x27;1.0.0&#x27;, &#x27;1.0.1&#x27;, &#x27;1.1&#x27;, &#x27;1.2&#x27;], description: &quot;包含固定格式版本，补位0&quot; &#125;, &#123; input: [&#x27;2.1&#x27;, &#x27;2.0&#x27;, &#x27;1.9&#x27;, &#x27;1.10&#x27;, &#x27;1.10.1&#x27;], expected: [&#x27;1.9&#x27;, &#x27;1.10&#x27;, &#x27;1.10.1&#x27;, &#x27;2.0&#x27;, &#x27;2.1&#x27;], description: &quot;小版本和补丁更新及主版本升级&quot; &#125;, &#123; input: [&#x27;0.1&#x27;, &#x27;0.0.1&#x27;, &#x27;0.10&#x27;, &#x27;0.2&#x27;, &#x27;0.2.0&#x27;], expected: [&#x27;0.0.1&#x27;, &#x27;0.1&#x27;, &#x27;0.2&#x27;, &#x27;0.2.0&#x27;, &#x27;0.10&#x27;], description: &quot;补位和次版本，不存在单一数字的歧义&quot; &#125;];/** * 用户需要在这里完成 sortVersions 函数 */function sortVersions(arr) &#123; let newArr = arr.map(e =&gt; e.split(&#x27;.&#x27;).map(Number)); newArr.sort((a, b) =&gt; &#123; for(let i = 0; i &lt; 3; i++)&#123; if(a[i] != b[i])&#123; return a[i] - b[i] &#125; &#125; return 0 &#125;); return newArr.map(e =&gt; e.join(&#x27;.&#x27;));&#125;/** * 判题系统：检查用户的排序结果是否符合预期 */function judge() &#123; testCases.forEach((&#123; input, expected, description &#125;, index) =&gt; &#123; const userSortedVersions = sortVersions([...input]); // 不改变原数组 const result = userSortedVersions.join(&#x27;,&#x27;) === expected.join(&#x27;,&#x27;) ? &#x27;Accepted&#x27; : &#x27;Wrong Answer&#x27;; console.log(`Test Case $&#123;index + 1&#125;: $&#123;description&#125;`); console.log(&quot;Input Versions: &quot;, input); console.log(&quot;User Sorted Versions: &quot;, userSortedVersions); console.log(&quot;Expected Result: &quot;, expected); console.log(&quot;Judge Result: &quot;, result); console.log(&quot;-------------&quot;); &#125;);&#125;// 运行判题系统judge();"},{"title":"react总结","path":"/2024/10/30/react概述/","content":"1. 组件（Components） 功能组件：函数形式的组件，返回 JSX。 类组件：通过类定义的组件，适用于较复杂的逻辑，但一般现在推荐使用功能组件。 2. JSX React 使用 JSX 语法，允许你在 JavaScript 中直接书写 HTML。 注意：JSX 需要用 className 代替 HTML 的 class。 3. 状态（State）与属性（Props） Props：父组件传递给子组件的数据，组件通过 props 接收。 State：组件内部的状态，用于控制组件的渲染。 4. 生命周期方法 对于类组件，有一些内置的生命周期方法（如 componentDidMount、componentDidUpdate 等）。 在功能组件中，可以使用 useEffect Hook 来处理副作用。 5. Hooks useState：用于管理组件状态。 useEffect：用于处理副作用，类似于生命周期方法。 自定义 Hook：可以封装逻辑，以便在多个组件中复用。 6. 事件处理 在 React 中，事件处理是通过 CamelCase 命名的，比如 onClick。 事件处理函数可以直接传递，但要注意 this 的绑定（在类组件中）。 7. 条件渲染与列表渲染 条件渲染可以通过 JavaScript 表达式实现，比如使用三元运算符。 列表渲染通常使用 map 方法，记得为每个元素提供唯一的 key。 8. 表单处理 在 React 中，表单元素的值通常由组件的 state 控制（受控组件）。 使用 onChange 事件处理输入变化。 9. 组件间通信 使用 props 进行父子组件通信。 对于兄弟组件，可以通过提升状态到共同的父组件。 10. 路由 使用 React Router 进行路由管理，常用组件有 BrowserRouter、Route 和 Link。 总结你可以通过构建一个简单的 Todo 应用来实践这些概念。这样可以让你对 React 的结构和思维方式有更深入的理解。 面试时，除了掌握以上基础概念，还可以关注一些常见的面试问题，例如： React 的虚拟 DOM 是什么？ 描述一下 React 的单向数据流。 在 React 中如何优化性能？","tags":["前端开发","react"]},{"title":"nvm","path":"/2024/10/30/nvm总结/","content":"nvm 是 “Node Version Manager” 的缩写，用于管理 Node.js 的版本。对于 Node.js 开发者来说，有时候在不同的项目中需要不同的 Node.js 版本，而手动切换和管理这些版本会比较麻烦。nvm 能帮助用户轻松地安装、管理和切换不同的 Node.js 版本。 1. 安装 nvmmacOS 和 Linux在 macOS 和 Linux 系统上可以使用以下命令安装 nvm： 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash 安装完成后，重启终端或运行以下命令，让 nvm 生效： 1source ~/.bashrc # 或者 source ~/.zshrc，根据使用的终端而定 Windows在 Windows 上可以使用 nvm-windows 版本，它是专门为 Windows 系统开发的 Node 版本管理器，与 Linux&#x2F;macOS 的版本稍有不同，但功能类似。下载并按照安装向导进行安装。 2. 常用命令 安装特定版本的 Node.js 1nvm install &lt;版本号&gt; 例如，安装 Node.js 14： 1nvm install 14 列出已安装的 Node.js 版本 1nvm list 或者可以用 nvm ls 查看本地已安装的版本列表。 切换 Node.js 版本 1nvm use &lt;版本号&gt; 例如，切换到 Node.js 14： 1nvm use 14 查看可用的远程版本 使用以下命令可以查看所有可安装的远程 Node.js 版本： 1nvm ls-remote 卸载某个版本的 Node.js 1nvm uninstall &lt;版本号&gt; 例如，卸载 Node.js 14： 1nvm uninstall 14 设置默认版本 如果希望在每次新打开终端时使用某个默认版本，可以使用以下命令： 1nvm alias default &lt;版本号&gt; 3. 使用场景nvm 特别适用于以下场景： 不同项目的依赖：如果某个项目使用 Node.js 14 而另一个项目依赖 Node.js 16，可以使用 nvm 快速切换版本。 测试兼容性：需要测试代码在多个 Node.js 版本上的表现，可以通过 nvm 安装多个版本并来回切换。 方便升级或降级：nvm 让升级到最新版本、或临时降级到旧版本变得很容易。 注意事项 nvm 只在当前用户的 shell 环境中生效，不会修改系统级的 Node.js 版本。 如果安装了 nvm，尽量不要再使用其他方式（如直接从官网安装）来安装 Node.js，以免发生冲突。"},{"title":"itopmap网站专题页面分析","path":"/2024/10/27/itopmap网站专题页面分析/","content":"卷帘添加节流处理，防止当用户拖动滑块地图组件触发较频繁"},{"title":"itopmap网站首页UI分析","path":"/2024/10/26/itopmap网站首页UI分析/","content":"1. 地图的居中对齐和填充布局 地图区域在整个页面中被居中显示，填充整个屏幕的可视区域。这通常是通过 flex布局 或 CSS grid布局 实现的，结合 justify-content: center 和 align-items: center 来水平和垂直居中。 地图本身会自动填满可用空间，保持响应性，可能使用了 position: relative 配合 width: 100% 和 height: 100vh 的设置，以确保地图在浏览器窗口大小变化时仍能适应。 2. 浮动的工具栏和按钮 页面左侧和底部的几个按钮（放大镜、回退按钮、层级选择按钮等）是独立浮动的。它们的位置可能是通过 绝对定位（position: absolute）实现的，以便于将它们固定在地图上某个具体的坐标。 z-index 可能用于这些工具栏按钮，以确保它们始终显示在地图之上，而不被地图或其他元素覆盖。 3. 按钮组的相对布局和排列 底部的 Esri、BingMap、OSM 按钮看起来是成组显示的，应该是一个水平排列的 flexbox 容器。可能使用了 display: flex 和 justify-content: space-around 或 justify-content: center 来让按钮均匀分布，且保持在页面底部。 它们的位置可能通过 position: absolute 或 position: fixed 与底部对齐（例如 bottom: 20px），确保这些按钮在页面滚动时保持固定位置。 4. 顶部菜单的相对和绝对布局 顶部菜单（“提交订单”、“开启&#x2F;关闭Roi”）是悬浮在地图顶部的，通常是使用 绝对定位 或 固定定位（position: fixed），使其在页面滚动时也保持在视窗顶部不动。 top 和 left 属性可以用来精确控制这些按钮的位置，而 z-index 则用于确保它们位于地图之上，始终可见。 5. 图标和按钮的对齐 左侧一列工具栏图标的排列方式可以通过 垂直 flexbox 布局或 垂直对齐的 CSS 样式 实现，使所有按钮按顺序纵向排列。 这些按钮的位置可能是通过 position: fixed 或 position: absolute 实现的，与地图内容相对布局，不会在地图移动时发生变化。 6. z-index 的应用 z-index 在此页面中起着重要作用，确保悬浮按钮（如工具栏按钮和底部地图切换按钮）总是显示在地图之上。通常 z-index 值较高的元素会覆盖值较低的元素，确保了用户交互性和可视性。 7. 响应式设计 地图本身具有响应性，在不同屏幕尺寸上会自动缩放。可能使用了媒体查询（@media）或者相对单位（如 % 或 vh/vw）来确保在不同设备和分辨率上都能自适应。 8. CSS 动画效果 这些按钮在点击时可能有动画效果，比如放大、缩小或阴影变化，可以通过 CSS transitions 或 animations 实现。例如 transform: scale(1.1) 可以用来实现按钮点击后的轻微放大效果。 总结这个页面布局运用了多种前端布局技术，包括 flexbox、absolute positioning、z-index、relative positioning 和响应式布局等，确保了地图和悬浮工具栏按钮的交互性和可视性。"},{"title":"从二叉树遍历视角看递归思想","path":"/2024/10/25/从二叉树遍历视角看递归思想/","content":"比如中序遍历左中右（适用于一棵仅有三个节点的小二叉树和由无数小的二叉树构成的大二叉树，区别在与小二叉树的子树是一个节点（最小的树），大二叉树的是一棵较大的树，都是符合二叉树的定义） 二叉树是一个抽象的概念，不要被名字误导，二叉树存储的信息包括二叉树的节点值和节点与节点之间的关系，理解了这层逻辑，叫二叉啥都无所谓。 中序遍历就是对二叉树中存储的信息进行读取的一种方式。读取的原则是先读取左子树的信息，再读取根节点的信息，再读取右子树的信息，这个简称逻辑A（如果子树中还有更小的子树-左子树或右子树, 根节点就是自身，不存在多态现象，根节点起连接节点关系的作用，这个子树中也执行同样的逻辑A，那么就可以将整棵树的信息按照中序遍历这种信息提取方式进行读取），其他遍历顺序同理。 关于递归容易让人产生迷雾，需要认识到的是递归函数是一个会调用自身的函数，这点和普通函数有区别，其之所以写起来代码简洁也是来源于这个性质。 递归函数很适合遍历一颗二叉树，因为递归函数自身调用自身的性质和二叉树节点连接节点的性质是一致的。 递归相关的题型可以用和“数形结合”类似的“码形结合”来分析，在脑海中左边是代码，右边是二叉树图像，这两者是可以对应联系起来的。 JavaScript的函数套函数性质可以实现求解一些不是用递归能一下解决、但递归可以作为求解此问题的核心思想的题目，因为递归过程中的参数在外层函数的作用域中。"},{"title":"回溯算法总结","path":"/2024/10/24/回溯算法总结/","content":"有递归就有回溯，因为如果递归进去如果没有找到结果就需要回到之前的位置往另一个方向递归（比如遍历树的情况），有的递归不容易看出回溯可能是没有用完全体的递归。","tags":["算法"]},{"title":"ps中新建图层分辨率，像素，厘米总结","path":"/2024/10/24/ps中新建图层分辨率，像素，厘米总结/","content":"如何理解 Photoshop 中的分辨率、像素与物理尺寸：打印时的最佳实践在设计或打印图像时，我们常常会遇到一些技术细节，比如像素、PPI（像素每英寸）、和物理尺寸。这些概念看似简单，但它们之间的关系决定了图像的质量和打印效果。如果你曾经想要打印一张图片，并发现打印出来的效果与预期不同，图像可能模糊或尺寸不对，那么你可能需要更好地理解它们之间的联系。本文将详细解析这些概念，并教你如何在 Photoshop 中使用这些参数进行正确的设置，确保打印出高质量的图像。 像素 vs. PPI vs. 物理尺寸：它们的区别是什么？1. 像素（Pixel）像素是图像的基本单位。任何数字图像都是由一个个小像素点组成的，每个像素都有不同的颜色和亮度。当你在 Photoshop 中看到一个512×512像素的图片，意味着这个图片在屏幕上是由512个宽度和512个高度的像素点构成。 像素本身没有物理尺寸的概念，它是纯粹的数字单位，主要影响图像在屏幕上的显示大小。 2. PPI（像素每英寸，Pixel Per Inch）PPI 表示每英寸包含多少个像素，它主要影响图像的打印质量和清晰度。较高的PPI意味着每英寸包含更多的像素，图像看起来更精细；较低的PPI则意味着图像在物理尺寸上变大，但像素分布较稀疏，可能导致图像变得模糊。 常见的PPI值： 72 PPI：适用于屏幕显示，如网页设计。 300 PPI：用于高质量的打印输出，能确保清晰细腻的图像效果。 3. 物理尺寸物理尺寸是图像在现实世界中的实际大小，如厘米或英寸。它与像素数和PPI直接相关。举个例子，如果你有一张分辨率为300 PPI的图片，并且宽度是1000像素，那么打印出来的物理宽度就是：[\\frac{1000 , \\text{像素}}{300 , \\text{PPI}} &#x3D; 3.33 , \\text{英寸} , (约 8.46 , \\text{厘米})]这表明在300 PPI的分辨率下，1000像素宽的图像打印尺寸为3.33英寸。 PPI 与物理尺寸的关系PPI与物理尺寸之间的关系可以总结为：PPI越高，打印的物理尺寸越小；PPI越低，打印的物理尺寸越大。然而，较低的PPI会导致图像在打印时失去清晰度，因为每个像素对应的物理面积变大，像素被拉伸。 例子：假设你有一张512×512像素的图片，并想打印成不同的尺寸： 300 PPI：打印出的尺寸约为 1.71×1.71英寸（4.35×4.35厘米），图像非常清晰。 100 PPI：打印出的尺寸变为 5.12×5.12英寸（13×13厘米），图像变大，但清晰度下降。 72 PPI：打印尺寸增至 7.11×7.11英寸（约18×18厘米），但细节变得模糊，适合屏幕显示，不适合高质量打印。 如何在 Photoshop 中设置物理尺寸与分辨率当你准备打印图片时，以下是你在 Photoshop 中的操作步骤： 打开图像后，选择“图像 &gt; 图像大小”。 在弹出的对话框中，你可以调整图像的物理尺寸（宽度和高度），并设置分辨率（PPI）。 勾选“重采样”选项，如果你希望 Photoshop 通过增加或减少像素数来适应你的物理尺寸和分辨率要求。 Photoshop 会根据你设定的PPI和物理尺寸，自动计算合适的像素数，或者调整现有的像素来满足你的需求。 重要提示：如果你不调整PPI而仅仅修改物理尺寸，Photoshop仍然会打印出你指定的尺寸，但图片可能会模糊。如果你想确保图像在指定的物理尺寸下保持高质量，建议使用300 PPI的分辨率。 为什么指定物理尺寸时要关注PPI？在打印图像时，像素数是固定的，不能任意放大或缩小。当你指定了物理尺寸，PPI 决定了图像在这个物理尺寸下的清晰度。如果像素数不足，强行将图像打印到过大的物理尺寸上，图像会变得模糊。这就是为什么打印时要调整 PPI 来匹配图像的物理尺寸。 换句话说，任意物理尺寸并不总是合适的。你需要确保图片的像素数和PPI值能够适应你所希望的打印大小和清晰度要求。 总结：如何选择合适的 PPI 和打印尺寸在 Photoshop 中，物理尺寸、PPI 和像素数三者紧密相关。为了确保打印质量： 如果你需要一个高质量的打印图像，通常建议使用 300 PPI 或更高的分辨率。 低于 100 PPI 的图像可能会在打印时显得模糊，尤其当你要求较大的物理尺寸时。 在打印前，确保根据图像的实际像素数和分辨率设置合理的物理尺寸。 通过设定正确的 PPI 和尺寸，Photoshop 可以帮助你实现精确的打印效果，避免不清晰或不合适的尺寸问题。 通过理解 PPI 和物理尺寸的关系，你可以更好地控制图像的输出质量，确保最终打印效果符合你的期望。"},{"title":"在vue项目中，一个组件如何区分是放到pages目录还是components目录","path":"/2024/10/23/在vue项目中，一个组件如何区分是放到pages目录还是components目录/","content":"在Vue项目中，通常将页面级别的组件放置在pages目录下，而将可复用的组件放置在components目录下。这样的组织结构有助于代码的可维护性和可读性。 Pages目录：用于存放整个应用的页面组件，每个页面通常对应着应用中的一个路由。这些页面组件通常是独立的，不太可能在其他地方被复用。它们负责组织和呈现其他组件，通常包含了数据获取、状态管理等逻辑。 Components目录：用于存放可复用的组件，这些组件可以在应用的多个页面中使用。它们通常被设计成独立的、高度可定制的组件，例如按钮、导航栏、卡片等等。这样做可以提高代码的重用性，并且有助于保持应用的一致性和可维护性。 当你在开发Vue项目时，如果一个组件是整个页面的核心部分，那么它应该放在pages目录下；如果一个组件是可以被多个页面复用的，那么它应该放在components目录下。这样做有助于组织你的代码并且使其易于理解和维护。"},{"title":"WMTS（Web Map Tile Service）","path":"/2024/10/23/WMTS（Web-Map-Tile-Service）/","content":"本来一个服务器存放瓦片信息就可以了，但是人们发现和地图相关的style和切片方案和服务元数据都可以放在WMTS中"},{"title":"yarn&npm常见命令总结","path":"/2024/10/23/yarn&npm常见命令总结/","content":"12345678910111213141516171819202122232425262728293031323334353637383940# ==========================================================# NPM# ==========================================================npm set registry https://registry.npmmirror.com # 注册模块镜像npm set disturl https://npmmirror.com/mirrors/node # node-gyp 编译依赖的 node 源码镜像## 以下选择添加npm set sass_binary_site https://registry.npmmirror.com/mirrors/node-sass # node-sass 二进制包镜像npm set electron_mirror https://registry.npmmirror.com/mirrors/electron/ # electron 二进制包镜像npm set puppeteer_download_host https://registry.npmmirror.com/mirrors # puppeteer 二进制包镜像npm set chromedriver_cdnurl https://registry.npmmirror.com/mirrors/chromedriver # chromedriver 二进制包镜像npm set operadriver_cdnurl https://registry.npmmirror.com/mirrors/operadriver # operadriver 二进制包镜像npm set phantomjs_cdnurl https://registry.npmmirror.com/mirrors/phantomjs # phantomjs 二进制包镜像npm set selenium_cdnurl https://registry.npmmirror.com/mirrors/selenium # selenium 二进制包镜像npm set node_inspector_cdnurl https://registry.npmmirror.com/mirrors/node-inspector # node-inspector 二进制包镜像npm set sentrycli_cdnurl https://npmmirror.com/mirrors/sentry-cli/ # sentry-clinpm cache clean --force # 清空缓存# ==========================================================# YARN# ==========================================================yarn config set registry https://registry.npmmirror.com # 注册模块镜像yarn config set disturl https://npmmirror.com/mirrors/node # node-gyp 编译依赖的 node 源码镜像## 以下选择添加yarn config set sass_binary_site https://registry.npmmirror.com/mirrors/node-sass # node-sass 二进制包镜像yarn config set electron_mirror https://registry.npmmirror.com/mirrors/electron/ # electron 二进制包镜像yarn config set puppeteer_download_host https://registry.npmmirror.com/mirrors # puppeteer 二进制包镜像yarn config set chromedriver_cdnurl https://registry.npmmirror.com/mirrors/chromedriver # chromedriver 二进制包镜像yarn config set operadriver_cdnurl https://registry.npmmirror.com/mirrors/operadriver # operadriver 二进制包镜像yarn config set phantomjs_cdnurl https://registry.npmmirror.com/mirrors/phantomjs # phantomjs 二进制包镜像yarn config set selenium_cdnurl https://registry.npmmirror.com/mirrors/selenium # selenium 二进制包镜像yarn config set node_inspector_cdnurl https://registry.npmmirror.com/mirrors/node-inspector # node-inspector 二进制包镜像yarn config set sentrycli_cdnurl https://npmmirror.com/mirrors/sentry-cli/ # sentry-cliyarn cache clean # 清空缓存 1yarn --network-timeout 100000"},{"title":"开源项目配置到服务器总结","path":"/2024/10/23/开源项目配置到服务器总结/","content":"在本地设备打包好所有依赖，通过服务器连接工具上传整个安装包，相当于执行离线安装。"},{"title":"动态规划算法","path":"/2024/10/22/动态规划算法/","content":"动态规划是一种将复杂问题分解为更小的子问题并通过缓存子问题的解来避免重复计算的算法设计方法。它适用于具有重叠子问题和最优子结构性质的问题。动态规划通常用于优化问题，目的是通过构建递归关系和记忆化中间结果，找到全局最优解。 核心思想动态规划的核心思想是将一个复杂的问题分解为若干个子问题，然后通过递推的方式逐步解决这些子问题。它的基本步骤如下： 定义状态：确定问题的状态，也就是用哪些变量来描述当前子问题的状态。 状态转移方程：找到子问题之间的递推关系（即状态转移方程），描述如何从已解决的子问题得到当前问题的解。 边界条件：确定初始状态的值，通常是最小规模的问题的解。 计算顺序：根据状态转移方程的依赖关系，从小到大计算每个子问题的解。 动态规划常用来解决最优化问题，如最短路径问题、最大子序列和问题、背包问题等。 动态规划的特性 重叠子问题：动态规划问题通常具有重叠子问题，即原问题可以分解成若干个相同的子问题。不同的子问题可能会在递归求解中被重复计算。如果使用简单的递归方法，会导致大量的重复计算，因此通过记忆化技术（如数组或表）存储子问题的解，可以避免重复计算。 最优子结构：如果问题的最优解可以由其子问题的最优解构造而成，称为最优子结构。例如，求解最短路径时，如果最短路径经过某个点，那么从该点到终点的子路径也一定是最短路径。 动态规划的两种实现方式 自顶向下（记忆化搜索）：使用递归的方式自顶向下解决问题，同时将子问题的解存储在数组或哈希表中（称为“记忆化”），以便下次遇到相同的子问题时直接返回之前计算的结果，而不是重新计算。 自底向上（迭代法）：先解决最简单的子问题，然后通过迭代的方式解决规模逐渐增大的问题。自底向上通常表现为使用一个数组或表，按照状态转移方程逐步填充表中的值。 动态规划的经典例题1. 斐波那契数列这是动态规划最简单的例子，斐波那契数列的递归公式为：[F(n) &#x3D; F(n-1) + F(n-2)]使用动态规划，可以避免递归的重复计算。 状态定义：令 dp[i] 表示斐波那契数列第 i 项的值。 状态转移方程：[dp[i] &#x3D; dp[i-1] + dp[i-2]] 边界条件：[dp[0] &#x3D; 0, \\ dp[1] &#x3D; 1] 自底向上代码实现： 12345678910def fibonacci(n): if n == 0: return 0 elif n == 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 0, 1 for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] 2. 背包问题背包问题是经典的动态规划问题，描述如下：有一个背包容量为 W，有 n 个物品，每个物品有重量 w_i 和价值 v_i，问如何选择物品装入背包，使得装入背包的物品总价值最大。 状态定义：dp[i][j] 表示前 i 个物品在背包容量为 j 时的最大价值。 状态转移方程：[dp[i][j] &#x3D; \\max(dp[i-1][j], dp[i-1][j-w_i] + v_i)]如果不选择第 i 个物品，则 dp[i][j] = dp[i-1][j]；如果选择，则 dp[i][j] = dp[i-1][j-w_i] + v_i。 边界条件：dp[0][j] = 0（没有物品时最大价值为0）。 3. 最长公共子序列（LCS）给定两个序列，求它们的最长公共子序列。其状态转移方程为： [dp[i][j] &#x3D;\\begin{cases}dp[i-1][j-1] + 1, &amp; \\text{if } s1[i] &#x3D; s2[j] \\\\max(dp[i-1][j], dp[i][j-1]), &amp; \\text{if } s1[i] eq s2[j]\\end{cases}] 总结动态规划通过记忆化子问题的解，可以极大地提高算法的效率。掌握动态规划的关键在于能识别问题的重叠子问题和最优子结构，并合理地定义状态和状态转移方程。","tags":["算法"]},{"title":"tomcat和nginx总结","path":"/2024/10/20/nginx总结/","content":"nginx是一个高效的静态内容 Web 服务器，同时也是反向代理服务器，擅长处理静态资源、负载均衡和反向代理功能。 vue发布的网站非根域名刷新404的错误*解决方法：配置一个重定向规则，使得所有请求都指向Vue应用的入口文件 index.html。 1234567891011server &#123; listen 80; server_name your_domain.com; # 替换为你的域名或IP地址 location / &#123; root /path/to/your/vue/app; # Vue应用打包后的文件存放目录 try_files $uri $uri/ /index.html; # 如果找不到文件，则返回index.html &#125; index index.html;&#125;"},{"title":"JavaScript 标记清除法总结","path":"/2024/10/17/JavaScript-标记清除法总结/","content":"12345678910111213var globalVariable = &#123;\tname: &quot;I&#x27;m a global variable&quot;,&#125;function fun() &#123;\tvar xiaoming = &quot;codereasy&quot;;&#125;fun();console.log(window.globalVariable);console.log(window.xiaoming);//(1) &#123;name: &quot;I&#x27;m a global variable&quot;&#125;//undefined 123456789101112131415161718192021222324// 全局变量可以被视为根， 因此他们是可达的let globalVariable = &#123;\tname: &quot;I&#x27;m a global variable&quot;,&#125;// 函数的参数和内部变量也是可达的function someFunction(someArgument) &#123;\tlet functionVariable = &#123; name: &quot;I&#x27;m a variable inside of a function&quot; &#125;; console.log(someArgument, functionVariable)&#125;someFunction(globalVariable);let objectA = &#123;\tobjectProperty: &#123; name: &quot;I&#x27;m a property of an object&quot;, &#125;&#125;console.log(objectA.objectProperty);// (1) &#123;name: &quot;I&#x27;m a global variable&quot;&#125; // (1) &#123;name: &quot;I&#x27;m a variable inside of a f...&#125; 优点：标记清除法解决了循环依赖的问题缺点：标记清除法会出现内存碎片"},{"title":"flask总结","path":"/2024/10/17/flask总结/","content":"服务器运行flask绑定所有端口 1flask run --host 0.0.0.0"},{"title":"JavaScript垃圾回收-引用计数法","path":"/2024/10/16/JavaScript垃圾回收-引用计数法/","content":"引用计数法进行垃圾回收内存泄露的例子 1234567function test() &#123; let objectA = &#123;name: &quot;Object A&quot;&#125;; let objectB = &#123;name: &quot;Object B&quot;&#125;; objectA.otherObject = objectB; objectB.otherObject = objectA;&#125;test()"},{"title":"this绑定相关面试题","path":"/2024/10/16/this绑定相关面试题/","content":"1234567891011121314function foo() &#123; console.log(this);&#125;var obj1 = &#123; name: &quot;obj1&quot;, foo: foo,&#125;;var obj2 = &#123; name: &quot;obj2&quot;,&#125;(obj2.foo = obj1.foo)(); 123456789101112131415var name = &quot;全局window&quot;;var person = &#123; name: &quot;person&quot;, sayName: function () &#123; console.log(this.name); &#125;&#125;function sayName() &#123; var fun = person.sayName; fun();// 全局window person.sayName(); //person (b = person.sayName)();// 全局window对象&#125;sayName();","tags":["编程语言","JavaScript"]},{"title":"双指针","path":"/2024/10/16/双指针/","content":"有序并不是双指针使用的必要前提，但在某些情况下，有序数组确实可以帮助我们充分发挥双指针的优势，特别是在减少搜索空间和提高效率方面。双指针是一种灵活的算法技巧，可以根据具体场景应用于有序或无序的场景。下面将详细讨论。 1. 有序数组中的双指针在有序数组或序列中使用双指针，可以利用排序的特性来快速定位解。这类问题通常依赖于数据的有序性来实现更高效的算法。例如，前面提到的 “Two Sum II” 问题，因为数组是有序的，双指针可以通过移动指针快速缩小搜索范围。如果数组是无序的，那么双指针这种方式在查找和筛选时会失去优势。 xxxxxxxxxx let arr &#x3D; [];let symIndex &#x3D; Symbol(“index”);arr[symIndex] &#x3D; “Hello”;​let string &#x3D; symIndex.toString();console.log(string)console.log(arr[string]);&#x2F;&#x2F; Symbol(index)&#x2F;&#x2F; undefinedjavascript 查找两数之和问题：利用双指针，从两端向中间靠拢，根据和与目标值的比较，决定移动哪一个指针。 2. 无序数组中的双指针虽然有序数组能让双指针更高效，但双指针同样可以在无序数组中使用。常见的应用场景包括处理特定条件的子数组、滑动窗口问题、快慢指针遍历链表等。这些问题不依赖有序性，而是基于特定的逻辑条件来移动指针。 例子： 快慢指针（Floyd’s Tortoise and Hare Algorithm）：该算法常用于检测链表中的环，并且链表不需要有序。一个指针每次走一步（慢指针），另一个指针每次走两步（快指针），最终两个指针会相遇。 滑动窗口：在处理动态长度的子数组问题时，双指针可以用来动态调整窗口的大小，维护窗口的边界。 3. 滑动窗口问题滑动窗口（Sliding Window）是一类经典的双指针应用，通常用于处理无序数组或字符串。在这些问题中，一个指针（左指针）固定窗口的起点，另一个指针（右指针）扩展窗口或收缩窗口，直到满足某个条件。 例子： 最长子数组问题：寻找一个数组中满足某些条件的最长子数组。双指针可以用来动态调整子数组的起始和结束位置，以优化解的查找。 总结：双指针并不依赖数据有序与否，而是依赖问题的具体要求和性质。在有序数组中，双指针通常可以更加高效地解决问题，因为排序提供了一个明确的规则（例如大小关系）来指导指针的移动；在无序数组或其他数据结构中，双指针也可以用于解决子数组、链表问题等。主要的前提是问题能够通过调整两个位置来逐步缩小搜索范围或满足特定条件。","tags":["算法"]},{"title":"JavaScript正则表达式","path":"/2024/10/16/JavaScript正则表达式/","content":"123function isCharacter(c) &#123; return /[a-zA-Z0-9]/.test(c);&#125;"},{"title":"npm配置代理","path":"/2024/10/16/npm配置代理/","content":"12npm config delete proxynpm config set proxy http://proxy-server:port"},{"title":"显示绑定、隐式绑定、new绑定的优点","path":"/2024/10/15/显示绑定、隐式绑定、new绑定的优点/","content":"1234567891011121314151617181920function foo() &#123; console.log(this);&#125;var obj1 = &#123; name: &quot;obj1&quot;, foo: foo,&#125;;var obj2 = &#123; name: &quot;obj2&quot;, foo: foo,&#125;;// 隐式绑定obj1.foo(); // obj1obj2.foo(); // obj2// 隐式绑定和显式绑定obj1.foo.call(obj2); //obj2, 说明显式绑定优先级更高","tags":["编程语言","JavaScript"]},{"title":"new关键字绑定","path":"/2024/10/15/new关键字绑定/","content":"12345678function Student(name) &#123; console.log(this); // Student &#123;&#125; this.name = name; // Student &#123;name : &quot;codereasy&quot;&#125;&#125;// 通过new关键字创建一个新对象的步骤是什么、构造函数是如何创建新对象的？var xiaoming = new Student(&quot;codereasy&quot;)console.log(xiaoming); 在构造函数中添加return，如果return的是对象，则直接返回该对象，如果return的是基本类型，则return语句无效，仍然返回我们创建的新对象。"},{"title":"显式绑定","path":"/2024/10/15/显式绑定/","content":"1234567function foo() &#123; console.log(this)&#125;foo.call(window); // windowfoo.call(&#123;name: &quot;codereasy&quot;&#125;); // &#123;name: &quot;codereasy&quot;&#125;foo.call(666); // Object( empty ) 1234567891011function foo() &#123; console.log(this);&#125;var obj = &#123; name: &quot;codereasy&quot;&#125;var bar = foo.bind(obj);bar(); // obj对象","tags":["编程语言","JavaScript"]},{"title":"隐式绑定","path":"/2024/10/15/隐式绑定/","content":"123456789101112131415function foo() &#123; console.log(this);&#125;var obj1 = &#123; name: &quot;obj1&quot;, foo: foo,&#125;;var obj2 = &#123; name: &quot;obj2&quot;, obj1: obj1,&#125;obj2.obj1.foo();// &#123;name: &quot;obj1&quot;, foo: foo()&#125; 谁直接调用foo（换而言之，谁离foo更近），那么foo()中的this就指向谁。"},{"title":"this在运行时绑定还是编译时绑定","path":"/2024/10/15/this在运行时绑定还是编译时绑定/","content":"1234567891011121314151617// 定义一个函数function foo() &#123; console.log(this);&#125;// 1.调用方式一： 直接调用foo(); // window// 2.调用方式二：将foo放到一个对象中，再调用var obj = &#123; name: &quot;codereasy&quot;, foo: foo,&#125;;obj.foo();// object对象// 3.调用方式三： 通过call或者apply调用foo.call(&quot;ctgu&quot;);// string &#123;ctgu对象&#125;","tags":["编程语言","JavaScript"]},{"title":"JavaScript寄生组合继承","path":"/2024/10/14/JavaScript寄生组合继承/","content":"123456789101112131415161718192021222324252627// 父类function Parent() &#123; this.sayHello = function () &#123; console.log(&quot;Hello&quot;); &#125;&#125;Parent.prototype.a = &quot;我是父类prototype上的属性&quot;;// 子类function Child() &#123; Parent.call(this)&#125;// 创建一个没有实例方法的父类实例作为子类的原型Child.prototype = Object.create(Parent.prototype);// 修复构造函数的指向Child.prototype.constructor = Child;// 创建两个Child实例var child1 = new Child();var child2 = new Child();console.log(child1.sayHello === child2.sayHello);// falsevar parentObj = new Parent();console.log(parentObj.a);//我是父类prototype上的属性console.log(child1.a)//我是父类prototype上的属性 12345678910111213141516171819202122232425262728// 父类function Parent() &#123; this.sayHello = function () &#123; console.log(&quot;Hello&quot;); &#125;&#125;Parent.prototype.a = &quot;我是父类prototype上的属性&quot;;// 子类function Child() &#123; Parent.call(this)&#125;Child.prototype.childFunction = ()=&gt; &#123; console.log(&quot;我是child方法&quot;);&#125;// 创建一个没有实例方法的父类实例作为子类的原型Child.prototype = Object.create(Parent.prototype);// 修复构造函数的指向Child.prototype.constructor = Child;// 创建两个Child实例var child1 = new Child();child1.childFunction();// TypeError: child1.childFunction is not a function// at &lt;anonymous&gt;:25:8// at mn (&lt;anonymous&gt;:16:5455) 优点：1 ，原型属性不会被共享2 ，可以继承父类的原型链上的属性和方法3 ．只调用了 1 次 Parent(), 因此，它不会在 Child 的prototype 上添加 Parent 的属性和方法。缺点： Child.prototype的原始属性和方法会丢失。"},{"title":"JavaScript组合继承","path":"/2024/10/14/JavaScript组合继承/","content":"123456789101112131415161718192021222324// 父类function Parent() &#123; this.sayHello = function () &#123; console.log(&quot;Hello&quot;); &#125;&#125;Parent.prototype.a = &quot;我是父类prototype上的属性&quot;;// 子类function Child() &#123; Parent.call(this)&#125;Child.prototype = new Parent()// 创建两个Child实例var child1 = new Child();var child2 = new Child();console.log(child1.sayHello === child2.sayHello);// falsevar parentObj = new Parent();console.log(parentObj.a);//我是父类prototype上的属性console.log(child1.a)//我是父类prototype上的属性 优点： 原型属性不会被共享。 可以继承父类的原型链上的属性和方法。缺点： 调用了 2 次 Parent()。 它在 child 的 prototype 上添加了父类的属性和方法。"},{"title":"JavaScript构造函数继承","path":"/2024/10/14/JavaScript构造函数继承/","content":"12345678910111213141516171819202122// 父类function Parent() &#123; this.sayHello = function () &#123; console.log(&quot;Hello&quot;); &#125;&#125;Parent.prototype.a = &quot;我是父类prototype上的属性&quot;;// 子类function Child() &#123; Parent.call(this)&#125;// 创建两个Child实例var child1 = new Child();var child2 = new Child();console.log(child1.sayHello === child2.sayHello);// falsevar parentObj = new Parent();console.log(parentObj.a);//我是父类prototype上的属性console.log(child1.a)//undefined 优点：这种继承方式的好处是，原型属性不会被共享。缺点：它不能继承父类prototype上的属性"},{"title":"原型链继承","path":"/2024/10/14/原型链继承/","content":"1234567891011121314151617function Parent() &#123; this.name = &#x27;parent&#x27;&#125;Parent.prototype.getName = function () &#123; return this.name;&#125;function Child() &#123; this.name = &quot;child&quot;;&#125;Child.prototype = new Parent();var child1 = new Child();console.log(child1.getName());// &quot;child&quot; 123456789101112131415161718function Parent() &#123; this.arr = [1,2,3];&#125;//定义子类function Child() &#123;&#125;// 子类继承父类，这里是关键，实现原型链继承Child.prototype = new Parent();// 实例化子类var child1 = new Child();var child2 = new child();child1.arr.push(4);console.log(child1.arr)console.log(child2.arr) 原型链继承的一个主要问题是包含引用类型值的原型属性会被所有实例共享。换而言之，如果一个实例改变了该属性，那么其他实例的该属性也会被改变","tags":["编程语言","JavaScript"]},{"title":"论文参考文献总结","path":"/2024/10/14/论文参考文献总结/","content":"论文参考文献的主要格式在学术写作中，最常用的参考文献格式包括APA（美国心理学会）、MLA（现代语言协会）、Chicago（芝加哥格式）和IEEE（主要用于工程和计算机科学）。以下是这几种常见格式的说明和示例。 1. APA格式 (American Psychological Association)通常用于社会科学和心理学领域。它的特点是以作者的姓氏和出版年份为主。 书籍示例：格式:作者姓氏, 姓名首字母. (出版年份). 书名. 出版地: 出版商. 示例:Smith, J. (2020). Cognitive Psychology. New York: Academic Press. 期刊文章示例：格式:作者姓氏, 姓名首字母. (出版年份). 文章标题. 期刊名称, 卷号(期号), 页码. 示例:Brown, L. (2019). The impact of stress on memory. Journal of Experimental Psychology, 45(3), 123-145. 2. MLA格式 (Modern Language Association)通常用于人文学科，尤其是文学、语言学等。MLA格式更注重作者和作品的标题。 书籍示例：格式:作者姓氏, 名字. 书名. 出版社, 出版年份. 示例:Smith, John. Understanding Poetry. Oxford University Press, 2018. 期刊文章示例：格式:作者姓氏, 名字. “文章标题.” 期刊名称, 卷号, 期号, 出版年份, 页码. 示例:Brown, Lisa. “Cultural Approaches to Modern Poetry.” Literary Review, vol. 45, no. 2, 2020, pp. 34-56. 3. Chicago格式 (芝加哥格式)适用于历史学和一些人文学科，有两种主要风格：注释-书目制和作者-日期制。这里介绍的是注释-书目制。 书籍示例：格式:作者姓氏, 名字. 书名. 出版地: 出版社, 出版年份. 示例:Smith, John. History of the Roman Empire. Chicago: University of Chicago Press, 2017. 期刊文章示例：格式:作者姓氏, 名字. “文章标题.” 期刊名称 卷号, 期号 (出版年份): 页码. 示例:Brown, Lisa. “The Role of Women in Roman Politics.” Classical Studies Journal 35, no. 4 (2019): 45-67. 4. IEEE格式主要用于工程、计算机科学等技术领域。IEEE采用编号系统来标示参考文献。 书籍示例：格式:[编号] 作者姓名, 书名, 版本 (如果有). 出版地: 出版社, 出版年份, 页码. 示例:[1] J. Smith, Introduction to Robotics, 2nd ed. New York: McGraw-Hill, 2019, pp. 100-120. 期刊文章示例：格式:[编号] 作者姓名, “文章标题,” 期刊名称, 卷号, 期号, 页码, 出版年份. 示例:[2] L. Brown, “Network security challenges,” IEEE Transactions on Computers, vol. 68, no. 3, pp. 45-58, 2018.","tags":["学术论文写作"]},{"title":"前端防抖","path":"/2024/10/13/前端防抖/","content":"前端防抖（Debounce）详解及应用在前端开发中，用户的操作可能会频繁触发事件，如输入框输入、窗口大小调整、按钮点击等。如果每次事件都立即触发相应的处理逻辑，可能会导致性能问题，甚至让用户体验变差。为了解决这些问题，我们可以使用防抖（Debounce）技术。防抖可以有效减少高频事件的处理次数，提高页面性能。 本文将从防抖的定义、实现、应用场景等多个方面进行详细讲解。 一、什么是防抖？防抖的基本概念是：在事件触发后，等待一定时间才执行回调函数，如果在等待时间内事件再次触发，则重新计时。防抖的主要目的在于减少不必要的高频触发，确保函数仅在一段时间后且没有其他触发事件时才执行。 防抖的典型例子：用户在搜索框中输入时，可能每个字符输入都会触发搜索请求。如果用户连续输入多个字符，就会发起多次请求。但实际上我们只希望用户停止输入时，再触发一次搜索。这时候，防抖就可以派上用场了。 二、防抖的原理及实现1. 核心原理防抖的核心原理是利用定时器，在事件触发时，不立即执行回调函数，而是延迟执行。如果在延迟期间事件再次触发，则清除之前的定时器，重新开始计时。只有当设定的延迟时间结束且没有新事件触发时，才会执行回调函数。 2. 防抖的基本实现我们可以通过 setTimeout 和 clearTimeout 来实现防抖功能： 123456789function debounce(fn, delay) &#123; let timer; // 用于保存定时器的ID return function(...args) &#123; if (timer) clearTimeout(timer); // 如果定时器存在，先清除 timer = setTimeout(() =&gt; &#123; fn.apply(this, args); // 在指定延迟后执行函数 &#125;, delay); &#125;;&#125; 这个 debounce 函数接受两个参数： fn：需要防抖的函数。 delay：延迟时间（毫秒）。 关键点在于：每次调用返回的函数时，都会重置定时器，只有在最后一次触发后的延迟时间过去，才会执行传入的函数。 3. 防抖函数的使用我们可以将防抖应用在用户的输入事件中，比如搜索框： 1234567function search() &#123; console.log(&quot;搜索请求发起&quot;);&#125;const debouncedSearch = debounce(search, 300);document.querySelector(&#x27;input&#x27;).addEventListener(&#x27;input&#x27;, debouncedSearch); 在上面的例子中，每次用户在输入框中输入字符时，都会触发 input 事件。由于 search 函数被防抖处理，只有用户停止输入并且超过300毫秒后，搜索请求才会真正发出。 三、防抖的应用场景1. 搜索框输入在用户输入时，避免每次字符变化都发起请求。防抖可以确保只在用户停止输入后的一段时间触发搜索请求。 2. 窗口调整大小当用户调整浏览器窗口大小时，频繁触发 resize 事件，可能会导致页面性能下降。防抖可以保证在用户停止调整窗口大小后一段时间再执行相关操作。 123window.addEventListener(&#x27;resize&#x27;, debounce(() =&gt; &#123; console.log(&#x27;窗口大小调整后处理逻辑&#x27;);&#125;, 300)); 3. 按钮点击有时我们需要防止按钮被短时间内重复点击，如避免表单多次提交。通过防抖，可以防止按钮被频繁点击触发事件。 4. 滚动事件滚动页面时，会触发 scroll 事件，如果绑定了复杂的处理逻辑，可能会导致性能问题。防抖可以减少滚动时触发处理函数的频率。 四、防抖和节流的区别在前端优化中，防抖（Debounce）和节流（Throttle）是常用的两种技术。虽然它们都用于限制函数的触发频率，但原理和应用场景有所不同。 防抖（Debounce）：在连续事件触发的情况下，只执行最后一次触发后的函数。例如：用户输入完成后的搜索请求。 节流（Throttle）：确保在一定时间间隔内，函数只执行一次。例如：滚动条滚动时，控制每100ms执行一次滚动逻辑。 两者的区别可以简单理解为： 防抖：电梯等人，如果有新乘客进入，电梯门重新打开，直到没有人进入才开始运行。 节流：定时发车，公交车无论人是否已到齐，每隔固定时间发车一次。 五、带立即执行的防抖在某些情况下，我们可能希望函数在首次触发时立即执行，而不是等到延迟结束后才执行。例如：在用户开始输入时立即发起一个搜索请求，然后在后续输入时使用防抖。 为此，我们可以在防抖函数中增加一个immediate参数来实现： 123456789101112function debounce(fn, delay, immediate = false) &#123; let timer; return function(...args) &#123; const callNow = immediate &amp;&amp; !timer; // 判断是否立即执行 if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; &#123; timer = null; if (!immediate) fn.apply(this, args); &#125;, delay); if (callNow) fn.apply(this, args); // 立即执行 &#125;;&#125; 在这种实现中，如果 immediate 参数为 true，则函数在第一次事件触发时立即执行，然后在延迟时间内不会再次触发。 六、总结防抖（Debounce）是一种常用的前端优化手段，用于处理高频事件，通过延迟执行回调函数来减少不必要的操作，提升性能。它适用于输入框搜索、窗口调整、按钮点击等场景。 通过本文的讲解，相信你已经掌握了防抖的概念、原理以及实际应用。防抖技术简单而高效，合理使用防抖可以显著提升页面性能并改善用户体验。在开发中根据不同的场景选择合适的优化方式（防抖或节流），能让应用更加高效和顺畅。 最后一点小建议：在复杂应用中，防抖技术需要和业务逻辑合理搭配。例如，在输入框防抖的场景中，可能还需要考虑到用户的快速输入与响应速度间的平衡。","tags":["前端开发","编程语言","JavaScript","性能优化"]},{"title":"javascript_map对象总结","path":"/2024/10/13/javascript-map对象总结/","content":"12345678910let fruits = new Map();fruits.set(&quot;apple&quot;, &quot;red&quot;);fruits.set(&quot;banana&quot;, &quot;yellow&quot;);console.log(fruits.get(&quot;apple&quot;));console.log(fruits.has(&quot;lemon&quot;));// red// false"},{"title":"手写实现深拷贝一解决循环引用问题","path":"/2024/10/13/手写实现深拷贝一解决循环引用问题/","content":"1234567891011121314151617181920212223242526272829303132function deepClone(source, clonedMap = new Map()) &#123; if(typeof source !== &quot;object&quot; || source == null)&#123; return source; &#125; // 如果这个对象已经被拷贝过，直接从Map中返回 if(clonedMap.has(source))&#123; return clonedMap.get(source); &#125; const target = Array.isArray(source) ? [] : &#123;&#125;; // 在Map中记录这个对象 clonedMap.set(source, target); for(const key in source)&#123; if( typeof source[key] === &quot;object&quot; &amp;&amp; source[key] !== null)&#123; target[key] = deepClone(source[key], clonedMap); &#125; else &#123; target[key] = source[key]; &#125; &#125; return target;&#125;const obj = &#123;a: 1, b: &#123;c: 2&#125;&#125;obj.self = obj;const copy = deepClone(obj);console.log(copy);//&#123; a: 1, b: &#123; c: 2 &#125;, self: [Circular] &#125;","tags":["编程语言","JavaScript"]},{"title":"手写实现深拷贝一基础版","path":"/2024/10/13/手写实现深拷贝一基础版/","content":"123456789101112131415161718192021222324252627282930313233343536function deepClone(source) &#123; if(typeof source !== &quot;object&quot; || source == null)&#123; return source; &#125; const target = Array.isArray(source) ? [] : &#123;&#125;; for(const key in source)&#123; if( typeof source[key] === &quot;object&quot; &amp;&amp; source[key] !== null)&#123; target[key] = deepClone(source[key]); &#125; else &#123; target[key] = source[key]; &#125; &#125; return target;&#125;const original = &#123; number: 123, string: &quot;hello&quot;, array: [1,2,3], obj: &#123; prop1: &quot;test&quot;, prop2: &#123; nested: &quot;test2&quot;, &#125;, &#125;,&#125;;const cloned = deepClone(original);console.log(cloned);//&#123;// number: 123,// string: &#x27;hello&#x27;,// array: [ 1, 2, 3 ],// obj: &#123; prop1: &#x27;test&#x27;, prop2: &#123; nested: &#x27;test2&#x27; &#125; &#125;//&#125; 针对循环引用对象会报栈溢出的错误","tags":["编程语言","JavaScript"]},{"title":"深拷贝的实现方式以及优缺点分析","path":"/2024/10/13/深拷贝的实现方式以及优缺点分析/","content":"12345678910111213141516171819202122232425262728293031323334const obj = &#123; name: &quot;John&quot;, age: 30, address: &#123; city: &quot;New York&quot;, country: &quot;USA&quot;, &#125;,&#125;;const deepCopy = JSON.parse(JSON.stringify(obj));console.log(deepCopy);// 修改原对象obj.name = &quot;Alice&quot;;obj.address.city = &quot;San Francisco&quot;;console.log(obj);console.log(deepCopy);//&#123;// name: &#x27;John&#x27;,// age: 30,// address: &#123; city: &#x27;New York&#x27;, country: &#x27;USA&#x27; &#125;//&#125;//&#123;// name: &#x27;Alice&#x27;,// age: 30,// address: &#123; city: &#x27;San Francisco&#x27;, country: &#x27;USA&#x27; &#125;//&#125;//&#123;// name: &#x27;John&#x27;,// age: 30,// address: &#123; city: &#x27;New York&#x27;, country: &#x27;USA&#x27; &#125;//&#125; JSON.stringify无法拷贝函数12345678910const obj = &#123; a: 1, b: function() &#123; console.log(&quot;hello&quot;); &#125;&#125;;const newObj = JSON.parse(JSON.stringify(obj));console.log(newObj);// &#123; a: 1 &#125; JSON.stringify无法拷贝特殊对象，如Date、正则表达式123456789101112131415const obj = &#123; date: new Date(), regex: &#x27;/test/&#x27;,&#125;const newObj = JSON.parse(JSON.stringify(obj));console.log(&quot;旧对象&quot;, obj.date);console.log(&quot;旧对象&quot;, obj.regex);console.log(&quot;新对象&quot;, newObj.date);console.log(&quot;新对象&quot;, newObj.regex);//旧对象 2024-10-13T05:42:50.531Z//旧对象 /test///新对象 2024-10-13T05:42:50.531Z（输出字符串，而不是Date对象）//新对象 /test/（输出空对象，而不是RegExp对象） JSON.stringify不会拷贝原型链上的属性12345678910const protoObj = &#123;c: 3&#125;;const obj = Object.create(protoObj);obj.a = 1;obj.b = 2;const newObj = JSON.parse(JSON.stringify(obj));console.log(obj.c);console.log(newObj.c);// 3// undefined JSON.stringify会忽略symbol和undefined属性12345678const obj = &#123; a: undefined, b: Symbol(&#x27;test&#x27;),&#125;;const newObj = JSON.parse(JSON.stringify(obj));console.log(newObj);// &#123;&#125;","tags":["编程语言","JavaScript"]},{"title":"docker总结","path":"/2024/10/12/docker技术总结/","content":"Docker容器：结合虚拟机隔离与高效资源利用的最佳实践在现代软件开发和部署中，容器技术正逐渐取代传统的虚拟机解决方案。Docker作为其中最流行的容器平台，凭借其高效的资源利用和灵活的环境隔离性，成为了开发者和运维人员的必备工具。那么，Docker容器到底是如何在保持隔离的同时提升效率的呢？它真的能取代虚拟机吗？让我们深入探讨。 虚拟机与Docker的区别1. 虚拟机的隔离性与开销虚拟机技术通过虚拟化，将一台物理服务器分割成多个虚拟的“机器”，每个虚拟机都运行在独立的操作系统上，包括完整的内核和用户空间。这种方式提供了非常强的隔离性：每个虚拟机之间完全独立，宛如多台真实的物理服务器。 但是，这种隔离的代价是较高的资源开销。每个虚拟机都需要加载自己的操作系统内核，这不仅使得启动时间长，而且消耗大量的计算、存储和内存资源。这对于一些场景（如微服务架构、持续集成&#x2F;持续部署）来说，显得过于笨重和低效。 2. Docker的轻量级容器Docker容器则提供了一种更高效的方式：容器共享宿主机的操作系统内核，不再为每个实例加载独立的操作系统。每个Docker容器运行在一个轻量级的、独立的用户空间中，它通过Docker镜像定义应用程序和依赖库，保持了独立的文件系统和运行环境。 这意味着Docker容器能够像虚拟机一样提供隔离效果，但不需要虚拟化整个操作系统内核。这极大地降低了资源消耗，使容器的启动和停止非常迅速，可以在几秒内完成。 Docker容器的核心优势1. 独立文件系统与应用环境隔离Docker容器提供了一个独立的文件系统，应用程序及其依赖库都封装在镜像里。即使宿主机环境不同，容器内的应用运行效果也始终如一。这种用户空间的隔离让开发者可以放心地在不同环境中部署应用，而不必担心系统配置或依赖冲突的问题。 2. 共享宿主机内核Docker容器的轻量化设计源于其共享宿主机的操作系统内核。容器不需要加载自己的内核，而是直接利用宿主机的内核进行系统调用和资源管理。与虚拟机需要额外的硬件虚拟化和完整的操作系统开销不同，容器直接与宿主系统交互，这让它更加高效。 3. 启动迅速，资源开销小由于容器不需要启动一个完整的操作系统，它的启动时间非常短，可以在几秒钟内完成。相比虚拟机需要几分钟才能完全启动，Docker容器更加适合频繁的启动和销毁操作，这对于微服务架构和自动化CI&#x2F;CD管道尤为重要。 4. 隔离与安全性虽然容器共享内核，但通过Linux的命名空间（namespaces）和控制组（cgroups）机制，Docker实现了资源、进程和网络等方面的隔离，保证了容器之间的独立性和安全性。虽然这种隔离性不如虚拟机那么彻底，但在大多数应用场景下，已经足够安全和高效。 Docker是否能取代虚拟机？从上面的分析可以看出，Docker并不是虚拟机的完全替代品，但它在许多场景下具有更大的优势： 高效资源利用：Docker容器通过共享内核，避免了虚拟机加载整个操作系统的资源开销，显得更加轻量化。 灵活部署和扩展：容器启动迅速，支持快速扩容和缩容，非常适合微服务架构和大规模的分布式系统。 环境一致性：通过容器化，开发、测试和生产环境可以保持高度一致，解决了传统部署中的“环境不一致”问题。 但是，Docker并不完全替代虚拟机，尤其是在某些高隔离和硬件依赖性高的场景中，虚拟机依然有其独特的优势。例如，虚拟机可以在不同的内核上运行，提供更严格的安全隔离。而Docker容器由于共享宿主机的内核，隔离强度不如虚拟机，存在内核级别的安全隐患。 为啥会有Docker Desktop？由于 Docker 容器需要 Linux 内核，而 Windows 和 macOS 并没有原生支持，Docker Desktop 会使用虚拟化技术（如 Hyper-V、WSL 2 或 macOS 的 HyperKit）来运行一个 Linux 虚拟机。 总结Docker容器在结合虚拟机隔离优势的同时，避免了虚拟机的资源浪费。它通过共享宿主机内核，提供了一个轻量级、高效的运行环境，特别适合现代的云原生应用和微服务架构。虽然它不完全取代虚拟机，但在资源消耗、启动速度和环境一致性等方面，Docker无疑是更好的选择。windows和MacOS可以通过安装Docker Desktop，利用其虚拟化技术运行一个Linux虚拟机来使用Docker。 对于大多数开发者和运维人员来说，Docker已经成为部署和管理应用的标准工具。而在那些对安全隔离要求极高的场景下，虚拟机依然是不可替代的解决方案。未来的趋势可能是两者结合，既享受容器的灵活性，又兼顾虚拟机的高隔离性。 参考文献： Docker官方文档 虚拟化与容器技术的对比分析 通过合理选择和组合这两种技术，可以在不同的场景中取得最佳的性能和灵活性。"},{"title":"让自己开发的软件产品保持latest_version_release的意义","path":"/2024/10/12/让自己开发的软件产品保持latest-version-release的意义/","content":"有助于不断加深自己对技术的理解热启动站在高位思考","tags":["项目复盘"]},{"title":"数组的浅拷贝","path":"/2024/10/12/数组的浅拷贝/","content":"123const arr1 = [1,2,3];const arr2 = arr1.slice();console.log(arr2); //[ 1, 2, 3 ] 123const arr1 = [1,2,3];const arr2 = arr1.slice(2, 3);// 左闭右开console.log(arr2); //[ 3 ] 123const arr1 = [1,2,3];const arr2 = [0,1,2].concat(arr1);console.log(arr2); //[ 0, 1, 2, 1, 2, 3 ] 123const arr1 = [1,2,3];const arr2 = [].concat(arr1);console.log(arr2);// [ 1, 2, 3 ]","tags":["编程语言","JavaScript"]},{"title":"对象的浅拷贝","path":"/2024/10/12/对象的浅拷贝/","content":"123const obj1 = &#123;a : 1, b : 2&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);console.log(obj2); //&#123; a: 1, b: 2 &#125; 123const obj1 = &#123;a : 1, b : 2&#125;;const obj2 = &#123;...obj1&#125;;console.log(obj2); //&#123; a: 1, b: 2 &#125; 123456789const obj1 = &#123;a:1,b:2,c:&#123;d:4&#125;&#125;;const obj2 = &#123;&#125;;for (const key in obj1) &#123; if(obj1.hasOwnProperty(key))&#123;// for in 会遍历原型上的属性，所以需要判断是否为自身的属性 obj2[key] = obj1[key]; &#125;&#125;console.log(obj2); //&#123; a: 1, b: 2, c: &#123; d: 4 &#125; &#125; 1234567const obj1 = &#123;a:1,b:2,c:&#123;d:4&#125;&#125;;const obj2 = &#123;&#125;Object.keys(obj1).forEach(key =&gt; &#123; obj2[key] = obj1[key];// Object.keys()只会遍历对象自身的可枚举属性，所以不需要判断是否为自身的属性&#125;)console.log(obj2); //&#123; a: 1, b: 2, c: &#123; d: 4 &#125; &#125;","tags":["编程语言","JavaScript"]},{"title":"深拷贝与浅拷贝的区别","path":"/2024/10/12/深拷贝与浅拷贝的区别/","content":"123456789101112131415161718192021let originalObject = &#123; name: &quot;John&quot;, age: 30, hobbies: [&quot;reading&quot;, &quot;coding&quot;],&#125;//浅拷贝对象const shallowCopyObj = Object.assign(&#123;&#125;, originalObject);// 修改拷贝对象的属性shallowCopyObj.name = &quot;Alice&quot;;shallowCopyObj.hobbies.push(&quot;painting&quot;);console.log(originalObject);console.log(shallowCopyObj);//&#123; name: &#x27;John&#x27;, age: 30, hobbies: [ &#x27;reading&#x27;, &#x27;coding&#x27;, &#x27;painting&#x27; ] &#125;//&#123;// name: &#x27;Alice&#x27;,// age: 30,// hobbies: [ &#x27;reading&#x27;, &#x27;coding&#x27;, &#x27;painting&#x27; ]//&#125; 如果对象的属性为引用类型或复杂类型，修改拷贝对象的属性，会影响到原对象，修改原对象的属性，也会影响到拷贝对象。","tags":["编程语言","JavaScript"]},{"title":"数组索引背后隐藏了哪些类型转换？","path":"/2024/10/12/数组索引背后隐藏了哪些类型转换？/","content":"12345678let a = new Array();a[0] = 1;a[&quot;0&quot;] = 2;a[0]++;console.log(&#x27;a[&quot;0&quot;]的输出是&#x27;, a[&quot;0&quot;]);console.log(&#x27;a[0]的输出是&#x27;, a[0]);//a[&quot;0&quot;]的输出是 3//a[0]的输出是 3 1234let arr = [];arr[5] = &quot;Hello&quot;;console.log(arr[&quot;5&quot;]);// Hello 12345let obj = [];let key = &#123;a:1&#125;;obj[key] = &quot;value&quot;;console.log(obj[&quot;[object Object]&quot;])// value 1234567let arr = [];function myFunction() &#123; return &quot;promptonce&quot;;&#125;arr[myFunction] = &quot;函数作为索引&quot;;console.log(arr[myFunction]);// 函数作为索引 12345let arr = [];let symIndex = Symbol(&quot;index&quot;);arr[symIndex] = &quot;Hello&quot;;console.log(arr[symIndex]);// Hello 123456789let arr = [];let symIndex = Symbol(&quot;index&quot;);arr[symIndex] = &quot;Hello&quot;;let string = symIndex.toString();console.log(string)console.log(arr[string]);// Symbol(index)// undefined","tags":["编程语言","JavaScript"]},{"title":"像素总结","path":"/2024/10/10/像素总结/","content":"512x512RGB图像可以理解为由512x512x3个逻辑上的编码,计算机来决定如何渲染到屏幕上 电子图像的PPI1英寸x1英寸的电子图片在某一行取一英寸，这一英寸有多少个像素点。 打印机的DPI表示打印机的信息转化能力（一英寸输出多少个像素点且不损失信息） 高ppi如果人眼离的较远，且图像较小时可能无法区分相邻像素点，从而降低人眼的信息获取质量 PPI与DPI的对应： 如果这张512x512的图片被定义为1英寸x1英寸，那么它的PPI就是512。（将512x512x3的数据表示在1英寸x1英寸的空间上） 当我们把这张图片打印出来时，如果打印机的DPI也是512，那么理论上，打印出来的图像每个像素点会对应一个墨点，效果会比较理想。 假设我们有一张512x512像素的照片，想要打印成一张4英寸x4英寸的照片。 计算PPI： 512像素 &#x2F; 4英寸 &#x3D; 128 PPI。 选择打印机： 如果我们的打印机最大支持1200 DPI，那么我们可以将图像的尺寸调整为4英寸x4英寸，分辨率设置为128 PPI进行打印，这样可以充分利用打印机的性能。 如果打印机只有300 DPI： 那么打印出来的图像会有一些模糊，因为每个墨点要对应多个像素。"},{"title":"JS中判断数组的方式有哪些?","path":"/2024/10/07/JS中判断数组的方式有哪些/","content":"12345let obj = &#123;&#125;;let arr = [1,2,3];console.log(&quot;对象的类型是&quot;, typeof obj);// 对象的类型是 objectconsole.log(&quot;数组的类型是&quot;, typeof arr);// 数组的类型是 object 12345678let obj = &#123;&#125;;let arr = [1,2,3];let objType = Object.prototype.toString.call(obj);let arrType = Object.prototype.toString.call(arr);console.log(&quot;对象的类型是&quot;, objType);// 对象的类型是 [object Object]console.log(&quot;数组的类型是&quot;, arrType);// 数组的类型是 [object Array] 通过原型链判断12let obj = [];console.log(obj.__proto__ === Array.prototype) 通过Array.isArray()判断ES6语法，如需运行在低版本浏览器上需要使用babel转换 12let obj =[];console.log(Array.isArray(obj)); 通过 instanceof 判断12let obj = [];console.log(obj instanceof Array)"},{"title":"css提高性能的方法","path":"/2024/10/07/css性能优化/","content":"压缩 CSS 文件：减少文件大小，去掉不必要的空格和注释，这样文件体积更小，加载速度更快。 移除未使用的样式：很多时候，写了样式没用上，导致 CSS 文件臃肿，清理掉没用的部分，减少体积。 合并和分割 CSS 文件：合并多个 CSS 文件减少 HTTP 请求；也可以按需加载，只在需要时加载特定页面的样式。 简化选择器：选择器不要太复杂，层级太深会增加计算负担，影响性能。尽量用类选择器，少用通配符和属性选择器。 避免 @import：@import 导入 CSS 会增加额外请求，加载速度慢。尽量用 &lt;link&gt; 直接引入外部文件。 减少重绘和回流：避免频繁使用会引起回流的属性，比如 width、height，动画时多用 transform 和 opacity 这种对性能影响小的属性。 优化字体加载：Web 字体加载会影响页面渲染速度，尽量少用字体，设置 font-display: swap，让文字先显示，再加载字体。 使用关键 CSS：首屏显示的 CSS 放在 &lt;head&gt; 里，确保页面先渲染出来，剩下的样式可以延迟加载。 使用现代布局方式：像 CSS Grid 和 Flexbox 这些布局方式，比传统的 float 布局性能更好、代码更简洁。 利用 CSS 变量：减少重复定义，提高代码的可维护性和简洁性。","tags":["前端开发","性能优化","CSS"]},{"title":"缓存总结","path":"/2024/10/07/缓存总结/","content":"强缓存就是在规定的时间内，浏览器直接从本地缓存中拿数据，不需要向服务器发送请求。这样，页面加载会更快。强缓存一般通过设置 Expires 或 Cache-Control 来控制缓存时间。 协商缓存则是浏览器会先向服务器询问，之前缓存的内容有没有更新。如果服务器确认没有更新，浏览器继续使用缓存数据。如果内容有变化，服务器会返回新的资源。协商缓存的机制常见于 Last-Modified 和 ETag 这两个头信息。"},{"title":"进制总结","path":"/2024/10/06/进制总结/","content":"进制（Number Base）是表示数值的方式之一，用不同的数字和符号来表示不同的数值。最常见的进制有二进制、十进制、八进制和十六进制等。接下来，详细介绍这些不同的进制及它们之间的转换。 1. 什么是进制？进制是指用多少个不同的符号来表示一个数值的系统。例如，十进制使用0到9共十个符号；而二进制使用0和1两个符号。因此，”进制”就是表示数值的基本符号种类的数量。 2. 常见进制及其特点 二进制（Binary，基数为2） 符号：0, 1 二进制的每一位只表示0或1。 常用于计算机和数字电路，因为电子元件只有开（1）或关（0）的状态。 例如，二进制数 101 表示十进制中的数字 5（从右到左依次表示 ( 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0 )）。 十进制（Decimal，基数为10） 符号：0, 1, 2, 3, 4, 5, 6, 7, 8, 9 是我们日常生活中最常用的进制。 例如，数字 123 表示 ( 1 \\times 10^2 + 2 \\times 10^1 + 3 \\times 10^0 &#x3D; 123 )。 八进制（Octal，基数为8） 符号：0, 1, 2, 3, 4, 5, 6, 7 每一位表示8的幂，常用于计算机中早期的一些操作系统和硬件。 例如，八进制数 17 表示十进制中的数字 15（从右到左依次表示 ( 1 \\times 8^1 + 7 \\times 8^0 &#x3D; 15 )）。 十六进制（Hexadecimal，基数为16） 符号：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F 用数字0-9和字母A-F表示，其中A表示10，B表示11，依此类推到F表示15。 十六进制常用于计算机编程，因为它可以简洁地表示二进制数。1个十六进制位可以表示4个二进制位（如F表示1111）。 例如，十六进制数 1A 表示十进制中的数字 26（从右到左依次表示 ( 1 \\times 16^1 + 10 \\times 16^0 &#x3D; 26 )）。 3. 进制转换 二进制到十进制 方法：按位展开成2的幂次方求和。 例如：二进制 1101 转换为十进制就是 ( 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0 &#x3D; 13 )。 十进制到二进制 方法：不断除以2，记录余数，然后逆序排列余数。 例如：十进制 13 转换为二进制就是： ( 13 \\div 2 &#x3D; 6 ) 余 1 ( 6 \\div 2 &#x3D; 3 ) 余 0 ( 3 \\div 2 &#x3D; 1 ) 余 1 ( 1 \\div 2 &#x3D; 0 ) 余 1 结果逆序为 1101。 十进制到八进制 方法：不断除以8，记录余数，然后逆序排列余数。 例如：十进制 64 转换为八进制就是： ( 64 \\div 8 &#x3D; 8 ) 余 0 ( 8 \\div 8 &#x3D; 1 ) 余 0 ( 1 \\div 8 &#x3D; 0 ) 余 1 结果逆序为 100。 十进制到十六进制 方法：不断除以16，记录余数（如果余数大于9，就用对应的字母），然后逆序排列余数。 例如：十进制 26 转换为十六进制就是： ( 26 \\div 16 &#x3D; 1 ) 余 10（即 A） ( 1 \\div 16 &#x3D; 0 ) 余 1 结果逆序为 1A。 4. 进制之间的快速转换 二进制到八进制 和 二进制到十六进制 可以通过分组快速转换： 二进制到八进制：每三位二进制数对应一位八进制数。例如：二进制 101110 可以分成 101 和 110，分别对应八进制的 5 和 6，所以结果是 56。 二进制到十六进制：每四位二进制数对应一位十六进制数。例如：二进制 11101100 可以分成 1110 和 1100，分别对应十六进制的 E 和 C，所以结果是 EC。 5. 进制的实际应用 二进制：计算机底层运算、逻辑电路等。 八进制：早期计算机系统，现代使用较少。 十进制：日常生活中最常用，如数学运算。 十六进制：编程中表示颜色代码（如 #FF00FF）、内存地址等。 总结 进制是用来表示数值的一种符号系统。 不同的进制系统有不同的符号数量和表示规则。 各进制之间的转换需要掌握其表示方式和运算规则。 计算机领域中最常用的是二进制和十六进制。十进制是日常生活中最为熟悉和使用的系统。 掌握进制及其转换对理解计算机的工作原理和程序设计非常有帮助。","tags":["算法"]},{"title":"DIFF算法","path":"/2024/10/03/DIFF算法/","content":"DIFF 算法的作用：同层树节点比较的算法那么 DIFF 算法是如何工作的？一、首先是先计算新老 DOM 的最小变化该算法会先遍历一遍老的 DOM. 然后在遍历新的DOM，最后会判断是改变&#x2F;新增&#x2F;删除来重新排序。这样无疑是非常耗费计算的，我们看一看出总共遍历了三回、如果有一千个节点．那么就湖发生了十亿次的计算。二. diff 算法的优化diff 算法的优化也就是这个算法的核心部分了，简单来说就是针对具有相同父节点的同层新旧子节点进行比较，不相同的话就会新增或者删除，而不是使用逐层搜索递归遍历的方式。时间复杂度为 O(n)。 只比较同一层级，不跨级比较 标签不同，直接删除，不继续比较 标签名相同， key相同，就认为是相同节点，不继续深度比较","tags":["算法"]},{"title":"Vuex","path":"/2024/10/03/Vuex/","content":"Vuex 通过集中存储和管理应用中的所有状态，避免了组件之间的状态不一致或数据混乱的问题。它的运作方式类似于 Flux 模式，能够帮助开发者更加有序地管理和维护应用的状态。 具体来说，Vuex 主要通过五个核心概念来工作： state：集中存储应用的状态，相当于数据的存储中心。 getter：类似于计算属性，从 state 中派生出新的数据给组件使用。 mutation：唯一修改 state 的方式，必须是同步操作。 action：可以包含异步操作，然后通过调用 mutation 来更新 state。 modules：将 store 划分为多个模块，每个模块可以拥有自己的 state、mutation、action、getters。 Vuex 的这种集中式的状态管理模式非常适合复杂的应用，尤其是当应用中的组件间状态需要共享时。","tags":["前端开发","Vue"]},{"title":"Vue中的keep-alive","path":"/2024/10/02/Vue中的keep-alive/","content":"Vue 中的 keep-alive用 keep-alive 包裏组件时．会缓存不活动的组件实例，而不是销毁．使得我们返回的时候能重新激活。 keep-alive主要用于保存组件状态或避免重复创建。避免重复渲染导致的性能间题。常见场景页面的缓存，如上面的保存浏览商品页的滚动条位置筛选信息等 注意这个和这个 Keep-Alive 是不一样的．这个属性的作用是、往往我们三次握手后，传输完数据就会断开连接进行四次挥手、关闭 TCP 连接．但是当我们在头信息中加入了该属性&#96;那么 TCP 会在发送后仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求、保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。","tags":["前端开发","Vue"]},{"title":"Vue中Scoped原理","path":"/2024/10/02/Vue中Scoped原理/","content":"Vue 中的 scoped 样式的作用是为了让组件的样式只在该组件的范围内生效，避免影响全局或其他组件。它的实现通过给每个组件生成一个唯一的标识符（如 data-v-xxxxxx），并将这个标识符附加到组件内的 DOM 元素和样式上。这样一来，样式表中的选择器只会影响带有相应标识符的 DOM 元素，而不会污染其他组件的样式。 总结特点： 1. 局部样式作用域：组件内的样式只能作用于组件自身的标签，且不会影响外部或其他组件。 2. 自动添加标识：Vue 会自动为组件的 DOM 和样式添加特定的 data-v- 属性，确保样式的唯一性和作用范围。 这个机制有效地解决了样式冲突问题，尤其在大型应用中，它可以确保不同组件的样式独立。","tags":["前端开发","Vue"]},{"title":"Vue过滤器","path":"/2024/09/30/Vue过滤器/","content":"Vue 过滤器的功能就是对数据进行格式化处理。它提供了两种常见的方式：一个是在双花括号插值中使用管道符号“|”来进行过滤，比如将消息首字母大写；另一个是在 v-bind 中使用过滤器来对绑定的值进行格式化，比如格式化 ID。 开发者可以通过定义过滤器来自定义常见的格式转换规则，例如把字符串的首字母大写。这个过滤器可以定义在组件内部，也可以定义为全局过滤器。 总结一下：Vue 过滤器相当于一种方便的工具，帮助开发者在显示数据之前对其进行简单的处理，使得代码更简洁。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue Filter Example&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Vue 过滤器示例&lt;/h1&gt; &lt;!-- 输入框 --&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; placeholder=&quot;输入一些文字&quot;&gt; &lt;!-- 使用过滤器 --&gt; &lt;p&gt;原始消息: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;过滤后的消息: &#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例 new Vue(&#123; el: &#x27;#app&#x27;, // 数据对象 data: &#123; message: &#x27;&#x27; &#125;, // 定义过滤器 filters: &#123; capitalize: function (value) &#123; if (!value) return &#x27;&#x27; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":["前端开发","Vue"]},{"title":"Segformer技术分析","path":"/2024/09/29/Segformer技术分析/","content":"SegFormer避免了使用显式位置编码，所以在处理不同分辨率的图像时，不需要进行复杂的插值操作，原因主要是它通过卷积操作和层次结构来隐式地捕捉位置信息，而不是依赖于固定的、与图像分辨率相关的位置编码。 在传统的Transformer模型（例如ViT）中，位置编码是为每个输入特征（如图像的每个patch）明确指定的位置信息。当分辨率改变时，patch的数量也会随之变化，模型无法直接理解新分辨率下的位置信息，因此需要对位置编码进行插值，让它适应新的patch数量和图像分辨率。这是一个复杂的过程，容易引入误差。 而SegFormer通过以下方式避免了这一问题： 卷积的局部感知特性：SegFormer在编码阶段使用了卷积来生成Overlap Patch Embeddings。卷积操作自带局部的空间感知能力，因此它能在不同分辨率下自动调整，依旧保持对邻近像素关系的理解，不需要显式位置编码来帮助模型识别位置。 层次化的特征提取：SegFormer通过层次结构逐级缩减特征图，提取不同分辨率的特征，从而保留了多尺度的空间信息。这种方式让模型在不依赖固定位置编码的情况下，也能从全局和局部两个层面理解图像的空间结构。 因此，当图像的分辨率改变时，SegFormer可以自适应地调整，而不用像ViT那样需要重新插值位置编码。"},{"title":"cookie和session","path":"/2024/09/29/cookie和session/","content":"Cookie 和 Session 是两种在网络请求中用来存储用户数据的机制。 Cookie 当你第一次访问某个网站时，服务器会把一些数据（叫做 Cookie）发到你的浏览器。 之后，每次你访问这个网站时，浏览器都会把这些 Cookie 发回给服务器。 Cookie 主要存储在本地电脑中，并且有大小限制，一般不能超过 4KB。 Cookie的保存形式分为会话Cookie和持久Cookie 会话 Cookie 和 持久 Cookie 的区别就在于它们的有效期和存储位置。 会话 Cookie（Session Cookie）： 只在当前会话（即浏览器打开的这段时间）内有效。 当你关闭浏览器后，会话 Cookie 就会被自动删除。 会话 Cookie 主要用于临时信息存储，比如登录状态，关掉浏览器后就不再保存这些信息了。 持久 Cookie（Persistent Cookie）： 它有明确的过期时间，可以在浏览器关闭后仍然保留，直到到达设定的过期时间或用户手动删除它。 持久 Cookie 常用于存储长期信息，比如网站的自动登录功能、用户偏好设置等。 总结就是：会话 Cookie 随浏览器关闭而消失，而 持久 Cookie 会保留到指定时间或被用户手动删除。 Session Session 是一种存储在服务器端的机制，它保存的是用户的会话信息。 当你登录某个网站后，服务器会生成一个 Session，保存你的登录状态等信息。之后每次你访问网站，服务器会根据你带上的 Cookie 来识别你，并找到对应的 Session 来确认你是谁。 Session 没有大小限制，但它会占用服务器的资源。 区别 Cookie 存在你的浏览器里，而 Session 存在服务器端。 Cookie 有大小和存储时间的限制，而 Session 通常没有这些限制。 优点与缺点 Cookie 比较方便，因为它存储在本地。但不太安全，容易被恶意利用。 Session 更安全，但需要服务器资源。 SSO（单点登录） SSO 就是让你只需要登录一次，就能访问多个系统。这对于使用多个系统的环境非常方便。 SSO的优点降低访问第三⽅⽹站风险（⽤户密码不存储或外部管理）；从不同的⽤户名和密码的组合减少密码疲劳；减少花费的时间重新输⼊密码相同的⾝份；降低IT成本适当降低⼀些IT帮助台调⽤有关密码；SSO集中的所有其他应⽤程序和系统，⽤于⾝份验证服务器的⾝份验证，并与技术相结合是为了确保⽤户不必主动输⼊凭据⼀次以上"},{"title":"在浏览器中输入网址后发生了什么","path":"/2024/09/29/在浏览器中输入网址后发生了什么/","content":"当在浏览器中输入一个网址并按下回车键后，大致发生了以下几个步骤： 解析URL：浏览器会分析你输入的网址，把它分解成协议（如http或https）、域名（如example.com）等部分。 生成HTTP请求：浏览器会根据解析好的网址，生成一个HTTP请求，准备向服务器获取网页内容。 DNS查询：浏览器接着会向DNS服务器查询你输入的域名对应的IP地址，以便找到具体的服务器位置。 与服务器建立连接：获取到IP地址后，浏览器会与目标服务器建立连接（如果是https，还会进行加密连接的建立）。 发送HTTP请求：浏览器将之前生成的HTTP请求发给服务器，请求获取网页资源。 服务器响应：服务器收到请求后，返回对应的网页数据（如HTML、CSS、图片等）。 渲染网页：浏览器接收服务器的响应数据后，开始解析和渲染网页，将它显示在屏幕上。 这些步骤迅速而连续地发生，最终会看到想要的网页。"},{"title":"OSI七层模型","path":"/2024/09/28/OSI七层模型/","content":"OSI七层模型是一种网络通讯的规则框架，它把数据传输分成了七个步骤，帮助不同的设备之间进行通信。这七个步骤（或层）分别是： 物理层：就是各种硬件的物理连接，如网线、光纤等，它主要负责把0和1这些数字信号在设备之间传输。 数据链路层：负责数据传输的准确性，确保数据不会出错，并规定如何进行数据的基本传输方式。 网络层：决定数据通过网络的路径，让数据能从一个设备顺利到达另一个设备，常用的协议如IP就是在这一层。 传输层：确保数据能完整无误地传到对方。常见的协议有TCP（可靠传输）和UDP（快速传输）。 会话层：控制两台设备之间的通信会话，确保数据的连续性，比如什么时候开始传输，什么时候结束。 表示层：对数据进行转换或加密，确保数据能被设备理解，比如文件的压缩和解压。 应用层：直接跟用户打交道，比如我们上网时用的浏览器或者收发邮件的软件就是应用层的一部分。 简单来说，OSI模型就是让不同设备可以按步骤有序地进行信息交流的一种规则。"},{"title":"JavaScript字典序比较","path":"/2024/09/28/JavaScript字典序比较/","content":"字典序算法详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140var strCode = function(s)&#123;\tlet tokens = s.split(&#x27;&#x27;)\tif(tokens.length === 1)&#123; return (&#x27;z&#x27;.charCodeAt(0) - tokens[0].charCodeAt(0)) * (10 ** 0)\t&#125;\tlet result = 0\tfor(let i = tokens.length - 1, j = 1; i &gt; 0 ; i--,j++)&#123; result += (&#x27;z&#x27;.charCodeAt(0) - tokens[i].charCodeAt(0)) * (10 ** j)\t&#125;\treturn result;&#125;function compareStrings_(s1, s2) &#123;\tlet tokens1 = s1.split(&#x27;&#x27;)\tlet tokens2 = s2.split(&#x27;&#x27;)\tfor(let i = 0; i &lt; tokens1.length; i++)&#123; tokens1[i] = tokens1[i].charCodeAt(0)\t&#125;\tfor(let i = 0; i &lt; tokens2.length; i++)&#123; tokens2[i] = tokens2[i].charCodeAt(0)\t&#125;\tlet result = 0;\tlet minLen = -1;\tif(tokens1.length &lt; tokens2.length)&#123; minLen = tokens1.length; result = -1\t&#125;else if(tokens1.length &gt; tokens2.length)&#123; minLen = tokens2.length; result = 1;\t&#125;else &#123; minLen = tokens1.length; result = 0;\t&#125;\t//console.log(tokens1,tokens2,minLen,result)\t//双指针比较\tlet pointer1 = 0\tlet pointer2 = 0\tif(tokens1[0] &gt; tokens2[0])&#123; return 1\t&#125;else if(tokens1[0] === tokens2[0])&#123;\t&#125;else&#123; return -1;\t&#125;\twhile(tokens1[pointer1] === tokens2[pointer2])&#123; pointer1++; pointer2++; if(tokens1[pointer1] &gt; tokens2[pointer2])&#123; result = 1 break; &#125; if(tokens1[pointer1] &lt; tokens2[pointer2])&#123; result = -1 break; &#125; if(pointer1 === minLen || pointer2 === minLen)&#123; break &#125;\t&#125;\treturn result;&#125;function compareStrings(s1, s2) &#123; return s1.localeCompare(s2);&#125;function randomString(length) &#123; const chars = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;; let result = &#x27;&#x27;; for (let i = 0; i &lt; length; i++) &#123; result += chars[Math.floor(Math.random() * chars.length)]; &#125; return result;&#125;function testCompareFunctions(iterations = 1000, maxStrLen = 10) &#123; const progressBarLength = 50; // 进度条长度 for (let i = 0; i &lt; iterations; i++) &#123; const len1 = Math.floor(Math.random() * maxStrLen) + 1; // 随机生成字符串长度 const len2 = Math.floor(Math.random() * maxStrLen) + 1; const s1 = randomString(len1); // 随机生成第一个字符串 const s2 = randomString(len2); // 随机生成第二个字符串 const result1 = compareStrings_(s1, s2); // 用自定义的 compareStrings_ 函数 const result2 = compareStrings(s1, s2); // 用内置的 localeCompare 函数 // 将 localeCompare 的结果标准化为 -1, 0, 1 以进行比较 const normalizedResult2 = result2 === 0 ? 0 : (result2 &gt; 0 ? 1 : -1); if (result1 !== normalizedResult2) &#123; console.log(`Test failed for inputs: &quot;$&#123;s1&#125;&quot; and &quot;$&#123;s2&#125;&quot;`); console.log(`compareStrings_ result: $&#123;result1&#125;`); console.log(`localeCompare result: $&#123;normalizedResult2&#125;`); return; // 一旦发现不一致，停止测试并打印错误信息 &#125; // 进度条每隔一定的迭代次数更新 if (i % Math.floor(iterations / 100) === 0 || i === iterations - 1) &#123; const progress = (i / iterations) * 100; // 计算百分比 const progressChars = Math.floor((progress / 100) * progressBarLength); // 进度条符号的数量 const progressBar = &#x27;=&#x27;.repeat(progressChars) + &#x27; &#x27;.repeat(progressBarLength - progressChars); // 构建进度条 process.stdout.write(`\\r[$&#123;progressBar&#125;] $&#123;progress.toFixed(2)&#125;%`); // \\r 使光标回到行首，覆盖之前的输出 &#125; &#125; console.log(&#x27; All tests passed!&#x27;);&#125;function testPerformance(iterations = 1000000, maxStrLen = 10) &#123; const strings = []; // 预生成随机字符串对 for (let i = 0; i &lt; iterations; i++) &#123; const len1 = Math.floor(Math.random() * maxStrLen) + 1; const len2 = Math.floor(Math.random() * maxStrLen) + 1; const s1 = randomString(len1); const s2 = randomString(len2); strings.push([s1, s2]); &#125; // 测试自定义 compareStrings_ 的性能 console.time(&#x27;Custom compareStrings_&#x27;); for (let i = 0; i &lt; iterations; i++) &#123; compareStrings_(strings[i][0], strings[i][1]); &#125; console.timeEnd(&#x27;Custom compareStrings_&#x27;); // 测试内置 localeCompare 的性能 console.time(&#x27;Built-in localeCompare&#x27;); for (let i = 0; i &lt; iterations; i++) &#123; strings[i][0].localeCompare(strings[i][1]); &#125; console.timeEnd(&#x27;Built-in localeCompare&#x27;);&#125;// 运行测试testCompareFunctions(1000); // 这里设置较小的迭代次数，方便观察进度// 运行性能测试testPerformance(1000); // 设置 1000 次测试//[================================================= ] 99.90%//All tests passed!//Custom compareStrings_: 0.395ms//Built-in localeCompare: 0.158ms"},{"title":"TCP三次握手四次挥手","path":"/2024/09/28/TCP三次握手四次挥手/","content":"TCP的三次握手和四次挥手就是为确保数据可靠传输的一种机制。我们来简单讲一下： 三次握手： 第一次握手：客户端发送一个SYN（同步序列编号）包，告诉服务器“我要开始连接，准备好了吗？”。 第二次握手：服务器收到后，回复一个SYN（synchronize）+ACK（Acknowledgment）包，表示“我准备好了，咱们可以开始连接，但你要确认一下”。 第三次握手：客户端收到后，回一个ACK包，表示“好的，我确认了，正式连接”。 这样，三次握手后，双方建立了可靠连接，开始数据传输。 四次挥手： 第一次挥手：客户端发送FIN（finish）包，表示“我不再传数据了，你准备断开吧”。 第二次挥手：服务器收到后，回复ACK包，表示“我知道了，但我还有数据要发”。 第三次挥手：服务器发FIN包，表示“我数据发完了，可以断开了”。 第四次挥手：客户端收到后，发ACK包，表示“好的，断开吧”。 这四次挥手确保数据完全发送并成功断开连接，避免信息丢失。 简单来说，三次握手建立连接，四次挥手安全断开，都是为确保数据传输完整性和可靠性。","tags":["计算机网络与通信"]},{"title":"理解JavaScript中this的行为:普通函数vs箭头函数","path":"/2024/09/27/理解JavaScript中this的行为-普通函数vs箭头函数/","content":"在 JavaScript 中，this 是一个非常重要但也容易引起混淆的概念。特别是在普通函数和箭头函数之间，this 的行为有着显著的区别。在这篇文章中，我们将通过一个代码示例，深入理解 this 在不同场景下的指向。 代码示例1234567891011121314151617181920var a = 1;function fn1() &#123; console.log(this.a);&#125;const fn2 = () =&gt; &#123; console.log(this.a);&#125;const obj = &#123; a: 10, fn1: fn1, fn2: fn2&#125;fn1(); // 输出: 1fn2(); // 输出: 1obj.fn1(); // 输出: 10obj.fn2(); // 输出: 1 让我们逐行解析这段代码，弄清楚为什么会得到这样的输出。 全局变量 a首先，我们定义了一个全局变量 a，并赋值为 1： 1var a = 1; 在浏览器环境中，使用 var 声明的全局变量会成为 window 对象的属性。所以此时，window.a 的值为 1。 普通函数 fn1接下来定义了一个普通函数 fn1： 123function fn1() &#123; console.log(this.a);&#125; 在 JavaScript 中，普通函数的 this 指向取决于它被调用的上下文。也就是说，谁调用了这个函数，this 就会指向谁。 箭头函数 fn2然后，我们定义了一个箭头函数 fn2： 123const fn2 = () =&gt; &#123; console.log(this.a);&#125; 与普通函数不同，箭头函数不会绑定自己的 this。它会继承定义时所在的上下文的 this 值。因此，fn2 的 this 始终是它在定义时的环境中的 this。 定义对象 obj我们定义了一个对象 obj，包含属性 a 和两个方法 fn1、fn2： 12345const obj = &#123; a: 10, fn1: fn1, fn2: fn2&#125; 这里的 a 是对象 obj 的属性，而 fn1 和 fn2 分别引用前面定义的普通函数和箭头函数。 函数调用分析1. 调用 fn1()1fn1(); // 输出: 1 这是直接调用 fn1。由于 fn1 是在全局作用域中调用的，因此它的 this 默认指向全局对象 window。于是 this.a 相当于 window.a，它的值为 1。 2. 调用 fn2()1fn2(); // 输出: 1 fn2 是一个箭头函数。箭头函数的 this 是在定义时决定的。在这里，fn2 是在全局作用域中定义的，因此它的 this 也是指向全局对象 window，所以输出的 this.a 也是 1。 3. 调用 obj.fn1()1obj.fn1(); // 输出: 10 这次调用 fn1 是通过对象 obj 来进行的。在这种情况下，this 指向调用函数的对象 obj，所以 this.a 实际上是 obj.a，即 10。 4. 调用 obj.fn2()1obj.fn2(); // 输出: 1 虽然 fn2 是通过对象 obj 调用的，但由于 fn2 是箭头函数，它的 this 并不会被调用方式所影响。fn2 的 this 是在定义时就已经决定了的，它指向全局对象 window，因此 this.a 仍然是 window.a，值为 1。 小结通过这个例子，我们可以清楚地看到 JavaScript 中 this 的不同表现： 普通函数：this 的指向取决于它的调用方式。谁调用了这个函数，this 就指向谁。 箭头函数：this 不会绑定调用时的对象，而是继承自定义时的上下文 this。 执行结果总结： fn1() 输出 1：普通函数，在全局作用域中调用，this 指向 window。 fn2() 输出 1：箭头函数，继承全局 this，所以输出 window.a。 obj.fn1() 输出 10：普通函数，通过对象调用，this 指向 obj。 obj.fn2() 输出 1：箭头函数，依旧继承定义时的 this，输出 window.a。 结论在 JavaScript 中，理解 this 的指向对于编写和调试代码非常重要。普通函数的 this 根据调用方式而变化，而箭头函数的 this 是固定的。掌握了这些规则，可以帮助我们更好地编写和调试代码，避免 this 指向错误带来的困扰。","tags":["编程语言","JavaScript"]},{"title":"PNG图片格式总结","path":"/2024/09/26/PNG图片格式总结/","content":"PNG有RGBA模式和RGB模式，灰度模式和调色板索引模式PNG可以实现无损压缩 1. 灰度模式（Grayscale Mode）灰度模式表示图像中的每个像素只有亮度信息，而没有颜色信息。简单来说，灰度图像只有黑白两种颜色的不同程度，从完全黑到完全白，中间有多个灰色渐变。 灰度模式的特点： 每个像素只使用一个数值（通常是 8 位，范围从 0 到 255）来表示亮度。值为 0 表示完全黑，255 表示完全白。 与彩色图像相比，灰度图像占用的存储空间更少，因为它不需要存储红、绿、蓝三种颜色信息。 应用场景：灰度模式常用于黑白照片、扫描的文本图像，以及不需要颜色信息的其他图像。 2. 调色板索引模式（Palette-Indexed Mode）调色板索引模式（有时也叫索引颜色模式）是一种节省存储空间的颜色表示方式，尤其适用于颜色数量有限的图像。在这种模式下，图像并不直接存储每个像素的颜色值，而是存储一个“索引”，这个索引指向调色板中的具体颜色。 调色板索引模式的特点： 图像的颜色信息被限制在一个调色板中，调色板通常最多包含 256 种颜色（8 位索引），每个颜色索引对应具体的 RGB 颜色。 每个像素只保存颜色索引，而不是直接的颜色值。这种方式可以极大地减少图像文件的大小，尤其是在图像颜色数量较少的情况下。 应用场景：调色板索引模式常用于网页图像、简单的图标、GIF 动画等场景，特别是颜色变化不多的图像。例如，简单的卡通画、徽标或按钮图像。 灰度模式 vs 调色板索引模式： 灰度模式：适合只有亮度变化的黑白图像，每个像素记录的是亮度信息。 调色板索引模式：适合颜色有限的图像，通过索引值指向调色板中的颜色，节省存储空间。 总的来说，这两种模式都是为了减少图像的存储需求而设计的，但应用场景有所不同。灰度模式用于单色图像，而调色板索引模式则用于有限颜色的彩色图像。"},{"title":"hexo部署静态资源到github服务器","path":"/2024/09/25/hexo部署静态资源到github服务器/","content":"hexo d失败可以用git clone github仓库地址然后用hexo public目录替换后使用授权github仓库账号执行git push操作替代hexo d fatal: bad tree object 76efcae7c5c88277bd54626c763b790961115445fatal: the remote end hung up unexpectedlysend-pack: unexpected disconnect while reading sideband packetfatal: the remote end hung up unexpectedlyerror: failed to push some refs to ‘https://xxx.git‘FATAL Something’s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess. (D:\\promptonce-blog ode_modules\\hexo-deployer-git ode_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:519:28) at cp.emit (D:\\promptonce-blog ode_modules\\cross-spawn\\lib\\enoent.js:34:29) at ChildProcess._handle.onexit (node:internal&#x2F;child_process:294:12) 清空public目录下的文件克隆托管hexo博客的github仓库，将除.git的文件及目录复制到public目录中将原来根目录的.git目录删掉将克隆下来的目录的.git移动到根目录执行命令 123hexo cleanhexo ghexo d"},{"title":"MMSegmentation实验结果保存命名格式总结","path":"/2024/09/23/MMSegmentation实验结果保存命名格式总结/","content":"日期_模型名_骨干网络_其他重要参数_训练步骤_批次大小_目标尺寸"},{"title":"GPT时代的程序员生存之道","path":"/2024/09/22/GPT时代的程序员生存之道/","content":"GPT时代的程序员生存之道"},{"title":"promise出现的原因和promise方法","path":"/2024/09/22/promise出现的原因和promise方法/","content":"一、Promise出现的原因背景在JavaScript中，异步编程是非常常见的需求，例如处理网络请求、文件读取、定时操作等。在早期，我们通常使用回调函数（callback）来处理异步操作，但随着代码复杂度的增加，回调函数的使用也带来了一些问题，例如： 回调地狱（Callback Hell）：当多个异步操作需要按顺序执行时，回调函数会嵌套得非常深，导致代码难以阅读和维护。 12345678asyncOperation1(function(result1) &#123; asyncOperation2(result1, function(result2) &#123; asyncOperation3(result2, function(result3) &#123; // 继续嵌套 &#125;); &#125;);&#125;); 错误处理复杂：每个回调函数都需要单独处理错误，这使得代码更为冗长且不易统一管理。 Promise的引入为了解决这些问题，ECMAScript 6（ES6）引入了Promise。Promise是一种用于管理异步操作的对象，提供了一种更为清晰和强大的方式来处理异步代码。 二、Promise的基本方法和用法1. 创建一个Promise你可以通过new Promise来创建一个Promise对象。它接受一个执行函数（executor），该函数有两个参数：resolve和reject。 12345678910let promise = new Promise(function(resolve, reject) &#123; // 异步操作 let success = true; if (success) &#123; resolve(&quot;操作成功&quot;); &#125; else &#123; reject(&quot;操作失败&quot;); &#125;&#125;); 2. 使用PromisePromise对象有三个主要方法：then、catch和finally，用于处理异步操作的结果。 then：用于处理成功的结果。 1234promise.then(function(result) &#123; console.log(result); // 操作成功&#125;); catch：用于处理失败的结果。 1234promise.catch(function(error) &#123; console.error(error); // 操作失败&#125;); finally：无论Promise成功还是失败，最终都会执行的代码。 1234promise.finally(function() &#123; console.log(&quot;操作完成&quot;);&#125;); 3. 链式调用Promise可以通过链式调用的方式来简化异步操作的串联，避免回调地狱。 1234567891011asyncOperation1() .then(result1 =&gt; asyncOperation2(result1)) .then(result2 =&gt; asyncOperation3(result2)) .then(result3 =&gt; &#123; // 处理最终结果 &#125;) .catch(error =&gt; &#123; // 统一处理错误 console.error(error); &#125;); 4. 常见的Promise方法 Promise.all：接收一个包含多个Promise的数组，只有当所有Promise都成功时，才会执行then，否则执行catch。 12345678Promise.all([promise1, promise2, promise3]) .then(results =&gt; &#123; // 所有Promise都成功 &#125;) .catch(error =&gt; &#123; // 任意一个Promise失败 &#125;); Promise.race：接收一个包含多个Promise的数组，只要有一个Promise成功或失败，就立即执行相应的then或catch。 12345678Promise.race([promise1, promise2, promise3]) .then(result =&gt; &#123; // 第一个成功的Promise &#125;) .catch(error =&gt; &#123; // 第一个失败的Promise &#125;); 总结Promise提供了一种更为优雅和简洁的方式来处理JavaScript中的异步操作，解决了回调函数嵌套和错误处理复杂的问题。理解和掌握Promise对现代JavaScript编程至关重要。 Promise 的状态一旦确定（resolved 或 rejected），就无法更改。同步代码先执行，Promise 回调是异步的，会在同步代码执行完毕后再执行。 12345678910console.log(1);new Promise(function (resolve, reject) &#123; reject(); resolve();&#125;).then(function () &#123; console.log(2);&#125;, function () &#123; console.log(3);&#125;);console.log(4); 输出 1 4 3"},{"title":"为何要将产品当成自己的孩子？","path":"/2024/09/20/为何要将产品当成自己的孩子？/","content":"只追求广度是不行的，光有广度不代表就有很强的判断力 如果学的是是技术的经典理论的话，那么毫无疑问是学的多更好，前提是能够学懂学好。如果是学习技术应用的话，需要知道的是应用是基于底层技术的上层建筑，如果从底层技术的角度分析，那么大多数技术应用在技术底层是同质化严重的，如果沉迷于学的多，对于通过项目来引导理论学习的人来说，可能会无法触及的更深层次的技术理论，从而在对技术的理解上显得局限，虽然这个和性格也有一定关系，但我认为软件工程师认真地学精可能比粗略地学广泛更有意义。 一个不能体现编程设计（能看出缺乏算法训练）的软件项目是很难让优秀的程序员去迭代的","tags":["项目复盘"]},{"title":"webpack","path":"/2024/09/20/webpack/","content":"Webpack 是一个强大的 模块打包工具，广泛应用于前端项目中。它的主要作用是将各种资源（JavaScript、CSS、图片等）当作模块进行处理，最后生成优化后的静态文件，提升项目的加载性能和开发体验。 简单来说，Webpack 可以将多个文件合并为一个或者多个打包文件，减少请求次数，提高性能，同时还能进行代码拆分、按需加载等优化。 Webpack 的核心概念： Entry（入口）：Webpack 从哪个文件开始进行打包。通常是你应用的主文件（例如 index.js），Webpack 会根据依赖关系递归解析所有依赖的模块。 Output（输出）：打包后的文件输出到哪里，通常是一个目录下的某个文件，比如 dist/main.js。 Loaders（加载器）：Webpack 本身只理解 JavaScript 文件，但通过加载器，你可以让它处理其他类型的文件，比如 CSS、图片、甚至 Sass 或 TypeScript 文件。 Plugins（插件）：插件用于扩展 Webpack 的功能，比如压缩打包后的文件、注入环境变量、分离 CSS 等。 Mode（模式）：Webpack 有 development（开发模式） 和 production（生产模式） 两种模式，开发模式注重调试和快速编译，而生产模式则侧重于优化性能，比如压缩代码、移除无用代码等。 Webpack 的使用流程： 安装 Webpack：在项目中通过 npm 安装 Webpack 和它的 CLI 工具。 1npm install --save-dev webpack webpack-cli **创建 webpack.config.js**：这是 Webpack 的配置文件，用于定义入口、输出、加载器和插件等。 123456789101112131415161718const path = require(&#x27;path&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, // 入口文件 output: &#123; filename: &#x27;bundle.js&#x27;, // 打包后的文件名 path: path.resolve(__dirname, &#x27;dist&#x27;), // 输出路径 &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 匹配所有的 CSS 文件 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], // 使用两个加载器来处理 CSS &#125;, ], &#125;, mode: &#x27;development&#x27;, // 开发模式&#125;; 运行打包命令：在终端中运行 npx webpack，Webpack 会根据配置文件进行打包，输出最终文件到指定目录。 1npx webpack Webpack 的主要功能： 代码拆分（Code Splitting）：Webpack 支持将代码拆分成多个包（chunks），只在需要时加载，提升应用的加载速度。 按需加载（Lazy Loading）：通过动态 import()，可以让某些模块在用户实际需要时才加载，这对大型应用非常有用。 模块热替换（Hot Module Replacement, HMR）：在开发过程中，当代码修改时，Webpack 能让你不刷新整个页面而只替换修改的模块，从而提升开发效率。 Tree Shaking：Webpack 能在打包时移除没有用到的代码（通常是未使用的 ES6 模块），从而减少打包文件的大小。 兼容各种模块化方案：Webpack 支持 AMD、CommonJS、ES6 模块等各种模块化标准，并能将这些模块统一打包为一个文件。 Webpack 例子：假如你有一个项目使用了 CSS 和图片，你可以这样配置 Webpack 来处理这些资源： 123456789101112131415161718192021222324252627282930const path = require(&#x27;path&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;), &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 处理 CSS 文件 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], &#125;, &#123; test: /\\.(png|jpg|gif)$/, // 处理图片文件 use: [ &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name].[hash].[ext]&#x27;, // 输出文件名格式 outputPath: &#x27;images&#x27;, // 输出路径 &#125;, &#125;, ], &#125;, ], &#125;, mode: &#x27;production&#x27;, // 生产模式&#125;; Webpack 的优点： 强大的模块打包能力：Webpack 支持将所有资源视作模块，统一进行管理，极大简化了前端开发流程。 灵活的配置：无论是简单的单页面应用，还是复杂的多页面应用，Webpack 都可以通过配置来满足不同的需求。 丰富的插件生态：通过 Webpack 插件，你可以扩展它的功能，比如压缩文件、生成 HTML 文件、分析打包结果等。 总结：Webpack 是现代前端开发中最常用的构建工具之一，它可以将项目中的各种资源（JS、CSS、图片等）进行打包、优化，提升项目的性能和开发体验。它的强大之处在于高度可配置性和丰富的插件生态，能够满足从小型项目到大型复杂项目的各种需求。","tags":["前端开发"]},{"title":"Vue路由传参","path":"/2024/09/20/Vue路由传参/","content":"路由传参方式可划分为 params 传参和 query 传参，而 params 传参又可分为在 url 中显示参数和不显示参数两种方式方式A ：这种需要在路由配置好可以传递参数 xxx 的，不是最方便的路由配置 1234&#123; path ： &#x27;/child/:XXX&#x27;, component ：（ child&#125; 父组件 1&lt;router—link to=&quot;/child/XXX&quot;&gt;:&lt;/router—link&gt; 子组件读取 1this.num = this.$route.params.XXX 方式B ：这种同样需要在路山配置好可以传递参数 XXX 的，不过是用到 push方法的路由配置 1234&#123; path:&#x27;/child/:XXX&#x27; component ：Child&#125; 父组件this.$router. push({、 &#x2F;chiId&#x2F;${XXXFpath ：子组件读取this.num &#x3D; this.Sroute.params.XXX上面两种方式都会在地址显示出传递的参数、类似 get 请求方式 c ．这种不需要在路由配置好根据路由的名称、需要保持一致路由配置不需要配置，但是子组件的 name 必须与父组件传递的路由一致父组件th iS ， $router.push({params ：{X)O(: ，1子组件读取this.num &#x3D; this 、 $route.params.XXX &#x2F;&#x2F;妈呀方式 D ，这种不需要在路由配置好根据路由的名称&#96;通过 que 缪来传递路由配置不需要配置，但是子组件的 name 必须与父组件传递的路由一致{父组件this.$router.push({path: ‘&#x2F;child’query: {子组件读取this.num &#x3D; this.$route.query.XXX总的来说使用方式 C 和 D 最为多，毕竟不需要对路由配置做修改 代码例子1234567891011121314151617181920212223&lt;!-- ParentComponent.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;Parent Component&lt;/h2&gt; &lt;button @click=&quot;goToChildWithParams&quot;&gt;Go to Child with Params&lt;/button&gt; &lt;button @click=&quot;goToChildWithQuery&quot;&gt;Go to Child with Query&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; // 使用params传参 goToChildWithParams() &#123; this.$router.push(&#123; path: `/child/$&#123;123&#125;` &#125;); &#125;, // 使用query传参 goToChildWithQuery() &#123; this.$router.push(&#123; path: &#x27;/child-query&#x27;, query: &#123; id: 123 &#125; &#125;); &#125; &#125;&#125;;&lt;/script&gt; 123456789101112131415161718192021222324252627&lt;!-- ChildComponent.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;Child Component&lt;/h2&gt; &lt;p&gt;Param ID: &#123;&#123; paramId &#125;&#125;&lt;/p&gt; &lt;p&gt;Query ID: &#123;&#123; queryId &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; computed: &#123; // 获取 params 参数 paramId() &#123; // this.$route.params.id 是通过路径传递的参数 console.log(&#x27;Route Params:&#x27;, this.$route.params); return this.$route.params.id; &#125;, // 获取 query 参数 queryId() &#123; // this.$route.query.id 是通过 query 传递的参数 console.log(&#x27;Route Query:&#x27;, this.$route.query); return this.$route.query.id; &#125; &#125;&#125;;&lt;/script&gt;","tags":["前端开发","Vue"]},{"title":"网站配置https","path":"/2024/09/20/网站配置https/","content":"1. 什么是 HTTPS？HTTPS（超文本传输安全协议）是 HTTP 的加密版本，通过 SSL&#x2F;TLS 协议来确保数据传输的安全性。也就是说，别人不能轻易地偷看你们之间的通信内容啦！ 2. HTTPS 配置流程步骤 1: 获取 SSL 证书首先你需要一个 SSL 证书。这个证书就像是网站的“身份证”，能保证访问者正在访问的确实是你的网站哦！你有两个选择： 购买 SSL 证书：许多域名提供商（如 Namecheap、GoDaddy）都有提供。 使用免费 SSL 证书：推荐使用 Let’s Encrypt，这是一个免费的证书颁发机构（CA），超棒的！ 步骤 2: 安装 SSL 证书获得证书后，要把它安装到你的服务器上。安装的具体方法取决于你的网站服务器种类，我们来看常见的两种情况。 a. Nginx 服务器 将 SSL 证书和私钥上传到服务器。 修改 Nginx 配置文件（通常在 /etc/nginx/sites-available/ 里面）： 1234567891011121314151617181920212223server &#123; listen 80; server_name example.com www.example.com; return 301 https://$host$request_uri; # 重定向到 https&#125;server &#123; listen 443 ssl; server_name example.com www.example.com; ssl_certificate /path/to/ssl/certificate.crt; ssl_certificate_key /path/to/private/key.key; # 启用 HTTPS 的一些推荐配置 ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / &#123; # 网站的根目录 root /var/www/html; index index.html; &#125;&#125; 保存配置，然后重启 Nginx： 1sudo systemctl restart nginx b. Apache 服务器 打开 Apache 配置文件（通常在 /etc/apache2/sites-available/ 里面）： 1234567891011121314151617181920&lt;VirtualHost *:80&gt; ServerName example.com Redirect permanent / https://example.com/&lt;/VirtualHost&gt;&lt;VirtualHost *:443&gt; ServerName example.com SSLEngine on SSLCertificateFile /path/to/ssl/certificate.crt SSLCertificateKeyFile /path/to/private/key.key SSLCertificateChainFile /path/to/ca_bundle.crt DocumentRoot /var/www/html &lt;Directory /var/www/html&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 启用 SSL 模块并重启 Apache： 12sudo a2enmod sslsudo systemctl restart apache2 步骤 3: 强制 HTTPS虽然你已经配置好 HTTPS 了，但是还需要确保所有用户都通过 HTTPS 来访问你的站点呢~ 最简单的方法就是在 Nginx 或 Apache 里设置 301 重定向，前面我们已经有提到啦，就是那个把 HTTP 重定向到 HTTPS 的部分。 步骤 4: 测试你的 HTTPS哇，终于配置好了！接下来打开浏览器，访问你的网站 https://your-domain.com，看看是不是成功显示一个小锁头🔒啦？如果有小锁头，恭喜你，HTTPS 配置成功！ 别忘了用在线工具 SSL Labs 来测试你的 SSL 证书是否配置得完美哦~ tomcat配置证书和Nginx配置https证书有何区别？","tags":["运维"]},{"title":"深度学习中nchw_to_nlc函数总结","path":"/2024/09/19/深度学习中nchw-to-nlc函数总结/","content":"下面的例子展示了如何手动实现 NCHW 到 NLC 的转换，使用纯 Python 列表和基础的列表操作。 NCHW -&gt; NLC 的手动实现12345678910111213141516171819202122232425262728293031323334import numpy as np# 创建一个 4D 张量 (NCHW)，Batch Size = 2, Channels = 3, Height = 4, Width = 4nchw_tensor = np.random.randn(2, 3, 4, 4) # 使用numpy来初始化张量print(&quot;NCHW 格式的张量：&quot;)print(nchw_tensor.shape) # 输出 (2, 3, 4, 4)# 手动转换 NCHW -&gt; NLCbatch_size, channels, height, width = nchw_tensor.shape# 初始化一个新的列表以存储转换后的数据nlc_tensor = []# 遍历每个 batchfor b in range(batch_size): # 存储每个 batch 的结果 batch_result = [] # 对于每个 batch，我们需要将 (Height, Width) 展开为一个长度 (Length)，然后通道排到最后 for h in range(height): for w in range(width): # 对于每个 (h, w) 位置，取出所有的通道值，并将它们组合成一个长度为 channels 的列表 pixel_data = nchw_tensor[b, :, h, w] batch_result.append(pixel_data) # 把这个 batch 的结果加到最终的输出列表中 nlc_tensor.append(batch_result)# 转换为 NumPy 数组，得到最终的形状nlc_tensor = np.array(nlc_tensor)print(&quot; 转换为 NLC 格式的张量：&quot;)print(nlc_tensor.shape) # 输出应为 (2, 16, 3)，其中 16 = 4 * 4（合并了 H 和 W） 代码解释： 创建初始张量： nchw_tensor 是一个 4D 的 NumPy 数组，形状为 (2, 3, 4, 4)，即 Batch Size = 2，Channels = 3，Height = 4，Width = 4。 手动遍历维度： 使用四重嵌套循环，其中： 第一层循环遍历每个批次 (b)； 第二、三层循环遍历 Height 和 Width 的每一个位置 (h, w)； 对于每个 (h, w) 位置，提取所有的通道数据，并将它们作为一组。 将每组通道数据按顺序存入 batch_result 列表中。 合并 Height 和 Width： 对于每个 batch，将 (Height, Width) 的像素展开为一个长度，得到的张量形状为 (Batch Size, Length, Channels)。其中 Length = Height * Width。 最终结果： 手动构造的 nlc_tensor 最终转换为 NumPy 数组，它的形状是 (2, 16, 3)，符合 NLC 格式。 输出：12345NCHW 格式的张量：(2, 3, 4, 4)转换为 NLC 格式的张量：(2, 16, 3) 手动实现的缺点： 虽然这个手动实现清楚地展示了张量的维度转换过程，但相对于使用库函数，它效率低，尤其是在数据规模较大时。 使用嵌套循环手动处理数据比用高效的库（如 PyTorch、NumPy 等）更慢，且代码冗长。 总结：虽然在实际工作中通常使用框架的内置函数（如 permute、reshape 等）进行张量操作，但理解手动转换的过程可以帮助你更好地掌握这些操作的本质。这个手动示例展示了如何通过基本的 Python 列表和循环，将 NCHW 格式的张量转换为 NLC 格式。","tags":["算法","编程语言","Python"]},{"title":"Hello World","path":"/2024/09/19/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"快速排序算法","path":"/2024/09/18/快速排序算法/","content":"利用递归，划分子区间","tags":["leetcode","算法"]},{"title":"RESTful_API","path":"/2024/09/18/RESTful-API/","content":"RESTful API（Representational State Transfer API）是一种设计风格，用于构建基于Web的应用程序和服务。它允许客户端（比如浏览器或移动应用）通过HTTP协议与服务器进行通信，通常涉及以下几个重要概念： 1. 资源（Resources） 资源是指你希望通过API管理的数据实体，比如用户、订单或产品。每个资源都有一个唯一的标识符（通常是一个URL）。 例如，如果你在构建一个电子商务网站，/products 可能是一个表示所有产品的资源，/products/123 可能表示一个特定的产品。 2. HTTP 方法RESTful API使用HTTP方法来执行不同的操作： GET：获取资源的表示。比如，GET /products 获取所有产品，GET /products/123 获取ID为123的产品。 POST：创建一个新的资源。比如，POST /products 发送一个新的产品数据，创建一个新产品。 PUT：更新一个现有的资源。比如，PUT /products/123 更新ID为123的产品的详细信息。 DELETE：删除一个资源。比如，DELETE /products/123 删除ID为123的产品。 3. 无状态（Stateless）每个请求都是独立的，服务器不会保存客户端的状态。每个请求必须包含所有信息以完成请求，例如，身份验证信息和请求数据。服务器不需要记住客户端的状态。 4. 可缓存（Cacheable）响应应标记为可缓存或不可缓存，以提高性能。比如，如果获取的数据不经常变化，可以将其缓存，以减少对服务器的请求。 5. 统一接口（Uniform Interface）RESTful API具有统一的接口，这意味着无论客户端如何与API交互，接口的行为是一致的。主要包括： 资源的标识：资源通过URI（统一资源标识符）标识。 资源的表现：资源可以通过不同的格式（如JSON或XML）表示。 自描述消息：消息中包含足够的信息，使接收方能够理解如何处理。 超媒体作为应用程序状态的引擎（HATEOAS）：服务器提供的响应包括了进一步操作的链接，帮助客户端动态导航API。 6. 层次结构（Layered System）API可以由多个层次组成，每一层可以处理请求和响应，客户端无法直接知道服务器的具体实现。这种层次化使得系统更加可扩展和维护。 示例假设你有一个管理图书的API，以下是一些常见的RESTful API操作示例： 获取所有图书1GET /books 获取特定图书1GET /books/1 创建新图书123456POST /booksContent-Type: application/json&#123; &quot;title&quot;: &quot;New Book&quot;, &quot;author&quot;: &quot;Author Name&quot;&#125; 更新特定图书123456PUT /books/1Content-Type: application/json&#123; &quot;title&quot;: &quot;Updated Book Title&quot;, &quot;author&quot;: &quot;Updated Author Name&quot;&#125; 删除特定图书1DELETE /books/1"},{"title":"腾讯云函数","path":"/2024/09/18/腾讯云函数/","content":"腾讯云函数（Cloud Functions for Tencent Cloud，简称 SCF）是一个事件驱动的无服务器计算平台，主要用于简化和加速云端应用的开发。它支持你在云上运行代码，而无需管理服务器基础设施。以下是一些常见的使用场景： 1. 事件驱动的计算 数据处理：当数据存储到腾讯云对象存储（COS）中时，自动触发函数进行数据处理或转换，比如对上传的图片进行压缩或格式转换。 消息处理：从消息队列（如 CMQ、CKafka）中获取消息，并处理这些消息，比如订单处理、日志分析等。 2. Web 应用的后端服务 API 接口：用于构建和部署 API 接口。你可以用腾讯云函数实现轻量级的 RESTful API，不需要管理传统服务器。 后台任务：处理来自前端的请求，比如用户注册、登录等操作。 3. 自动化操作 定时任务：设置定时触发函数执行任务，例如定期备份数据库、清理过期数据等。 自动化运维：自动执行运维脚本，例如监控系统状态、自动扩展资源等。 4. 集成与互操作 第三方服务集成：通过触发器或事件，将云函数与其他云服务或第三方服务集成。例如，响应来自外部 API 的请求，或在数据变更时更新外部服务。 自定义逻辑：实现自定义业务逻辑，比如在用户上传文件后，自动发送通知或更新用户数据。 5. 无服务器计算 微服务架构：在微服务架构中，云函数可以作为独立的微服务组件，处理特定的业务逻辑和功能。 弹性伸缩：云函数具有自动伸缩能力，根据请求的数量自动调整计算资源，适合处理变化不定的负载。 6. 安全和审计 安全操作：在特定事件发生时自动执行安全操作，比如扫描恶意软件、检查数据合规性等。 日志记录：自动记录操作日志，用于审计和分析。 这些场景展示了腾讯云函数的灵活性和广泛应用，可以根据具体需求进行配置和扩展，使得开发者能够专注于业务逻辑，而无需担心基础设施的维护。"},{"title":"cloudflare","path":"/2024/09/17/cloudflare/","content":"在当今的数字时代，网站的性能、安全性和可靠性对各种规模的企业都至关重要。而Cloudflare正是革新了网站内容交付和保护方式的公司。 Cloudflare是什么？Cloudflare是一家美国公司，提供一系列旨在提高网站和互联网应用程序的安全性、性能和可靠性的服务。其服务包括内容分发网络（CDN）、DDoS防护、Web应用防火墙（WAF）和DNS服务等。 Cloudflare的核心原理Cloudflare的运作基于几个关键原则： DNS重定向 反向代理 缓存 全球分布式网络 安全过滤 协议优化 边缘计算 智能路由 让我们详细探讨每一个原理。 1. DNS重定向当你访问受Cloudflare保护的网站时，会发生以下过程： 123456789101112sequenceDiagram participant 用户 participant DNS participant Cloudflare participant 源服务器 用户-&gt;&gt;DNS: 请求网站IP DNS-&gt;&gt;Cloudflare: 返回Cloudflare IP 用户-&gt;&gt;Cloudflare: 请求内容 Cloudflare-&gt;&gt;源服务器: 如果未缓存则获取内容 源服务器-&gt;&gt;Cloudflare: 返回内容 Cloudflare-&gt;&gt;用户: 提供内容 DNS查询返回的是Cloudflare的IP地址，而不是原始服务器的IP。这意味着所有流量首先通过Cloudflare。 2. 反向代理Cloudflare充当用户和原始服务器之间的中间人。它接收所有发往网站的请求，可以过滤、修改或优化这些请求，然后再转发给原始服务器。 3. 缓存Cloudflare可以缓存静态内容，如图片、CSS和JavaScript文件。对于经常请求的内容，Cloudflare可以直接从其服务器提供，减少对原始服务器的负载并加快交付速度。 4. 全球分布式网络Cloudflare在全球拥有数百个数据中心。用户请求被路由到最近的数据中心，显著减少延迟并改善加载时间。 5. 安全过滤所有通过Cloudflare的流量都经过安全检查。这使得Cloudflare能够在恶意流量（包括DDoS攻击）到达原始服务器之前就将其阻止。 6. 协议优化Cloudflare支持最新的网络协议，如HTTP&#x2F;3，即使原始服务器不支持。它可以在客户端和服务器之间进行协议转换，确保最佳性能。 7. 边缘计算通过Cloudflare Workers，开发者可以在Cloudflare网络的边缘运行代码。这支持实时内容修改、A&#x2F;B测试等功能，无需更改原始服务器设置。 8. 智能路由Cloudflare的Argo智能路由技术实时优化网络路径。它分析网络状况，选择数据传输的最快路径。 为什么Cloudflare很重要利用这些原理，Cloudflare显著提高了网站性能、安全性和可靠性。以下是它的重要性： 提升速度：更快的加载时间带来更好的用户体验，可能对SEO产生积极影响。 增强安全性：对各种网络威胁的保护确保了您的网站和用户安全。 减轻服务器负载：通过自身处理许多请求，Cloudflare减轻了源服务器的负担。 经济高效的扩展：Cloudflare的服务可以帮助网站应对流量高峰，无需升级服务器基础设施。 全球覆盖：即使是小型网站也能受益于全球服务器网络，为世界各地的用户提供更好的性能。 结论Cloudflare已成为现代网络基础设施不可或缺的一部分。理解其工作原理可以帮助网站所有者和开发者更好地利用其功能，创造更快、更安全、更可靠的在线体验。 无论您是经营个人博客还是管理大型电子商务网站，Cloudflare的技术都可以帮助您更高效、更安全地交付内容。随着互联网的不断发展，像Cloudflare这样的服务将在塑造我们的在线世界中发挥越来越重要的作用。","tags":["前端开发","性能优化","运维"]},{"title":"Linux","path":"/2024/09/17/Linux/","content":"centos命令行操作，配合带远程文件管理器的终端（cursor&amp;vscode remotessh插件）即可完成大部分编程工作。没有GUI页面。"},{"title":"PPT制作总结","path":"/2024/09/15/PPT制作总结/","content":"高效美观地传递信息"},{"title":"Google Colab","path":"/2024/09/15/Google-Colab/","content":"谷歌硬盘保存代码及数据"},{"title":"编码隐匿在计算机软硬件背后的语言","path":"/2024/09/15/编码隐匿在计算机软硬件背后的语言/","content":"人们在相互沟通时使用了各种不同的编码，因为在不同的应用场合，其中的一些较其他的更为简便。例如，语言不能在纸上存储，所以使用了文字；语言、文字不适合用来在黑夜中安静地传递消息，故摩尔斯电码是一个方便的替代品。只要一种编码可以适用于其他编码所不能适用的场合，它就是一种有用的编码。 总结:为特定环境编码提高效率，满足需求","tags":["技术书籍阅读"]},{"title":"Gulp","path":"/2024/09/15/Gulp/","content":"Gulp 是一个基于 Node.js 的自动化构建工具，专门用于前端开发工作流的优化。它可以帮助开发者自动执行一些常见的任务，比如压缩文件、编译 Sass&#x2F;LESS、优化图片、自动刷新浏览器等，大大简化了开发过程中的重复劳动。 Gulp 的核心概念： 任务（Tasks）：Gulp 的核心就是任务。每个任务是一个函数，定义好后，Gulp 会按你的需求执行它们，比如压缩文件或转译代码。 管道流（Pipelines）：Gulp 使用流（streams）处理文件数据，你可以通过管道的方式让文件经过多个处理步骤，非常高效。 插件（Plugins）：Gulp 有很多插件来处理具体的任务，比如 gulp-sass 用于编译 Sass，gulp-uglify 用于压缩 JS 文件。 Gulp 的常见用途： 编译预处理语言：比如将 Sass 或 LESS 编译成 CSS。 压缩文件：将 JavaScript、CSS 压缩，减少体积，提高加载速度。 实时刷新：通过监听文件的变化，自动刷新浏览器。 文件合并：将多个 JS 或 CSS 文件合并成一个文件，减少 HTTP 请求。 优化图片：通过压缩图像文件来提高网页性能。 Gulp 的使用步骤： 安装 Gulp：在项目中通过 npm 安装 Gulp。 12npm install --global gulp-clinpm install --save-dev gulp **创建 gulpfile.js**：这是 Gulp 的配置文件，定义各种任务。 12345678// gulpfile.jsconst gulp = require(&#x27;gulp&#x27;);// 定义一个任务gulp.task(&#x27;default&#x27;, (done) =&gt; &#123; console.log(&#x27;Hello Gulp!&#x27;); done();&#125;); 运行任务：在终端中运行 gulp 命令，它会执行你定义的默认任务。 1gulp Gulp 例子：假设你想用 Gulp 编译 Sass 文件并压缩输出的 CSS，你可以这样配置： 12345678910111213141516171819const gulp = require(&#x27;gulp&#x27;);const sass = require(&#x27;gulp-sass&#x27;)(require(&#x27;sass&#x27;));const cleanCSS = require(&#x27;gulp-clean-css&#x27;);// 编译 Sass 并压缩 CSSgulp.task(&#x27;sass&#x27;, function() &#123; return gulp.src(&#x27;src/scss/*.scss&#x27;) // 源文件路径 .pipe(sass().on(&#x27;error&#x27;, sass.logError)) // 编译 Sass .pipe(cleanCSS()) // 压缩 CSS .pipe(gulp.dest(&#x27;dist/css&#x27;)); // 输出路径&#125;);// 监听文件变化gulp.task(&#x27;watch&#x27;, function() &#123; gulp.watch(&#x27;src/scss/*.scss&#x27;, gulp.series(&#x27;sass&#x27;)); // 监听 Sass 文件的变化&#125;);// 默认任务gulp.task(&#x27;default&#x27;, gulp.series(&#x27;sass&#x27;, &#x27;watch&#x27;)); Gulp 的优点： 快速且高效：由于它是基于流的操作，不需要生成临时文件，处理速度很快。 插件丰富：Gulp 拥有庞大的插件生态，能够满足几乎所有前端自动化任务。 易于使用：配置文件简单明了，逻辑清晰。"},{"title":"哈希表","path":"/2024/09/15/哈希表/","content":"哈希表将value和key关联起来，通过value计算出key实现快速判断一个元素是否出现集合里。 参考文章代码随想录"},{"title":"Vue中$nextTick的使用","path":"/2024/09/15/Vue中-nextTick的使用/","content":"$nextTick官方解释：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM因为vue中不是数据一发生改变就马上更新视图层的，如果这样会带来比较差的性能优化，而是在vue中会添加到任务队列中，待执行栈的任务处理完才执行。所以vue中我们改变数据时不会立即触发视图，但是如果我们需要实时获取到最新的DOM,这个时候可以手动调用nextTick。 性能优化体现在哪里?Vue 的性能优化主要体现在它的 异步更新策略 和 批量 DOM 更新 机制，而 $nextTick 就是为了配合这些机制而存在的。让我用更简单的方式解释一下哈： 异步更新：当数据发生变化时，Vue 并不会立刻更新 DOM。相反，Vue 会将这些变化放到一个队列中，然后在当前的事件循环（event loop）结束时再统一处理这些更新。这样就避免了每次数据变化时立刻对 DOM 进行操作，减少了不必要的频繁更新。 批量更新：Vue 会对相同的 DOM 进行 批量更新，即如果在同一事件循环中多次修改数据，Vue 只会更新一次 DOM。这也是 Vue 的一种优化手段，不会因为多次数据变化导致多次 DOM 操作。 为什么这样做是性能优化呢？ 减少重绘重排：每次 DOM 更新都会引起页面的重绘或重排，这是非常耗性能的操作。通过异步和批量更新，Vue 可以把多次变化合并成一次更新，从而减少性能开销。 降低浏览器负担：频繁操作 DOM 是很消耗资源的，尤其是在复杂的页面中。Vue 通过将更新推迟到当前事件循环结束后，能够让浏览器有时间完成其他更重要的任务。 所以，$nextTick 就是为了帮助你在 Vue 进行异步更新 DOM 的同时，如果你需要立刻获取更新后的 DOM，可以使用 $nextTick 来确保你拿到的 DOM 是最新的。这种机制既保证了性能，也保证了功能的正确性。","tags":["前端开发","Vue"]},{"title":"中缀表达式转后缀表达式","path":"/2024/09/14/中缀表达式转后缀表达式/","content":"从左到右依次扫描中缀表达式遇到元素为数字直接输出遇到算数运算符入栈遇到”(“入栈遇到”)”, 匹配左括号，所以栈顶元素依次出栈，直到”(“, 左括号也要出栈，然后直接扔掉，不放于结果后遇到符号，但栈顶符号优先大于当前元素，所以出栈〈栈中符号优先级如果都不小于当前元素则全部出栈）。当前元素入栈。最后如果栈中还有元素，则栈中符号依次出栈。"},{"title":"前中后缀表达式","path":"/2024/09/14/前中后缀表达式/","content":"中缀表达式：运算符夹在操作数中间，比如 A + B。我们平时最常用的就是这种表达方式。 后缀表达式（也叫逆波兰表达式）：运算符放在操作数的后面，比如 A B +。这种方式没有括号，计算顺序完全取决于操作符的先后位置。","tags":["leetcode","算法"]},{"title":"完全二叉树","path":"/2024/09/14/完全二叉树/","content":"完全二叉树只允许最后一行不为满 最后一行必须从左往右排序 最后一行元素之间不可以有间隔","tags":["算法"]},{"title":"策略模式","path":"/2024/09/14/策略模式/","content":"策略模式允许用户在运行时选择算法或行为的具体实现。使用策略模式可以定义一系列的算法，并将每一个算法封装起来，使他们可以相互替换，这样算法的变化不会影响到使用算法的客户端"},{"title":"Vue中的ref","path":"/2024/09/13/Vue中的ref/","content":"ref常用来辅助开发者，获取DOM元素或组件的引用，以及用于在父子组件中获取对方的某个元素进行取值，调用方法等。在每个Vue的组件实例上，都包含一个$refs对象，里面存储着对应的DOM元素或组件的引用·默认情况下，组件的$refs指向一个空对象·如果想要使用ref引用页面上的组件实例，则可以按照如下方式：·使用ref属性，为对应的组件添加引用名称 12345678&lt;my-counter ref=&quot;counterRef&quot;&gt;&lt;/my-counter&gt;&lt;button@click=&quot;getRef&quot;&gt;获取$refs引用&lt;/button:&gt;methods:getRef()&#123;//通过this.$refs.引用的名称，可以引用组件的实例console.log(this.$refs.counterRef)//引用到组件的实例之后，就可以调用组件上的methods方法this.$refs.counterRef.add() 这个方法可以说很便利，但是不要太依赖了，往往在不能通过其他方法获取的时候回才比较建议使用，毕竟我们因该尽量减少添加，而是复用可以复用的部分。 $refs只会在组件渲染完成之后生效，并且不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”一你应该避免在模板或计算属性中访问tip:如果获取不到的时候，可以试一试使用nextTick","tags":["前端开发","Vue"]},{"title":"虚拟DOM","path":"/2024/09/13/虚拟DOM/","content":"一、什么是虚拟DOM呢？再过去或者我们原生JavaScript的时候，我们可以发现，当我们需要改变视图的数据的时候，我们往往需要先获取到这个DOM元素，然后对其进行更新。也就是：数据改变–&gt;操作D0M–&gt;视图更新但是我们在VUE或者React中是直接改变Data就能实现视图的更新了。数据改变–&gt;视图更新那么要是我们每一次数据改变都需要操作DOM,那就非常麻烦，而且慢。因为JavaScript:执行时很快的，但是操作DOM就不是了。所以就有了虚拟DOM了数据改变–&gt;操作虚拟D0M(计算变更)–&gt;操作真实的D0M–&gt;视图更新那么什么虚拟DOM呢？可以说虚拟DOM本质上是JS和DOM之间的映射，表现为是一个能描述DOM结构及其属性信息的JS对象。那么下面我们看一个例子为什么这么说吧： 1234567891011121314151617181920212223242526272829303132//我们定义的D0M&lt;div id=&quot;app&quot;&gt;&lt;p class=&quot;text&quot;&gt;hello&lt;/p&gt;&lt;h1 class=&quot;text&quot;&gt;hello world!!!&lt;/h1&gt;&lt;/div&gt;//转换为虚拟D0M&#123; tag:&#x27;div&#x27;, props: &#123; id:&#x27;app&#x27; &#125;, chidren: [ &#123; tag:&#x27;p&#x27;, props: &#123; className:&#x27;text&#x27; &#125;, chidren: [ &#x27;hello world!!!&#x27; ] &#125;, &#123; tag:&#x27;h1&#x27;, props: &#123; className:&#x27;text&#x27; &#125;, chidren: [ &#x27;hello world!!!&#x27; ] &#125; ]&#125; 实际上就是通过JavaScript对象来作为基础的树，用对象的属性来描述节点，然后通过映射成真实的DOM结构。二、那么这么做有什么好处呢1、优化性能我们常说要减少重排的发生，那是为什么呢，因为那会涉及到DOM树的重新渲染。而操作DOM树是比较慢的，且DOM元素的数量是很庞大的，当操作DOM很容易带来页面的性能问题。很容易给用户带来不好的体验，而这点是很重要的，可以说我们前端页面是与用户的第一个窗口。比如，正常情况下，当我们要更新10个节点的时候，浏览器就会计算10次，一次一次的进行更新。而在使用虚拟DOM，他相对就好像多了一个缓存区，当DOM操作（渲染更新）比较频繁时，它会先将前后两次的虚拟D0M树进行对比，定位出具体需要更新的部分，生成一个“补丁集”（也就是一个S对象），最后只把“补丁”一次性打在需要更新的那部分真实的D0M树上，避免了很多没必要的计算，提高了性能。2、抽象化渲染过程很多人认为虚拟DOM最大的优势是diff算法，减少JavaScript操作真实DOM的带来的性能消耗。虽然这一个虚拟DOM带来的一个优势，但并不是全部。虚拟D0M最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的DOM,可以是安卓和I○S的原生组件，可以是近期很火热的小程序，也可以是各种GUI。解耦了视图层和渲染平台，带来了更多的可能性有点像我们语言中，都会编译成AST,而在这个阶段，可以实现多种转化，就像Babel，和ESList等。3、缺点也是有的：在初次渲染的时候，会多出一层虚拟DOM的计算，而且使用虚拟D○M也不一定是高效的，往往当我们每一次改动不大的时候，才是相对高效的，但是如果我们改动大的话，相比还多出了更多的计算，是不利的。总结虚拟DOM本质上是JS和DOM之间的映射，表现为一个能描述DOM结构及其属性信息的JS对象。没有使用虚拟DOM时，当我们改变数据-&gt;就需要操作DOM-&gt;然后视图更新，当是当我们使用虚拟DOM,就是我们改变数据-&gt;框架就会操作虚拟DOM进行计算变更-&gt;之后映射到真实的DOM上-&gt;完成视图更新。当我们说虚拟DOM的优点，我们常说虚拟DOM提高效率，其实这需要根据场景而言的！当操作DOM的数量比较少的时候，使用虚拟DOM反而效率低，因为添加了更多的计算等操作。而当操作大量DOM的时候，使用虚拟DOM会将多次操作合并为一次更新，减少JavaScript操作真实DOM的带来的性能消耗。另外一个重要的优点是虚拟DOM抽象了原本的渲染过程，实现了跨平台，跨端的能力！不再局限于浏览器！"},{"title":"Vue中的key","path":"/2024/09/12/Vue中的key/","content":"关于key,我们常常在v-for中会接触到，当我们需要进行列表循环的时候，如果没有使用key,就会有警报提示。 123456//场景一：循环列表&lt;div v-for=&quot;num in numbers&quot; :key=&quot;index&quot;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;//场景二：通过时间戳强制重新渲染&lt;div :key=&quot;+new Date()&quot;&gt;+new Date()&lt;/div&gt; 那么为什么需要key呢？因为使用key相当于给node添加上一个唯一的id,主要是在DOM DIFF算法中使用的下面我们看个例子：1.如果上面的场景一items的值为[1,2,3,4,5,6,7,8,9,10]那么就是渲染出十个div是吧。如果没有key,那么当我们现在items的值变为[0,1,2,3,4,5,6,7,8,9呢，那么机会第一个原来是”1”的div内容变为0，而原来是”2”的div内容变为”1”..以此类推。（因为没有key属性，Vue无法跟踪每个节点，使用的是“就地复用”得策略，通过这样的方法来完成变更)但是如果key的情况下，Vue能跟踪每个节点，就会直接新增一个div添拥到内容是”1”的div前面。根据key,更准确，更快的找到对应的vnode节点。设置key能够大大减少对页面的DOM操作，提高了diff效率，更加的高效更新虚拟D0M2.还有的用途就是我们的场景二用来强制替换元素，当key改变时，Vue认为个新的元素产生了, 从而会新插入一个元素来替换掉原有的元素。所以上面的元素会被删除而重新添加。但是如果没有添加key的话，就会直接替换dv里面的内容。而不是删除添加元素。注意点尽量不要使用索引index做key的值，要使用唯一的标识值，比如id之类的，因为如果使用数组索引index为key,当向数组中指定位置插入一个新元素后，因为这时候会重新更新index索引，对应着后面的虚拟DOM的key值全部更新了，这时候做的更新是没有必要的，就像没有加key一样，因此index虽然能够解决key不冲突的问题，但是并不能解决复用的情况。如果没有唯一ID的情况下，可以使用用组件的uid拼接index的形式，因为uid是唯一的。或者生成一个时间戳~。总结关于在v-for中使用key是因为使用key相当于给节点添加上一个唯一的id,在DOM DIFF算法中能更高效的更新虚拟DOM。当没有使用的时候，如果我们需要对一个循环渲染的列表插入一个，那么实际上会“就地复用”的策略，比如我们需要在最前面插入一个，那么就会后面的全部往后变更，发生多次DOM操作，这是因为u无法跟踪每个节点，而使用ky后，节点标识，定位到最前面，然后插入修改，只发生一次DOM操作，大大优化了性能。","tags":["前端开发","Vue"]},{"title":"computed和watch的区别","path":"/2024/09/12/computed和watch的区别/","content":"computed和watch的区别一、这两者解决的问题当我们的数据发生改变的时候，所有和该数据有关的数据都自动更新，执行我们定义的方法。不同于methods是需要相关的方法和交互来实现调用执行的。二、computed和watch以及methods的区别1、性质上methods:定义函数，手动调用computed:计算属性，return返回结果，自动调用watch:观察，监听，发生改变就调用2、使用场景methods：一般不处理数据的逻辑，用于获取数据，和改变状态等情况computed：多用于一个数据受多个数据影响的情况，具有缓存的特性，避免每次重新计算watch：多用于一个数据影响多个数据的情况，且类似异步等情况的时候建议使用3、执行时间computed和methods的初始化是在beforeCreated和created之间完成的。（以及Props,data都是）4、缓存computed:有缓存，重新渲染时，要是值没有改变，会直接返回之前的watch:无缓存，重新渲染时，要是值没有改变，也会执行5、是否异步computed:不支持异步，但异步监听的时候，无法监听数据变化watch:支持异步监听三、computed和methods的区别无论是定义为一个计算属性还是一个函数方法，对于结果来说都是一样的，不同点在于，计算属性是根据依赖值变化才发生改变，而函数方法需要调用执行。","tags":["前端开发","Vue"]},{"title":"IEEE论文模板总结","path":"/2024/09/11/IEEE论文模板总结/","content":"Title Titles should be written in uppercase and lowercase letters, not all uppercase. Abstract Abstract must be an accurate, stand-alone reflection of the contents of the article. They shall not contain displayed mathematical equations, numbered reference citations, nor footnotes. They should include three or four different keywords or phrases, as this will help readers to find it. It is important to avoid over-repetition of such phrases as this can result in a page being rejected by search engines. Ensure that your abstract reads well and is grammatically correct. Index Terms Enter keywords or phrases in alphabetical order, separated by commas. Using the IEEE Thesaurus can help you find the best standardized keywords to fit your article. Use the thesaurus access request form for free access to the IEEE Thesaurus 样式是有系统或用户定义保存的一系列排版格式，包括字体、段落、制表符和边距等。使用样式，可以轻松地对文档进行排列，并保持格式的严格一致。 模板(.dotx) File Formats for Graphics Format and save your graphics using a suitable graphics processing program that will allow you to create the images as PostScript (PS), Encapsulated PostScript (.EPS), Tagged Image File Format (.TIFF), Portable Document Format (.PDF), JPEG, or Portable Network Graphics (.PNG). These programs can re-size them and adjust the resolution settings. If you created your source files in one of the following programs you will be able to submit the graphics without converting to a PS, EPS, TIFF, PDF, or PNG file: Microsoft Word, Microsoft PowerPoint, or Microsoft Excel. Though it is not required, it is strongly recommended that these files be saved in PDF format rather than DOC, XLS, or PPT. Doing so will protect your figures from common font and arrow stroke issues that occur when working on the files across multiple platforms. When submitting your final files, your graphics should all be submitted individually in one of these formats along with the manuscript. Sizing of Graphics Most charts, graphs, and tables are one column wide (3.5 inches &#x2F; 88 mm &#x2F; 21 picas) or page wide (7.16 inches &#x2F; 181 millimeters &#x2F; 43 picas). The maximum depth a graphic can be is 8.5 inches (216 millimeters &#x2F; 54 picas). When choosing the depth of a graphic, please allow space for a caption. Figures can be sized between column and page widths if the author chooses, however, it is recommended that figures not be sized less than column width unless when necessary.The final printed size of author photographs is exactly1 in wide by 1.25 in tall (25.4 mm x 31.75 mm &#x2F; 6 picas x 7.5 picas). Author photos printed in editorials measure 1.59 in wide by 2 in tall (40 mm x 50 mm &#x2F; 9.5 picas x 12 picas). Resolution The proper resolution of your figures will depend on the type of figure it is as defined in the “Types of Figures” section. Author photographs, color, and grayscale figures should be at least 300dpi. Line art, including tables should be a minimum of 600dpi. Vector Art In order to preserve the figures’ integrity across multiple computer platforms, we accept files in the following formats: .EPS&#x2F;.PDF&#x2F;.PS. All fonts must be embedded or text converted to outlines in order to achieve the best-quality results. Color Space The term “color space” refers to the entire sum of colors that can be represented within the said medium. For our purposes, the three main color spaces are grayscale, RGB (red&#x2F;green&#x2F;blue), and CMYK (cyan&#x2F;magenta&#x2F;yellow&#x2F;black). RGB is generally used with on-screen graphics, whereas CMYK is used for printing purposes.All color figures should be generated in RGB or CMYK color space. Grayscale images should be submitted in grayscale color space. Line art may be provided in grayscale OR bitmap colorspace. Note that “bitmap colorspace” and “bitmap file format” are not the same thing. When bitmap color space is selected, .TIF&#x2F;.TIFF&#x2F;.PNG are the recommended file formats. Accepted Fonts Within Figures When preparing your graphics, IEEE suggests that you use one of the following Open Type fonts: Times New Roman, Helvetica, Arial, Cambria, or Symbol. If you are supplying EPS, PS, or PDF files, all fonts must be embedded. Some fonts may only be native to your operating system; without the fonts embedded, parts of the graphic may be distorted or missing.A safe option when finalizing your figures is to strip out the fonts before you save the files, creating “outline” type. This converts fonts to artwork which will appear uniformly on any screen. CONCLUSION conclusion section is not required. Although a conclusion may review the main points of the article, do not replicate the abstract as the conclusion. A conclusion might elaborate on the importance of the work or suggest applications and extensions."},{"title":"v-show和v-if的区别","path":"/2024/09/11/v-show和v-if的区别/","content":"1 、本质上 v-show 是把标签里的 display 设置为 none ，所以页面上是可见的 v-if 是动态的操作 DOM 元素，页面上不可见的 2 、性能上 要是需要频繁的操作的话，肯定是v-show ，因为他只是操作css的值，不会频繁触发重排。但是v-if是不断的向DOM 树添加或删除元素，在比较少改变的时候比较合适的 v-show无论任何条件，初始都会渲染， v-if是惰性的，如果初始条件为false ，初始不会渲染DOM ，为true才会渲染。因此v-if有更高的切换开销，而 v-show 有更高的初始渲染开销","tags":["前端开发","Vue"]},{"title":"Vue-router中hash模式和history模式的区别","path":"/2024/09/11/Vue-router中hash模式和history模式的区别/","content":"最明显的是在显示上， hash 模式的 URL 中会夹杂着#号，而 history 没有。 Vue 底层对它们的实现方式不同。 hash 模式是依靠 onhashchange 事件（监听 location.hash 的改变），而 history 模式是主要是依靠的 HTML5 history 中新增的两个方法， pushState() 可以改变 url 地址且不会发送请求，replaceState() 可以读取历史记录栈，还可以对浏览器记录进行修改。 当真正需要通过 URL 向后端发送 HTTP 请求的时候，比如常见的用户手动输入 URL 后回车，或者是刷新（重启）浏览器，这时候 history 模式需要后端的支持。因为 history 模式下，前端的 URL 必须和实际向后端发送请求的 URL一致，例如有一个 URL 是带有．路径 path 的（例如 www.lindaidai.wang/blogs/id) ，如果后端没有对这个路径做处理的话，就会返回 404 错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个 404 页面","tags":["前端开发","Vue"]},{"title":"订单网站团队协作开发回顾","path":"/2024/09/10/订单网站团队协作开发回顾/","content":"进度把控能力任务拆解能力","tags":["软件项目复盘"]},{"title":"windows高效工具列表","path":"/2024/09/09/windows高效工具列表/","content":"notion sublime text vscode syncthing atom github noi microsoft powertoys bitwarden git microsoft whiteboard"},{"title":"OJ在线编程常见输入输出练习场总结","path":"/2024/09/09/OJ在线编程常见输入输出练习场总结/","content":"对于javascript语言, 掌握readline()函数和split()函数的使用编写代码速度要看内功，代码只是形式，编写代码过程中先在纸上完成题目的分析和方法的筛选，这一步先不要用代码作为分析语言，用纯逻辑分析，逻辑要严密，相当于在大脑中先运行排除掉一些后续翻译代码潜在的的bug，然后代入一个测试用例模拟运行分析是否可行，在纸上分析觉得可以的话就可以开始编码（题目简单基础的话可以只在大脑中完成），遇到bug就结合纸上的模拟运行的记录进行debug, 很多面试题都是考察经典的计算机编程理论。 做编程题（以培养编程思维为目的）的时候要适当克制用ide运行排错的意识，很多时候想用编译器进行边界条件的检查，但编程思维或编程信心也部分来自于脱离编译器独立得出正确的边界条件的过程。对于算法水平一般的人来说，考虑的主要是稳定性的边界条件。 学习编程题是为了更好的指导机器工作，不是让程序员去替代机器执行它所擅长的，不要试图理解每一个细节（可以适当不追求你的可读性，符合行业标准即可），除非必要。 编程是程序员为主，程序员是程序成长的主导者，不要有深度学习里的那种黑盒借口，这里的程序你是可控的。 如果一个API上网查的速度小于记忆回忆的速度就需要记住，这和现在有了AI翻译但那些会讲英语的人仍然优秀的原理是相同的。 平时刷题的时候不要过多花时间去从0想一个新算法，现在能够学习到的经典算法（其中部分已应用到生产中）的算法都是优秀的人花精力和天赋总结的，更多时候只需要理解别人的成果外加不断的练习巩固就可以提升自己的编程算法能力。 编程算法题笔试面试遇到不会的首先分析这个题的可能解题方向是啥（更多的是数据结构与算法的内容，不需要像搞科研那样的创新），如果是考察的经典的解题思路，由于一般这种题都会是在经典题型上进行变体（大公司很少考原题），需要将问题拆分为子问题逐个解决，这样有助于克服思绪混论的问题，然后，如果想不到解题方向，就将题进行简化为经典熟悉的简化题型（哪些题你确定你掌握了呢，根据打蛇打七寸的思想找，一定是有这种已掌握的题型的。）找是否可以排列组合成一个可能的解题思路。"},{"title":"passwordtry","path":"/2024/09/08/passwordtry/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107const rl = require(&quot;readline&quot;).createInterface(&#123; input: process.stdin &#125;);var iter = rl[Symbol.asyncIterator]();const readline = async () =&gt; (await iter.next()).value;void async function () &#123; // // Write your code here // while(line = await readline())&#123; // let tokens = line.split(&#x27; &#x27;); // let a = parseInt(tokens[0]); // let b = parseInt(tokens[1]); // console.log(a + b); // &#125; let n = parseInt(await readline()) let correct = await readline() let test = [] for(let i = 0; i &lt; n; i++)&#123; test.push(await readline()) &#125; // console.log(test) let qpl = [] let arr = [] let idxarr = new Array(test.length).fill(0) // console.log(idxarr) const permute = (test) =&gt; &#123; let result = []; // 用于存放最终的所有排列 let arr = []; // 当前的排列结果 let used = new Array(test.length).fill(false); // 标记哪些元素已经使用过 const backtracking = () =&gt; &#123; // 当排列长度等于输入数组长度时，表示找到一个完整的排列 if (arr.length === test.length) &#123; result.push(arr.slice()); // 将当前排列的拷贝加入结果 return; &#125; // 遍历数组中的每一个元素 for (let i = 0; i &lt; test.length; i++) &#123; // 如果当前元素已经使用过，跳过 if (used[i]) continue; // 将当前元素加入排列，并标记为已使用 arr.push(test[i]); used[i] = true; // 递归调用，继续生成下一个元素的排列 backtracking(); // 回溯：撤销当前的选择，恢复状态 arr.pop(); used[i] = false; &#125; &#125;; backtracking(); // 开始回溯 return result; // 返回所有生成的排列&#125;;// 示例调用let permutations = permute(test);// console.log(permutations);// 将permutations数组按字符串长度从小到大的顺序排序//想要排序的对象：是 permutations 数组的排列，而不是排列内的元素。排序标准：是根据每个排列的长度（permutations[i].length），而不是排列内元素的大小。for(let i = 0; i &lt; permutations.length; i++)&#123; for( let j = permutations[i].length - 1; j &gt; 0; j--)&#123; for( let k = 0; k &lt; j; k++)&#123; if(permutations[i][k] .length&gt; permutations[i][k+1].length)&#123; let temp = permutations[i][k]; permutations[i][k] = permutations[i][k+1]; permutations[i][k+1] = temp; &#125; &#125; &#125;&#125;// console.log(permutations)let minTry = nlet maxTry = 1for(let i = 0; i &lt; permutations.length; i++)&#123; let currentTry = 0 let wrongAnswer = [] for( let j = 0; j &lt; permutations[i].length ; j++)&#123; let flag1 = false for(let k = 0; k &lt; wrongAnswer.length; k++)&#123; if(permutations[i][j] == wrongAnswer[k])&#123; flag1 = true; break &#125; &#125; if(flag1)&#123; continue; &#125; currentTry++; if(permutations[i][j] == correct)&#123; break; &#125; else &#123; wrongAnswer.push(permutations[i][j]) &#125; &#125; if(currentTry &lt; minTry)&#123; minTry = currentTry &#125; if(currentTry &gt; maxTry)&#123; maxTry = currentTry &#125;&#125;console.log(minTry,maxTry)&#125;() 通过绘制树形图来理解。涉及到数组的排列和组合可以通过结合树形图和回溯来理解，直接从数组角度不太好想。 你想要排序的对象：是 permutations 数组的排列，而不是排列内的元素。 排序标准：是根据每个排列的长度（permutations[i].length），而不是排列内元素的大小。"},{"title":"ajax","path":"/2024/09/08/ajax/","content":"AJAX（Asynchronous JavaScript and XML）是一种用于创建交互式网页的技术。它允许网页在不重新加载整个页面的情况下，与服务器交换数据和更新部分网页内容。以下是AJAX的一些核心概念： 1. 同步与异步 同步请求：在发送请求后，浏览器会等待服务器响应，在此期间，浏览器无法进行其他操作。 异步请求：在发送请求后，浏览器不必等待服务器响应，用户可以继续与页面进行交互。 2. AJAX的工作原理 创建XMLHttpRequest对象：这是AJAX的基础，用于在后台与服务器交换数据。1var xhr = new XMLHttpRequest(); 配置请求：设置请求的类型（GET或POST）、URL以及是否异步处理。1xhr.open(&quot;GET&quot;, &quot;example.php&quot;, true); 发送请求：将请求发送到服务器。1xhr.send(); 监听状态变化：通过onreadystatechange事件监听器来处理服务器响应。123456xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 请求已完成，且服务器响应正常 console.log(xhr.responseText); &#125;&#125;; 3. XMLHttpRequest对象的属性和方法 readyState：表示请求的状态，有5个值，从0到4分别表示不同阶段。 status：表示服务器响应的状态码，如200表示成功。 responseText：获取字符串形式的响应数据。 responseXML：获取XML形式的响应数据。 **open(method, url, async)**：配置请求。 **send(data)**：发送请求。 4. AJAX的优点 提升用户体验：无需刷新页面即可更新内容。 减少服务器压力：只需更新部分内容，减轻服务器负担。 前后端分离：前端负责展示，后端负责数据处理，便于维护和扩展。 5. AJAX的缺点 破坏了浏览器的后退功能：由于AJAX更新页面内容不刷新整个页面，可能导致浏览器历史记录无法正确记录。 搜索引擎优化（SEO）问题：爬虫可能无法抓取到通过AJAX加载的内容。总之，AJAX技术在现代网页开发中具有重要作用，它使得网页具有更好的交互性和用户体验。随着技术的发展，AJAX也逐渐被更先进的API（如Fetch API）所取代，但了解AJAX仍然是前端开发者必备的基础知识。","tags":["前端开发","编程语言","JavaScript","计算机网络与通信"]},{"title":"简单工厂模式","path":"/2024/09/08/简单工厂模式/","content":"简单工厂模式（Simple Factory Pattern) ：又称为静态工厂方法 (Static Factory Method) 模式》它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。"},{"title":"单例模式","path":"/2024/09/07/单例模式/","content":"单例模式饿汉式12345678910111213141516171819202122232425262728293031var Singleton = (function() &#123; var instance; function createInstance() &#123; // 这里可以添加一些属性和方法来初始化实例 return &#123; name: &#x27;Singleton&#x27;, getName: function() &#123; console.log(this.name); &#125; &#125;; &#125; return &#123; getInstance: function() &#123; if (!instance) &#123; instance = createInstance(); &#125; return instance; &#125; &#125;;&#125;)();// 使用单例var singleton1 = Singleton.getInstance();singleton1.getName(); // 输出：Singletonvar singleton2 = Singleton.getInstance();singleton2.getName(); // 输出：Singletonconsole.log(singleton1 === singleton2); // true，它们是同一个实例 懒汉式123456789101112131415161718192021222324252627var LazySingleton = (function() &#123; var instance; function createInstance() &#123; // 创建一个新对象，并添加方法和属性 var object = new Object(&quot;I am the instance&quot;); return object; &#125; return &#123; getInstance: function() &#123; if (!instance) &#123; instance = createInstance(); &#125; return instance; &#125; &#125;;&#125;)();// 使用单例var singleton1 = LazySingleton.getInstance();console.log(singleton1); // 输出：I am the instancevar singleton2 = LazySingleton.getInstance();console.log(singleton2); // 输出：I am the instanceconsole.log(singleton1 === singleton2); // 输出：true，证明它们是同一个实例 单例模式是一种在软件工程中常用的设计模式，它确保一个类仅有一个实例，并提供一个全局访问点来访问这个实例。以下是单例模式的一些优缺点：优点： 控制了实例的数量：单例模式确保系统中一个类只有一个实例，这有助于节约系统资源，特别是当对象的创建开销较大时。 全局访问点：单例模式提供了一个全局访问点，这使得它可以方便地被其他对象访问。 避免共享资源的多重占用：在系统中，某些类对于实例化多个对象可能没有意义，或者可能会导致错误，单例模式可以防止这种情况的发生。 允许对实例进行优化：由于单例模式限制了实例的个数，因此可以在不影响系统其他部分的情况下对实例进行优化。缺点： 违反单一职责原则：单例类除了自身的业务逻辑外，还负责控制实例的创建，这可能会使得类承担过多的职责。 不利于测试：单例模式使得单例类很难进行单元测试，因为它通常涉及到静态方法和全局状态。 可能导致代码的不透明性：客户端代码可能不知道它们正在使用单例，因为它们是通过全局访问点来获取实例的，这可能会使得代码更难以理解和维护。 并发问题：在多线程环境下，单例模式可能会导致并发问题，因为多个线程可能会同时尝试创建单例类的实例。 难以扩展：由于单例模式限制了实例的数量，因此在某些情况下可能难以扩展，尤其是在需要多个实例的情况下。 可能导致资源闲置：如果单例持有资源（如数据库连接），而该资源在长时间内未被使用，则可能导致资源浪费。 总的来说，单例模式在特定场景下非常有用，例如管理数据库连接或配置文件，但是它也可能导致一些设计上的问题，因此在选择使用单例模式时需要权衡其优缺点。","tags":["编程语言","JavaScript"]},{"title":"77.组合,216.组合总和III,17.电话号码的字母组合","path":"/2024/09/06/77-组合-216-组合总和III-17-电话号码的字母组合/","content":"77.组合 代码随想录 leetcode 可以用回溯，但不知道如何回溯 定义了两个数组，一个用于函数返回的结果，一个用于记录返回结果的单元即数组的元素，在分析出这个题用回溯算法可以解决后，第一步需要做的就是定义变量，代码就是根据多种定义的变量编写的逻辑。 arr.slice() 创建一个包含原有数组中一个或多个元素的新数组 216.组合总和III17.电话号码的字母组合","tags":["leetcode","算法"]},{"title":"Vue中实现组件通信的方式","path":"/2024/09/06/Vue中实现组件通信的方式/","content":"在VUE中实现通信有很多种的方式，每一种都有其对应的使用情况。首先我们看看有哪些方式： props emit v-model refs provide&#x2F;inject eventBus uex&#x2F;pinia(状态管理工具) 常见的是上面的这几种，少见的其实还可以算上插槽slot,混入，路由携带参数，localStorage,$parent&#x2F;$children等 props常常使用在父组件传递給子组件通信的过程中，首先在子组件中使用props,来接收对应的属性，而在父组件中使用子组件的地方，添加上面定义的属性。（就是通过:props&#x3D;’xxx’来传递变量，子组件有一个和data并列的props属性，用来接收变量） emit这个就和上面的相反，是使用在子组件给父组件传递值的中。子组件中声明对应的事件，当子组件触发事件，就会通过this.$emit(‘事件’，数据)传递到，而在父组件中使用子组件的地方，添加上面定义的事件，这个可以获取子组件传来的值。（emit相反，用于子组件向父组件传递消息，子组件：this.$emit(‘updateMessage’, this.localMessage); 父组件：&lt;ChildComponentA @updateMessage&#x3D;”handleMessageUpdate” &#x2F;&gt;，父组件编写handleMessageUpdate函数接收子组件传来的值 123456methods: &#123; // 处理从子组件发来的事件 handleMessageUpdate(newMessage) &#123; this.xxx = newMessage; &#125;&#125; ） provide&#x2F;inject这对组合往往使用在层级比较深的时候，比如A组件下可能还有B组件，B组件下有C组件..E组件而使用这对API,就能无论层级有多深都能获取到 eventBus也就是事件总线，简单粗暴，可以到处飞。可以不管你是不是父子关系，通过新建一个Vue事件bus对象，然后通过bus.emit触发事件，bus.on监听触发的事件。但不建议乱用，不好维护。 vuex对于大型的项目来说往往是很必要的，尤其单页面应用，很多页面嵌套页面，关系很多。而使用VUEX就能便捷的统一管理。 总结常见的组件通信方式有通过props&#x2F;emit&#x2F;provide和inject&#x2F;eventBus&#x2F;vuex等，一般根据不同的场景来决定使用的方式。比如父子组件通信使用props,反过来使用emit。而当层级很多的时候使用provide,全局的状态管理使用vuex等。","tags":["前端开发","Vue"]},{"title":"MMSegmentation1.x环境配置","path":"/2024/09/05/MMSegmentation1-x环境配置/","content":"全新安装电脑配置：RTX3060 12G 系统: Windows11 安装nvidia cuda11.7 安装anaconda3 打开官方github地址，切换到1.x分支, 按照安装指令安装 安装pytorch可以通过whl包安装, 注意要安装的pytorch版本要和cuda版本及python版本对应 安装GDAL可以通过whl包安装, 注意要安装的GDAL版本要和python版本对应 迁移 安装nvidia cuda11.7 复制env目录到新电脑的anaconda3 env目录下 打开anaconda3终端，进入env目录，执行activate mmdetection1.x命令"},{"title":"235.二叉搜索树的最近公共祖先,701.二叉搜索树中的插入操作,450.删除二叉搜索树中的节点","path":"/2024/09/04/235-二叉搜索树的最近公共祖先-701-二叉搜索树中的插入操作-450-删除二叉搜索树中的节点/","content":"​235. 二叉搜索树的最近公共祖先 只能想到普通的二叉树搜索最近的公共祖先的方法，不知道如何利用二叉搜索树的性质。 二叉搜索树根节点的值大于左子树的所有值小于右子树的所有值，从上到下便利到第一个位于p，q区间内的说明p，q位于当前便利节点的两侧，根据二叉树的图形，当前节点一定是p，q最近的公共祖先节点，因为如果不是接下来向左或向右都会错过成为另一个节点的祖先的机会，所以返回这个节点即可。 单层递归逻辑中，当p，q的值都大于或都小于当前遍历节点的值时，依次递归右子树或左子树后接收返回值需要判断是否为null再返回，递归下一层时漏写参数。 4. 单层递归逻辑中，当p，q的值都大于或都小于当前遍历节点的值时，依次递归右子树或左子树后接收返回值需要判断是否为null再返回，递归下一层时再次注意不要漏写参数。用了一天的零散时间。 701.二叉搜索树中的插入操作 根据二叉搜索树的性质，无论插入的数值是啥，都可以通过遍历到一个左右节点为null的节点进行插入。 插入是在二叉搜索树的叶子节点进行插入操作。 迭代法中没有考虑二叉搜索树为空的情况以及当前遍历节点左右子树其中一个为空另一个不为空的情况；递归法终止条件是返回一个新创建的节点。 4. 迭代法中没有考虑二叉搜索树为空的情况以及当前遍历节点左右子树其中一个为空另一个不为空的情况；递归法终止条件是返回一个新创建的节点。用了一天的零散时间。 450.删除二叉搜索树中的节点 不知道咋做。 递归的返回值是删除节点后的根节点，删除二叉搜索树中的节点分几种情况，第一种是待删除的节点为叶子节点，这种直接将null返回到上层递归进行处理即可，如果删除节点不是叶子节点且左右子树中一个为空一个不为空，则返回不为空的那一个（作为删除待删除节点后到二叉搜索树的根节点）到上一层递归中进行处理。如果待删除节点左右子树不为空，则先定义一个临时指针，初始值为当前指针的右子树位置，依次往左子树左边遍历，直到临时指针的左指针为null时暂停，将之前遍历的指针（临时指针的初始位置）的左子树放置到临时指针的右子树位置，返回之前遍历的指针（临时指针的位置）。 3. 递归的返回值是删除节点后的根节点，删除二叉搜索树中的节点分几种情况，第一种是待删除的节点为叶子节点，这种直接将null返回到上层递归进行处理即可，如果删除节点不是叶子节点且左右子树中一个为空一个不为空，则返回不为空的那一个（作为删除待删除节点后到二叉搜索树的根节点）到上一层递归中进行处理。如果待删除节点左右子树不为空，则先定义一个临时指针，初始值为当前指针的右子树位置，依次往左子树左边遍历，直到临时指针的左指针为null时暂停，将之前遍历的指针（临时指针的初始位置）的左子树放置到临时指针的右子树位置，返回之前遍历的指针（临时指针的位置）；递归函数内部再次递归时漏写参数。 4. 递归的返回值是删除节点后的根节点，删除二叉搜索树中的节点分几种情况，第一种是待删除的节点为叶子节点，这种直接将null返回到上层递归进行处理即可，如果删除节点不是叶子节点且左右子树中一个为空一个不为空，则返回不为空的那一个（作为删除待删除节点后到二叉搜索树的根节点）到上一层递归中进行处理。如果待删除节点左右子树不为空，则先定义一个临时指针，初始值为当前指针的右子树位置，依次往左子树左边遍历，直到临时指针的左指针为null时暂停，将之前遍历的指针（临时指针的初始位置）的左子树放置到临时指针的右子树位置，返回之前遍历的指针（临时指针的位置）；递归函数内部再次递归时注意不要漏写参数。用了两天的零散时间。","tags":["leetcode","算法"]},{"title":"530.二叉搜索树的最小绝对差,501.二叉搜索树中的众数,236.二叉树的最近公共祖先","path":"/2024/09/04/530-二叉搜索树的最小绝对差-501-二叉搜索树中的众数-236-二叉树的最近公共祖先/","content":"​530.二叉搜索树的最小绝对差 第一遍没有看懂题, 用层序遍历将所有树节点保存到一个数组中，然后依次遍历数组中每一个元素（即节点），将节点值作为基准元素递归遍历以这个节点为根节点的二叉树，计算根节点和当前遍历节点的值差的绝对值，然后和全局最小值进行比较，如果比全局最小值更小则更新全局最小值，最后返回全局最小值。 此题中说了是找二叉搜索树的最小绝对差，这颗树是有顺序的，左子树的值小于根节点的值小于右子树的值，用中序遍历转为转为数组也可以比较简单计算出最小绝对差，更好的方法是用一个指针变量记录前一个遍历节点的值（这里利用了二叉搜索树是有序的这个性质，最小绝对差的两个元素一定是相邻的两个元素），通过不断地递归中序遍历整棵树，同时更新pre指针变量，依次计算差的绝对值，然后和全局最小绝对差进行比较，如果当前差的绝对值更小则更新全局最小绝对差，最后返回全局最小绝对差。 不知道如何用javascript表示一个最大的数，忘记了是将当前遍历节点值和前一个结点值做差再和全局最小值做比较，这里用了当前遍历结点值直接和全局最小值做了比较，不够细致。忘记了更新pre指针，有偷懒的想法，因为看卡哥视频讲解中将一些关键代码都记录下来了，没有严格要求自己。 javascript中Math.max()对应的是-Infinity，要细致地读题，充分利用题目中的条件；刷题时尽量不要偷懒背题不思考；用了一天的零散时间。 501.二叉搜索树中的众数 1. 通过中序遍历将二叉搜索树所有结点值转为一个数组，然后本题就变成了求一个数组最长的连续重复子数组对应的数值的问题，然后用快慢指针先找到最大重复次数，然后同样用快慢指针再循环一遍数组找到所有等于最大重复次数的数值将其保存到一个结果数组中返回。 用双指针的思路，定义一个指针记录前一个遍历的结点，再定义一个全局最大重复次数的最大值，再定义一个全局变量result收集结果集，中序遍历过程中，定义一个count记录当前重复了多少次，如果当前重复次数和全局最大重复次数相等，则收集结果集，如果当前重复次数大于全局最大重复次数，更新全局最大重复次数的同时还要清空结果集，因为之前的结果集已经不满足条件了，最后返回结果集。 在用1中的思路时，当得到二叉搜索树中序遍历结点值数组后，用快慢指针遍历时在边界条件那里想了很长时间。在用2中的思路时更新前一个pre指针写到了判断当前结点和前一个结点的判断逻辑中去了，中序遍历过程中用于记录当前重复次数的count大于全局最大重复次数的代码处理逻辑中，只更新了全局最大重复次数和清空了结果数组，没有将新的结点值添加到结果数组中。 4. 在用1中的思路中，当得到二叉搜索树中序遍历结点值数组后，用快慢指针遍历时在边界条件外层写一个条件后可以通过内层循环逻辑去适配这个边界条件，不用同时外层考虑两个边界条件，这样可能会思路会乱。在用2中的思路时更新前一个pre指针写到了判断当前结点和前一个结点的判断逻辑中去了，中序遍历过程中用于记录当前重复次数的count大于全局最大重复次数的代码处理逻辑中，如果中序遍历过程中当前重复次数大于全局最大重复次数了，说明此时找到了更满足题条件的解，应当清空数组但也需要将当前结点值保存下来，否则结果集就会漏解。用了两天的零散时间。 二叉树的最近公共祖先 读题后感觉需要题目说的是判断两个结点是否有共同的最近祖先，不知道咋做。 本题用了回溯的思想，首先需要明确是从下往上找，所以用后续遍历，在左右子树上如果找到了这两个子节点中的其中一个都可以返回到上一级递归中，上一级递归中判断左右子树是否分别有这两个结点，如果有，那说明这一级递归中的结点就是最近的公共祖先，如果只有左子树有其中一个给定子节点，右子树没有给定的另一个子节点，说明当前递归层中的结点不是公共祖先，那么则返回右的这个子节点，交由上一级递归中的结点去判断，反之如果右子树有左子树没有也是同样的逻辑，如果左右子树都没有，那么就返回null。递归的终止条件是如果当前遍历结点为null或者为两个给定子节点中的其中一个则返回当前结点。 分别递归左右子树的时候递归函数中少写了参数，又有背卡哥视频的代码，对原理理解的还不是很透彻。 尽量理解原理做题而不是靠记忆。用了两天的零散时间","tags":["leetcode","算法"]},{"title":"654.最大二叉树,617.合并二叉树,700.二叉搜索树中的搜索,98.验证二叉搜索树","path":"/2024/09/04/654-最大二叉树-617-合并二叉树-700-二叉搜索树中的搜索-98-验证二叉搜索树/","content":"​654.最大二叉树 不知道咋做。 找到数组最大值，将数组划分为左右数组，然后递归构造二叉树，当数组长度为1时，构造二叉树节点然后返回。 在递归生成左右子树时需要判断划分的数组长度是否不为1,生成的节点递归创建左右子树有意义。 用了一天的零散时间。 617.合并二叉树 不知道咋做。 同时操作两棵树t1,t2, 可以直接用t1或t2根节点返回，递归的终止条件是如果t1为null,则返回t2, 如果t2为null则返回t1, 比如同时遍历t1和t2时，两颗树都有值直接进行相加操作，其中一个为null则返回另一个节点，依次递归处理左子树和右子树。 3. 同时操作两棵树t1,t2, 可以直接用t1或t2根节点返回，递归的终止条件是如果t1为null,则返回t2, 如果t2为null则返回t1, 比如同时遍历t1和t2时，两颗树都有值直接进行相加操作，其中一个为null则返回另一个节点，依次递归处理左子树和右子树。 4. 用了两天的零散时间。 二叉搜索树中的搜索 不知道咋做。 二叉搜索树根节点的值大于左子树的值，小于右子树的值，根据数值的大小自动选择递归调用选择返回左子树 &#x2F; 右子树节点。迭代法通过循环和节点值选择方向。 3. 二叉搜索树根节点的值大于左子树的值，小于右子树的值，根据数值的大小自动选择递归调用选择返回左子树 &#x2F; 右子树节点。迭代法通过循环和节点值选择方向。 4. 用了两天的零散时间。 98.验证二叉搜索树 不知道咋做。 通过生成一个中序遍历的数组，检查数组是否单调递增即可判断是否是二叉搜索树；通过设置一个变量记录前一个变量节点的数值，然后在每次遍历时通过比较前序遍历的中节点的值和记录的变量的大小关系，如果当前节点的值大于变量记录的值，则可能是二叉搜索树，否则不是二叉搜索书。 用生成数组判断递增中用到了双指针，后一个指针当&gt;&#x3D; length - 1时就需要跳出循环，while循环最下面判断后指针位于数组最后一个元素位置则跳出循环;JavaScript中定义最小值-Math.min() 4.用了两天的零散时间。","tags":["leetcode","算法"]},{"title":"513.找树左下角的值,112. 路径总和,106.从中序与后序遍历序列构造二叉树","path":"/2024/09/04/513-找树左下角的值-112-路径总和-106-从中序与后序遍历序列构造二叉树/","content":"​513.找树左下角的值 层序遍历可以做，不知道用递归咋做。 2.认真读题，首先是必须同时满足深度最大和左边两个条件，通过一个全局变量maxDepth保存最大深度，result保存最大深度对应的节点值，这个值必须是左节点，本题没有对中节点的处理逻辑，前中后序遍历都可以，只需满足左节点比右节点先遍历，递归结束后，返回result。 javascript不能直接在函数外层用let定义变量（maxDepth, result）,递归过程中这些值不能更新，可以通过用一个函数f在内部嵌套递归函数，函数f中定义的变量递归函数可以访问到和更新。 用了两天的零散时间。 路径总和 需要在递归计算过程中去判断是否节点值和为sum, 不知道单层递归逻辑是啥。 2.递归遍历节点过程中对sum进行可以减去节点值，当遍历到叶子节点判断sum是否为0则知道这个遍历路径是否满足条件，如果不满足条件，则会进行回溯，继续寻找其他路径。当为sum为0且当前节点为叶子节点则找到一条路径，返回true。 3.第一次递归就需要进行一个sum - root.val操作传递给递归函数，在对左右子树分别进行递归处理后需要返回false, 因为左右子树都没有找到满足条件的路径，则说明树没有符合节点和相加为sum的路径，则返回false。 用了两天的零散时间。 106.从中序与后序遍历序列构造二叉树 不知道咋做，觉得很麻烦。 从中序和后续遍历序列构造二叉树也是一个递归过程，先从后续遍历的最后一个位置确定根节点，这个值用来创建根节点n，二叉树在创建过程中也可以看成是无数个根节点创建而成的，然后根据这个根节点的值将中序遍历序列划分为左中序序列和有中序遍历序列，根据左中序序列的数组长度和右中序序列的数组长度将后续遍历序列也划分为左后续序列和右后续序列，然后递归处理左中序序列，左后序序列赋值给n的左孩子，递归处理右中序序列，右后序序列赋值给n的右孩子，最后返回节点n。 从中序和后续遍历序列构造二叉树也是一个递归过程，先从后续遍历的最后一个位置确定根节点，这个值用来创建根节点n，二叉树在创建过程中也可以看成是无数个根节点创建而成的，然后根据这个根节点的值将中序遍历序列划分为左中序序列和有中序遍历序列，根据左中序序列的数组长度和右中序序列的数组长度将后续遍历序列也划分为左后续序列和右后续序列，然后递归处理左中序序列，左后序序列赋值给n的左孩子，递归处理右中序序列，右后序序列赋值给n的右孩子，最后返回节点n。划分中序右序列那里需要从根节点位置的下一位作为开始节点位置。 用了两天的零散时间。","tags":["leetcode","算法"]},{"title":"110.平衡二叉树,257.二叉树的所有路径,404.左叶子之和,222.完全二叉树的节点个数","path":"/2024/09/04/110-平衡二叉树-257-二叉树的所有路径-404-左叶子之和-222-完全二叉树的节点个数/","content":"​110.平衡二叉树 （优先掌握递归） 不知道咋做。 在求二叉树的高度的代码上改，二叉树的高度肯定是大于等于0的，这里利用高度不可能是-1但可以表示当前子树不是平衡二叉树，子树不是平衡二叉树递归回来也不是平衡二叉树。 3. 在求二叉树的高度的代码上改，二叉树的高度肯定是大于等于0的，这里利用高度不可能是-1但可以表示当前子树不是平衡二叉树，子树不是平衡二叉树递归回来也不是平衡二叉树。 4。用了零散时间看，大概用了两天。 二叉树的所有路径 （优先掌握递归） 不知道咋做，但知道和遍历顺序有关。 递归进入下一层后要能够回到之前的状态，这样才能够遍历到以某个节点的另一条路径，回藏在递归中。 javascript本身就是赋值引用，所以不用单独针对递归进行处理。 用了零散时间，大概用了两天。 404.左叶子之和 （优先掌握递归） 这个是不是在递归过程中要用if判断。 首先是叶子节点，然后是左叶子节点，所以无法从当前节点进行判断是否是左叶子节点，只能从节点的父节点进行判断，如果当前节点的左孩子不为空，且左孩子的左孩子、右孩子为空，则找到了一个左叶子，右子树可能也有左叶子节点，也要递归，最后将左右的叶子节点相加返回。 3.首先是叶子节点，然后是左叶子节点，所以无法从当前节点进行判断是否是左叶子节点，只能从节点的父节点进行判断，如果当前节点的左孩子不为空，且左孩子的左孩子、右孩子为空，则找到了一个左叶子，右子树可能也有左叶子节点，也要递归，最后将左右的叶子节点相加返回。 4.用了零散时间，大概用了两天。 222.完全二叉树的节点个数（优先掌握递归） 不知道咋做。 没有完全理解，这个博客拖了太久了，这个题二刷再研究吧，因为可以用后续遍历，这里直接用的普通的后续遍历，遍历到空节点返回0,然后分别递归左右子树计算节点数和再加1得到以当前节点为根节点的数的节点数和然后返回。 3. 没有完全理解，这个博客拖了太久了，这个题二刷再研究吧，因为可以用后续遍历，这里直接用的普通的后续遍历，遍历到空节点返回0,然后分别递归左右子树计算节点数和再加1得到以当前节点为根节点的数的节点数和然后返回。 &#x2F;","tags":["leetcode","算法"]},{"title":"226.翻转二叉树,101.对称二叉树,104.二叉树的最大深度,111.二叉树的最小深度","path":"/2024/09/04/226-翻转二叉树-101-对称二叉树-104-二叉树的最大深度-111-二叉树的最小深度/","content":"​226.翻转二叉树 根节点可以交换左右指针，其他层逻辑不清楚，觉得应该不是简单的交换指针。 从下到上，依次交换节点的左右指针即可，关键在于选择遍历顺序，可以选择前序遍历和后序遍历，后续遍历（左右中，右左中）是先处理下层节点再处理当前层节点，处理每个节点都是执行一个交换指针操作。 交换指针的逻辑，javascript交换指针函数需要传递root,不能改变root.left和root.right的值达到交换指针的效果。 4.用了一个小时左右。 对称二叉树 根节点可以比较左右指针，其他层如何比较不知道。 2. 以根节点的子节点leftnode,rightnode这一层为例，首先判断leftnode,rightnode是否为空，leftnode和rightnode都为空，满足对称返回true, leftnode，rightnode其中一个为空则返回false,如果leftnode,rightnode都不为空则判断leftnode,rightnode两个节点的值是否相等，不相等则返回false,相等则继续递归比较leftnode.left和rightnode.right是否想等，leftnode.right和rightnode.left是否相等。如果这两次判断都为true,则结果为true,否则结果为false。递归结束条件为当前遍历节点为空。 3. 以根节点的子节点leftnode,rightnode这一层为例，首先判断leftnode,rightnode是否为空，leftnode和rightnode都为空，满足对称返回true, leftnode，rightnode其中一个为空则返回false,如果leftnode,rightnode都不为空则判断leftnode,rightnode两个节点的值是否相等，不相等则返回false,相等则继续递归比较leftnode.left和rightnode.right是否想等，leftnode.right和rightnode.left是否相等。如果这两次判断都为true,则结果为true,否则结果为false。递归结束条件为当前遍历节点为空。 用了一个小时左右。 104.二叉树的最大深度 只想到了层序遍历可以计算深度。 根节点的最大高度就是二叉树的最大深度，二叉树要求高度，通过后序遍历（即左右中）往上计算，叶子节点的高度为1，对于左右中的遍历顺序来说，中节点的最大深度高度为左右子节点高度中的最大值+1，递归结束条件为遍历节点为空，此时高度为0。 3. 根节点的最大高度就是二叉树的最大深度，二叉树要求高度，通过后序遍历（即左右中）往上计算，叶子节点的高度为1，对于左右中的遍历顺序来说，中节点的最大深度高度为左右子节点高度中的最大值+1，递归结束条件为遍历节点为空，此时高度为0。 用了一个小时左右。 111.二叉树的最小深度 只想到了层序遍历可以计算深度。 同样可以转换为计算二叉树的最小高度，采用左右中的遍历顺序，注意二叉树最小深度的定义，是从根节点到叶子节点的长度，不是空节点，所以需要添加判断条件 — 当左子树为空有子树为空时返回右子树的高度+1；当左子树不为空右子树为空时，返回左子树的高度+1；当左右子树都为空时，说明此时为叶子节点，高度为1；当左右子树都不为空时，分别计算左右子树的高度，取最小值再+1即为中节点对应高度；递归结束条件为当前节点为空。 3. 当左子树为空有子树为空时返回右子树的高度+1；当左子树不为空右子树为空时，返回左子树的高度+1。 用了一个小时左右。","tags":["leetcode","算法"]},{"title":"N叉树遍历相关(144,94,102,102,107,199,429,515,16,117,104,111)","path":"/2024/09/04/N叉树遍历相关(144,94,102,102,107,199,429,515,16,117,104,111)/","content":"​144. 二叉树的前序遍历 1.用递归。 2.递归结束条件是root为null。 3.&#x2F; 4.用了半个小时。 二叉树的后序遍历1.用递归。 2.递归结束条件是root为null。 3.递归那里忘记传入数组。 4.用了半个小时。 二叉树的中序遍历1.用递归。 2.递归结束条件是root为null。 3.&#x2F; 4.用了一分钟。 二叉树的层序遍历 1.首先想用循环，但又感觉做不出来。 利用队列的先进先出特性，同时记录一下树每一层的节点个数size，在开始读树的新一层时更新size, 循环size次将同一层的节点值保存进一个数组vector，size次后将vector作为一个元素保存进结果数组，当队列长度为0时代码执行结束。 3.最外层循环的边界条件没想清楚，左右节点入队时要判断是否为空。 用了一个小时左右。 二叉树的层序遍历 II 二叉树层序遍历为基础改的题。 没有看。 3.javascript array的unshift是从前面添加数组元素。 用了十分钟左右。 二叉树的右视图 二叉树层序遍历为基础改的题。 没有看。 3.javascript中获取数组最后一个元素不能通过arr[-1]来获取。 用了十分钟左右。 429 ． N 叉树的层序遍历 二叉树层序遍历为基础改的题。 没有看。 3.多子节点是存放在一个数组中。 用了半个小时左右。 515 ．在每个树行中找最大值 二叉树层序遍历为基础改的题。 没有看。 3.多子节点是存放在一个数组中。 用了半个小时左右。 16 ．填充每个节点的下一个右侧节点指针 二叉树层序遍历为基础改的题。 没有看。 3.javascript中可以通过Math.max.apply(null, arr)获取arr的最大值。 用了半个小时左右。 117 ．填充每个节点的下一个右侧节点指针 二叉树层序遍历为基础改的题。 没有看。 3.在如何连接指针那里想了一下，将二叉树层序遍历存放节点值修改为存放节点对象，就可以通过遍历二维数组中的每个层节点数组进行指针指向操作，不知道是否还有更好的方法。 将二叉树层序遍历存放节点值修改为存放节点对象，就可以通过遍历二维数组中的每个层节点数组进行指针指向操作；用了一个小时左右。 104 ·二叉树的最大深度 二叉树层序遍历为基础改的题。 没有看。 3.在如何获得二叉树最大深度那里想了一下，遍历每一层节点值将其保存进一个数组作为二维数组的元素，有多少个这样的元素二叉树的深度就是多少，不知道是否还有更好的方法。 遍历每一层节点值将其保存进一个数组作为二维数组的元素，有多少个这样的元素二叉树的深度就是多少；用了半个小时左右。 111 ．二叉树的最小深度 二叉树层序遍历为基础改的题。 没有看。 3.在如何获得二叉树最小深度那里想了一下，遍历每一层时将节点保存进一个数组中，然后将层节点数组作为二维数组的一个元素，循环遍历这个二维数组中的每一个元素，如果该元素的左右子节点均为空，则这个元素所在的最外层索引下标+1即为二叉树的最小深度，不知道还有没有更好的方法。 遍历每一层时将节点保存进一个数组中，然后将层节点数组作为二维数组的一个元素，循环遍历这个二维数组中的每一个元素，如果该元素的左右子节点均为空，则这个元素所在的最外层索引下标+1即为二叉树的最小深度；用了一个小时左右。","tags":["leetcode","算法"]},{"title":"计算数组平均值","path":"/2024/09/04/计算数组平均值/","content":"计算数组平均值使用 reduce 方法1234const numbers = [1, 2, 3, 4, 5];const sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);const average = sum / numbers.length;console.log(average); // 输出: 3 使用 forEach 方法12345const numbers = [1, 2, 3, 4, 5];let sum = 0;numbers.forEach(number =&gt; sum += number);const average = sum / numbers.length;console.log(average); // 输出: 3 使用 map 和 reduce 方法12345678const numbers = [1, 2, 3, 4, 5];const sumAndCount = numbers.reduce((acc, val) =&gt; &#123; acc.sum += val; acc.count++; return acc;&#125;, &#123; sum: 0, count: 0 &#125;);const average = sumAndCount.sum / sumAndCount.count;console.log(average); // 输出: 3 获取数组最大值使用 Math.max 和 apply123const numbers = [1, 2, 3, 4, 5];const max = Math.max.apply(null, numbers);console.log(max); // 输出: 5 使用 Math.max 和扩展运算符123const numbers = [1, 2, 3, 4, 5];const max = Math.max(...numbers);console.log(max); // 输出: 5 使用 reduce 方法123const numbers = [1, 2, 3, 4, 5];const max = numbers.reduce((a, b) =&gt; Math.max(a, b));console.log(max); // 输出: 5 使用 sort 方法1234const numbers = [1, 2, 3, 4, 5];numbers.sort((a, b) =&gt; b - a);const max = numbers[0];console.log(max); // 输出: 5 使用 for 循环12345678const numbers = [1, 2, 3, 4, 5];let max = numbers[0];for(let i = 1; i &lt; numbers.length; i++) &#123; if(numbers[i] &gt; max) &#123; max = numbers[i]; &#125;&#125;console.log(max); // 输出: 5 计算次方使用 Math.pow1234const base = 2;const exponent = 3;const result = Math.pow(base, exponent);console.log(result); // 输出: 8 使用 ** 运算符1234const base = 2;const exponent = 3;const result = base ** exponent;console.log(result); // 输出: 8 获取二维数组内层最小数组的长度12345const arrayOfArrays = [[1, 2, 3], [1, 2], [1, 2, 3, 4, 5], [1]];const minLength = arrayOfArrays.reduce((min, arr) =&gt; &#123; return Math.min(min, arr.length);&#125;, Infinity);console.log(minLength); // 输出: 1 或者使用 map 和 Math.min 1234const arrayOfArrays = [[1, 2, 3], [1, 2], [1, 2, 3, 4, 5], [1]];const lengths = arrayOfArrays.map(arr =&gt; arr.length);const minLength = Math.min(...lengths);console.log(minLength); // 输出: 1 以上内容涵盖了在 JavaScript 中对数组进行操作和计算的一些基本知识点。","tags":["编程语言","JavaScript"]},{"title":"150.逆波兰表达式求值","path":"/2024/09/04/150-逆波兰表达式求值/","content":"​150. 逆波兰表达式求值 知道会用到栈，要用到入栈和弹出操作。 遇到数就入栈，遇到操作符就弹出两个操作数，用操作符进行计算，然后将结果入栈，直到遍历完后缀表达式，栈中最后一个元素就是逆波兰表达式计算结果。 注意两个数在和操作符的相对位置，弹出的第一个数应该在操作符的右边，弹出的第二个数应该在操作符的左边，循环遍历逆波兰表达式判断是否位操作符时tokens[i]没有写[i]导致程序用例不能完全通过。 用了一个小时左右。","tags":["leetcode","算法"]},{"title":"232.用栈实现队列,225.用队列实现栈,20.有效的括号,1047.删除字符串中的所有相邻重复项","path":"/2024/09/04/232-用栈实现队列-225-用队列实现栈-20-有效的括号-1047-删除字符串中的所有相邻重复项/","content":"​232.用栈实现队列 知道要用两个栈实现，具体咋做忘了。队列的特性是先进先出，栈是先进后出，入队操作直接入栈就行，实现出队操作，入栈的第一个元素在栈最下面出来需要借助另一个栈b，先将所有元素入栈b，这样出栈的时候就是入队的第一个元素了，javascript中的栈竟然是直接用数组代替的，直接就可以进行pop操作和push操作。实现了pop函数在实现peek操作的时候可以直接调用pop来简化代码这个编程习惯真好。不知道栈如何实现。用了一个小时左右。225. 用队列实现栈 模模糊糊知道要用两个队列来实现，具体咋做忘了。用一个队列也可以实现栈，比如栈是先进后出，在一个队列里这个元素要出来必须等前面的元素出来才可以，可以让这个元素之前的元素出队再入队，这样就可以达到出栈元素的目的。javascript中队列竟然也是用数组实现的，出队元素是通过执行数组的shift方法达到获取移除第一个元素的作用。用了一个小时左右。 20. 有效的括号 有栈的代码了这个题感觉ok。&#x2F;需要建立左符号和右符号的关系，遇到右符号不是比较出栈元素和这个元素是否相等，而是判断这两个符号是否配对；遍历完字符串后，栈是否为空都有返回值。用了半个小时左右。 1047. 删除字符串中的所有相邻重复项 先想到用双指针，没做出来。原来用栈这么简单，结果就藏在栈里面的内容中，遍历一个新元素就检查栈顶是否和这个新元素相同，相同就出栈，不相同就入栈，将栈中的结果反转一下就是满足题意的结果。这个题用之前写过的类定义的栈会超时间，感觉可能和最后反转拼接操作有关，不知道具体啥原因，最后用了一个数组来实现存放元素，移除元素的逻辑，最后时间复杂度降低了。用了一个小时左右。","tags":["leetcode","算法"]},{"title":"151.翻转字符串里的单词,卡码网:55.右旋转字符串","path":"/2024/09/04/151-翻转字符串里的单词-卡码网-55-右旋转字符串/","content":"​151.翻转字符串里的单词 感觉需要用到反转字符串操作，但空格不知道如何处理。 先反转整个字符串，然后对单词进行反转，需要注意空格的处理。 3.坚持循环不变量原则，while循环中尽量将循环变量自增操作放置在最后，这样可以让循环变量自增后有一次判断，带入测试用例推导花了一些时间。主要是涉及到对末尾空格的处理，可能有多个空格或一个空格，这个空格需要删除。 4.用了一个小时左右。 卡码网：55.右旋转字符串 想用双指针，发现用不了。 2.先反转整个字符串，然后分段进行反转拼接即可。 3.javascript如何处理输入操作，输入处理的代码是网上找的，还没有掌握, 在concat那里少写了一个reverse函数导致结果顺序不对。 reverse函数是原地操作 123let a = [1,2,3]let b = a.reverse()console.log(a, b)//[ 3, 2, 1 ] [ 3, 2, 1 ] 4.用了半个小时左右。","tags":["leetcode","算法"]},{"title":"344.反转字符串,541.反转字符串II","path":"/2024/09/04/344-反转字符串-541-反转字符串II/","content":"​344. 反转字符串 感觉需要用到指针，但不知道咋做。 倒序就是一个交换left,right指针对应指针值的过程。 纠结在javascript中能不能用字符串索引（就是当数组用），javascript中不能像数组那样索引元素。 再一次见识到了双指针的力量。用了半个小时左右。 反转字符串 II 读不懂题。 卡哥真牛啊，纸上推一下吧，用小人脑虚拟出来的小计算机测试一下不好想的地方（谁和计算机比计算能力哟）。 （如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）前半段字符串反转，这句话是遍历到后面才会遇到的，题目中放在了前面，（如果剩余字符少于 k 个，则将剩余字符全部反转），这两句话前面遍历遇到，题目中放在了后面，这个算法其实还是在考reverse函数的实现，（如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）这本质上就是在计算机试结果。写边界条件确定整个题的循环不变量是啥，严格按照循环变量来写边界条件，出错率低。 4. （如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）前半段字符串反转，这句话是遍历到后面才会遇到的，题目中放在了前面，（如果剩余字符少于 k 个，则将剩余字符全部反转），这两句话前面遍历遇到，题目中放在了后面，这个算法其实还是在考reverse函数的实现，（如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）这本质上就是在计算机试结果。写边界条件确定整个题的循环不变量是啥，严格按照循环变量来写边界条件，出错率低。","tags":["leetcode","算法"]},{"title":"454.四数相加II,383.赎金信,15.三数之和,18.四数之和","path":"/2024/09/04/454-四数相加II-383-赎金信-15-三数之和-18-四数之和/","content":"​454.四数相加II 暴力算法。 先两个循环将和放到map中，再两个循环求和查询map，计算总数求和，将一个4层循环复杂度降低了。要查找一个元素是否出现用map, map也是一个hash结构。 3.没啥问题。 用了半个小时左右。 赎金信 没读懂。 和有效字母异位词方法差不多。 没啥问题。 4.用了半个小时左右。 三数之和 1.暴力算法。 2.用hash法去重麻烦，双指针好理解。 3.快速排序代码不熟悉，最外层循环的边界条件，当left&#x3D;&#x3D;right后left和right要移动(left左移,right右移)，不然会一直循环下去。 4.用了一个小时左右，快速排序代码不熟悉，最外层循环的边界条件，当left&#x3D;&#x3D;right后left和right要移动(left左移,right右移)，不然会一直循环下去。 四数之和 题目说了是用一个数组，用map也不好处理去重。 在双指针上增加一层循环，然后修改对应边界条件，添加去重逻辑，剪枝逻辑。 外层循环和内层循环的边界条件，剪枝操作那里为啥是break? 4.用了两个小时左右。","tags":["leetcode","算法"]},{"title":"242.有效的字母异位词,349. 两个数组的交集,202.快乐数,1. 两数之和","path":"/2024/09/04/242-有效的字母异位词-349-两个数组的交集-202-快乐数-1-两数之和/","content":"​ 242.有效的字母异位词 对每一个字符串用一个字典统计每个字母出现的次数，最后比较两个字典是否key和value都相同。都相同则是有效字母异位词, javascript中如何实现字典的key和value的比较? 这个编程问题可以分解为多个查询问题，涉及到查询，用hash法肯定是最快和简单的，只需要用长度为26，值全为0的数组模拟一个hash表,遍历第一个字符串时查询hash表对应字母然后执行加1操作，然后遍历第二个字符串时查询hash表对应字母执行减1操作，遍历完两个字符串后，循环一次hash表检查是否都为0, 都为0则是有效的字母异位词，同样这种策略也可以用于判断多个字符串是否是有效的字母异位词。 在JavaScript中，不能直接用inputStr[i] - ‘a’映射到对应下标，要用inputStr[i].charCodeAt(0) - ‘a’.charCodeAt(0)，charCodeAt(0)是用来获取ascii码的函数。 感受到了用hash法的简洁，用了一个小时左右，调试花了一些时间，在JavaScript中，不能直接用inputStr[i] - ‘a’映射到对应下标，要用inputStr[i].charCodeAt(0) - ‘a’.charCodeAt(0)，charCodeAt(0)是用来获取ascii码的函数。 两个数组的交集 遍历第一个数组，对于每一个元素都去第二个数组中查找，如果找到了，就将这个元素保存到结果数组中，同时在第二个数组中将所有对应这个元素值的元素都删除，遍历完第一个数组后返回结果数组。 也利用了hash法在查找元素方面的优点，这里由于元素长度不固定，用数组就不太适合，利用set这个数据结构(底层实现是红黑树，可以用于这种查找元素范围不固定的情况)，将第一个数组转为set1，这样就自动完成了去重操作，然后遍历第二个数组，对每一个元素，在set1中执行查询操作，找到了就添加到结果set2中，利用set2完成去重操作，最后将set2转为数组返回。 不知道如何用javascript创建set类型，没有理解这个题用set的原因，利用了hash法在查找元素方面的优点，这里由于元素长度不固定，用数组就不太适合，利用set这个数据结构(底层实现是红黑树，可以用于这种查找元素范围不固定的情况)，将第一个数组转为set1，这样就自动完成了去重操作，然后遍历第二个数组，对每一个元素，在set1中执行查询操作，找到了就添加到结果set2中，利用set2完成去重操作，最后将set2转为数组返回。 4，用了一个小时左右，利用set完成去重操作和提高查找效率。 快乐数 觉得这个题是一个数学问题，不知道咋做，大致知道要用循环提取数字每一位。 循环计算各位的数字平方和的过程中，如果当前计算过的数和之前计算过的数字重复了，那么再进行操作就会陷入无限循环中，确认当前计算过的数是否在之前出现了，这又是一个查找元素的问题，那么又要回归到用哈希法上来，用set保存每次计算得到的各位平方和，然后每次计算出新的各位平方和判断是否在set中出现过，如果出现过，则跳出循环返回false, 如果没有出现过则将当前的各位平方和保存到set中，直到和为1返回true, 这有点像计算机的算力解决一个数学问题，如果和不为1且没有出现重复值时，继续循环，不可能不一直循环下去同时值也不为1。 3.计算各位和的函数没有抽离处理，也没有意识到这是一个可以抽离的公共函数，导致代码比较混乱，定义set的代码写到循环里去了，然后每次都会清空set，没有达到代码的效果。 4, 需要养成好的代码习惯，这个题用了一个小时左右。 两数之和 两重循环，第二重循环不能用第一层循环的值，判断第一层循环和第二层循环的两个数是否和为target, 如果和为target，则返回下标数组。 还是利用hash法查询元素快的优点，先将第一个数组转为一个map，因为查的是数组元素的值, 所以key就是数组元素的值, 而key对应的value就存放数组元素的下标，然后遍历第二个数组，每次就查询target - nums2[index]的元素是否在set中，如果在，将target - nums2[index]这个值对应的value，和第二次循环的index一起作为一组下标结果返回。 3.不知道javascript中map如何实现、如何获取map元素和设置map元素。利用hash法查询元素快的优点，先将第一个数组转为一个map，因为查的是数组元素的值, 所以key就是数组元素的值, 而key对应的value就存放数组元素的下标，然后遍历第二个数组，每次就查询target - nums2[index]的元素是否在set中，如果在，将target - nums2[index]这个值对应的value，和第二次循环的index一起作为一组下标结果返回。 4.let map &#x3D; {};map[key]&#x3D;value;var a &#x3D; map[key];解题用了一个小时左右。 ​","tags":["leetcode","算法"]},{"title":"24. 两两交换链表中的节点,19.删除链表的倒数第N个节点,面试题 02.07. 链表相交,142.环形链表II","path":"/2024/09/04/24-两两交换链表中的节点-19-删除链表的倒数第N个节点-面试题-02-07-链表相交-142-环形链表II/","content":"​ 24.两两交换链表中的节点 第一想法是不知道这个题如何做，知道有改变指针这个操作。 双指针也太好用了，用双指针整个过程就是一个双指针移动加修改指针的过程，就像织毛衣一样的感觉。这里竟然要保存两个临时指针变量。 要保存两个临时指针变量，结合示意图分析实现起来还可以，主要是指针赋值那里想清楚，输入用例一遍过。 分析能否用双指针的意识，这个编程题用了半个小时左右。 19.删除链表的倒数第N个节点 第一想法先计算得到链表的总长度，根据倒数多少个节点计算正向应该遍历多少个节点count，然后正向遍历到了待删除结点的前一个结点执行删除操作。 用双指针正好表示了倒数多少个这个概念，先让快指针移动n+1个位置（不是移动n位是因为用了虚拟头节点，然后需要在待删除结点的前一个节点才能执行操作），然后一起移动快慢指针，当快指针到达链表末尾的位置，慢指针在的位置正好是待删除的元素的前一个节点位置，执行删除操作即可。 快慢指针开始时指向虚拟头节点，然后可以通过一个示意图来推导一下执行n+1才是对应待删除节点的前一个位置，一起移动快慢指针循环的边界条件时fast指针是否为空，而不是fast.next,可以想一想fast指针应该是在最后一个节点的位置,此时fast指针的下一个节点为null,不能进入循环执行移动操作，正好满足fast指针在最后一个节点位置。 一起移动快慢指针循环的边界条件时fast指针是否为空，而不是fast.next,可以想一想fast指针应该是在最后一个节点的位置,此时fast指针的下一个节点为null,不能进入循环执行移动操作，正好满足fast指针在最后一个节点位置。这个题目用了接近一个小时的时间。 面试题 02.07. 链表相交1.看不懂题 2.再回去读题，大致懂了是需要先找出最短的链表，最极端的就是短的链表头节点就是相交的位置，这种链表相交可以节省计算机的存储空间，找到这两个链表长度的差值dista后，将长链表的cur指针向后移动这个差值（正数）个位置，然后从这里依次遍历长短链表，对应位置指针相同则返回，遍历完都没有找到指针相同的位置则返回null. 3.根据链表长度不同执行了两端差不多的代码，后一段代码拷贝过来时没有将循环的条件改过来，导致用例报错。用了一个小时左右，主要时题干没有读懂。 142.环形链表II1.不知道咋做 2.真聪明，又是双指针，数学证明有点多。 3.不熟悉这类需要数学推导证明的编程题，完全没有想到用数学方法。 4.数学推导证明完了，用结论写代码实现起来比较简单，这个题先背方法，一刷就先记得这个结论吧，先不追求掌握的很深入，二刷深入研究一下。","tags":["leetcode","算法"]},{"title":"203.移除链表元素,707.设计链表,206.反转链表","path":"/2024/09/04/203-移除链表元素-707-设计链表-206-反转链表/","content":"​203.移除链表元素 1.这个移除链表的原理已经懂了。 2.和我的方法差不多，但卡哥的代码没有用到temp变量，节省了内存。 3.当遇到要删除的元素时，prev指向待删除元素的下一个节点后，这个时候prev是否需要移动要看cur移动后对应的节点是否还是待删除的元素，如果是prev就不需要移动，因为还是待删除节点的前一个节点，如果不是prev就需要移动一位。 4.整体还行，半个小时左右，主要是prev是否移动那里没有想清楚。 707.设计链表 1.觉得这个题太复杂了，涉及到链表操作太多，对javascript class语法不太熟悉。删除节点那里比较容易实现，又有index这个参数，感觉代码量较大。 2.首先没有意识去定义size变量，计算机的存储空间那么大，总是觉得引入变量会让题变得复杂，其实要看你引入的变量有没有意义。dummyhead的设置感觉会让代码简洁的多。 3.javascript定义链表那里有点不熟练，null写成了None, 这是python代码写多了吗？然后就是读题，这个题是设计链表，题目已经明确规定了链表的定义，只需要严格按照这个题目的要求进行实现，比如哪些index是合法的，在index合法和index不超过size那里需要注意，不超过size是可以取到size的。边界条件比如while循环判断cur是否为空还是cur.next是否为空，一个是代入极端情况检验，一个是看之后的代码用了哪些，比如用了cur.next.val,那么cur.next就不能为空。 4.这个题用了一个小时左右，速度慢一是排斥做这种题干复杂的题，其实实现了一个函数就将一个函数折叠起来看起来就要好的多，然后是javascript定义ListNode和class语法还不熟悉，关于链表操作原理多理解其实已经不难了，多注意一下就行。 206.反转链表 1.不知道咋做，又一个反向指多感觉，但感觉实现起来比较复杂。 2.双指针正好可以反向指还可以移动，这个反转链表的操作可以拆解为多次反向指的操作，但要合理地连接起来。 3.双指针法实现起来比较简单，一遍过。 4.用了二十分钟左右，分析问题的能力和计算机模拟的思维能力是我觉得这道题比较难的地方。","tags":["leetcode","算法"]},{"title":"977. 有序数组的平方、59.螺旋矩阵II\"","path":"/2024/09/04/977-有序数组的平方、59-螺旋矩阵II/","content":"​977.有序数组的平方 1.最先是对题目有点看不懂，为啥会强调非递减，元素平方后负数会变为正数，原有的非递减顺序会改变。最直接想到的是直接数组每个元素求平方然后对数组排序。 2.非递减这个条件利用的好，较大的数位于数组两端，这就为用双指针解法创造了条件，这个题目没有要求数组原地操作，所以定义left,right指针指向原数组，k指针指向函数返回的新数组，依次比较left,right指向元素平方和的大小，较大的值赋值给k指针指向的位置，较大的指对应的指针移动（向右或向左），k指针后移，知道left&gt;right结束。 3.第一次用暴力解法做，在排序哪里用了冒泡排序，但内层循环本来是遍历的j, 结果用了外层循环的i，导致用例报错。用双指针法在循环结束条件处应该是当left&lt;&#x3D;right继续循环，因为当left&#x3D;right时left或right指向的元素一直没有放到新数组中去，但最后一次需要放进去。 4.学会了要充分利用题中的条件，比如非递减用双指针就比较好。然后就是边界条件用一个特殊情况去分析是否取等号，这个题学习了近一个小时。 59.螺旋矩阵II 1.第一次看到这个题目，不知道这个题如何做，只知道可能要利用下标关系，没有发现这个过程有何规律。 2.首先是这个规律看得很准，就是将这个过程分解为几圈和中间位置的处理，只有n为奇数时才会有中间位置，中间位置也就是模拟过程的最后一步，转多少圈可以通过n&#x2F;2取整来计算，最关键的还是要定义好循环不变量，比如用左闭右开的原则就要坚持每条边都用左闭右开的原则。每次转完一圈后就更新转圈的起始位置，横纵坐标加1就可以完成，然后在转每一个圈中，左闭右开这个边界通过引入一个offset变量控制，初始值为1, 转完一圈后offset加1。如果是奇数，最后一步还需要将中心位置赋值。 3.首先没有搞清楚循环的条件是啥，应该是转多少圈，用n&#x2F;2取整获得转的圈数。然后是数组索引的部分，没有想清楚哪里用startX,startY,i,j这些变量，用startX,startY初始化i,j后需要用i,j来定位，i,j是记录着当前位置的信息，startX,startY本身只在转完一圈后再执行+1的操作。 4.体会到了用好循环不变量的重要性，整个思维过程比较严谨且可控，学习了一个小时左右，第一次真正实现了这种精确的计算机模拟算法。","tags":["leetcode","算法"]},{"title":"704. 二分查找、27. 移除元素。","path":"/2024/09/04/704-二分查找、27-移除元素/","content":"​704.二分查找 第一想到的算法就是遍历数组判断是否等于要查找的元素，学习到一些编程技巧后知道用二分查找效率更高。 对区间的明确定义可以让逻辑更加清晰，闭区间就是可以取到的，开区间就是不能取到的，开区间不能取到所以用左闭右开时right要设置为nums.length,也就是要多一位，左闭右闭就不用多一位。同样的逻辑也可以用在计算完middle更新left或right那里, 用左闭右开时更新right时就不用减去1,因为取不到，用左闭右闭就需要减去1。 3. 开区间不能取到所以用左闭右开时right要设置为nums.length,也就是要多一位。同样的逻辑也可以用在计算完middle更新left或right那里, 用左闭右开时更新right时就不用减去1,因为取不到。 4.明确了区间定义后实现起来就容易多了，降低了想的难度，学习了一个小时。 27.移除元素 第一想到的算法就是形象地想从数组中直接将这个元素清除，有点和打麻将拿出一张牌有点像，需要移动后面的元素。 首先是暴力解法，就是遍历到要删除的元素然后将后续的元素依次向前移动覆盖。然后是双指针解法，理解双指针在这个题中的定义非常重要，快指针是遍历旧数组的指针，慢指针是新数组的指针，只需要快指针循环一次，就可以完成暴力解法两层的循环，开始时快慢指针在同一个位置，如果fast指针所指元素是要删除的元素，fast指针继续移动，slow指针不懂，移动后如果fast指针所指元素不是要删除的元素，则对slow指针所指的位置赋值为fast指针所指的值，slow指针移动, fast指针继续移动，直到遍历到末尾结束，slow指针对应新数组长度。 暴力实现最开始用的是for循环，测试用例报错，原因在于用for循环遍历到要删除的位置，然后内层循环后续的元素向前依次移动，这个时候外层循环指向的位置可能仍然是需要删除的元素，但外层for循环已经去到了下一个位置，看了卡哥代码，是将外层循环的指针回退了一位，我用的while循环感觉逻辑更清晰。用双指针方法最开始没有理解双指针在这个题中的定义，导致写出了两层循环，代码反而更复杂，然后如果fast指针所指元素不是要删除的元素，则对slow指针所指的位置赋值为fast指针所指的值，slow指针移动, fast指针继续移动，这个逻辑也能处理nums数组第一个元素不是要删除元素的情况，虽然有点冗余计算，但代码逻辑比较简单。 ​","tags":["leetcode","算法"]},{"title":"域名解析的好处","path":"/2024/09/03/域名解析的好处/","content":"tomcat配置多网站时，Nginx可以根据不同域名解析到不同的网站端口，其他操作比如回调都是基于域名的，不会因为tomcat配置多网站选择的端口问题而影响其他服务。当更换服务器后，只需要修改域名解析，不需要改动其他相关联的服务代码，因为都是基于域名的。","tags":["前端软件开发"]},{"title":"高分辨率小屏设备远程控制低分辨率大屏设备方案","path":"/2024/09/03/高分辨率小屏设备远程控制低分辨率大屏设备方案/","content":"启动parsec-vdd添加一块屏幕在window显示设置中调整显示方式为仅在这块新增的屏幕上显示调整屏幕分辨率为适合小屏设备（能占据全屏幕）的分辨率"},{"title":"conda","path":"/2024/08/31/conda/","content":"Conda is a cross-platform, language-agnostic binary package manager."},{"title":"Vue-router","path":"/2024/08/28/Vue-router/","content":"一、路由常见的属性路由的两个属性$router和$route。$router1.$router.app2.$router.mode3.$router.currentRoute4.router.addRoutes(routes)5.router.beforeEach(to,from,next)6.router.afterEach()7.router.go(n)8.router.push(location)9.router.replace(location)10.router.back()11.router.forward()12.router.resolve(location)13.router.onReady(callback,[errorCallback])14.router.onError(callback)$route1.$route.path2.$route.query3.$route.params4.$route.hash5.$route.fullPath6.$route.name7.$route.matched8.$route.redirectedFrom Vue-router 是 Vue.js 中用于管理前端路由的一个插件，它可以帮助我们在单页面应用（SPA）中轻松地在不同的视图（页面）之间切换，而无需重新加载整个页面。 Vue-router 有两个重要的对象：$router 和 $route，分别代表路由实例和当前路由的状态。 1. $router 对象：$router 是整个路由实例，包含了控制路由的各种方法和属性。主要用来编程式导航，即通过代码改变路由。 常见的 $router 属性和方法： $router.app：当前应用的根 Vue 实例。 $router.mode：当前路由的工作模式（比如 hash 或 history）。 $router.currentRoute：获取当前路由对象，等价于 $route。 **$router.addRoutes(routes)**：动态添加更多的路由规则。 **router.beforeEach(to, from, next)**：全局前置导航守卫，路由跳转前的处理逻辑。 **router.afterEach()**：全局后置钩子，路由跳转后的处理。 **router.push(location)**：跳转到新的 URL，等价于用户点击链接。 **router.replace(location)**：类似 push，但不会留下历史记录。 **router.go(n)**：类似浏览器的前进后退，参数是步数，如 router.go(-1) 回到上一页。 **router.back()、router.forward()**：浏览器历史记录中的前进和后退。 2. $route 对象：$route 代表当前激活的路由，包含了当前 URL 解析后的信息。 常见的 $route 属性： $route.path：当前路由的路径。 $route.query：URL 中的查询参数，如 ?id=123 中的 id。 $route.params：动态路由的参数，如 /user/:id 中的 id。 $route.hash：当前路由的 hash 值（即 URL 中 # 后的部分）。 $route.fullPath：完整的 URL，包括查询参数和 hash。 $route.name：当前路由的名称（如果路由是有命名的）。 $route.matched：当前路由匹配的路由记录。 $route.redirectedFrom：重定向来源的路由。 总结： $router：用来控制路由跳转和导航（主动改变 URL）。 $route：表示当前路由的信息（被动获取 URL 状态）。 通过 Vue-router，开发者可以轻松管理 SPA 应用中的页面切换和路由逻辑，同时支持路由守卫、动态路由和编程式导航等高级功能。 App.vue 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Vue Router Example&lt;/h1&gt; &lt;nav&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/nav&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;button @click=&quot;goBack&quot;&gt;Go Back&lt;/button&gt; &lt;button @click=&quot;goForward&quot;&gt;Go Forward&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import router from &#x27;./router&#x27;;export default &#123; name: &#x27;App&#x27;, router, methods: &#123; goBack() &#123; this.$router.back(); &#125;, goForward() &#123; this.$router.forward(); &#125; &#125;, mounted() &#123; console.log(&#x27;Current Route:&#x27;, this.$route.path); console.log(&#x27;Query Params:&#x27;, this.$route.query); console.log(&#x27;Route Params:&#x27;, this.$route.params); console.log(&#x27;Route Name:&#x27;, this.$route.name); &#125;&#125;;&lt;/script&gt; router.js 123456789101112131415161718192021222324252627import Vue from &#x27;vue&#x27;;import Router from &#x27;vue-router&#x27;;import Home from &#x27;./components/Home.vue&#x27;;import About from &#x27;./components/About.vue&#x27;;Vue.use(Router);const routes = [ &#123; path: &#x27;/&#x27;, component: Home, name: &#x27;home&#x27; &#125;, &#123; path: &#x27;/about&#x27;, component: About, name: &#x27;about&#x27; &#125;];const router = new Router(&#123; mode: &#x27;history&#x27;, routes&#125;);router.beforeEach((to, from, next) =&gt; &#123; console.log(&#x27;Before each route:&#x27;, to.path); next();&#125;);router.afterEach((to, from) =&gt; &#123; console.log(&#x27;After each route:&#x27;, to.path);&#125;);export default router;","tags":["前端开发","Vue"]},{"title":"Vue的生命周期","path":"/2024/08/28/Vue的生命周期/","content":"一、各个生命周期的作用 Vue 的生命周期就是 Vue 实例从创建到销毁的过程，包括了它的初始化、渲染、更新、销毁等多个阶段。每个阶段 Vue 都会触发特定的生命周期钩子函数，让开发者有机会在不同的时间点执行代码。 首先在Vue生命周期中有十个阶段： 11、beforeCreate(创建前) 在实例初始化之后，进行数据侦听和事件&#x2F;侦听器的配置之前同步调用。因为data和methods中的数据都还没有初始化，常常在该阶段执行与Vue数据无关的事件，比如我们的loading等待事件。这是 Vue 实例刚开始初始化的阶段，此时实例还没有创建，数据和事件都还未准备好，DOM 结构也还没生成。 12、created(创建后) 在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件&#x2F;侦听器的回调函数。然而，挂载阶段还没开始，且$el property目前尚不可用。 在该阶段已经完成data和methods的初始化了，只是页面还未渲染，可以在该阶段来发起请求获取数据等，以及操作data和调用methods等Vue 实例已经创建好了，此时可以访问 data 和 methods，但 DOM 还没渲染。适合在这个阶段执行一些数据初始化或 Ajax 请求。 13、beforeMount(挂载前) 在挂载开始之前被调用：相关的render函数首次被调用。该钩子在服务器端渲染期间不被调用Vue 实例的模板已经编译好，准备将编译后的模板挂载到页面的 DOM 上，但 DOM 还未真正渲染。 14、mounted(挂载后) 实例被挂载后调用，这时el被新创建的vm.$el替换了。如果根实例挂载到了一个文档内的元素上，当mounted被调用时vm.$el也在文档内。注意mounted不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在mounted内部使用vm.$nextTick该钩子在服务器端渲染期间不被调用这时候Vue实例完成初始化，且挂载渲染到页面了，最早我们可以在这个阶段来操作页面上的DOM节点。Vue 实例已经挂载到页面上，DOM 已经渲染完成，适合在这里进行与 DOM 相关的操作。 15、beforeUpdate(更新前) 在数据发生改变后，DOM被更新之前被调用。这里适合在现有DOM将要被更新之前访问它，比如移除手动添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行该阶段此时实例中的数据已经是最新的啦，但是页面的还未更新在数据发生变化并且即将重新渲染 DOM 前触发。在这个阶段，你可以看到旧的 DOM 状态，但还没有更新。 16. updated（更新后） 数据更新完成，DOM 已经被重新渲染，适合执行需要与更新后的 DOM 交互的操作。 17. beforeDestroy（销毁前） Vue 实例即将销毁，在这里可以进行一些清理操作，比如移除事件监听器或清除定时器。 18. destroyed（销毁后） Vue 实例已经销毁，所有数据绑定、事件监听等都已经清除，DOM 结构也被移除了。","tags":["前端开发","Vue"]},{"title":"Vue的优点和特点","path":"/2024/08/28/Vue的优点和特点/","content":"一、优点1.首先是双向绑定这也是我们使用框架的一大优势，VUE使用MVVC架构，在VUE.2X中使用Object.definProperty (来劫持绑定数据，在VUE.3X中使用Proxy劫持。如果按照最初的开发，我们前端开发不仅仅是需要完成业务代码的实现，同时还需要对每个DOM元素进行获取绑定时间和数据。而双向绑定使得我们只需要专注于业务代码的实现上。 2.简单易学VUE以简单，易上手的特点，在国内很多企业得到使用。同时作为国人开发的框架，中文文档，相关的论坛，生态完善，也便于我们学习和遇到问题寻找解决方案。 3.虚拟D0M使用虚拟DOM,结合DIFF算法能减少性能损耗。他会把我们多次的操作合并为一次，推送到真实的DOM。另外补充，我们说虚拟DOM减少损耗是有条件，是指在频繁操作的情况下，不然肯定简单的获取操作最快的，期间没有很多计算等处理。 4.组件化的思想实现组件的封装（比如itopmap.com中的openlayermap.vue），我们往往是使用组件开发的思想去封装组件，这样不仅便于复用也好维护修改！ 二、缺点1.生态不够完善相比angular和react来说，生态环境较为不足，在构建大型的应用方面，企业使用react的比较多。而中小型企业使用VUE比较多。 三、react与VUE的区别和优缺点VUE和React的共同点是，都是组件化的思想，虚拟DOM,数据绑定，而不同点在于，首先两者的设计思想不同，前者定位降低前端开发的门槛，而后者推崇函数式编程。另外在React中，是使用JSX的写法，把HTML和CSS都写入到JavaScript中。还有的就是他们的DIFF算法实现也不太一样。","tags":["前端开发","Vue"]},{"title":"前端安全","path":"/2024/08/28/前端安全/","content":"XSS跨站脚本攻击Cross Site Scripting为了和CSS区别，CSS指的是层叠样式表(Cascading Style Sheets)用户输入或使用其他方式向代码中注入其他S,然后S代码被执行。1.可能是写一个死循环、获取cookie登录2.监听用户行为3.修改DOM伪造登录表单4.页面生成浮窗广告 反射型 XSS代码通过URL注入。因为恶意脚本通过作为网络请求的参数，经过服务器，然后反射到HTML文档中执行解析，服务器不会存储这些恶意脚本。反射型XSS漏洞常见于通过URL传递参数的功能，如网站搜索、跳转等。 存储型 XSS代码发送到服务器数据库，前端请求数据时，将XSS代码发送到前端。场景：留言区提交一段脚本执行，若前后端未做好转义的工作，评论内容存在数据库，页面渲染过程中直接执行相当于是执行一段未知逻辑的S代码。如论坛发帖、商品评论、用户私信等。 文档型 XSS攻击不会经过服务端，作为中间人的角色，数据传输过程劫持到网络数据包，然后修改里面的HTML文档。劫持包括：1.WIF路由劫持2.本地恶意软件DOM型XSS跟前两种XSS的区别：DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种XSS都属于服务端的安全漏洞。防范：一个信念，两个利用1.对输入转码过滤2利用CSP浏览器内容安全策略，核心就是服务器决定浏览器加载哪些资源，功能：1.限制其他域下的资源加载2.禁止向其它域提交数据3.提供上报机制3.HttpOnlyIttpOnly类型的cookie阻止JS对其的访问（标记或授权对话）阻止XSS攻击：服务器对脚本进行过滤或转码，利用CSP策略，使用HttpOnly;CSRF-跨站伪造请求（钓鱼）Cross-Site Request Forgery攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证（比如cookie)，绕过后台的用户验证，因此可以冒充用户对被攻击的网站执行某项操作。利用所在网站的目前登录信息，悄悄提交各种信息，比XSS更恶劣。本质：利用cooki会在同源请求中携带发送给服务器的特点，以此冒充用户。利用服务器的验证漏洞和用户之前的登录状态模拟用户操作。点击链接后，可能发生3件事1.自动发送GET请求。利用src发送请求2.自动发送POST请求3.诱导点击发送GET请求防范1.SameSiteSameSite可以设置为三个值，Strict、Lax和None。a.在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带Cookie,在其他网站请求都不能。b.在Lax模式，宽松一点，但是只能在get方法提交表单况或者a标签发送get请求的情况下可以携带Cookie,其他情况均不能。c.在None模式下，也就是默认模式，请求会自动携带上Cookie..2验证来源站点请求头中的origin和refererorigin,只包含域名信息，referer包含具体的URL路径。3.CSRF Roken利用token(后端生成的一个唯一登陆态，传给前端保存)每次前端请求都会带token,后端检验通过才同意请求。·敏感操作需要确认·敏感信息的cookie只能有较短的生命周期4安全框架如Spring Security.SQL注入攻击SQL注入攻击，将恶意的Sq查询或添加语句插入到应用的输入参数中，再在后台Sq服务器上解析执行。如何让Web服务器执行攻击者的SQL语句？SQL注入的常规操作就是将有毒的SQL语句放置于Fo表单或请求参数之中，然后提交到后端服务器，如果后端服务器没有做输入安全检查，直接将变量取出执行SQL语句，就容易中招。预防方式如下：·严格检查输入变量的类型和格式·过滤和转义特殊字符·对访问数据库的Web应用程序采用Web应用防火墙其他种类的攻击：DDoS全称Distributed Denial of Service:分布式拒绝服务攻击。是拒绝服务攻击的升级版。拒绝攻击服务顾名思义，让服务不可用。常用于攻击对外提供服务的服务器，像常见的：·Web服务。邮件服务·DNS服务·即时通讯服务DNS劫持JSON劫持暴力破解HTTP报头追踪漏洞信总泄露目录遍历漏洞命令执行漏洞文件上传漏洞等等","tags":["前端开发"]},{"title":"SPA首屏优化","path":"/2024/08/28/SPA首屏优化/","content":"浏览器从响应用户输入网址地址，到首屏内容渲染完成时间，整个网页不一定要完全渲染完成，但需要展示当前视窗内容加载慢的原因 网络延时 资源文件体积过大 资源加载重复发送请求 加载脚本时，渲染内容阻塞 解决 减少入口文件体积 静态资源本地缓存 UI框架按需加载 图片资源压缩 组件重复打包 开启GZip压缩 使用SSR 减少入口文件体积 路由懒加载，将不同路由对应组件分割成不同代码块，待路由被请求时单独打包路由，使得入口文件变小以函数形式动态加载路由，可以把各自的路由文件分别打包，只在解析给定路由时，才会加载路由组件 静态资源本地缓存 HTTP缓存和localStorage 按需加载 对UI库按需引用 图片资源压缩 对icon,使用在线字体图标 组件重复打包 若A.js是一个常用库，多个路由使用它会造成重复下载 在webpack的config中，修改CommonChunkPlugint的配置 minChunks为3表示会把使用3次及以上的包抽离，放进公共依赖文件 使用SSR 服务端渲染，Server Side,组件或页面通过服务器生成html字符串，发送到浏览器","tags":["前端开发","性能优化"]},{"title":"其他文件优化","path":"/2024/08/28/其他文件优化/","content":"1.服务端开启文件压缩功能2.执行JS代码过长会卡住渲染，对于需要很多时间计算的代码可以使用WebworkerwebWorker是运行在后台的JS,另开一个子线程，不会影响性能","tags":["前端开发，性能优化"]},{"title":"图片","path":"/2024/08/28/图片/","content":"电商类项目，存在大量图片，banner广告图、菜单导航栏、列表头图等图片众多以及体积过大影响页面加载速度为啥？有些图片请求并发，Chrome最多支持并发请求数有限，其他请求被push进队列中等待或停滞，直到上轮请求完成后才被发出，一部分资源需要排队等待时间，过多的图片影响页面加载展示合适图片格式1.WebP格式具有更好的图像数据压缩算法，更小的图片体积，拥有肉眼识别无差异的图像质量，缺点是兼容性并不好2.小图使用PNG,对于大部分图标，完全可以使用SVG代替3.照片使用JPEG4.雪碧图（将多个图标文件整合到一张图片中）可能请求非常多的小图片，会受到浏览器并发HTTP请求数的限制1.图片压缩2.不用图片，用CSS代替3.对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用CDN加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片JPEG&#x2F;JPG1.高质量有损压缩，体积小，不支持透明2.应用于轮播图大的背景图、bannerPNG1.无损压缩，质量好，体积大，支持透明2.应用小的10g0SVG1.体积小，不失真，兼容好2.应用于图标GIF1.支持透明Webp有损压缩与无损压缩（可逆压缩）的图片文件格式比PNG&#x2F;PEG格式小支持透明度体积和效果上都做的不错 12345&lt;picture&gt;&lt;source type=&quot;image/webp&quot;srcset=&quot;/static/img/perf.webp&quot;&gt;&lt;source type=&quot;image/jpeg&quot;srcset=&quot;/static/img/perf.jpg&quot;&gt;&lt;img src=&quot;/static/img/perf.jpg&quot;&gt;&lt;/picture&gt; webpack压缩配置image-webpack-loader雪碧图CSS Sprites,精灵图，图像合成技术，主要用于小图片显示同原域名请求有最大并发限制，Chrome为6个，如页面有10个小图，需要10次请求，2次并发若把10个图合成一个大图，只需1次请求1.减少请求次数2.减少服务器压力3.诚少并发4.提高加载速度5.减少鼠标滑过的一些bug6.解决网页设计师在图片命名上的困扰iconfont通过字体方式展示图标，用户图标渲染、简单图形、特殊字体等1.轻量，已修改2.诚少请求次数内联Base64图片转为base64串，解析图片不会请求下载，而是解析字符串缺点1.比使用二进制体积增大33%2.全部内联后，原本可并行加载的图片会串行放入请求适用于更新频率低、首屏或骨架图上的小图标CSS代替图实现修饰效果，半透明、阴影、圆角、渐变等"},{"title":"渲染优化","path":"/2024/08/28/渲染优化/","content":"懒执行将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。懒加载将不关键的资源延后加载一尽量只加载用户正浏览或即将会浏览的图片只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西对于图片来说，先设置图片标签的src属性为一张占位图，真实的图片资源放入自定义属性data-src中，当进入自定义区域时，就将自定义属性替换为sc属性，这样就会下载图片资源节流防抖防抖：单位时间内多次触发，只执行最后的那一次，原理：延迟执行，期间但凡有新的触发就重置定时器节流：单位时间只触发一次，原理：上锁，只有满足一定间隔时间才能执行"},{"title":"性能优化","path":"/2024/08/28/性能优化/","content":"1.网站打开速度2.动画流畅3.表单提交速度4.列表滚动页面切换是否卡顿优化手法1.聚焦用户2.尽快响应用户输入3.动画执行流肠4.最大化主线程空闲时间5.网页可交互性"},{"title":"鉴权","path":"/2024/08/28/鉴权/","content":"Cookie服务端响应客户端请求时，会返回一个cookie,后续客户端的请求携带这个cookie特点1.存储在客户端，可随意纂改2.影响性能，最大为4kb3.一个浏览器对于一个网站只能存不超过20个Cookie,而浏览器一般只允许存放300个Cookie4.移动端对Cookie支持不友好5.一般情况下存储的是纯文本，对象需要序列化之后才可以存储，解析需要反序列化通过设置正确的domain和path,减少数据传输，节省带宽 Cookie-sessioncookie需要的存的东西越来越多，但是cookie大小有限制所以后端返回sessionId,客户端将sessionid存在cookie中缓存数据库：所有机器根据sessionId去缓存系统获取用户信息和认证局限性1.依赖Cookie,但Cookie可被禁用2.系统不停请求缓存服务器查找信息，内存开销增加3.存在单点登录失败的可能性若负责session的机器挂了，整个登录就挂了，但项目中，负责session的机器也是有多台机器的集群进行负载均衡增加可靠性 SSO(单点登录)三种类型Single Sign On在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统单点登录1.同一站点下2.相同的顶级域名3.不同的顶级城名相同域名和相同顶级域名下可共享cookie但是不同域呢？ CAS(中央认证服务)原理 流程和Cookie-session模式相同 Json Web Token最简单的token组成：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+哈希算法压缩成一定长的十六进制字符串，防止恶意三方拼接token请求)JWTheader(头部)、payload(负载)、signature(签名)这三个部分组成，中间用.来分隔开：Header.Payload.Signaturejwt:“eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiJhliwiaWFOIjoxNTUxOTUxOTk4fQ.2jf3kl_uKWRkwjOP6uQRJFqMlwSABcgqqcJofFH5XCo” 弊端 1.JWT的退出是假的登录失效，只要之前的token没过期依然可以用2.安全性依赖密钥3.加密生成的数据长 优点 1.不依赖Cookie2.没有单点登录的cookie-sessionId模式好扩展3.服务器保持无状态性session和token的对比就是「用不用cookie」和「后端存不存」的对比","tags":["前端软件开发"]},{"title":"Cookie","path":"/2024/08/28/Cookie/","content":"Cookie 曾一度用于客户端数据的存储，因当时并没有其他合适的存储办法而作为唯一的存储手段，但现在推荐使用现代存储 API。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（localStorage 和 sessionStorage）或 IndexedDB 。 在 JavaScript 中，Cookie 可以通过 document.cookie 进行设置、获取和删除。以下是一些具体的例子，展示如何在 JavaScript 中操作 HTTP Cookie。 1. 设置 Cookie通过 document.cookie 设置一个 Cookie 的例子： 12345678910// 设置一个名为 &quot;username&quot; 的 Cookie，有效期为7天function setCookie(name, value, days) &#123; const date = new Date(); date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000)); // 计算到期时间 const expires = &quot;expires=&quot; + date.toUTCString(); document.cookie = `$&#123;name&#125;=$&#123;value&#125;; $&#123;expires&#125;; path=/;`;&#125;// 使用 setCookie 函数设置一个 CookiesetCookie(&quot;username&quot;, &quot;JohnDoe&quot;, 7); // Cookie 将在7天后过期 这里的 document.cookie 会将 username 设置为 JohnDoe，并将 Cookie 的有效期设为 7 天。 2. 获取 Cookie获取 Cookie 的值时，我们可以从 document.cookie 中找到特定的 Cookie 值： 123456789101112131415// 获取名为 &quot;username&quot; 的 Cookie 值function getCookie(name) &#123; const cookieArr = document.cookie.split(&quot;;&quot;); // 分割所有的 Cookie for (let i = 0; i &lt; cookieArr.length; i++) &#123; let cookie = cookieArr[i].trim(); if (cookie.indexOf(name + &quot;=&quot;) === 0) &#123; return cookie.substring(name.length + 1); // 返回 Cookie 值 &#125; &#125; return null; // 如果未找到，则返回 null&#125;// 使用 getCookie 函数获取 &quot;username&quot; 的值const username = getCookie(&quot;username&quot;);console.log(username); // 如果存在，则打印 &quot;JohnDoe&quot; 这里，我们首先通过 document.cookie.split(&quot;;&quot;) 分割所有 Cookie，然后检查是否存在指定名称的 Cookie。 3. 删除 Cookie删除 Cookie 可以通过将 Cookie 的有效期设为过去的时间来实现： 1234567// 删除名为 &quot;username&quot; 的 Cookiefunction deleteCookie(name) &#123; document.cookie = `$&#123;name&#125;=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;&#125;// 使用 deleteCookie 函数删除 &quot;username&quot; CookiedeleteCookie(&quot;username&quot;); 设置 expires 为一个过去的日期，浏览器会删除该 Cookie。 4. 综合示例：设置、获取和删除 Cookie一个简单的完整示例，用来设置、获取和删除 Cookie： 123456789// 设置 CookiesetCookie(&quot;username&quot;, &quot;JohnDoe&quot;, 7);// 获取 Cookieconsole.log(&quot;Username Cookie:&quot;, getCookie(&quot;username&quot;));// 删除 CookiedeleteCookie(&quot;username&quot;);console.log(&quot;Username after deletion:&quot;, getCookie(&quot;username&quot;)); // 输出 null 总结 设置 Cookie：通过 document.cookie 直接赋值并指定过期时间。 获取 Cookie：解析 document.cookie 中的字符串内容。 删除 Cookie：设置过期时间为过去的日期。"},{"title":"前端路由","path":"/2024/08/28/前端路由/","content":"把不同路由对应不同内容或页面的任务交给前端来做，之前通过服务端根据的不同返回不同的页面实现前端路由实质上就是检测URL的变动，截获URL地址，通过解析、匹配路由规定实现UI更新单页面应用中的路由分为hash和history模式 hash模式监听浏览器地址hash值变化，执行事件hash会在浏览器URL后增加#号一个完整的的URL包含：协定、域名、端口、虚拟目录、文件名、参数、锚比如https://www.google.com/#abc中的hash值为abc特点：hash的变化不会刷新页面，也不会发送给服务器但hash的变化会被浏览器记录下来，来指导浏览器中的前进和后退window.location.hash变化触发窗口onhashchange事件，监听hash变化触发路由时视图容器更新一多数前端框架哈希路由的实现原理触发hashchange的情况 URL变化（包括浏览器的前进、后退）修改window.location.hash 浏览器发送http://www.baidu.com/至服务器，请求完毕后设置散列值为#/home 只修改hash部分，不发请求 a标签可设置页面hash,浏览器自动设置hash 12345window.location.hash=&#x27;abc&#x27;;let &#123;hash&#125;=window.locationwindow.addEventListener(&#x27;hashchange&#x27;,function()&#123;//监听hash变化&#125;) 特点 兼容性好路径在#后面，不好看 history模式H5新特性，允许直接修改前端路由，更新URL但不重新发请求，history可自定义地址window.history属性指向History对象，表示当前窗口的浏览历史，保存了当前窗口访问过的所有页面网址由于安全原因，浏览器不允许脚本读取这些地址，但允许在地址间导航 1234//后退到前一个网址history.back()//等同于history.go(-1) 浏览器工具栏的“前进”和“后退”按钮，就是对History对象进行操作History对象主要有两个属性History.length:当前窗口访问过的网址数量（包括当前网页）History.state:History堆栈最上层的状态值（详见下文） 12345//当前窗口访问过多少个网页window.history.length//History对象的当前状态//通常是undefinedwindow.history.state history.back(history.forward()history.go()用于在历史之中移动 History.back()：移动到上一个网址，等于点击浏览器后退键。对于第一个访问的网址，该方法无效 History.forward()：移动到下一个网址，等于点击浏览器前进键。对于最后一个访问的网址，该方法无效果 History.go()：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，go(1)相当于forward(),go(-1)相当于back()。如果参数超过实际存在的网址范围，该方法无效；如果不指定参数，默认0,相当于刷新页面 history.pushState()在历史中添加一条记录，不会导致页面刷新 1window.history.pushState(state,title,url) state:对象，触发popstate事件将该对象传递到新页面。不需要可以填null tit1e:新页面标题。但现在所有浏览器都忽视这个参数，所以可以填空串 url：新网址，必须与当前页面在同域。地址栏将显示这个网址假定当前网址是example.com&#x2F;1.html,使用pushState()在浏览记录(History对象)中添加一个新记录 12var stateobj =foo:&#x27;bar&#x27;&#125;history.pushState(stateobj,&#x27;page 2&#x27;,&#x27;2.html&#x27;); 添加新记录后，浏览器地址栏显示example.com&#x2F;2.html,但不会跳转到2.html,也不会检查2.html是否存在，它只是成为浏览历史的最新记录。这时，在地址栏输入一个新的地址（如访问go0g1.com),然后点击倒退按钮，页面的URL将显示2.htmL;再点击一次倒退，URL将显示1.htmlpushState()不触发页面刷新，只导致History对象变化，地址栏有反应使用该方法后，可以用History.state读出状态对象 123var stateobj =foo:&#x27;bar&#x27;&#125;;history.pushstate(stateobj,&#x27;page 2&#x27;,&#x27;2.html&#x27;);history.state /&#123;foo:&quot;bar&quot;&#125; 如果oushState的URL参数设置了一个新的锚点值（即hash),不会触发hashchange事件。反过来，如果URL的锚点值变了，会在History对象创建一条浏览记录如果pushState()方法设置了一个跨域网址，报错 123/报错//当前网址为http://example.comhistory.pushState(null,&#x27;&#x27;,&#x27;https://twitter.com/hello&#x27;); pushStat想要插入一个跨域的网址，导致报错。防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转history.replaceState()修改History当前记录，其他与oushState()一模一样假定当前网页是example.com&#x2F;example.html 123456789101112history.pushstate(&#123;page:1&#125;,&#x27;title 1&#x27;,&#x27;?page=1&#x27;)//URL显示为http://example.com/example.html?page=1history.pushState(&#123;page:2&#125;,&#x27;title 2&#x27;,&#x27;?page=2&#x27;);//URL显示为http://example.com/example.html?page=2history.replaceState(&#123;page:3&#125;,&#x27;title 3&#x27;,&#x27;?page=3&#x27;);//URL显示为http://example.com/example.html?page=3history.back()//URL显示为http://example.com/example.html?page=1history.back()//URL显示为http://example.com/example.htmlhistory.go(2)//URL显示为http://example.com/example.html?page=3 popstate事件当同一个文档的浏览历史变化触发popstate注意“仅调用pushState()&#x2F;replaceState(),不会触发。只有点击浏览器倒退&#x2F;前进，或调用History.back()、History.forward()、History.go()才会触发·只针对同一个文档，如果浏览历史切换，导致加载不同文档，不会触发popstate指定回调函数 123456789window.onpopstate function (event)&#123;console.log(&#x27;location:&#x27;document.location);console.log(&#x27;state:&#x27;JSON.stringify(event.state));&#125;//或者window.addEventListener(&#x27;popstate&#x27;,function (event)&#123;console.log(location:&#x27;document.location);console.log(&#x27;state:&#x27;JSON.stringify(event.state));)； 回调函数参数event事件对象，它的state:指向当前状态对象，这个state.也可以通过history对象读取 1var currentstate=history.state; 页面第一次加载不会触发popstate事件特点路径正规兼容性不比hash,需服务端支持对于一个应用而言，url的改变（不包括hash值改变）只能由下面三种情况引起： 点击浏览器的前进或后退按钮&#x3D;&gt;可以监听popstate事件 点击a标签 JS触发history.pushState()、history.replaceState()","tags":["前端开发"]},{"title":"输入URL回车后","path":"/2024/08/28/输入URL回车后/","content":"简易版1.URL解析2.查找缓存3.域名解析：浏览器缓存&gt;系统缓存&gt;本地hosts&gt;根域名&gt;顶级域名&gt;二级域名&gt;三级域名4.TCP三次握手5.发送HTTP请求6.服务器处理请求并返回报文7.浏览器解析渲染页面8.TCP四次挥手关闭TCP连接","tags":["前端开发"]},{"title":"微前端","path":"/2024/08/28/微前端/","content":"一种类似于微服务的架构，它将微服务的理念应用于浏览器端，将Wb应用由单一的应用转变为多个小型前端应用聚合为一的应用各个前端应用可以使用不同技术栈、独立运行、独立开发、独立部署不是框架或工具，而是一套架构体系解决问题1.将庞大应用拆分，每个部分可以单独部署、维护，提升效率2.整合系统，在基本不修改原来系统逻辑的同时兼容新老老套系统并行运行技术方案思想就是拆解和整合应用，通常是一个父应用加上一些子应用·Nginx路由转发实现不同路径映射到不同应用，这不属于是前端层面的改造，更多是运维的配置简单、快速、易配置，切换应用时触发浏览器刷新会引用体验·iframe嵌套子应用嵌套iframe,父子通信可采用POSTMessage?或contentWindow实现实现简单、子应用间自带沙箱隔离互不影响、iframe样式显示有兼容性、太过简单显得lowWeb Components子应用采用纯Web Components技术编写，是全新的开发模式可单独部署，系统改造成本高，子应用通信复杂易踩坑·组合式应用路由分发子应用独立构建和部署，父应用管理路由、应用加载、启动、卸载和通信纯前端改造、体验好、可无感切换，需设计和开发父子应用于同一页面运行，需解决子应用样式冲突、变量对象污染、通信等技术点应用隔离分为主应用和微应用微应用间的S执行环境隔离、CSS隔离CSS隔离主微应用同屏渲染时，可能有样式会相互污染，需要彻底隔离CSS污染，可采用CSS module或命名空间的方式，保证不相互干扰，或者webpack的postcss:插件，打包时加上特定的前缀微应用间的CSS隔离，应用加载时，将应用所有的1ik和stylei进行标记，卸载应用时再同步卸载即可JS隔离使用沙箱机制，避免对全局window和全局事件的修改浏览器可结合with关键字或Proxy实现浏览器端沙箱保证局部S运行时，对对外部对象的访问和修改在可控范围内","tags":["前端开发"]},{"title":"CDN","path":"/2024/08/28/CDN/","content":"Content Delivery Network,内容分发网络我们访问一个页面的时候，会请求很多资源，包括各种图片、声音、影片、文字等信息。这和我们要购买多种货物一样网站可以预先把内容分发至全国各地的加速节点。用户可以就近获取内容，避免网络拥堵、地域、运营商等因素带来的访问延迟问题“内容分发网络”像前面提到的”全国仓配网络”，解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景用户可就近取得所需内容，解决Internet网络拥挤的状况CDN本质是一大堆遍布在全球各个角落的缓存服务器。通过与DNS的配合，找到最靠近用户的一台CDN缓存服务器，将数据快速分发给用户减少对整体骨干网的流量负担，提高用户体验DNS解析之后，浏览器向服务器请求内容后发生长途骨干网的传输最耗时，需经过网站服务器所在的机房、骨干网、用户所在城局域网、用户所在接入网等，物理传输距离遥远1亿人同时请求12306上一张一模一样的图片，对国家的互联网基础设施是一个灾难CDN提前把数据存在离用户最近的数据节点，避免长途跋涉经过长途骨干网，最终减少骨干网负担、提高访问速度请求图片数据，先去CDN缓存服务器获取，若获取到数据直接返回，否则才经过长途骨干网，最终达到网站服务器获取数据CDN其实还缩短了请求数据的距离用户分布全国各地，一般会在离用户在较近的地方设置CDN缓存服务器，酱紫各个地区的用户能直接请求对应的CDN服务器，不需要来回跑大半个中国！过程1.发起请求，本地DNS解析，将域名解析权交给域名CNAME指向的CDN专用DNS服务器2.CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回浏览器3.浏览器向CDN全局负载均衡设备发起URL请求4.CDN全局负载均衡设备根据用户IP，以及URL,选择一台用户所属区域的区域负载均衡设备，向其发请求5.区域负载均衡设备为用户选最合适的CDN缓存服务器（考虑的依据包括：服务器负载情况，距离用户的距离等)，返回给全局负载均衡设备6.全局负载均衡设备将选中的CDN缓存服务器IP返回给用户7.根据用户IP,判断最近边缘节点8.根据用户请求URL中内容，判断有用户所需内容的边缘节点9.查询边缘节点负载情况，判断有服务能力的边缘节点0.全局负载均衡设备将服务器IP返回给用户1.用户向CDN缓存服务器发起请求，缓存服务器响应用户请求，最终将内容返回组成(CDN)由多个节点组成。一般，CDN网络主要由中心节点、边缘节点两部分构成中心节点中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责整个CDN网络的分发及管理边缘节点CDN边缘节点主要指异地分发节点，有负载均衡设备、高速缓存服务器两部分负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点工作效率；同时负责收集节点与周围环境的信息，保持与全局负载均衡DNS的通信，实现整个系统的负载均衡高速缓存服务器(Cache)负责存储客户网站信息，像一个靠近用户的网站服务器一样响应本地用户的请求通过全局负载均衡DS的控制，用户的请求被透明指向离他最近的节点，节点中Cache服务器像网站的原始服务器一样，响应终端用户的请求中心节点像仓配网络中负责货物调配的总仓，边缘节点就是负责存储货物的各个城市的本地仓库","tags":["前端开发","性能优化","运维"]},{"title":"Ajax、Fetch和Axios","path":"/2024/08/28/Ajax、Fetch和Axios/","content":"AjaxAjax(Asynchronous JavaScript and XML,异步JavaScript.与XML技术)，使网页实现异步更新，不重新加载网页的情况下，对网页部分进行更新不是一种新技术，而是2005年被提出的新术语由XMLHttpRequestp的API实现请求步骤 123456789101112//创建XMLHttpRequest对象const ajax new XMLHttpRequest();//规定请求的类型、URL以及是否异步处理请求，通过MLHttpRequest对象的open()方法与服务端建立连接ajax.open(&#x27;GET&#x27;,url,true);//发送信息至服务器时内容编码类型ajax.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//发送请求ajax.send(null);//监听服务端的通信状态，接受服务器响应数据ajax.onreadystatechange function ()if (ajax.readyState ==4 &amp;(ajax.status =200 ajax.status =304))&#123;&#125;&#125; 特点：·局部刷新页面，无需重载整个页面·基于原生XHR开发，而XHR本身架构不清晰·对基于异步的事件不友好Fetchfetch是底层API,代替XIHR,是真实存在的，基于promise实现不是Ajax的封装，而是原生JS,没有使用XMLHttpRequest对象特点： 使用promise,.支持async&#x2F;await 提供的API丰富 脱离XHR 不携带cookie,需要手动添加配置项 AxiosAxios是一个基于promise封装的HTTP客户端，可以用在浏览器和node.js中它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范特点： 从浏览器中创建XMLHttpRequests 从node.js创建http请求 支持Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF 1234567891011axios(&#123; url:&#x27;xxx&#x27;,//设置请求的地址 method: &quot;GET&quot;,//设置请求方法 params:&#123;//get请求使用params进行参数凭借，如果是post请求用data type:&#x27;&#x27;, page:1 &#125;&#125;).then(res =&gt; //res为后端返回的数据 console.log(res);&#125;) 设置接口请求前缀利用ode环境变量判断，区分开发、测试、生产环境 1234if (process.env.NODE_ENV ===&#x27;development&#x27;)&#123;axios.defaults.baseURL = &#x27;http://dev.xxx.com&#x27;else if (process.env.NODE_ENV ===&#x27;production&#x27;)&#123;axios.defaults.baseURL = &#x27;http://prod.xxx.com&#x27; 本地调试时，在config.js中配置proxy实现代理转发设置请求头和超时时间 123456789101112const service axios.create(&#123;timeout:30000,//请求30s超时headers:get:&#x27;Content-Type&#x27;:application/x-www-form-urlencoded;charset=utf-8&#x27;/在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来&#125;,post:&#x27;Content-Type&#x27;:&#x27;application/json;charset=utf-8&#x27;//在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来&#125;,&#125;) 封装请求方法 1234567891011121314//get请求export function httpGet(&#123;url,params =&#123;&#125;)&#123;return new Promise((resolve,reject)=&gt;&#123;axios.get(url,params&#125;).then((res)=&gt;&#123;resolve(res.data)&#125;).catch(err =&gt;reject(err)&#125;)&#125;) 请求拦截器在每个请求里加上token,统一处理维护方便响应拦截器在接收到响应后先做一层判断，比如状态码判断登录状态、授权 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 扩充后的影视、动漫角色名称列表 const characterKeywords = [&#x27;Spider-Man&#x27;, &#x27;Batman&#x27;, &#x27;Superman&#x27;, &#x27;Naruto&#x27;, &#x27;Goku&#x27;, &#x27;Iron Man&#x27;, &#x27;Captain America&#x27;, &#x27;Thor&#x27;, &#x27;Wonder Woman&#x27;, &#x27;Black Widow&#x27;, &#x27;Hulk&#x27;, &#x27;Loki&#x27;, &#x27;Sasuke&#x27;, &#x27;Itachi&#x27;, &#x27;Gon Freecss&#x27;, &#x27;Killua Zoldyck&#x27;, &#x27;Ichigo Kurosaki&#x27;, &#x27;Rukia Kuchiki&#x27;, &#x27;Light Yagami&#x27;, &#x27;L&#x27;, &#x27;Eren Yeager&#x27;, &#x27;Mikasa Ackerman&#x27;, &#x27;Armin Arlert&#x27;, &#x27;Sailor Moon&#x27;, &#x27;Tuxedo Mask&#x27;, &#x27;Vegeta&#x27;, &#x27;Piccolo&#x27;, &#x27;Gohan&#x27;, &#x27;Trunks&#x27;, &#x27;Frieza&#x27;, &#x27;Cell&#x27;, &#x27;Majin Buu&#x27;, &#x27;Alucard&#x27;, &#x27;Inuyasha&#x27;, &#x27;Kagome Higurashi&#x27;, &#x27;Sango&#x27;, &#x27;Miroku&#x27;, &#x27;Edward Elric&#x27;, &#x27;Alphonse Elric&#x27;, &#x27;Winry Rockbell&#x27;, &#x27;Natsu Dragneel&#x27;, &#x27;Lucy Heartfilia&#x27;, &#x27;Gray Fullbuster&#x27;, &#x27;Erza Scarlet&#x27;, &#x27;Luffy&#x27;, &#x27;Zoro&#x27;, &#x27;Nami&#x27;, &#x27;Usopp&#x27;, &#x27;Sanji&#x27;, &#x27;Chopper&#x27;, &#x27;Robin&#x27;, &#x27;Franky&#x27;, &#x27;Brook&#x27;, &#x27;Asta&#x27;, &#x27;Yuno&#x27;, &#x27;Noelle Silva&#x27;, &#x27;Deku&#x27;, &#x27;Bakugo&#x27;, &#x27;Todoroki&#x27;]; let usernames = []; let iterationCount = 0; const maxIterations = 20; const minValidUsers = 10; async function iterateAndValidate() &#123; if (iterationCount &gt;= maxIterations || usernames.length &gt;= minValidUsers) &#123; return; &#125; let username = &#x27;&#x27;; const randomKeyword = characterKeywords[Math.floor(Math.random() * characterKeywords.length)]; username = `$&#123;randomKeyword&#125;`; try &#123; const response = await axios.get(`https://api.github.com/users/$&#123;username&#125;`); usernames.push(username); &#125; catch (error) &#123; // 忽略不存在的用户 &#125; iterationCount++; return iterateAndValidate(); &#125; iterateAndValidate().then(() =&gt; &#123; const userInfoPromises = usernames.map(username =&gt; axios.get(`https://api.github.com/users/$&#123;username&#125;`)); return Promise.all(userInfoPromises); &#125;).then(responses =&gt; &#123; // 对多个用户信息进行分析 const totalFollowers = responses.reduce((acc, response) =&gt; acc + response.data.followers, 0); const averageFollowers = totalFollowers / responses.length; console.log(`平均粉丝数：$&#123;averageFollowers&#125;`); const popularUsers = responses.filter(response =&gt; response.data.followers &gt; averageFollowers); console.log(&#x27;粉丝数高于平均的用户：&#x27;); popularUsers.forEach(user =&gt; console.log(user.data.login)); const userInfoDiv = document.createElement(&#x27;div&#x27;); userInfoDiv.innerHTML = `&lt;p&gt;平均粉丝数：$&#123;averageFollowers&#125;&lt;/p&gt;&lt;p&gt;粉丝数高于平均的用户：$&#123;popularUsers.map(user =&gt; user.data.login).join(&#x27;, &#x27;)&#125;&lt;/p&gt;`; document.body.appendChild(userInfoDiv); &#125;).catch(error =&gt; &#123; console.error(&#x27;发生错误：&#x27;, error); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":["编程语言","JavaScript"]},{"title":"addEventListener和onClick()","path":"/2024/08/28/addEventListener和onClick/","content":"addEventListener是为元素绑定事件的方法，接收三个参数： 第一个参数：绑定的事件名 第二个参数：执行的函数 第三个参数： false:默认，代表冒泡时绑定 true:代表捕获时绑定onclick和addEventListener事件区别是：onclick事件会被覆盖，而addEventListener可以先后运行不会被覆盖，addEventListener可以监听多个事件"},{"title":"JSON.stringify()","path":"/2024/08/28/JSON-stringify/","content":"转换过程中会忽略值为undefined的字段需要检测一下，若某个字段为undefined,则将其值修改为空字符串1、若目标对象存在toJSON()方法，它负责定义哪些数据被序列化 123456789let obj = &#123; x:1, y:2, toJSON:function() &#123; return &#x27;a string create by toJSON&#x27;; &#125;&#125;console.log(JSON.stringify(obj));//&#x27;a string create by toJSON&#x27; 2、Boolean、Number、String对象被装换为对应原始值 1234567const obj = &#123; a:new Number(11), b:new String(&#x27;aaa&#x27;), c:new Boolean(true)&#125;console.log(JSON.stringify(obj));//&#123;&quot;a&quot;:11,&quot;b&quot;:&quot;aaa&quot;,&quot;c&quot;:true&#125; 3、undefined、Function和Symbol不是有效的JSON值，要么被忽略（在对象中找着）,要么被更改为null(在数组中找着) 12345678910const obj = &#123; name:Symbol(&#x27;aaa&#x27;), age:undefined, isHigh:function()&#123;&#125;&#125;console.log(JSON.stringify(obj));//&#123;&#125;const arr = [Symbol(&#x27;aaa&#x27;),undefined,function()&#123;&#125;,&#x27;fighting&#x27;]console.log(JSON.stringify(arr));//[null,null,null,&quot;fighting&quot;] 4、所有Symbol-keyed属性被忽略 123456const obj = &#123;&#125;obj[Symbol(&#x27;a&#x27;)]=&#x27;aa&#x27;;obj[Symbol(&#x27;b&#x27;)]=&#x27;bb&#x27;;console.log(obj);console.log(JSON.stringify(obj));//&#123;Symbol(a):&#x27;aa&#x27;,Symbol(b):&#x27;bb&#x27;&#125; 5、Date的实例返回一个字符串实现toJSON0方法（和date.toISOString0一一使用ISO标准返回Date对象的字符串格式相同) 12console.log(JSON.stringify(new Date()));//&quot;2024-09-06T10:34:46.203Z&quot; 6、Infinity、NaN和nul都被认为是null 12345678const obj = &#123; a:Infinity, b:NaN, c:null, val:20&#125;;console.log(JSON.stringify(obj));//&#123;&quot;a&quot;null,&quot;b&quot;null,&quot;c&quot;:null,&quot;val&quot;:20&#125; 7、所有其他Object实例（包括Map、Weakmap、Set和WeakSet))序列化为其可枚举的属性 123456789101112131415let enumobj =&#123;&#125;//直接在一个对象上定义新的属性或修改现有属性，并返回该对象Object.defineProperties(enumobj, &#123; &#x27;name&#x27;: &#123; value:&#x27;a&#x27;, enumerable:true &#125;, &#x27;age&#x27;: &#123; value:99, enumerable:false &#125;,&#125;);console.log(JSON.stringify(enumobj))//&#123;&quot;name&quot;:&quot;a&quot;&#125; 8、遇到循环抛出TypeError(循环对象值)异常 123456const obj = &#123; a:&#x27;aa&#x27;&#125;obj.subObj = obj;console.log(JSON.stringify(obj));//VM357:5 Uncaught TypeError:Converting circular structure to JSON 9、对BigInt值字符串化时抛出TypeError(BigInt值无法在钉SON中序列化) 12345const obj = &#123; a:BigInt(999999999999999999999)&#125;;console.log(JSON.stringify(obj));//VM362:4 Uncaught TypeError:Do not know how to serialize a BigInt"},{"title":"parselnt&parseFloat","path":"/2024/08/28/parselnt-parseFloat/","content":"parseInt(): 将字符串转换为整数。 语法: parseInt(string, radix) string: 要被解析的字符串 radix: 可选,表示数字的基数(进制),范围2-36,默认为10 从字符串的开头解析,直到遇到非数字字符。 如果字符串的第一个字符不能被转换为数字,返回NaN。 示例: 12345parseInt(&quot;10&quot;); // 返回 10parseInt(&quot;10.5&quot;); // 返回 10parseInt(&quot;10 20 30&quot;); // 返回 10parseInt(&quot;10&quot;, 2); // 返回 2 (二进制解析)parseInt(&quot;0xA&quot;); // 返回 10 (十六进制解析) parseFloat(): 将字符串转换为浮点数。 语法: parseFloat(string) 从字符串开头解析,直到遇到非数字字符(除了第一个小数点)。 只解析十进制数,不接受基数参数。 如果字符串的第一个字符不能被转换为数字,返回NaN。 示例: 12345parseFloat(&quot;10&quot;); // 返回 10parseFloat(&quot;10.5&quot;); // 返回 10.5parseFloat(&quot;10.5.6&quot;); // 返回 10.5parseFloat(&quot;10 20 30&quot;); // 返回 10parseFloat(&quot;3.14e-2&quot;); // 返回 0.0314 主要区别: parseInt主要用于整数,parseFloat可以处理小数。 parseInt可以指定进制,parseFloat只处理十进制。 parseFloat能识别科学记数法(如3.14e-2)。","tags":["前端软件开发"]},{"title":"dom.onclick和dom.addEventListener的区别","path":"/2024/08/28/dom-onclick和dom-addEventListener-的区别/","content":"在一个大型网页应用中，**addEventListener通常更合适**，这是因为它提供了更灵活、更可控的事件管理功能，而这些特性在大型应用中尤其重要。以下是一些关键原因： 1. 多事件处理器支持 在大型应用中，通常需要为同一个元素绑定多个不同的事件处理器（例如，为按钮添加基础功能的点击事件，同时添加动画效果事件等）。 onclick属性只能绑定一个事件处理器，后续绑定会覆盖之前的处理器，这在复杂场景中是一个限制。 addEventListener允许绑定多个事件处理器，这样你可以为同一事件类型添加多个功能模块，增强代码的灵活性和可维护性。 2. 动态事件绑定与解绑 在大型应用中，通常会有模块化需求，比如当某些组件卸载时，需要移除绑定的事件以释放内存和资源。 addEventListener支持通过removeEventListener来解绑事件处理器，确保应用性能优化和资源管理。 onclick虽然可以设置为null来移除事件，但这对大型应用的动态性支持不足，且在代码可读性上较差。 3. 事件捕获与冒泡的控制 addEventListener的第三个参数可以控制事件的捕获或冒泡阶段的触发，这在处理复杂的事件流时非常重要，尤其是在具有嵌套结构的UI中（如复杂的表单、多层嵌套的菜单）。 onclick不支持这种控制，仅在冒泡阶段触发。因此在事件流控制上更显局限，可能导致不必要的事件触发或逻辑混乱。 4. 代码组织和模块化 在大型应用中，代码的模块化和可维护性至关重要。addEventListener常与事件委托结合使用，在父元素上绑定事件处理器，从而管理子元素的事件。 onclick不适合这种模式，因为它通常直接绑定在具体的元素上，不利于事件委托的实现。 5. 浏览器兼容性 addEventListener在现代浏览器中完全兼容，只是在早期的IE版本（IE8及以下）中缺乏支持，需使用attachEvent作为替代。但如今，主流应用开发通常不再考虑这些老旧版本的兼容性。 onclick虽然兼容性广泛，但考虑到现代浏览器的普及和需求的多样性，addEventListener的功能优势更适合现代的开发需求。 总结建议在大型网页应用中，通常建议选择addEventListener，因为它的灵活性、可维护性和性能优势更适合复杂的项目需求。onclick可以用于简单的静态页面或少量的事件需求中，但在大型应用中，addEventListener的适用性更强且可维护性更高。"},{"title":"JavaScript中日期时间格式转换","path":"/2024/08/28/JavaScript中日期时间格式转换/","content":"获取当天时间： 123456789101112131415//获取当前时间var date = new Date();var year = date.getFullYear();var month = date.getMonth()+1;var day = date.getDate();//这两个是针对小于十的时候，会为个位数if (month &lt; 10)&#123; month =&quot;0&quot;+month;&#125;if (day 10)&#123; day =&quot;0&quot;+day;&#125;var nowDate = year &quot;&quot;month +&quot;-&quot;day;//往往格式成这种样式是后台处理好的，或者我们会使用一些插件，又或者我们在vu中会使用过滤器来处理。//输出结果格式：2021-11-08 一、基本的函数：·getDate(0返回一个月中的某一天(1-31)·getMonth(O返回月份(0-1I)·getFullYear(0以四位数字返回年价(20I1)·getHours(0返回小时(0-23)·getMinutes(0返回分钟(0-59)·getSeconds(0返回秒数(0-59)·get Time(0返回1970年1月1日至今的毫秒数(1566715528024)二、获取时间澄的方法let timestamp &#x3D;(new Date()).valueof();&#x2F;&#x2F;或者let timestamp&#x3D;new Date().getTime();三、练习圈问题：返回“现在距离今年元旦还有X天X小时X分钟X秒”function timemove(){&#x2F;获取当前时问let d1 new Date();&#x2F;获取下一年let nextYear d1.getFullYear()+1;&#x2F;&#x2F;定义目标时间let d2 new Date(nextYear +”&#x2F;1&#x2F;1 00:00:00”);&#x2F;&#x2F;定义剩余时间1etd&#x3D;d2-d1;&#x2F;是-个时间戳&#x2F;&#x2F;计算剥余天数let Day parseInt(d 1000 &#x2F;60 60 24);&#x2F;计算剩余小时let Hours parseInt(d 1000 60 60%24);&#x2F;&#x2F;计算剩余分钟let Minutes parseInt(d 1008 &#x2F;60%60);&#x2F;&#x2F;计算剩余秒let Seconds parseInt(d 1000%60);&#x2F;拼接变量let time&#x3D;Day+”天”+Hours+”小时”+Minutes+”分钟”+Seconds+”秒”；&#x2F;将拼接好的变量显示在页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;日期格式转换器&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css&quot; integrity=&quot;sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;style&gt; body &#123; background-color: #f8f9fa; &#125; .container &#123; max-width: 600px; margin-top: 50px; &#125; .form-group &#123; margin-bottom: 1rem; &#125; .alert &#123; transition: all 0.3s ease-in-out; opacity: 0; &#125; .alert.show &#123; animation: fadeIn 0.5s forwards; &#125; .spinner-border &#123; display: none; &#125; .clock &#123; text-align: center; margin-bottom: 20px; position: relative; &#125; .clock canvas &#123; display: block; margin: 0 auto; &#125; @keyframes fadeIn &#123; from &#123; opacity: 0; transform: translateY(-20px); &#125; to &#123; opacity: 1; transform: translateY(0); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;text-center mb-4&quot;&gt;日期格式转换器&lt;/h1&gt; &lt;p class=&quot;lead text-center&quot;&gt;输入一个日期，选择输出格式，然后点击按钮查看结果。&lt;/p&gt; &lt;div class=&quot;clock&quot; id=&quot;clockContainer&quot;&gt; &lt;canvas id=&quot;clockCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;form id=&quot;dateForm&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputDate&quot;&gt;选择日期:&lt;/label&gt; &lt;input type=&quot;date&quot; class=&quot;form-control&quot; id=&quot;inputDate&quot; value=&quot;2024-09-22&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;formatSelect&quot;&gt;选择格式:&lt;/label&gt; &lt;select class=&quot;custom-select&quot; id=&quot;formatSelect&quot;&gt; &lt;option value=&quot;iso&quot;&gt;ISO格式 (YYYY-MM-DD)&lt;/option&gt; &lt;option value=&quot;us&quot;&gt;美国格式 (MM/DD/YYYY)&lt;/option&gt; &lt;option value=&quot;eu&quot;&gt;欧洲格式 (DD/MM/YYYY)&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-block mr-2&quot; onclick=&quot;convertDate()&quot;&gt;转换日期&lt;/button&gt; &lt;div class=&quot;spinner-border spinner-border-sm text-primary&quot; role=&quot;status&quot; id=&quot;spinner&quot; style=&quot;display:none;&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Loading...&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;div class=&quot;alert alert-secondary mt-4&quot; role=&quot;alert&quot; id=&quot;result&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; const canvas = document.getElementById(&#x27;clockCanvas&#x27;); const ctx = canvas.getContext(&#x27;2d&#x27;); let currentTimestamp = null; function initializeClock() &#123; currentTimestamp = Date.now(); drawClock(); &#125; function drawClock() &#123; ctx.clearRect(0, 0, canvas.width, canvas.height); // 获取当前时间 const now = new Date(currentTimestamp); const hours = now.getHours(); const minutes = now.getMinutes(); const seconds = now.getSeconds(); // 画圆盘 ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, 80, 0, Math.PI * 2); ctx.strokeStyle = &#x27;#333&#x27;; ctx.lineWidth = 5; ctx.stroke(); // 绘制时标 for (let i = 0; i &lt; 12; i++) &#123; const angle = (Math.PI / 6) * i - Math.PI / 2; const x = 100 * Math.cos(angle) + canvas.width / 2; const y = 100 * Math.sin(angle) + canvas.height / 2; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + 10 * Math.cos(angle), y + 10 * Math.sin(angle)); ctx.strokeStyle = &#x27;#000&#x27;; ctx.lineWidth = 3; ctx.stroke(); &#125; // 绘制秒针 const secondAngle = ((seconds % 60) / 60) * 2 * Math.PI - Math.PI / 2; drawHand(secondAngle, 70, &#x27;red&#x27;, 2); // 绘制分针 const minuteAngle = ((minutes + seconds / 60) / 60) * 2 * Math.PI - Math.PI / 2; drawHand(minuteAngle, 60, &#x27;blue&#x27;, 3); // 绘制时针 const hourAngle = ((hours % 12 + minutes / 60) / 12) * 2 * Math.PI - Math.PI / 2; drawHand(hourAngle, 50, &#x27;black&#x27;, 4); requestAnimationFrame(drawClock); &#125; function drawHand(angle, length, color, lineWidth) &#123; ctx.beginPath(); ctx.lineWidth = lineWidth; ctx.strokeStyle = color; ctx.moveTo(canvas.width / 2, canvas.height / 2); ctx.lineTo( Math.cos(angle) * length + canvas.width / 2, Math.sin(angle) * length + canvas.height / 2 ); ctx.stroke(); &#125; window.onload = () =&gt; &#123; initializeClock(); setInterval(() =&gt; &#123; currentTimestamp += 1000; // 增加1秒 &#125;, 1000); &#125;; function formatDate(date, formatType) &#123; const pad = n =&gt; (&#x27;0&#x27; + n).slice(-2); switch (formatType) &#123; case &#x27;iso&#x27;: return `$&#123;date.getFullYear()&#125;-$&#123;pad(date.getMonth() + 1)&#125;-$&#123;pad(date.getDate())&#125;`; case &#x27;us&#x27;: return `$&#123;pad(date.getMonth() + 1)&#125;/$&#123;pad(date.getDate())&#125;/$&#123;date.getFullYear()&#125;`; case &#x27;eu&#x27;: return `$&#123;pad(date.getDate())&#125;/$&#123;pad(date.getMonth() + 1)&#125;/$&#123;date.getFullYear()&#125;`; default: return &#x27;&#x27;; &#125; &#125; function convertDate() &#123; const inputDate = document.getElementById(&#x27;inputDate&#x27;).value; const formatSelect = document.getElementById(&#x27;formatSelect&#x27;).value; const resultDiv = document.getElementById(&#x27;result&#x27;); const spinner = document.getElementById(&#x27;spinner&#x27;); const date = new Date(inputDate); if (isNaN(date.getTime())) &#123; spinner.style.display = &#x27;none&#x27;; resultDiv.className = &#x27;alert alert-danger show&#x27;; resultDiv.textContent = &#x27;请输入有效的日期！&#x27;; &#125; else &#123; spinner.style.display = &#x27;inline-block&#x27;; setTimeout(() =&gt; &#123; const formattedDate = formatDate(date, formatSelect); spinner.style.display = &#x27;none&#x27;; resultDiv.className = &#x27;alert alert-success show&#x27;; resultDiv.textContent = `转换后的日期是：$&#123;formattedDate&#125;`; &#125;, 500); // 模拟异步请求的时间延迟 &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"简单了解null和undefined","path":"/2024/08/28/简单了解null和undefined/","content":"句简单来说是：undefined代表了不存在的值，null代表了没有值。也就是，比如对一个值声明后，没有赋值，输出他就是undefined,是不存在的，而当赋值为null,那么输出就是null。这两者还有一些区别点要注意： 123456789//1undefined == null//true,这里相等是因为“==”对他们做了转换undefined === null //false//undefined的值是nulL派生来的，所以他们表面上是相等的//2let a;typeof a;//undefinedlet b=null;typeof b;//object 这里为什么typeof b输出为Object呢？null不是一个对象，尽管ypeof age输出的是Object,逻辑上讲，null值表示一个空对象指针，这是一个历史遗留问题，JS的最初版本中使用的是32位系统，为了性能考虑使用低位存储变量的类型信息，000开头代表是对象，null表示为全零，所以将它错误的判断为Object。 12if(!undefined) console.log(&quot;undefined is false&quot;);// undefined is falseif(!null) console.log(&quot;null is false&quot;);// null is false 12345678//对于nu11let nullValue = null;let nullToNumber = Number(nullValue);console.log(nullToNumber);//输出：0//对于undefinedlet undefinedValue;let undefinedToNumber = Number(undefinedValue);console.log(undefinedToNumber);//输出：NaN null可以被转为数字0. undefined不可以转为数字 12Object.getPrototypeof(Object.prototype);// null 项目实践中的区别null表示”没有对象”，即该处不应该有值。典型用法是：(1)作为函数的参数，表示该函数的参数不是对象。(2)作为对象原型链的终点。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：(1)变量被声明了，但没有赋值时，就等于undefined。(2)调用函数时，应该提供的参数没有提供，该参数等于undefined。(3)对象没有赋值的属性，该属性的值为undefined。.(4)函数没有返回值时，默认返回undefined。","tags":["编程语言","JavaScript"]},{"title":"闭包和内存泄漏","path":"/2024/08/28/闭包和内存泄漏/","content":"闭包有权访问另外一个函数作用域中变量的函数。闭包是指那些能够访问自由变量的函数.自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。闭包&#x3D;函数+函数能够访问的自由变量。每一个函数都会拷贝上级作用域，形成一个作用域链条。闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方。闭包的变量存在堆中，即解释了函数调用之后为什么闭包还能引用到函数内的变量。闭包的形成需要两个条件： 闭包是在函数被调用执行的时候才被确认创建的。 闭包的形成，与作用域链的访问顺序有直接关系。 只有内部函数访问了上层作用域链中的变量对象时，才会形成闭包，因此，我们可以利用闭包来访问函数内部的变量。 闭包，本质上是上级作用域内变量的生命周期，因为被下级作用域引用，没有得到释放，需要等到下级作用域执行完后才得到释放。 作用 独立作用域，避免变量污染 实现缓存计算结果 库的封装jQuery 运用防抖节流防抖：事件触发高频到最后一次操作，如果规定时间内再次触发，则重新计时。 1234567891011function debounce(fn,delay=300)&#123; let timer;//闭包引用外界变量 return function () &#123; consr args=arguments; if (timer)&#123; clearTimeout(timer); &#125; timer = setTimeout(()= &#123; fn.apply(this,args); &#125;, delay);&#125;; 模拟块级作用域12345678function OutPutNum(cnt)&#123; (function () &#123; for (let i=0;i&lt;cnt;i++)&#123; alert(i); &#125; &#125;)(); alert(i);&#125; 对象中创建私有变量 内存泄露12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;JavaScript 示例&lt;/title&gt; &lt;style&gt; body &#123; font-family: Arial, sans-serif; text-align: center; margin: 20px; &#125; #button &#123; padding: 10px 20px; font-size: 16px; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;JavaScript 事件监听示例&lt;/h1&gt; &lt;button id=&quot;button&quot;&gt;点击我&lt;/button&gt; &lt;script&gt; function fun() &#123; var element = document.getElementById(&quot;button&quot;); var someResource = new Array(1000).join(&quot;*&quot;); // 模拟一个超大资源 element.addEventListener(&quot;click&quot;, () =&gt; &#123; console.log(someResource); &#125;); &#125; fun(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 解决方法：不再使用监听事件时通过removeEventListener移除监听","tags":["编程语言","JavaScript"]},{"title":"内存管理GC","path":"/2024/08/28/内存管理GC/","content":"栈中JS引擎自动清除栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收，而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。JS引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。自动垃圾回收机制：找出不使用的值，释放内存。函数运行结束，没有闭包或引用，局部变量被标记清除全局变量：浏览器卸载页面被清除垃圾回收算法不论哪个垃圾回收算法，都有一套共同的流程：1.标记内存空间中的活动对象（在使用中的对象）和非活动对象（可以回收的对象）。2.删除非活动对象，释放内存空间。3.整理内存空间，避免频繁回收后产生的大量内存碎片（不连续内存空间）。引用计数一个对象是否有被引用（循环引用导致内存泄露）策略：跟踪每个变量被使用的次数1.当声明了一个变量且将一个引用类型赋值给该变量时，这个值的引用次数为12.若同一个值又被赋给另一个值，引用数+13.如果该变量的值被其他的值覆盖了，则引用次数减14.当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为0的值占用的内存缺点：·需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。·解决不了循环引用导致的无法回收问题。标记清除将“不再使用的对象”定义为“无法到达的对象”工作流程：1.垃圾收集器在运行时给内存变量加上标记，假设内存汇总所有对象都是垃圾，全标记为02.从根部出发，寻找可到达的变量，并将其标记清除，改为13.留有标记的变量就是待删除的，即标记为0，销毁并回收它们占用的内存4.把所有内存中对象标记修改为0，等待下一轮垃圾回收优点：实现简单，一位二进制位就可以为其标记缺点：内存碎片化，空闲内存块不连续·分配速度慢，因为即使使用first-fit策略，其操作仍是一个O(n)的操作，最坏情况是每次都要遍历到最后，因为碎片化，大对象的分配速率会更慢复制算法为了解决上述问题，复制算法出现了。1.将整个空间平均分成from和to两部分。2.先在from空间进行内存分配，当空间被占满时，标记活动对象，并将其复制到to空间。3.复制完成后，将from和to空间互换。由于直接将活动对象复制到另一半空间，没有了清除阶段的开销，所以能在较短时间内完成回收操作，并且每次复制的时候，对象都会集中到一起，相当于同时做了整理操作，避免了内存碎片的产生。优点：吞吐量高、没有碎片缺点：首先，复制操作需要时间成本的，若堆空间很大且活动对象很多，则每次清理时间会很久；其次，将空间二等分的操作，让可用的内存空间直接减少了一半。标记整理也叫做标记压缩算法。结合了标记-清除和复制算法的优点。1.从一个GC root集合出发，标记所有活动对象。2.将所有活动对象移到内存的一端，集中到一起。3.直接清理掉边界以外的内存，释放连续空间。该算法既避免了标记-清除法产生内存碎片的问题，又避免了复制算法导致可用内存空间减少的问题。当然，该算法也不是没有缺点的，由于其清除和整理的操作很麻烦，甚至需要对整个堆做多次搜索，故而堆越大，耗时越多。识别内存泄露经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存的占用情况。在Chrome浏览器中，我们可以这样查看内存占用情况1.打开开发者工具，选择Performance面板2.在J顶部勾选Memory3.点击左上角的record按钮4在页面上进行各种操作，模拟用户的使用情况5.一段时间后，点击对话框的stop按钮，面板上就会显示这段时间的内存占用情况造成内存泄露1.意外的全局变量2.被遗忘的定时器和回调函数3.事件监听没有移除4.没有清理的DOM引用5.子元素存在的内存泄漏 V8对GC优化 ·栈中数据回收：执行状态指针ESP在执行栈中移动，移过某执行上下文，就会被销毁；·堆中数据回收：V8引擎采用标记清除算法；·V8把堆分为两个区域一新生代和老生代，分别使用副、主垃圾回收器；·副垃圾回收器负责新生代垃圾回收，小对象(1~8M)会被分配到该区域处理；·新生代采用scavenge算法处理：将新生代空间分为两半，一半空闲，一半存对象，对对象区域做标记，存活对象复制排列到空闲区域，没有内存碎片，完成后，清理对象区域，角色反转；·新生代区域两次垃圾回收还存活的对象晋升至老生代区域；·主垃圾回收器负责老生区垃圾回收，大对象，存活时间长；·新生代区域采用标记-清除算法回收垃圾：从根元素开始，递归，可到达的元素活动元素，否则是垃圾数据；n为了不造成卡顿，标记过程被切分为一个个子标记，交替进行。分代式垃圾回收以上所说的垃圾清理算法每次垃圾回收时都要检查内存中所有的对象，酱紫对一些大，老，存活时间长的对象来说，同新，小，存活时间短的对象一个频率的检查很不好，因为前者需要时间长且不需要频繁进行清理，后者恰恰相反，如何优化？分代式分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率新老生代V8的GC策略基于分代式垃圾回收机制，将堆内存分为新生代和老生代两区域，采用不同的垃圾回收策略进行垃圾回收新生代的对象是存活时间较短的对象，简单来说就是新产生的对象，通常只支持1-8M的容量，而老生代的对象为存活时间较长或常驻内存的对象， 新生代垃圾回收新生代中对象一般存活时间较短，采用scavenge算法处理，在Scavenge算法具体实现中，主要采用一种复制式的方法及Cheney.算法：其将新生代空间对半分为from-space和to-space两个区域。新创建的对象都被存放到from-space,当空间快被写满时触发垃圾回收。先对from-space中的对象进行标记，完成后将标记对象复制到to-space的一端，然后将两个区域角色反转，就完成了回收操作。由于每次执行清理操作都需要复制对象，而复制对象需要时间成本，所以新生代空间会设置得比较小(1~8M)。当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了25%，那么这个对象会被直接晋升到老生代空间中，设置为25%的比例的原因是，当完成Scavenge回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配 老生代垃圾回收老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。什么情况下对象会出现在老生代空间中：。新生代中的对象是否已经经历过一次Scavenge算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。·To空间的对象占比大小超过25%。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象清除阶段老生代垃圾回收器会直接将非活动对象清理掉前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而V8中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间在老生代中，以下情况会先启动标记清除算法：·某一个空间没有分块的时候·空间中被对象超过一定限制·空间不能保证新生代中的对象移动到老生代中由于S是单线程运行的，意味着垃圾回收算法和脚本任务在同一线程内运行，在执行垃圾回收时，后续脚本任务需要等垃圾回收完成后才能继续执行。若堆中的数据量非常大，一次完整垃圾回收的时间会非常长，导致应用的性能和响应能力直线下降。为了避免垃圾回收影响应用的性能，V8将标记的过程拆分成多个子标记，让垃圾回收标记和应用逻辑交替执行，避免脚本任务等待较长时间。","tags":["前端开发"]},{"title":"哪些事件支持冒泡","path":"/2024/08/28/哪些事件支持冒泡/","content":"可以通过event.bubbles属性判断该事件是否可以冒泡： 事件 是否冒泡 click 可以 dbclick 可以 keydown 可以 keyup 可以 mousedown 可以 mousemove 可以 mouseout 可以 mouseover 可以 mouseup 可以 scroll 可以 概括来说，鼠标事件，键盘事件，以及点击事件是支持冒泡的。 以下事件不支持冒泡： 事件 是否冒泡 blur 不可以 focus 不可以 resize 不可以 about 不可以 mouseenter 不可以 mouseleave 不可以 load 不可以 unload 不可以 而聚焦和失焦事件，加载事件，ui事件、鼠标移入移出事件是不支持冒泡的。","tags":["前端开发"]},{"title":"模块化","path":"/2024/08/28/模块化/","content":"特点1.解决命名污染，全局污染，变量冲突等2.内聚私有，变量不能被外部访问3.更好的分离，按需加载4.引入其他模块可能存在循环引用问题5.代码抽象，封装，复用和管理6.避免通过script标签从上至下加载资源7.大型项目资源难以维护，特别是多人合作的情况 CommonJS服务端解决方案。加载速度快（因为模块文件一般存在本地硬盘）每个文件是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 运行时加载，只能在运行时才能确定一些东西 同步加载，只有加载完成后，才能执行后续操作。因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。 导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。 模块在首次执行后会缓存，再次加载只返回缓存结果，若想再次执行，可清除缓存。 模块加载的顺序就是代码出现的顺序 基本语法 暴露模块：module.exports&#x3D;value或exports.xxx&#x3D;value 引入模块：require(xx),如果是第三方模块，x为模块名；如果是自定义模块，xx为模块文件路径 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports&#x2F;属性（即module.exports)是对外的接口。加载某个模块，其实是加载该模块的module..exports&#x2F;属性。 1234567891011//加载模块var example=require(&#x27;./example.js&#x27;);var config=require(config.js&#x27;);var http=require(&#x27;http&#x27;);//对外暴露模块module.exports.example = function ()&#125;module.exports = function(x)console.log(x)&#125;exports.xxx=value; require命令用于加载模块文件。require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。因为nodejs主要用于服务器编程，模块文件一般已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以使用CommonJS规范。如果是浏览器环境，要从服务器端加载模块，用CommonJS需要等模块下载完并运行后才能使用，将阻塞后面代码的执行，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范，解决异步加载的问题。AMD会编译成require&#x2F;exports来执行浏览器一般使用AMD规范，解决异步加载问题。RequireJS是一个工具库。主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载，从而提高代码的性能和可维护性。它的模块管理遵守AMD规范。Require.js的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。基本语法定义暴露模块： 12345678//定义没有依赖的模块define(function()&#123; return 模块&#125;)//定义有依赖的模块define([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123;return 模块) 引入使用模块： 12345require([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; 使用m1/m2&#125; 采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数；也可以根据需要动态加载模块 AMD模块定义的方法非常清晰，不会污染全局环境，可清楚地显示依赖关系 CMDCMD规范专门用于浏览器端，异步加载模块，实用模块时才会加载执行。整个了CommonJS和AMD规范的特点。Sea.js中，所有JS模块都遵循CMD模块定义规范。 基本语法 定义暴露模块： 123456789101112131415//定义没有依赖的模块define(function(require,exports,module)&#123; exports.xxx value module.exports value&#125;)//定义有依赖的模块define(function(require,exports,module)&#123;//引入依赖模块（同步）var module2 require(&#x27;./module2&#x27;)//引入依赖模块（异步）require.async(&#x27;./module3&#x27;,function (m3)&#123;&#125;)//暴露模块exports.xxx value&#125; 引入使用模块： 123456define(function (require)&#123;var m1=require(&#x27;./module1&#x27;)var m4=require(&#x27;./module4&#x27;)m1.show()m4.show()&#125;) ES6使用import和export的形式来导入导出模块。这种方案和上面三种方案都不同。思想是尽量静态化，为了保证在编译时就能确定模块的依敕关系和输入输出的变量。异步导入，因为用于浏览器，需要下载文件，如果采用同步导入会对渲染有很大影响采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化会编译成require&#x2F;exports来执行·使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块。一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。在编译阶段，import会提升到整个模块的头部，首光执行。如果不需要知道变量名或函数就完成加载，就要用到export defaulti命令，为模块指定默认输出。·export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，importi命令后面才不用加大括号，因为只可能唯一对应export default命令。基本语法export1.如果不想对外暴露内部变量的真实名称，可以使用s关键字设置别名，同一个属性可以设置多个别名。在外部进行引入时，可以通过name2这个变量访问到king值。 12const name=&#x27;king&#x27;;export &#123;name as name2&#125;; 2.在同一个文件中，同一个变量名只能够xport一次，否则会抛出异常。 1234const name=&#x27;king&#x27;;const _name=&#x27;king&#x27;;export &#123;name as _name&#125;;export&#123;name&#125;;/抛出异常，name作为对外输出的变量，只能export一次 import1.import和export的变量名相同2.相同变量名的值只能import-一次3.import命令具有提升的效果 12345//export.jsexport const name=&#x27;king&#x27;;//import.jsconsole.log(name);//kingimport &#123;name&#125;from &#x27;./export.js&#x27; 本质：因为import是在编译期间运行的，在执行console语句之前就已经执行了importi语句。因此能够打印出name的值，即，King4.多次import时，只会加载一次以下代码汇总，我们import了两次export.js文件，但是最终只输出执行了一次“开始执行”，可以推断出import导入的模块是个单例模式。 1234567//export.jsconsole.log(&#x27;start&#x27;);export const name=&#x27;king&#x27;;export const age=19;//import.jsimport &#123;name&#125;from &#x27;./export.jsimport &#123;age&#125;from &#x27;./export.js&#x27;&#x27; 5.允许我们在需要的时候才动态加载模块，而不是一开始就加载所有模块，这样可以帮我们提高性能。这个新功能允许我们将import()作为函数调用，将其作为参数传递给模块的路径。它返回一个promise,它用一个模块对象来实现，可以访问该对象的导出。 1234import(&#x27;/modules/myModule.mjs&#x27;)then((module)=&gt;/Do something with the module.&#125;)； 对比总结ES6输出值的引用（对外接口只是一种静态定义，代码解读阶段生成），CommonJS模块输出值的拷贝（加载一个对象，及module.exports.属性，该对象只有在脚本运行时才会生成)ES6模块时动态引用，且不会缓存值，模块中的变量绑定其所在的模块ES6模块编译时输出接口，CommonJS模块运行时加载1.CommonJS规范主要用于服务端编程，同步加载模块，不适合浏览器环境，因为同步意味阻塞，而浏览器资源时异步加载的，因此诞生了AMD和CMD2.AMD规范在浏览器环境中异步加载模块，且可以并行加载多个模块。但是开发成本高，代码阅读困难，模块定义语义不顺畅3.CMD和AMD相似，依赖就近，延迟执行，易在nod©js运行。但是，依赖SPM打包，模块加载逻辑偏重4.ES6实现模块功能且实现简单，完全可以取代CommonJS和AMD规范，进而成为浏览器和服务器通用模块解决方案的笼儿。","tags":["编程语言","JavaScript"]},{"title":"事件流","path":"/2024/08/28/事件流/","content":"事件流描述从页面接收事件的顺序事件发生时会在元素节点和根节点之间按照特定的顺序传播，路径所经过的节点都会收到该事件一DOM事件流。两种事件流模型：1捕获：触发元素的事件时，该事件从该元素的祖先元素传递下去（不太具体的节点应该更早接收到事件，而最具体的节点最后收到事件)2.冒泡：到达此元素之后，又会向其祖先元素传播上去DOM标准规定事件流包括3个阶段：事件捕获、处于目标阶段和事件冒泡 事件捕获：实现目标在捕获阶段不会接收事件 处于目标阶：事件在上发生并处理。但是事件处理会被看成是冒泡阶段的一部分 冒泡阶段：事件又传播回文档 所有事件都要经过捕获阶段和处于目标阶段，但有些事件没有冒泡阶段。如focus(获得输入焦点)和失去输入焦点的blur事件。无法进行委托事件模型原始事件模型var btn &#x3D; document.getElementByld(.btn’);btn.onclick &#x3D; fun; 绑定速度快可能页面还未完全加载出来，事件可能无法正常运行 只支持冒泡，不支持捕获 同一个类型的事件只能绑定一次 var btn &#x3D; document.getElementById(.btn’);btn.onclick &#x3D; fun2;&#x2F;&#x2F;出错后绑定的事件会覆盖掉之前的事件删除DOM0级事件处理程序只要将对应事件属性置为ul即可btn.onclick &#x3D; null; 标准事件模型·事件捕获：从document-一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行·事件处理：到达目标元素，触发目标元素的监听函数·事件冒泡：从目标元素冒泡到document,依次检查经过的节点是否绑定了事件监听函数，如果有则执行事件绑定监听函数的方式如下：addEventListener(eventType,handler,useCapture)事件移除监听函数的方式如下：removeEventListener(eventType,handler,useCapture)·eventType:指定事件类型（不要加on)·handler是事件处理函数·useCapture是boolean类型用于指定是否在捕获阶段进行处理，一般设置为false.与IE浏览器保持一致举个例子：var btn &#x3D; document.getElementByld(.btn’);btn.addEventListener(‘click’,showMessage,false);btn.removeEventListener(‘click’,showMessage,false);特性可以在一个DOM元素上绑定多个事件处理器，不会冲突btn.addEventListener(‘click’,showMessagel,false);btn.addEventListener(‘click’,showMessage2,false);btn.addEventListener(‘click’,showMessage3,false);第三个参数(useCapture)设置为true就在捕获过程中执行，反之在冒泡过程中执行E事件模型·事件处理：事件到达目标元素，触发目标元素的监听函数。·事件冒泡：事件从目标元素冒泡到document·事件绑定监听函数的方式attachEvent(eventType,handler)·事件移除监听函数的方式detachEvent(eventType,handler)举个例子：var btn &#x3D; document.getElementByld(.btn’);btn.attachEvent(‘onclick’,showMessage);btn.detachEvent(‘onclick’,show Message);","tags":["前端开发"]},{"title":"改变this指向的方法","path":"/2024/08/28/改变this指向的方法/","content":"(bind&#x2F;call&#x2F;apply)三者都是用来重新定义this这个对象的一、三者的区别：1、调用上 123456789101112131415let name =&quot;www&quot;,age =&quot;17&quot;;let obj = &#123; name:&quot;aaa&quot;; objAge:this.age; myFun:function ()&#123; console.log(this.name+&quot;年龄&quot;+this.age)\t&#125;&#125;let db = &#123; name:&quot;bbb&quot;; age:12&#125;obj.myFun.call(db)//bbb年龄99obj.myFun.apply(db);//bbb年龄99obj.myFun.bind(db)();//bbb年龄99 首先我们可以看出，除了bind需要在方法后面添加”)”以外，其他的都是直接调用。这是因为bind()方法创建了一个新的函数，你必须调用显函数才会执行目标函数，而对于call和apply是使用后马上执行。1、参数上 12345678910111213141516let name =&quot;www&quot;,age =&quot;17&quot;;let obj = &#123; name &quot;aaa&quot;, objAge this.age, myFun:function(fm,t)&#123; console.log(this.name+&quot;年龄&quot;+this.age,&quot;来自&quot;+fm+&quot;去往&quot;+t) &#125;&#125;let db=&#123; name:&quot;bbb&quot;, age:12&#125;obj.myFun.call(db,&#x27;成都&#x27;，&#x27;上海&#x27;);//bbb年龄99来自成都去往上海obj.myFun.apply(db,[&#x27;成都&#x27;，&#x27;上海&#x27;]);//bbb年龄99来自成都去往上海obj.myFun.bind(db,&#x27;成都&#x27;，&#x27;上海&#x27;)();//bbb年龄99来自成都去往上海obj.myFun.bind(db,[&#x27;成都&#x27;，&#x27;上海&#x27;])();//bbb年龄99来自成都，上海去往undefined 可以看出，三个函数的第一个参数都是hs的指向对象，区别在于第二个参数。 对于Function.prototype.calL来说，第一个参数就是this的指向对象，其余参数是直接放进去，用逗号隔开就好了。 对于Function.prototype.apply来说，Function.apply(obj,args)方法能接收两个参数，obj:是this的指向对象。而args:这个是数组，它将作为参数传递，也就是说apply的所有参数都必须放在一个数组里面传进去 对于Function.prototype.bind来说，第一个参数就是this的指向对象，其余参数是直接放进去，用逗号隔开就好了。也就是说他和cl1是基本相同的，除了是返回是一个函数。 注意对于bind来说，多次的bind调用，this的指向仍然是第一次的function aa(){console.log(this)aa.bind(1).bind(2)()&#x2F;&#x2F;1 一、bind &#x2F; call &#x2F; apply的异同相同：都能改变this的指向，都是挂载在Function.prototype上不同：call和apply是使用后马上执行，而bind是返回一个新的函数，调用显函数才会执行目标函数。并且call和bind的参数格式是一样的，第一个参数是this的指向对象，其余参数用逗号，apply是参数需要放到数组中。 总结 关于修改this的指向的方法有三个，bind和call以及apply,他们的相同点都是能修改this的指向的问题的，并且都是挂载在Function.prototype上的。 不同点在于参数和执行上，call和bind的参数格式是一样的，第一个参数是this的指向对象，其余参数用逗号，而apply的参数需要放到数组中。在执行中，call和apply是使用后马上执行，而bind是返回一个新的函数，调用显函数才会执行目标函数。 其中需要注意的是，箭头函数的his是指向他所在的上下文中，并且是不能使用这三个方法修改的。","tags":["编程语言","JavaScript"]},{"title":"继承方式","path":"/2024/08/28/继承方式/","content":"构造函数会在每一个实例上都创建一遍！使用原型模式定义的属性和方法由所有实例共享！原型链 12345678910function Parent()&#123; this.name = &#x27;kevin&#x27;;&#125;Parent.prototype.getName=function() &#123; console.log(this.name);&#125;function Child() &#123;&#125;Child.prototype = new Parent(); //表明继承关系，还没有创建child1对象var child1 = new Child();// 创建child1对象console.log(child1.getName())//kevin 缺点1.引用类型的属性被所有实例共享2.创建Child实例时，不能向Parent传参借用构造函数（经典继承） 1234567891011function Parent()&#123; this.names=[&#x27;kevin&#x27;,&#x27;daisy&#x27;];&#125;function Child()&#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push(&#x27;yayu&#x27;);console.log(child1.names);//[&quot;kevin&quot;,&quot;daisy&quot;,&quot;yayu&quot;]var child2 = new Child();console.log(child2.names);//[&quot;kevin&quot;,&quot;daisy&quot;] 1.避免了引用类型的属性被所有实例共享2.可以在Child中向Parent传参缺点方法都在构造函数中定义，每次创建实例都会创建一遍方法组合继承原型链继承+经典继承双创合璧 12345678910111213141516171819202122function Parent(name)&#123; this.name=name; this.colors=[&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;]; Parent.prototype.getName = function () &#123; console.log(this.name) &#125;&#125;function Child(name,age)&#123; Parent.call(this,name); this.age=age;&#125;Child.prototype = new Parent();//表明继承关系Child.prototype.constructor = Child;//修正了构造函数的指向。var child1 = new Child(&#x27;kevin&#x27;,&#x27;18&#x27;);child1.colors.push(&#x27;black&#x27;);console.log(child1.name);//kevinconsole.log(child1.age);//18console.log(child1.colors);//[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;]var child2 = new Child(&#x27;daisy&#x27;,&#x27;20&#x27;);console.log(child2.name);//daisyconsole.log(child2.age);//20console.log(child2.colors);//[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] 融合原型链继承和构造函数的优点，JS最常用继承模式原型式继承 12345function createobj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 一个使用这种方法实现继承的例子 123456789101112131415161718192021// 定义一个父类对象let parentObj = &#123; name: &#x27;Parent&#x27;, sayHello: function () &#123; console.log(`Hello from $&#123;this.name&#125;`); &#125;&#125;;// 使用 createobj 函数实现继承function createobj(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;// 创建一个继承自 parentObj 的子类对象let childObj = createobj(parentObj);childObj.name = &#x27;Child&#x27;;// 调用继承自父类的方法childObj.sayHello(); ES5 Object.create的模拟实现，将传入对象作为创建的对象的原型包含引用类型的属性值都会共享相应的值一—和原型链继承一样 123456789101112131415function createobj(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name:&#x27;kevin&#x27;, friends:[&#x27;daisy&#x27;,&#x27;kelly&#x27;]&#125;var person1 = createobj(person);var person2 = createobj(person);person1.name = &#x27;person1&#x27;;console.log(person2.name);//kevinperson1.friends.push(&#x27;taylor&#x27;);console.log(person2.friends);//[&quot;daisy&quot;,&quot;kelly&quot;,&quot;taylor&quot;] 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式做增强对象，再返回对象 123456function createobj(o)&#123; var clone = Object.create(o); clone.sayName = function () console.log(&#x27;hi&#x27;); return clone;&#125; 缺点和借用构造函数一样，每次创建对象都会创建一遍方法寄生组合式继承组合继承最大缺点一调用2次父构造方法1.设置子实例的原型时2.创建子类型的实例时如何避免重复调用？如果我f们不使用Child.prototy pe&#x3D;new Parent(),而是间接让Child.prototype访问Parent..prototypel呢？ 123456789101112131415161718192021222324252627function Parent(name)&#123; this.name=name; this.colors=[&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;]; Parent.prototype.getName function () console.log(this.name)&#125;function Child(name,age)&#123;Parent.call(this,name);this.age age;//关键的三步var F = function (&#123;&#125;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child(&#x27;kevin&#x27;,&#x27;18&#x27;);console.log(child1);封装一下这个继承方法function object(o)function F()&#123;&#125;F.prototype o;return new F();function prototype(child,parent)&#123; var prototype = object(parent.prototype);//创建父类原型对象的副本 prototype.constructor = child;//增强对象，补充因重写原型而失去的默认的constructor/属性 child.prototype = prototype;//将创建的新副本指定给子类的原型对象&#125;//当我们使用的时候：prototype(Child,Parent); 优点一引用类型最理想的继承方式只调用一次Parent构造函数，避免了在Parent.prototype.上面创建不必要的、多余的属性同时，原型链能保持不变，能正常使用instanceof和isPrototypeOf ————————————-分割线———————————– 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 定义构造函数*（普通函数加个this）function Animal(name) &#123; this.name = name;&#125;// 定义构造函数的原型方法, 在构造函数的prototype上注册了speak方法Animal.prototype.speak = function() &#123; console.log(this.name + &#x27; makes a noise.&#x27;);&#125;;// 定义另一个构造函数function Dog(name) &#123; Animal.call(this, name); // 继承 Animal 的属性&#125;// Dog 继承 Animal 的方法，先声明prototype, 再指定prototype.constructorDog.prototype = Object.create(Animal.prototype);Dog.prototype.constructor = Dog;Dog.prototype.speak = function() &#123; console.log(this.name + &#x27; barks.&#x27;);&#125;;// 创建实例const myDog = new Dog(&#x27;Rex&#x27;);// 使用 instanceof 检查console.log(myDog instanceof Dog); // trueconsole.log(myDog instanceof Animal); // trueconsole.log(myDog instanceof Object); // true// 逐步调试：自定义 instanceof 实现, 用Object.getPrototypeOf循环遍历left的prototype, 查看是否和right的prototype相等function myInstanceof(left, right) &#123; console.log(`Checking if $&#123;left&#125; is an instance of $&#123;right.name&#125;`); // 如果左边是 null 或 undefined，直接返回 false if (left === null || typeof right !== &#x27;function&#x27;) &#123; return false; &#125; // 获取左边对象的原型 let proto = Object.getPrototypeOf(left); const prototype = right.prototype; // 沿着原型链查找 while (proto !== null) &#123; if (proto === prototype) &#123; return true; &#125; proto = Object.getPrototypeOf(proto); &#125; return false;&#125;// 调试 myInstanceof 函数console.log(myInstanceof(myDog, Dog)); // trueconsole.log(myInstanceof(myDog, Animal)); // trueconsole.log(myInstanceof(myDog, Object)); // trueconsole.log(myInstanceof(myDog, Array)); // false 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个构造函数 Personfunction Person(name, age) &#123; this.name = name; this.age = age;&#125;// 向构造函数的 prototype 添加一个方法Person.prototype.sayHello = function() &#123; console.log(&#x27;Hello, my name is &#x27; + this.name);&#125;;// 创建一个实例对象var person1 = new Person(&#x27;Alice&#x27;, 25);var person2 = new Person(&#x27;Bob&#x27;, 30);// 查看实例对象的属性和原型链console.log(&#x27;person1 的 name:&#x27;, person1.name); // 输出: Aliceconsole.log(&#x27;person1 的 age:&#x27;, person1.age); // 输出: 25// 调用 prototype 上的方法person1.sayHello(); // 输出: Hello, my name is Aliceperson2.sayHello(); // 输出: Hello, my name is Bob// 查看实例的 __proto__，它指向构造函数的 prototype, new 的对象具有__proto__属性，instance.__proto__和class的prototype相等console.log(&#x27;person1.__proto__ === Person.prototype:&#x27;, person1.__proto__ === Person.prototype); // true// 查看构造函数的 prototypeconsole.log(&#x27;Person.prototype:&#x27;, Person.prototype); // 输出: &#123; sayHello: f &#125;// 查看实例 person1 的 __proto__console.log(&#x27;person1.__proto__:&#x27;, person1.__proto__); // 输出: &#123; sayHello: f &#125;// 验证 person1 是否是 Person 的实例console.log(&#x27;person1 instanceof Person:&#x27;, person1 instanceof Person); // 输出: true// 查看 Object.prototype，所有对象最终的原型console.log(&#x27;Person.prototype.__proto__ === Object.prototype:&#x27;, Person.prototype.__proto__ === Object.prototype); // true// 创建一个普通的对象，不通过构造函数var obj = &#123; greeting: &#x27;Hi&#x27; &#125;;console.log(&#x27;obj.__proto__ === Object.prototype:&#x27;, obj.__proto__ === Object.prototype); // trueconsole.log(&#x27;obj 是 Object 的实例:&#x27;, obj instanceof Object); // true","tags":["编程语言","JavaScript"]},{"title":"构造函数","path":"/2024/08/28/构造函数/","content":"构造函数在JavaScript中，通过new来实例化对象的函数叫构造函数（函数没有通过new实例化对象，这个函数就是普通函数），也就是初始化一个实例对象，对象的prototype属性是继承一个实例对象。构造函数的命名一般会首字母大写 为什么需要使用构造函数？是为了创建对象JavaScript中创建对象有两种，一种是构建函数+prototype,另一种是用class。.这里我们不去讲解class,先放到构造函数上。 12345//当我们需要创建比较多信息时var person1=&#123;name:&#x27;aa&#x27;,age:6,gender:&#x27;男&#x27;，classRoom:&#x27;高-&#x27;&#125;：var person2=&#123;name:&#x27;bb&#x27;,age:6,gender:&#x27;女&#x27;，classRoom:&#x27;高-&#x27;&#125;；var person3=&#123;name:&#x27;cc&#x27;,age:6,gender:&#x27;女&#x27;，classRoom:&#x27;高-&#x27;&#125;；var person4=&#123;name:&#x27;dd&#x27;,age:6,gender:&#x27;男&#x27;，classRoom:&#x27;高-&#x27;&#125;； 那么如果需要创建很多呢？需要这样一个一个的写下去吗？但是实际上可以通过下面的形式来实现 1234567891011function Person(name,age,gender,classRoom)&#123; this.name name; this.ageage; this.gender gender; this.classRoom=&#x27;高一&#x27;&#125;Person.prototype.sayHi function () console.log(&quot;你好，我叫&quot;+this.name+&quot;是一个&quot;+this.sex+&quot;来自&quot;+classRoom);&#125;;let person1=new Person(&quot;a&quot;,l8,&#x27;男&#x27;)；//我们还可以不传classRoom,让他使用默认的let person2=new Person(&quot;b&quot;,l9,&#x27;女&#x27;)； 构造函数的执行过程构造函数的执行过程其实也就是new操作符的基本过程 创建一个新的对象，并且在内存中创建一个新的地址。&#x2F;&#x2F;let person1&#x3D;0: 继承原型&#x2F;&#x2F;person1.proto&#x3D;Person.prototype 改变构造函数的this指向，并且新对象添加构造函数的属性和方法&#x2F;执行Person函数，将name,age,sex参数传入Person中执行，此时函数内部this为new创建的person1对象，所以person1.name&#x3D;’a’;person1.age&#x3D;l8;person1.gender&#x3D;-‘男’； 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理new操作符通过构造函数创建的实例，可以访问构造函数的属性和方法，同时实例与构造函数通过原型链连接起来了。 构造函数的返回值构造函数中，不要显示返回任何值 1234567891011121314151617//返回原始值function Person(name)&#123; this.namename; return&#x27;啦啦啦啦&#x27;&#125;let person1 = new Person(&quot;a&quot;);console.log(person1.name)//a//返回对象function Person(name)&#123; this.name name; return &#123; aaa:&quot;asdas&quot; &#125;&#125;let person1 = new Person(&quot;a&quot;);console.log(person1)//faaa &quot;asdas&quot;&#125;console.log(person1.name)//&#x27;undefined&#x27; 可以看到当返回原始值的时候，并不会正常返回这个原始值“啦啦啦啦”，而当返回直是对象的时候，这个返回值能被正常返回，但是这时候new就不生效了。所以，构造函数尽量不要返回值。因为返回原始值不会生效，返回对象会导致new操作符没有作用。 那么为什么会这样呢? 构造函数没有返回值的原因是因为它不是由你的代码直接调用的，它是由运行时的内存分配和对象初始化代码调用的。它的返回值（如果它在编译为机器代码时实际上有一个）对用户来说是不透明的一因此，你不能指定它。其实在JavaScript中， let a&#x3D;0也就是let a&#x3D;new Array[]; function a(){}也就是let a&#x3D;new Function(){}","tags":["编程语言","JavaScript"]},{"title":"箭头函数和普通函数的区别","path":"/2024/08/28/箭头函数和普通函数的区别/","content":"箭头函数的this为定义时所在的this,不绑定this(因为箭头函数没有Constructor),会捕获其所在上下文的this作为自己的this 若包裹在函数中，就是函数调用时所在的对象，放在全局就是window,箭头函数的this就是外层代码块的this,固定不变。 没有自己的this 继承来的this不会变 没有arguments,实际获得的arguments是外层函数的arguments call apply和bind无法改变this指向 不可用于构造函数，没有new关键字 无prototype 不能用于generator函数，没有yield关键字 定义对象的大括号不是一个单独的执行环境，它依旧处于全局环境中","tags":["前端软件开发"]},{"title":"函数","path":"/2024/08/28/函数/","content":"函数声明使用function的函数声明比函数表达式优先提升变量对象的创建过程中，函数声明比变量声明有更为优先的执行顺序无论在什么位置声明了函数，都可以在同一个执行上下文中直接使用 函数表达式也叫匿名函数函数表达式使用var&#x2F;let&#x2F;const声明，我们在确认他是否可以正确使用时，必须依照var&#x2F;let&#x2F;const的规则判断，即变量声明使用var进行变量声明，进行了两步操作 函数声明和函数表达式主要有以下区别： 一、语法形式 函数声明： 使用 function 关键字，后跟函数名，再加上括号和花括号包裹的函数体。 例如：123function add(a, b) &#123; return a + b;&#125; 函数表达式： 将一个匿名函数赋值给一个变量。 例如：123const subtract = function(a, b) &#123; return a - b;&#125;; 二、提升（Hoisting）特性 函数声明会在代码执行前被提升到其所在作用域的顶部，这意味着可以在函数声明之前调用该函数。而函数表达式只有在其所在的语句被执行到的时候才会被创建，不能在其定义之前被调用。 例如： 12345console.log(add(2, 3)); // 输出 5，函数声明可以在声明之前调用console.log(subtract(5, 2)); // 报错，因为函数表达式在定义之前不能调用const subtract = function(a, b) &#123; return a - b;&#125;; 三、命名方式 函数声明必须有一个名称，而函数表达式可以是匿名的（没有名称），也可以是具名的（有名称），但这个名称只在函数内部可见。 例如： 12345678function multiply(a, b) &#123; return a * b;&#125;const divide = function namedDivide(a, b) &#123; return a / b;&#125;;console.log(multiply(4, 2)); // 输出 8console.log(divide(8, 2)); // 输出 4，在函数内部可以使用 namedDivide 这个名称进行递归等操作，但在外部只能通过 divide 来调用 12345//变量声明var a = 20;//实际执行顺序var a = undefined;//变量声明，初始值undefined,变量提升，提升l顺序次于function声明a = 20;//变量赋值，该操作不会提升 同样道理，当我们使用变量声明的方式声明函数时一函数表达式。函数表达的提升方式与变量声明一致 1234567891011fn();//报错var fn=function ()&#123; console.log(&#x27;function&#x27;);&#125;//上述例子执行顺序为var fn=undefined;//变量声明提升fn();//执行报错fn = function () &#123; //赋值操作，此时将后边函数的引用赋值给f console.log(&#x27;function&#x27;)&#125; 因此，由于声明方式的不同，导致函数声明与函数表达式在使用上的一些差异需要注意，除此之外，这两种形式的函致在使用上并无不同 匿名函数没有被显示进行赋值操作的函数。使用场景一多作为一个参数传入另一个函数中函数自执行，其实是匿名函数的一种应用 在 JavaScript 中，匿名函数是没有名称的函数表达式。以下是定义和使用匿名函数的方法： 一、定义匿名函数 作为变量的值123const myFunction = function() &#123; console.log(&#x27;这是一个匿名函数作为变量的值。&#x27;);&#125;; 作为立即执行函数表达式（IIFE）123(function() &#123; console.log(&#x27;这是一个立即执行的匿名函数。&#x27;);&#125;)(); 二、使用匿名函数 作为回调函数12345678function doSomething(callback) &#123; console.log(&#x27;正在执行一些操作...&#x27;); callback();&#125;doSomething(function() &#123; console.log(&#x27;这是作为回调函数的匿名函数。&#x27;);&#125;); 在数组方法中使用1234const numbers = [1, 2, 3, 4, 5];numbers.forEach(function(number) &#123; console.log(number);&#125;); 回调函数匿名函数传入另一个函数之后，最终在另一个函数中执行，因此我们也常常称这个匿名函数为回调函数 高阶函数一个函数接收另一个函数作为参数或返回另一个函数1.map2.reduce参数：两个参数，一个为回调函数，另一个初始值。回调函数中四个默认参数，依次为积累值、当前值、当前索引和整个数组1.filter返回新数组2.sort 以下是使用这些高阶函数的 JavaScript 示例： 1234567891011121314151617const numbers = [1, 2, 3, 4, 5];// 使用 mapconst mappedNumbers = numbers.map((num) =&gt; num * 2);console.log(mappedNumbers); // [2, 4, 6, 8, 10]// 使用 reduceconst sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);console.log(sum); // 15// 使用 filterconst filteredNumbers = numbers.filter((num) =&gt; num % 2 === 0);console.log(filteredNumbers); // [2, 4]// 使用 sortconst sortedNumbers = numbers.sort((a, b) =&gt; a - b);console.log(sortedNumbers); // [1, 2, 3, 4, 5] 在这个例子中，首先定义了一个数组numbers。然后分别使用map对数组中的每个元素进行乘以 2 的操作，使用reduce计算数组元素的总和，使用filter筛选出偶数元素，使用sort对数组进行升序排序。 普通函数若是’use strict’,不能将全局对象window作为默认绑定。this&#x3D;undefined普通函数：定义时this指向函数作用域，但定时器之后执行函数时，this指向window普通函数的this一调用时所在的对象函数声明、函数表达式1.函数声明式：function functionName()}2.函数表达式：let name&#x3D;function()0 以下是关于普通函数以及严格模式下相关行为的 JavaScript 代码示例： 1234567891011121314151617181920212223242526272829303132333435// 非严格模式下的函数声明function declaredFunction() &#123; console.log(this);&#125;declaredFunction();// 非严格模式下的函数表达式let expressionFunction = function() &#123; console.log(this);&#125;;expressionFunction();// 定时器中的非严格模式函数setTimeout(function() &#123; console.log(this);&#125;, 1000);// 严格模式下的函数声明(function strictDeclaredFunction() &#123; &#x27;use strict&#x27;; console.log(this);&#125;)();// 严格模式下的函数表达式let strictExpressionFunction = function() &#123; &#x27;use strict&#x27;; console.log(this);&#125;;strictExpressionFunction();// 定时器中的严格模式函数setTimeout(function() &#123; &#x27;use strict&#x27;; console.log(this);&#125;, 2000); 在这个例子中，可以观察到非严格模式下普通函数在不同场景下的 this 指向，以及严格模式对 this 指向的影响。","tags":["编程语言","JavaScript"]},{"title":"ES6新增的数组方法","path":"/2024/08/28/ES6新增的数组方法/","content":"好的，接下来我会详细讲解 ES6 新增的 数组方法。这些方法大大增强了JavaScript中数组的处理能力，使得操作数组更加简洁高效。我们将重点介绍一些常用的、典型的ES6数组方法。 1. forEach()forEach() 方法用于对数组中的每个元素执行一次指定的函数。与传统的 for 循环相比，它更简洁，且不需要手动管理索引。 语法：123array.forEach(function(element, index, array) &#123; // 执行操作&#125;); element：当前元素的值 index：当前元素的索引 array：原数组 示例：1234let arr = [1, 2, 3];arr.forEach((value, index) =&gt; &#123; console.log(`Index: $&#123;index&#125;, Value: $&#123;value&#125;`);&#125;); 输出： 123Index: 0, Value: 1Index: 1, Value: 2Index: 2, Value: 3 2. map()map() 方法创建一个新数组，数组中的每个元素是通过调用提供的函数对原数组元素进行处理后的结果。 语法：123let newArray = array.map(function(element, index, array) &#123; // 返回新的元素&#125;); 返回值是一个新数组，不会修改原数组。 示例：123let arr = [1, 2, 3];let doubled = arr.map(x =&gt; x * 2);console.log(doubled); // [2, 4, 6] 3. filter()filter() 方法创建一个新数组，包含所有通过测试的元素，测试由提供的函数定义。 语法：123let newArray = array.filter(function(element, index, array) &#123; return true_or_false; // 测试条件&#125;); 只有符合条件的元素会被添加到新数组中。 示例：123let arr = [1, 2, 3, 4, 5];let evenNumbers = arr.filter(x =&gt; x % 2 === 0);console.log(evenNumbers); // [2, 4] 4. reduce()reduce() 方法对数组中的每个元素执行一个 reducer 函数（从左到右），并将其结果汇总为一个单一的值。它非常适合用来做累计、求和、拼接等操作。 语法：123let result = array.reduce(function(accumulator, currentValue, index, array) &#123; return accumulator + currentValue; // 返回累计值&#125;, initialValue); accumulator：累计值 currentValue：当前值 initialValue（可选）：初始值 示例：123let arr = [1, 2, 3, 4];let sum = arr.reduce((total, num) =&gt; total + num, 0);console.log(sum); // 10 5. some()some() 方法测试数组中是否至少有一个元素满足提供的函数条件。如果有一个元素符合条件，返回 true，否则返回 false。 语法：123let hasEven = array.some(function(element) &#123; return element % 2 === 0; // 检查是否有偶数&#125;); 示例：123let arr = [1, 3, 5, 7];let hasEven = arr.some(x =&gt; x % 2 === 0);console.log(hasEven); // false 6. every()every() 方法测试数组中是否所有元素都满足提供的函数条件。如果所有元素都符合，返回 true，否则返回 false。 语法：123let allEven = array.every(function(element) &#123; return element % 2 === 0; // 检查所有元素是否都是偶数&#125;); 示例：123let arr = [2, 4, 6];let allEven = arr.every(x =&gt; x % 2 === 0);console.log(allEven); // true 7. find()find() 方法返回数组中第一个满足提供的函数条件的元素。如果没有找到符合条件的元素，返回 undefined。 语法：123let foundElement = array.find(function(element) &#123; return element === value; // 查找元素&#125;); 示例：123let arr = [5, 12, 8, 130, 44];let found = arr.find(x =&gt; x &gt; 10);console.log(found); // 12 8. findIndex()findIndex() 方法返回数组中第一个满足条件的元素的索引。如果没有找到符合条件的元素，返回 -1。 语法：123let index = array.findIndex(function(element) &#123; return element === value; // 查找元素的索引&#125;); 示例：123let arr = [5, 12, 8, 130, 44];let index = arr.findIndex(x =&gt; x &gt; 10);console.log(index); // 1 9. includes()includes() 方法检查数组中是否包含指定的元素。如果包含，返回 true，否则返回 false。 语法：1let isPresent = array.includes(value); 示例：123let arr = [1, 2, 3];let containsTwo = arr.includes(2);console.log(containsTwo); // true 10. from()from() 方法用于将类似数组的对象（如 arguments 对象）或者可迭代对象（如字符串、集合等）转换为一个数组。 语法：1let newArray = Array.from(arrayLikeObject); 示例：123let str = &quot;hello&quot;;let arr = Array.from(str);console.log(arr); // [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;] 总结：这些新增的数组方法提高了JavaScript中数组操作的简洁性和可读性，尤其在函数式编程中起到了重要作用。它们能够帮助开发者用更少的代码实现复杂的数组操作，大大提高开发效率。同时，正确使用这些方法也能减少对循环的依赖，写出更具表达力和易于维护的代码。"},{"title":"类型转换","path":"/2024/08/28/类型转换/","content":"类型 6种基本类型null undefined number stringify boolean symbol1种引用类型object 对象转换为基本类型 对象转换为字符串 1234567891011//模拟toString返回的不是基本类型值，value0f返回的基本类型值var obj = &#123; tostring:function () return &#123;&#125; &#125;, valueof:function ()&#123; return null &#125;&#125;String(obj)//&quot;null&quot; 对象转为数字 先判断valueOf方法, 再判断toString方法 12345678910//value0f和toString返回的都不是基本类型值var obj = &#123;valueof:function ()&#123; return &#123;&#125;&#125;toString:function ()&#123; return &#123;&#125;&#125;&#125;Number(obj)//Uncaught TypeError:Cannot convert object to primitive value Object.create(null)创建的对象没有valueOf和toString方法，因此转换报错一般情况，我们不会重写valueOf和toString,大部分对象valueOfi返回的仍然是对象，因此对象转换为基本类型值可以直接看toString返回的值 显式强制类型转换 转换为字符串如果对象有自定义toString方法，则返回toString.方法的结果，若是toString返回的结果不是基本类型值，报错TypeError 12345678var obj = &#123; toString: function() &#123; return &#123;&#125; &#125;&#125;String(obj)//Uncaught TypeError:Cannot convert object to primitive valueobj +&quot;&quot;//Uncaught TypeError:Cannot convert object to primitive valueobj.toString()//&#123;&#125; -转换为boolean类型null undefined false +0 -0 NaN “”其他情况都是真值 转换为数字类型 12345Number(&#x27;&#x27;)//0Number(null)//0Number(undefined)//NaNNumber(true)//1Number(false)//0 对象首先被转换为相应基本类型值，再转换 12Number([])//0// [] value0f返回的是[]，因此继续调用toString得到基本类型值&quot;&quot;，转换为数字为0 隐式强制类型转换 转换为字符串 123456789var obj = &#123; valueof:function () return 1 &#125;, toString:function () return 2 &#125;&#125;obj+&#x27;&#x27;//&#x27;1&#x27; 123console.log(&quot;123&quot; == 123)console.log(true == 1)console.log(false == 0) x+”,会将x转换为字符串，+运算符其中一个操作数是字符串，会执行字符串拼接操作对象和字符串拼接时，对象转为基本类型按转为数字转换，先判断valueOf,再判断toString 转换为布尔值 发生布尔值隐式强制类型转换的情况1.if()语句中的条件判断表达式2.for(…;…;…)语句中的条件判断表达式（第二个）3.while()和do..while(..)循环中的条件判断表达式4.？:中的条件判断表达式5.逻辑运算符||(逻辑或)和&amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式） 转换为数字类型 12345678910+&#x27;2&#x27;//2&#x27;2&#x27;-0//2&#x27;2&#x27;/1//2&#x27;2&#x27;*1//2+&#x27;x&#x27;//NaN&#x27;x&#x27;-0//NaN&#x27;x&#x27;/1//NaN&#x27;x&#x27;*1//NaN1+&#x27;2&#x27;//121++&#x27;2&#x27;//3即：1+(+2&#x27;) 优先将数字转为字符串进行拼接 12console.log(3 + &#x27;4&#x27;); // 输出 &quot;34&quot;console.log(&#x27;3&#x27; + 4); //输出 &quot;34&quot; 1234567891011const obj = &#123; valueOf() &#123; return 42; &#125;, toString() &#123; return &quot;I am an object&quot;; &#125;&#125;console.log(obj + 1);console.log(&quot;Hello, &quot; + obj); 1234567891011const obj = &#123; valueOf() &#123; return &#123;&#125;; &#125;, toString() &#123; return &quot;I am an object&quot;; &#125;&#125;console.log(obj + 1);console.log(&quot;Hello, &quot; + obj); 当一个操作数是布尔值时，布尔值会被先转换为数字（true被转换为1, false被转换为0）,然后按照前面的规则执行加法运算。 12console.log(true + 3); // 4console.log(false + &#x27;3&#x27;);// &quot;false3&quot; 当一个操作数是null或undefined时，null和undefined分别被转换为数字0和NaN,然后按照前面的规则执行加法运算。 1234console.log(null+2); //2console.log(undefined+2); //NaNconsole.log(&#x27;Hello, &#x27;+ null); //Hello, nullconsole.log(&#x27;Hello, &#x27;+ undefined);//Hello, undefined 12345678910111213//减法运算符的规则console.log(5 - &quot;2&quot;);//3console.log(&quot;5&quot; - 2);//3console.log(true - 3);//-2console.log(null - 2);//-2console.log(undefined - 2);//NaN//乘法运算符的规则console.log(5 * &quot;2&quot;);//10console.log(&quot;5&quot; * 2);//10console.log(true * 3);//3console.log(null * 2);//0console.log(undefined * 2);//NaN 12345console.log(10 / &quot;2&quot;); // 输出5 (&#x27;2&#x27;被转换为数字2)console.log(&quot;10&quot; / 2); // 输出5 (&#x27;10&#x27;被转换为数字10)console.log(true / 2); // 输出0.5 (true被转换为数字1)console.log(null / 2); // 输出0 (null被转换为数字0)console.log(undefined / 2); // 输出NaN (undefined被转换为数字NaN) if语句后的隐式类型转换以下类型会被转换为false, 其他类型会被转换为true false 0 NaN null undefined 空字符串(“”) 12345678910111213141516171819let emptyString = &quot;&quot;;if (emptyString) &#123; console.log(&quot;不执行代码块&quot;);&#125; // 空字符串转换为false，因此不执行代码块let nonEmptyString = &quot;Hello&quot;;if (nonEmptyString) &#123; console.log(&quot;执行代码块&quot;);&#125; // 非空字符串转换为true，因此执行代码块let nullValue = null;if (nullValue) &#123; console.log(&quot;不执行代码块&quot;);&#125; // null转换为false，因此不执行代码块let objectValue = &#123;&#125;;if (objectValue) &#123; console.log(&quot;执行代码块&quot;);&#125; // 对象转换为true，因此执行代码块 123456console.log([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt))//[// 1,// NaN,// NaN//] &#x3D;&#x3D;和&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;允许在相等比较中进行强制类型转换，而&#x3D;&#x3D;&#x3D;不允许比较规则1、字符串和数字比较，字符串先转换为数字，再比较2、其他类型和布尔类型比较，布尔类型转换为数字，再比较3、对象和非对象比较，对象转换成基本类型值，按转换为数字的流程转换后进行比较。对象转换优先级最高 12345678910let myObject = &#123; valueOf() &#123; return 1; &#125;, toString() &#123; return &quot;2&quot; &#125;&#125;console.log(myObject == &quot;2&quot;);// falseconsole.log(myObject == 1);// true 如果一个操作数是对象，另一个操作数是字符串或者数字，会首先调用对象的valueOf方法, 将对象转化为基本类型，再进行比较。 当valueOf()返回的不是基本类型的时候，才会调用toString()方法。 12345678910let myObject = &#123; valueOf() &#123; return &#123;&#125;; &#125;, toString() &#123; return &quot;2&quot; &#125;&#125;console.log(myObject == &quot;2&quot;);// trueconsole.log(myObject == 1);// false 123456789101112let a = &#123; value: 1, valueOf() &#123; return this.value++; &#125;, toString() &#123; return this.value++; &#125;&#125;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log(&quot;条件语句返回值为true&quot;);&#125; 4、null和undefined,nul&#x3D;&#x3D;undefined,其他类型和null均不相等，undefined也是如此5、特殊情况 12NaN =NaN /false-0==+0//true 两个对象比较，判断的是两个对象是否是同一个引用 12345678910&quot;0&quot;==false //true//第2条规则，false转换为数字，结果为0，等式变为&quot;0&quot;=0//两边类型不一致，继续转换，第1条规则，&quot;0”转换为数字，结果为0，等式变为0=0false =[]//true//第3条规则，[】转换基本类型值，[].toString(),结果为&quot;&quot;，等式变为&quot;=false//两边类型不一致，继续转换，第2条规则，false转换为数字，结果为0，等式变为&quot;==0//两边类型不一致，继续转换，第1条规则，&quot;转换为数字，结果为0，等式变为0==00=[]//true//第3条规则，[]转换基本类型值，[].toString(),结果为&quot;，等式变为0=&quot;&quot;//两边类型不一致，继续转换，第1条规则，“”转换为数字，结果为0，等式变为0=0","tags":["编程语言","JavaScript"]},{"title":"instanceof","path":"/2024/08/28/instanceof/","content":"在 JavaScript 中，instanceof 操作符用于检查一个对象是否是某个构造函数的实例。具体来说，它用来判断对象的原型链中是否存在构造函数的 prototype 属性。 instanceof 的实现原理instanceof 操作符的基本原理是基于原型链的逐层查找过程： 对象的 __proto__ 指针：每个对象在创建时会自动关联到某个原型对象，这个原型对象通过对象的 __proto__ 指针来引用。 构造函数的 prototype 属性：每个构造函数（如 Array、Object）都有一个 prototype 属性，指向一个原型对象。这个原型对象包含了所有实例共享的属性和方法。 原型链查找：instanceof 会从目标对象的 __proto__ 开始，沿着原型链一级一级查找，看是否能够找到构造函数的 prototype 属性所指向的那个原型对象。 返回结果：如果在原型链中找到构造函数的 prototype 属性，instanceof 返回 true，否则返回 false。 代码示例12345function Person() &#123;&#125;const john = new Person();console.log(john instanceof Person); // trueconsole.log(john instanceof Object); // true 在这个例子中： Person 是一个构造函数，它的 prototype 属性指向 &#123;&#125;（一个空的对象）。 john 是通过 Person 构造函数创建的实例。 john 的 __proto__ 指针指向 Person.prototype。 john instanceof Person 会沿着 john.__proto__ 查找，发现它指向 Person.prototype，所以返回 true。 因为 Person.prototype 的原型是 Object.prototype，所以 john instanceof Object 也返回 true。 instanceof 的内部实现过程假设我们要判断 object instanceof Constructor： 取得 object 的原型，赋值给一个变量 proto，即 proto = object.__proto__。 取得 Constructor 的 prototype 属性，赋值给 prototype。 循环检查 proto 是否严格等于 prototype。 如果相等，则返回 true。 如果 proto 为 null，说明到达原型链的顶端，还未找到，返回 false。 否则，继续沿着原型链查找，更新 proto = proto.__proto__。 实现一个简单的 instanceof我们可以用 JavaScript 模拟实现 instanceof 的基本逻辑： 123456789101112131415161718function myInstanceof(object, constructor) &#123; let proto = object.__proto__; const prototype = constructor.prototype; while (proto) &#123; if (proto === prototype) &#123; return true; &#125; proto = proto.__proto__; &#125; return false;&#125;// 测试console.log(myInstanceof(john, Person)); // trueconsole.log(myInstanceof(john, Object)); // trueconsole.log(myInstanceof(john, Array)); // false 特殊情况 原始类型：对于 null 和 undefined，instanceof 无法使用，因为它们没有原型链，会直接返回 false。 自定义类型继承：如果构造函数的 prototype 被重新赋值为其他对象，实例也会相应受到影响，instanceof 结果会发生变化。 123456function Animal() &#123;&#125;const dog = new Animal();console.log(dog instanceof Animal); // trueAnimal.prototype = &#123;&#125;;console.log(dog instanceof Animal); // false 小结instanceof 的原理在于通过原型链逐层查找，将对象的 __proto__ 与构造函数的 prototype 进行比对。因此，instanceof 能准确判断对象和构造函数的继承关系，只要 prototype 没有被修改。"},{"title":"不同等号的区别","path":"/2024/08/28/不同等号的区别/","content":"&#x3D;&#x3D;&#x3D;这个比较简单。下面的规则用来判断两个值是否&#x3D;&#x3D;&#x3D;相等： 如果类型不同，就不相等 如果两个都是数值，并且是同一个值，那么相等；(！例外)的是，如果其中至少一个是NaN,那么不相等。（判断一个值是否是NaN,只能用isNaN()来判断) 如果两个都是字符串，每个位置的字符都一样，那么相等；否则不相等。 如果两个值都是true,或者都是false,那么相等。 如果两个值都引用同一个对象或函数，那么相等；否则不相等。 如果两个值都是null,或者都是undefined,那么相等。 &#x3D;&#x3D; 如果两个值类型相同，进行&#x3D;&#x3D;&#x3D;比较。 如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： 如果一个是null、一个是undefined,那么相等。 如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 如果任一值是true,把它转换成1再比较；如果任一值是false,把它转换成0再比较。 如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString;例外的是Date,Date利用的是toString转换。非js核心的对象，另说（比较麻烦，我也不大懂） 任何其他组合，都不相等。 有时会在结构读取属性值时会在前面加上“？”这个是可选链，表示判断空值的情况。","tags":["前端软件开发"]},{"title":"for_in和for_of的区别","path":"/2024/08/28/for-in和for-of的区别/","content":"一句话总结：for.,.in是为遍历对象属性而构建的，遍历的是index,而for,,,of是为了遍历数组的，遍历的是value 12345678910111213141516171819202122232425const arobj = 100:1, d:2, a:9, 1:3, 5:99, b:8&#125;Object.prototype.fun =()=&gt;&#123;&#125;arobj.name = &quot;lallala&quot;const arr=[1,2,4,8,9,10]Array.prototype.method ()=&gt;&#123;&#125;arr.name =&quot;bababa&quot;;for (const item in arobj)&#123; console.log(arobj[item])//3 99 1 2 9 8 lallala ()=&gt;&#123;&#125;for (const item in arr)&#123; console.log(item)//0 1 2 3 4 5 name method fun&#125;for (const item of arobj)&#123; console.log(item)//Uncaught TypeError:arobj is not iterable&#125;for (const item of arr)&#123; console.log(item)//1 2 4 8 9 10&#125; 一、for..in1.for..in适合遍历对象，遍历数组的时候会出现奇奇怪怪的问题2.for.in遍历会遍历所有的可枚举属性，包括原型链上的，可以使用hasOwnProperty来过滤3.for..in中index索引为字符串型数字，不能直接进行几何运算二、for..of1.适合比遍历所有拥有迭代器的对象的集合","tags":["编程语言","JavaScript"]},{"title":"判断数据类型","path":"/2024/08/28/判断数据类型/","content":"一、常见判断：typeof 这个方法很常见，一般用来判断基本数据类型，如：string,number,boolean,symbol,bigint(es10新增一种基本数据类型bigint),undefined等。返回数据类型的字符串形式 typeof目前能返回string,number,boolean,symbol,bigint,unfined,object,function这八种判断类型，但是注意null返回的是Object。而且对于引用类型返回的是object因为所有的对象的原型最终都是Object。 1234567891011121314//例子typeof &quot;safsadff&quot;;//&quot;string&quot;typeof 145;//&quot;number&quot;typeof false;//&quot;boolean&quot;typeof undefined;//&quot;undefined&quot;typeof function (&#123;&#125;//&quot;function&quot;typeof &#123;&#125;//&quot;object&quot;typeof Symbol();//&quot;symbol&quot;typeof null;//&quot;object&quot;typeof[];//&quot;object&quot;typeof new Date();//&quot;object&quot;typeof new RegExp();//&quot;object&quot;typeof new Number(33)//&quot;object&quot;typeof Null //&quot;undefined&quot; 为什么typeof null是Object答：因为在钉avaScript中，不同的对象都是使用二进制存储的，如果二进制前三位都是0的话，系统会判断为是Objecta类型，而null的二进制全是0，自然也就判断为Object这个bug是初版本的JavaScriptr中留下的，扩展一下其他五种标识位： 000对象 1整型 010双精度类型 100字符串 110布尔类型 二、已知对象判断：instanceof 用来判断引用数据类型的，判断基本数据类型无效，如：Object,Function,Array,Date,RegExp等，instanceof主要的作用就是判断一个实例是否属于某种类型 instanceof也可以判断一个实例是否是其父类型或者祖先类型 instanceof原理实际上就是查找目标对象的原型链 12345//例子[]instanceof Array;/true[]instanceof object;/true[1,2,3]instanceof Array /truenew Date()instanceof Date /true 手写实现一个 1234567891011121314//手写实现function myInstance(L,R)&#123;//L代表instanceof左边，R代表右边var RP R.prototypevar LP L._proto_while (true)if (LP =null)&#123;return false&#125;if (LP =RP)&#123;return trueLPLP._proto_&#125;&#125;console.log(myInstance(,object)); 三、根据对象的构造器：constructor 与instanceof相似，但是对于instanceof只能再检测用类型，而constructor还可以检测基本类型，因为constructor是原型对象的属性指向构造函数。 注意 null和undefined是无效的对象，因此是不会有constructor存在的，所以无法根据constructor来判断。 JS对象的constructor是不稳定的，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失，constructor会默i认为Object 类继承的也会出错，因为Object被覆盖了，检测结果就不对了 四、对象原型链判断：Object.prototype.toString.cal(这个是判断类型最准的方法) toString是Object原型对象上的-个方法，该方法默认返回其调用者的具体类型，更严格的讲，是toStringi运行时this指向的对象类型，返回的类型格式为[object,XXx],XXx是具体的数据类型，其中包括：Sng,Number,Boolean,Undefined,Null,Function,Date,Array,RegExp,Error,HTMLDocument..基本上所有对象的类型都可以通过这个方法状取到。 必须通过Object.prototype..toString.call来获取，而不能直接new Date().toString),从原型链的角度讲，所有对象的原型链最终都指向了Object,按照S变量查找规则，其他对象应该也可以直接访问到Object的toString方法，而事实上，大部分的对象都实现了自身的toString方法，这样就可能会导致Object的toString被终止查找，因此要用cal来强制执行Object的toString方法。 缺点：不能再细分 123456789//例子Object.prototype.toString.call(&quot;a&quot;)[object String]&quot;Object.prototype.toString.call(undefined)[object Undefined ]Object.prototype.tostring.call(null)[object Null]&quot;Object.prototype.tostring.call(new Date())[object Date]&quot; 简单来说，JavaScript中我们有四种方法来判断数据类型。一般使用ypeof来判断基本数据类型，不过需要注意当遇到u的问题，这里不足就是不能判断对象具休类型(typeof xjj只是Object不能看出是person):而在要判断一个对象的具体类型，就可以用nstanceof,但是也可能不准确，对于一些基础数据类型，数组等会被判断为object。结合typeof和instanceof的特点，还能使用constructor来判断，他能判断基本类型和引用类型，但是对于null和undefined是无效的，以及constructor不太稳定。最后如果需要判断准确的内置类型，就可以使用object.prototy pe.toString.call,是根据原型对象上的tostring方法获取的，该方法默认返回其调用者的具体类型。","tags":["前端开发","编程语言","JavaScript"]},{"title":"数据类型","path":"/2024/08/28/数据类型/","content":"原始类型Undefined,Null,Boolean,Number,String（没有int,object类型）ES6新增了Symbol和BigInt. Symbol代表独一无二的值，最大的用法是为对象定义唯一的属性名 BigInt可表示任意大小的整数，指安全存储、操作大整数。 数据处理 parseInt(5.4)只保留整数部分，有基模式 解析一个字符串，并返回一个整数。parseInt相比Number,就没那么严格了，parseInt数逐个解析字符，遇到不能转换的字符就停下来。parseInt(string,radix)string必需，表示要被解析的字符串。radix可选，表示要解析的数字的基数。该值介于2~36之间。如果省略该参数或其值为’0’，则数字将以10为基础来解析。如果它以”0x”或”0X””开头，将以16为基数。如果该参数小于2或者大于36，则’parseInt()&#x2F;将返回NaN’。 parseFloat()把值转换成浮点数，没有基模式 Number()把给定的值转换成数字（可以是整数或浮点数），Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值。 Math.floor(4.33)向下取整 Math.ceil(6.7)向上取整 Math.round(6.19)四舍五入 Math.abs(-1)绝对值 String()把给定的值转换成字符串 toFixed(2)四舍五入 null&amp;undefined 这两个基本数据类型分别都只有一个值，就是undefined和null。 undefined代表的含义是未定义，null代表的含义是空对象。一般变量声明了但还没有定义的时候会返回undefined,null主要用于赋值给一些可能会返回对象的变量，作为初始化。 undefined在js中不是一个保留字，这意味着我们可以使用undefined来作为一个变量名，这样的做法是非常危险的，它会影响我们对undefined值的判断。但是我们可以通过一些方法获得安全的undefined值，比如说void(). 当我们对两种类型使用typeof进行判断的时候，Nul类型化会返回”object’”,这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回true,使用三个等号时会返回false。 typeof null为”Object”在第一版JS中，变量的值被设计保存在一个32位内存单元中。该单元包含一个1或3位的类型标标志，和实际数据值。类型标志存储在单元的最后。包括以下2几种情况1.000:object,数据为对象的引用2.1：int,数据为31位的有符号整型3.010:double,数据为一个双精度浮点数的引用4.100:string,数据为一个字符串的引用5.110:boolean,数据为布尔类型的值特殊情况：·undefined负的2的30次方（超出当时整型取值范围的一个数）·null空指针null的存储单元最后三位（即标志位）和object-一样，所以被误判为Object引用类型1.Object2.Date3.Array4.RegExp","tags":["编程语言","JavaScript"]},{"title":"原型和原型链","path":"/2024/08/28/原型和原型链/","content":"任何函数都可以作为构造函数，当该函数通过new关键字调用时，就可以称这个函数为构造函数。 prototype是函数特有的属性一句话概括prototype的作用：让某一个构造函数实例化的所有对象可以找到公共的方法和属性 1234567891011var Parent = function()&#123;&#125;Parent.prototype.name = &quot;所有Parent的实例都可以读取到我&quot;;let p1 = new Parent();let p2 = new Parent();p1.name // &quot;所有Parent的实例都可以读取到我&quot;p2.name // &quot;所有Parent的实例都可以读取到我&quot; __proto__属性是对象特有的属性。 它表示当前对象的原型对象是谁对象的__proto__就是构造函数的prototype 1p1.__proto__ === Parent.prototype; //true 原型链的基本概念 每个对象都有一个原型（prototype）,并从原型上继承属性和方法。原型本身也是一个对象，它也有自己的原型，形成一个链式结构。这种链式结构就被称为原型链。 实例是类的具象化产品对象是一个具有多种属性的内容结构实例都是对象，对象不一定是实例（如Dbject.prototype是对象但不是实例），构造函数也是对象prototype,是构造函数的属性proto是对象的属性 Object也是Function的实例，那Function是谁的实例呢？ 12Function._proto_===Function.prototype;//true Function构造函数的prototype和proto属性都指向同一个原型，是否可以说Function对象是由Function构造函数创建的一个实例？Yes and No.Yes的部分：按照JS中“实例”的定义，a是b的实例即a instanceof b为true,默认判断条件就是b.prototype在a的原型链上。而Function instanceof Function为true,本质上即Object..getPrototypeOf(Function)&#x3D;&#x3D;Function.prototype,正符合此定义。No的部分：Function是built-in的对象，也就是并不存在“Function对象由Function构造函数创建”这样显然会造成鸡生蛋蛋生鸡的问题。实际上，当直接写一个函数时（如function f0或x&#x3D;&gt;x),也不存在调用Function构造器，只有在你显式调用Function构造器时（如new Function(x’,’return x’))才有。注意，本质上，a instanceof b只是一个运算，即满足某种条件就返回true&#x2F;false,当我们说a是b的实例时，也只是表示他们符合某种关系。JS是一门强大的动态语言，你甚至可以在运行时改变这种关系，比如修改对象的原型从而改变instanceof运算的结果。此外，ES6+已允许通过Symbol.hasInstance来自定义instanceof运算。 1Function.prototype//&quot;function&quot; 后来意见：先有的Object.prototype,Object.prototype构造出Function.prototype,然后Function.prototype构造出Object和Function。Object.prototype.是鸡，Object和Function都是蛋。prototype有一个默认的constructor属性，用于记录实例由哪个构造函数创建.proto每一个对象都具有的一个属性，叫proto,这个属性指向该对象的原型.，原型有两个属性，constructor和proto既然实例对象和构造函数都可以指向原型，那么原型是否有属性可以指向构造函数或实例吗？proto.与其说是一个属性，不如说是个getter&#x2F;setter,,当使用obj.proto时，可以理解为返回了Object.getPrototypeOf(obj),constructor每一个原型都有一个constructor属性指向关联的构造函数. 12345678910function Person()&#123;&#125;var person new Person();console.log(person.__proto_==Person.prototype)//trueconsole.log(Person.prototype.constructor=Person)//true原型对象的constructor指向构造函数本身//顺便学习一个ES5的方法，可以获得对象的原型console.log(Object.getPrototypeof(person)===Person.prototype)//trueconsole.log(Object.getPrototypeof(person))person._proto_Person.prototype //constructor 实例&amp;原型当读取实例属性时若找不到，就会查找与对象关联原型中的属性，若还查不到，就去找原型的原型，一直找到最顶层为止原型的原型实例的proto:指向构造函数的prototype原型链 1console.log(Object.prototype._proto_===null)//true 意思就是Object.prototype没得原型，图中由相互关联的原型组成的练状结构就是原型链（蓝色这条线）创建一个原型链只有name属性的对象 123let obj=Object.create(null)/为obj的prototype属性赋值为nullobj.name &#x27;merry&#x27;console.log(obj) 参考文档https://zh.javascript..info/prototype-methodsproto和prototypeprototype是原型对象一proto一将对象和该对象的原型相连特殊的Function对象，Function的proto指向的是自身的prototype。构造函数prototype的proto也是指向构造函数的构造函数的prototype构造函数是一个函数对象，通过Function构造器产生的。原型对象本身是一个普通对象，而普通对象的构造函数是Object。.除了Object的原型对象(Object.prototype)的proto指向null,其他内置函数对象的原型对象（例如：Array.prototype)和自定义构造函数的proto都指向Object.prototype,因为原型对象本身是普通对象 123Object.prototype._proto_=null;Array.prototype._proto_=object.prototype;Foo.prototype.proto object.prototype; 一切对象都是继承自Object对象，Object对象直接继承根源对象null·一切的函数对象（包括Object对象），都是继承自Function对象·Object对象直接继承自Function对象·Function对象的proto会指向自己的原型对象，最终还是继承自Object对象原型&amp;原型链需要new关键字，成为”构造器constructor或构造函数”。通过prototype定义的属性，再被多个实例化后，引用地址是同一个。继承链从祖父—到爷爷—到爸爸—到自己 constructor指向构造函数，每个对象的proto指向创建它的构造函数的prototype,而构造函数的prototype也有proto:指向他的父辈或者是Object,当查找一个对象中不存在的属性时，会去它的proto、proto中的proto中进行寻找，直到找到或者是nul为止 instanceof判断对象的proto和构造函数的prototype是不是同一个地址 Object.setPrototypeOfr改变对象的proto原型(prototype):一个对象，实现对象的属性继承，简单理解为对象的爹。prototype可以通过Object.getPrototypeOf()和Object..setPrototypeOf()访问器访问。当继承的函数被调用时，ts指向的是当前继承的对象，而不是继承的函数所在的原型对象。不是所有对象都有原型。","tags":["编程语言","JavaScript"]},{"title":"判断对象是否具有属性","path":"/2024/08/28/判断对象是否具有属性/","content":"1、in如果属性来自对象的原型，仍然返回true 12345let obj = &#123; name:aa&#x27;&#125;;&#x27;name&#x27; in obj;//true&#x27;toString&#x27;in obj;//true 2、Reflect.has()检查属性是否在对象中，和一样作为函数工作 12345const obj = &#123; name:111&#125;;Reflect.has(obj,&#x27;name&#x27;);//trueReflect.has(obj,&#x27;toString&#x27;);//true 3、hasOwnProperty()返回布尔值，指对象是否具有指定属性作为它自己的属性（不是继承）可正确区分对象本身属性和其原型的属性 12345const obj = &#123; a:1&#125;;obj.hasownProperty(&#x27;a&#x27;);//trueobj.hasownProperty(&#x27;toString&#x27;);//false 缺点：如果对象是用Object.create(null)创建的，不能使用这个方法 123const obj object.create(null);obj.name =&#x27;merry&#x27;;obj.hasownProperty(&#x27;name&#x27;);//Uncaught TypeError:obj.hasownProperty is not a function 4.Object.prototype.hasOwnProperty()可解决3的问题，本方法直接调用内置有效函数，跳过原型链 1234const obj=object.create(null);obj.name=&#x27;merry&#x27;Object.prototype.hasOwnProperty.call(obj,&#x27;name&#x27;)//trueObject.prototype.hasOwnProperty.call(obj,&#x27;toString&#x27;);//false 5、Object.hasOwn()若对象具有指定属性作为自己的属性，则Object.hasOwn(O静态方法返回true,若属性被继承或不存在，返回false 1234const obj=object.create(null);obj.name =&#x27;merry&#x27;object.hasown(obj,&#x27;name&#x27;);//trueObject.hasOwn(obj,&#x27;toString&#x27;);//false","tags":["编程语言","JavaScript"]},{"title":"遍历对象的方法","path":"/2024/08/28/遍历对象的方法/","content":"for in以任意顺序迭代一个对象的除Symbol以外的可枚举属性，包括继承的可枚举属性。 1234567891011121314151617181920212223//Object原型链上扩展的方法也会被遍历出来Object.prototype.fun ()=&gt;&#123;&#125;var obj = &#123; a:1, b:2, c:3&#125;for (const item in obj)&#123; console.log(&quot;属性名：&quot;+item+&quot;/属性值：&quot;+obj[item]);&#125;//属性名：a/属性值：1//属性名：b/属性值：2//属性名：C/属性值：3//属性名：fun/属性值：()=&gt;&#123;&#125;//而如果我们不希望搜索到原型上的，我们就可以使用hasOwnPropertyfor (const item in obj)&#123; if (obj.hasOwnProperty(item))&#123; console.log(&quot;属性名：&quot;+item+&quot;/属性值：&quot;+obj[item]); &#125;&#125;//属性名：a/属性值：1//属性名：b/属性值：2//属性名：c/属性值：3 如果我们不希望搜索到原型上的，我们就可以使用hasOwnProperty Object.key返回一个给定对象的自身可枚举属性名组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致。 123456789//注意：当属性名为数字的时候会排序，key/values/entries都有这个特性~const anobj=&#123;100:&#x27;a&#x27;,2:&#x27;b&#x27;,7:&#x27;c&#x27;&#125;;console.log(Object.keys(anobj));//console:[&#x27;2&#x27;,7,&#x27;100&#x27;]const str = &#x27;hello&#x27;;console.log(Object.keys(str));//[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]const arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];console.log(Object.keys(arr));//[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;]var obj = &#123;a:1,b:2,c:3&#125;;console.log(Object.keys(obj));//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] Object.values12345678910//注意：当属性名为数字的时候会排序，key/values/entries都有这个特性~//注意：当属性名为数字的时候会排序，key/values/entries都有这个特性~const obj1=&#123;100:1,d:2,a:9,1:3,5:99,b:8&#125;;console.log(Object.values(obj1));//[3,99,1,2,9,8]const str=&#x27;hello&#x27;;console.log(Object.values(str));//[&quot;h&quot;,&quot;e&quot;,&quot;&quot;&quot;&quot;&quot;o&quot;]const arr=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];console.log(Object.values(arr));//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]var obj2=&#123;a:1,b:2,c:3&#125;;console.log(Object.values(obj2));//[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]v Object.entries返回一个给定对象自身可枚举属性的键值对数组，其排列与使用for.循环遍历该对象时返回的顺序一致 1234567891011121314//注意：当属性名为数字的时候会排序，key/values/entries都有这个特性~const obj1=&#123;100:1,d:2,a:9,1:3,5:99,b:8&#125;;console.log(Object.entries(obj1));//[[&quot;1&quot;,3],[&quot;5&quot;,99],[&quot;100&quot;,1],[&quot;d&quot;,2],[&quot;a&quot;,9],[&quot;b&quot;,8]]const str=&#x27;hello&#x27;;console.log(Object.entries(str));//[[&quot;0&quot;,&quot;h&quot;],[&quot;1&quot;,&quot;e&quot;],[&quot;2&quot;,&quot;&quot;],[&quot;3&quot;,&quot;&quot;],[&quot;4&quot;,&quot;o&quot;]]const obj2=&#123;a:1,b:2,c:3&#125;;console.log(Object.entries(obj2));//[[&quot;a&quot;,1],[&quot;b&quot;,2],[&quot;c&quot;,3]]const obj3=&#123;a:1,b:2,c:3&#125;;for (const [key,value] of Object.entries(obj3))&#123; console.log(`$&#123;key&#125;:$&#123;value&#125;`);&#125;//a:1//b:2//c:3 object.getownPropertyNames返回一个由指定对象的所有自身属性的属性名组成的数组。（包括不可枚举属性但不包括Symbol值作为名称的属性) 123456789101112131415//注意：当属性名为数字的时候会排序，key/values/entries都有这个特性const arobj=&#123;100:1,d:2,a:9,1:3,5:99,b:8&#125;;console.log(Object.getOwnPropertyNames(arobj));//[&quot;1&quot;,&quot;5&quot;,&quot;100&quot;,&quot;d&quot;,&quot;a&quot;,&quot;b&quot;]const str=&#x27;hello&#x27;;console.log(Object.getOwnPropertyNames(str));//[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;length&quot;]const arr=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];console.log(Object.getOwnPropertyNames(arr));//s[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;length&quot;]const obj=&#123;a:1,b:2,c:3&#125;;console.log(Object.getOwnPropertyNames(obj));//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]const syobj =&#123;a:1,b:2 &#125;const symbol1=Symbol(&#x27;symbol1&#x27;)const symbol2=Symbol(&#x27;symbol2&#x27;)syobj[symbol1]=&#x27;hello&#x27;syobj[symbol2]=&#x27;world&#x27;console.log(Object.getOwnPropertyNames(syobj));//[&quot;a&quot;,&quot;b&quot;] Object.getownPropertySymbols()方法返回一个给定对象自身的所有Symbol属性的数组 123456const obj=&#123;a:1,b:2,c:3&#125;;const symbol1=Symbol(&#x27;symbol1&#x27;)const symbol2=Symbol(&#x27;symbo12&#x27;)obj[symbol1]=&#x27;hello&#x27;obj[symbol2]=&#x27;world&#x27;console.log(Object.getOwnPropertySymbols(obj));//[Symbol(symbol1),Symbol(symbol2)] 报错：TypeError: Cannot convert a Symbol value to a string Reflect.ownKeys()静态方法Reflect..ownKeys(()返回一个由目标对象自身的属性名组成的数组 123456const obj=&#123;a:1,b:2,c:3&#125;;const symbol1=Symbol(&#x27;symbol1&#x27;)const symbol2=Symbol(&#x27;symbol2&#x27;)obj[symbol1]=&#x27;hello&#x27;obj[symbol2]=&#x27;world&#x27;console.log(Reflect.ownKeys(obj));//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,Symbol(symbol1),Symbol(symbol2) 报错：TypeError: Cannot convert a Symbol value to a string 注意 在ES6之前Object的键值对是无序的； 在ES6之后Object的键值对按照自然数、非自然数和Symbol进行排序，自然数是按照大小升序进行排序，其他两种都是按照插入的时间顺序进行排序。","tags":["编程语言","JavaScript"]},{"title":"遍历对象属性","path":"/2024/08/28/遍历对象属性/","content":"使用hasOwnProperty判断对象自身属性中是否具有指定的属性访问属性点表示和加[]语法的主要优点是可以通过变量访问属性。如果属性包含空格，就不能通过.访问它。属性名可以包含非字母非数字，使用[]访问它。除非必须使用变量访问属性，否则我们使用点表示法。注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object) 1234567891011const keyA = &#123; a:1&#125;;const keyB = &#123; b:2&#125;;const myobject = &#123; [keyA]:&#x27;valueA&#x27;, [keyB]:&#x27;valueB&#x27;&#125;;console.log(myobject) //object &#123;[object object]:&quot;valueB&quot;&#125; for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）Object.keys(obj)返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）的键名Object.getOwnPropertyNames(obj)返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）的键名Object.getOwnPropertySymbols(obj)返回一个数组，包含对象自身的所有Symbol属性的键名Reflect.ownKeys(obj)返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是Symbol或字符串，也不管是否可枚举","tags":["编程语言","JavaScript"]},{"title":"String方法","path":"/2024/08/28/String方法/","content":"charAt(index):返回指定索引处的字符串，若没找着，返回空 charCodeAt(index):返回指定索引处的字符的Unicode值123//toLowerCase()转换成小写toUpperCase()转换成大写var x =&quot;a&quot;.toLowercase().charCodeAt(0)//x=97 concat(str1,str2,.):连接多个字符串，返回连接后字符串副本，纯函数（和数组一样的用法） fromCharCode():将Unicode值转换成实际字符串12String.fromCharCode(97)//返回&quot;a&quot; indexOf(str):返回str在父串中第一次出现的位置，若没有返回-1 lastIndexOf(str):返回str在父串中最后一次出现的位置，若没有返回-1 match(regex):搜索字符串，返回正则表达式的所有匹配 search(regex):基于正则表达式搜索字符串，返回第一个匹配的位置 slice(start,,end):返回字符索引在start和end(不含)之间的子串 split(sep,l1imit):将字符串分割为字符数组，limit为从头开始执行分割的最大数量 substr(start,length):从字符索引start的位置开始，返回长度为length的子串 substring(from,to):返回字符索引在from和to(不含)之间的子串，和slice几乎相同，但它允许from&gt;to,不支持负参数 toLowerCase0:将字符串转换为小写 toUpperCase():将字符串转换为大写 valueOf0:返回原始字符串值 toString)把Number对象转换为字符串，返回结果{}的valueOf结果为，toString的结果为”[object Object]”[]的valueOf结果为0，toString的结果为” str.codePointAt(pos)返回pos位置的字符编码123//不同的字母有不同的代码alert(&quot;z&quot;.codePointAt(0));//122alert(&quot;Z&quot;.codePointAt(0));//90 String.fromCodePoint(code)通过code创建字符1234567891011alert(String.fromCodePoint(90));//Z//八u后跟十六进制代码，通过代码添加Unicode字符//在十六进制系统中90为5aalert(&#x27;\\u005a&#x27;);//Z&#x27;a&#x27;&gt;&#x27;Z因为字符通过数字代码比较，ā(97)&gt;Z(90)//英文是否大写function upperCase(num)&#123; var reg =/[A-Z]+$/; return reg.test(num);&#125; replace不会修改原字符串！第二个参数传入要替换的目标字符串，replace只会匹配一次第二个参数也可传入一个函数，若原始字符串中有个我们查找的字符串，函数就会执行次，且函数返回一个字符串，来替换每次匹配到的字符串参数$&amp;$&amp;适用于没有子表达式的情况123var sStr=&#x27;讨论一下正则表达式中的replacel的用法&#x27;；sStr.replace(/正则表达式/，&#x27;《$&amp;》&#x27;)；//得到：&quot;讨论一下《正则表达式》中的replace的用法&quot; $匹配字符串左边的所有字符123var sStr=&#x27;讨论一下正则表达式中的replace的用法&#x27;；sStr.replace(/正则表达式/，&#x27;《$`》&#x27;)；//得到：&quot;讨论一下《讨论一下》中的replacel的用法&quot; $’匹配字符串右边的所有字符123var sStra=&#x27;讨论-下正则表达式中的replace的用法&#x27;；sStr.replace(/正则表达式/，&quot;《$&#x27;》&quot;)；/得到：&quot;讨论一下《中的replacel的用法》中的replacel的用法&quot; 123,4..n依次匹配子表达式123var sStr=&#x27;讨论一下正则表达式中的replace的用法&#x27;；sStr.replace(/(正则)(.+？)（式）/，&quot;《$1》$2&lt;$3&gt;&quot;)；//得到：&quot;讨论一下《正则》表达&lt;式&gt;中的replace的用法&quot; 函数12345var sStr=&#x27;讨论一下正则表达式中的replacel的用法&#x27;；sStr.replace(/(正则).+？（式）/，function()&#123;console.log(arguments);&#125;)；/[&quot;正则表达式&quot;，&quot;正则&quot;，&quot;式&quot;，4，&quot;讨论一下正则表达式中的replace的用法&quot;] 参数分别为。匹配到的字符串·若正则使用了分组匹配就是多个，否则无此参数·匹配字符串的索引位置·原始字符串arguments是当前函数的内置属性，指代当前匹配的参数伪数组。或者使用命名形参的方式：12345var sStr=&#x27;讨论一下正则表达式中的replace的正则表达式用法&#x27;；sStr.replace(/(正则).+？（式）/g,function($1)&#123;console.log($1);return $1 +&#x27;a&#x27;;&#125;)； 用法12345678910111213str=str.replace(八s*/g);//去除字符串内所有的空格\\s匹配任何空白字符。（空格，制表符，换行符）str=str.replace(/\\s*|\\s*$/g,&quot;&quot;);//去除字符串内首尾空格str=str.replace(/\\s*/,&quot;&quot;);//去除字符串左侧空格str=str.replace(/八s*&amp;/,&quot;&quot;);//去除字符串右侧空格name &quot;Doe,John&quot;;let a=name.replace(/(\\w+)\\s*,\\s*(\\w+)/,&quot;$2 $1&quot;);console.log(a)//John Doe/首字母大写let name =&#x27;aaa bbb ccc&#x27;;let uw=name.replace(/\\b\\w+\\b/g,function(word)&#123;return word.substring(0,1).toUppercase()+word.substring(1);&#125;) str.trim()r0删除字符串两端的空白字符并返回，不影响原来字符串本身，返回一个新的字符串*缺陷：只能去除字符串两端的空格，不能去除中间的空格截取字符串substring()substring0用于提取字符串中介于两个指定下标之间的字符substring(start,stop)·st妇t:一个非负整数，指要提取的子串的第一个字符在字符串中的位置，必需填写·soP:一个非负整数，比要提取的子串的最后一个字符在字符串上的位置多1，可写可不写，如果不写则返回的子串会一直到字符串的结尾该字符串的长度为stop-start如果参数start与stop相等，则该方法返回的就是一个空串，如果start比stoP大，那么该方法在提取子串之前会先交换这两个参数substr()substr(O在字符串中抽取从start下标开始的指定数目的字符substr(start,length)·st妇t:要截取的子串的起始下标，必须是数值。如果是负数，那么该参数从字符串的尾部开始算起的位置。也就是说，1指字符串中最后一个字符，2指倒数第二个字符，以此类推，必需要写·length:子串中的字符数，必须是数值。如果不填该参数，返回字符串的开始位置到结尾的字符。如果length为0或者负数，将返回一个空字符串split()split(0把一个字符串分割成字符串数组stringObject.split(separator,howmany)separator:字符串或正则表达式，从该参数指定的地方分割字符串。(必须要填写)howmany:指返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。(可选)","tags":["前端软件开发"]},{"title":"对原数组无影响","path":"/2024/08/28/对原数组无影响/","content":"concat()创建一个副本，返回新构建的数组 slice()创建一个包含原有数组中一个或多个元素的新数组 reduce()reduce()方法不会改变原有数组 filter将所有元素进行判断，将满足条件的元素作为一个新的数组返回 some将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true,若所有元素都不满足判断条件，则返回false; every将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回ue,否则为false; 求最大值12vara=[1,2,3,4];Math.max.apply(null,a); join纯函数 flat(),flatMap()将数组扁平化处理，返回一个新数组，对原数据没有影响。flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。flatMap()方法对原数组的每个成员执行一个函数相当于执行Array.prototype.map(),然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。 123456789101112131415161718192021222324252627282930// 示例数组，包含嵌套数组const nestedArray = [1, [2, [3, [4]], 5]];// 使用 flat() 方法拉平一层const flatArrayOneLevel = nestedArray.flat();console.log(&#x27;flat() 一层拉平:&#x27;, flatArrayOneLevel);// 使用 flat() 方法拉平两层const flatArrayTwoLevels = nestedArray.flat(2);console.log(&#x27;flat() 两层拉平:&#x27;, flatArrayTwoLevels);// 使用 flat() 方法拉平所有层const flatArrayAllLevels = nestedArray.flat(Infinity);console.log(&#x27;flat() 所有层拉平:&#x27;, flatArrayAllLevels);// 使用 flatMap() 方法const flatMapArray = nestedArray.flatMap((item) =&gt; &#123; // 如果是数字，返回一个包含该数字的新数组 // 如果是数组，返回该数组本身 return Array.isArray(item) ? item : [item];&#125;);console.log(&#x27;flatMap():&#x27;, flatMapArray);// 使用 flatMap() 方法并绑定 thisconst context = &#123; multiplier: 10 &#125;;const flatMapArrayWithContext = nestedArray.flatMap(function(item) &#123; // 使用 this 乘以数组中的每个数字 return Array.isArray(item) ? item.map(num =&gt; this.multiplier * num) : [this.multiplier * item];&#125;, context);console.log(&#x27;flatMap() 绑定 this:&#x27;, flatMapArrayWithContext);","tags":["编程语言","JavaScript"]},{"title":"对原数组有影响","path":"/2024/08/28/对原数组有影响/","content":"push返回数组最新长度 unshift()返回新数组长度 splice()返回空数组，返回包含删除元素的数组 123[2,3,4].splice(0,1);//0位置删除-个，返回[2][2,3,4].sp1ice(0,1,5);//0位置删除1个，插入5，原数组是[5,3,4]，返回[2]arrayObject.splice(index,howmany,item1,.....,itemx) index:必需。添加&#x2F;删除项目位置，使用负数可从数组结尾处规定位置。howmany:必需。要删除项目数量。如果设置为0，则不会删除项目。item1,…..,itemx:可选。向数组添加新项目。 pop()shift()","tags":["编程语言","JavaScript"]},{"title":"创建数组","path":"/2024/08/28/创建数组/","content":"Array.from()浅拷贝1234const dp1=Array(5).fill(1);console.log(dp1)//1,1,1,1,1const dp2=Array.from(Array(5),()=&gt;Array(5).fill(1));console.log(dp2)//1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 从类数组对象或者可迭代对象中创建一个新的数组实例。Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 Array.of()根据一组参数来创建新的数组实例，支持任意的参数数量和类型，没有参数时返回[]，当参数只有一个的时候，实际上是指定数组的长度。 sort原理对数组进行排序，默认排序顺序规则是将元素转换为字符串，然后比较它们的UT℉-16代码单元值序列时构建的。 copyWithin()将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。 target(必需)：从该位置开始替换数据。如果为负值，表示倒数。 start(可选)：从该位置开始读取数据，默认为0。如果为负值，表示从末尾开始计算。 end(可选)：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。123[1,2,3,4,5].copyWithin(0,3);//将从3号位直到数组结束的成员（(4和5)，复制到从0号位开始的位置，结果覆盖了原来的1和2//[4,5,3,4,5] find()find)用于找出第一个符合条件的数组成员参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组 findIndex()findIndex.返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1find和findIndex这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置注意，如果填充的类型为对象，则是浅拷贝","tags":["前端软件开发","编程语言","JavaScript"]},{"title":"响应式布局","path":"/2024/08/28/响应式布局/","content":"页面的设计和开发根据用户行为和设备环境进行调整和响应Content is like water 12&lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;&gt; 1.width&#x3D;device-width:自适应手机屏幕的尺寸宽度2.maximum-scale:缩放比例的最大值3.inital-scale:缩放的初始化4.user-scalable:用户可以缩放实现响应式布局的方式1.媒体查询2.百分比3.vw&#x2F;vh4.rem响应式设计实现通常会从以下几方面思考：1.弹性盒子和媒体查询等2.百分比布局创建流式布局的弹性UⅡ，同时使用媒体查询限制元素的尺寸和内容变更范围3.相对单位使得内容自适应调节缺点：1.仅适用布局、信息、框架并不复杂的部门类型网站2.兼容各种设备工作量大，效率低下3.代码累赘，出现隐藏无用的元素，加载时间加长4.一定程度上改变了网站原有的布局结构"},{"title":"div居中的几种方式","path":"/2024/08/28/div居中的几种方式/","content":"方式一 123456position:absolute;top:0;bottom:0;left:0;right:0;margin:auto; 方式二可以给父元素添加下面的属性，利用lex布局来实现 123display:flex;align-items:center;flex-direction:column 方式三通过定位和变形来实现给父元素添加position:relative;相对定位。给自身元素添加position:absolute,绝对定位。top:50%;使自身元素距离上方”父元素的50%高度”的高度。1eft:50%;使自身元素距离上方”父元素的50%宽度”的宽度。transform:translate(-50%,-50%):使自身元素再往左，往上平移自身元素的50%宽度和高度。 1234position:absolute;top:50%;left:50%;transform:translate(-50%,-50%); 方式四这个是实现内容文本居中的，坑死了，之前没留意在一个全局的文件加了，后面很多组件里面的内容都居中了，还一时没发现，虽然想到会不会是全局文件的问题，但一下子眼拙没看到，结果捣鼓半天 1body&#123;text-align:center&#125;","tags":["前端开发","UI","CSS"]},{"title":"重排，重绘和合成","path":"/2024/08/28/重排，重绘和合成/","content":"回流一定触发重绘，重绘不一定触发回流。重绘开销小，回流代价高。回流reflow也叫重排layout渲染树中部分或全部元素的尺寸、结构或属性变化，浏览器会重新渲染部分或全部文档触发回流的操作：·初次渲染·窗口大小改变(resize事件)■元素属性、尺寸、位置、内容改变元素字体大小变化■添加或者删除可见dom元素■激活CSS伪类（如：hover)■查询某些属性或调用某些方法clientWidth、clientHeight、clientTop、clientLeftoffsetWidth、offsetHeight、offsetTop、offsetLeftscrollWidth、scrollHeight、scrollTop、scrollLeftgetComputedStyle()getBoundingClientRect()scrollTo()修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。重绘repaint某些元素的样式如颜色改变，但不影响其在文档流中的位置，浏览器会对元素重新绘制不再执行布局阶段，直接进入绘制阶段合成利用transform、opacity和filter可实现合成效果，即GPU加速避开布局分块和绘制阶段优化·最小化重绘和重排：样式集中改变，使用添加新样式类名■使用absolute或fixed使元素脱离文档流（制作复杂动画时对性能有影响）■开启GPU加速。利用css属性transform opacity will-change等，比如改变元素位置，使用translate会比使用绝对定位改变其left或top更高效，因为它不会触发重排或重绘，transform使浏览器为元素创建一个GPU图层，这使得动画元素在一个独立的层中进行谊染，当元素内容没有改变就没必要进行渲染。·使用visibility替换display:none,因为前者只会引起重绘，后者会引发回流（改变了布局）。DOM离线后修改，如：先把DOM设为display:none(有一次Reflow),然后修改再显示，只会触发一次回流不要把DOM结点属性值放在一个循环当成循环里的变量不要使用table布局，可能很小的一个小改动会造成整个table重新布局动画实现速度的选择，动画速度越快，回流次数越多，也可以选择使用requestAnimationFrameCSS选择符从右往左匹配查找，避免节点层级过多。频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于vd©o标签，浏览器会自动将该节点变为图层·通过documentFragment创建一个DOM文档片段，在它上面批量操作DOM,完成后再添加到文档中，只触发一次回流documentFragment不是真实DOM的一部分，它的变化不会触发DOM树的重新渲染，不会导致性能问题效果不甚明显，因为现代浏览器会使用队列存储储存多次修改进行优化"},{"title":"水平居中","path":"/2024/08/28/水平居中/","content":"不定宽高1.定位+margin:auto2.定位+transform3.定位+margin:负值4.f1ex布局5.grid布局 内联元素水平居中l.行内元素可设置：text-align:center2.flex布局设置父元素：display:flex;justify-content:center垂直居中1.单行文本父元素确认高度：height&#x3D;&#x3D;line-height2.多行文本父元素确认高度：disaply:table-cell,vertical-align:middle 块级元素水平居中1.定宽：margin:0auto2.绝对定位+left:50%+margin:负自身一半垂直居中l.position:absolutei设置left、top、margin-left、margin-top(定高)2.display:table-cell3.transform:translate(x,y)4.flex(不定高，不定宽)5.grid(不定高，不定宽)，兼容性相对比较差","tags":["前端开发"]},{"title":"盒子模型","path":"/2024/08/28/盒子模型/","content":"盒模型宽度的计算普通盒模型默认盒子属性：box-sizing:content-box; width只包含内容宽度，不包含border和padding offsetWidth &#x3D;(width padding border),margin width和height属性只会应用到这个元素的内容区 box-sizing:content–box;&#x2F;&#x2F;定义引擎如何计算元素的总高度和总宽度 content-box默认值，元素的width&#x2F;height不包含padding,border,与标准盒子模型表现一致 border-box元素的width&#x2F;height包含padding,border,与怪异盒子模型表现一致 inherit指定box-sizing属性的值，应该从父元素继承 怪异盒模型设置语句：box-sizing:border-box; offsetWidth&#x3D;width(padding和border都挤压到内容里面) width和height包括内容区、padding和border,不算margin margin纵向重叠margin负值问题BFCfloat元素居中样式单位两栏布局左边宽度固定，右边宽度自适应。 利用flex布局，将左边元素设置为固定宽度200px,将右边的元素设置为flex:1 利用浮动。左边元素宽度设置为200px,且设置向左浮动。右边元素的margin-left设置为200px,宽度设置为auto(默认为auto,撑满整个父元素)。margin-left&#x2F;padding-left&#x2F;calc 利用浮动。左边元素宽度固定，设置向左浮动。右侧元素设置overflow:hidden;这样右边就触发了BFC,BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。float+overflow:hidden 左列左浮动，将自身高度塌陷，使得其它块级元素可以和它占据同一行位置 右列利用自身流特性占满整行 右列设置overflow,触发BFC特性，使自身和左列浮动元素隔开，不沾满整行 绝对定位父级相对定位左边absolute定位，宽度固定。设置右边margin-left为左边元素的宽度值。 绝对定位，父级元素相对定位。左边元素宽度固定，右边元素absolute定位，left为宽度大小，其余方向为0。（有歧义，谨慎使用) 使用calc计算123456789.leftdisplay:inline-block;width:240px;&#125;rightdisplay:inline-block;width:calc(100%-240px);&#125;//使用calc()函数计算&lt;div&gt;元素的宽度 grid","tags":["前端开发","UI","CSS"]},{"title":"脱离文档流","path":"/2024/08/28/脱离文档流/","content":"定位流元素的属性position为absolute或fixed,它就是一个绝对定位元素。 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 它的定位相对于它的包含块，相关CSS属性：top、bottom、left、right; 对于position:absolute,元素定位将相对于上级元素中最近的一个relative、fixed、absolute,如果没有则相对于body; 对于position:fixed,正常来说是相对于浏览器窗口定位的，但是当元素祖先的transform属性非none时，会相对于该祖先进行定位。 浮动流在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能地向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 普通流普通流其实就是指BFC中的FC。FC(Formatting Context),直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。在普通流中，元素按照其在HTML中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行。块级元素则会被渲染为完整的一个新行。除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在HML文档中的位置决定。","tags":["前端开发"]},{"title":"px_em_rem_vh_vw的区别及使用场景","path":"/2024/08/28/px-em-rem-vh-vw的区别及使用场景/","content":"px也就是像素，是基于屏幕分辨率来说的，一旦设置了，就无法适应页面大小的变化。 emem：是相对单位，相对于当前对象内文本的字体大小（也就是它的父元素），如果当前对象内文本的字体没有设置大小，就会相对于浏览器默认字体大小也就是16px。所以在没有设置的情况下1em&#x3D;16px。 为了便于运算你可以在body选择器中声明Font-size-62.5%;这就使em值变为16px*62.5%&#x3D;10px,这样12px&#x3D;1.2em,10px&#x3D;1em,也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。 remrem的出现是为了解决em的问题的，em是相对于父元素来说的，这就要求我们进行任何元素设置的时候，都需要知道它的父元素字体的大小。而rem是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值，就可以了，同时还能做到只修改根元素就成比例地调整所有字体大小。 vh,vwvh、vw是根据窗口的宽度。会把窗口的大小分为100份，所以50w代表窗口大小的一半。并且这个值是相对的，当窗口大小发生改变也会跟着改变，同理，则为窗口的高度 区别px是固定的大小，em是相对于父元素字体的大小，rem是相对于根元素字体的大小，vh、w是相对可是窗口的大小 使用场景 一般我们在设置边框和边距的时候用px比较好 而在一些需要做响应式的页面用rem比较便捷 但是具体还是得看你的业务来定的"},{"title":"position属性","path":"/2024/08/27/position属性/","content":"relative:相对自身之前正常文档流中的位置发生偏移，未脱离文档流, 且原来的位置仍然被占据。发生偏移时，可能覆盖其他元素, 但不会影响其他元素的位置和大小。body默认是relative,子绝父相。 absolute:元素框不再占有文档位置，脱离文档流, 并且相对于包含块进行偏移（所谓包含块就是最近一级外层元素position不为static的元素)。 给元素设置position:absolute, 在没有定义宽度的情况下，宽度由元素里面的内容决定。 在父元素没有设置相对定位或绝对定位的情况下，元素相对于根元素定位（即html元素）（是父元素没有）。 父元素设置了相对定位或绝对定位，元素会相对于离自己最近的设置了相对或绝对定位的父元素进行定位（或者说离自己最近的不是static的父元素进行定位，因为元素默认是static）。 fixd:元素框不再占有文档流位置，并且相对于视窗进行定位。 static:默认值，取消继承。 sticky:css3新增属性值，粘性定位，相当于relative和fixed的混合。最初会被当作是relative,相对原来位置进行偏移；一旦超过一定的阈值，会被当成fixed定位，相对于视口定位。 inherit 绝对定位：absolute 和 fixed 统称为绝对定位相对定位：relative默认值：static 参考文章：css之position相对定位和绝对定位CSS position 相对定位和绝对定位","tags":["前端软件开发"]},{"title":"CSS选择器优先级总结","path":"/2024/08/26/CSS选择器优先级总结/","content":"CSS有多少种样式类型：1.行内样式：&lt;style&#x2F;style&gt;2.内联样式：&lt;div style-“color:red&gt;;3.外部样式：或@import引入 常见选择器及选择器权重 选择器 格式 优先级权重 id选择器 #id 100 类选择器 .classname 10 属性选择器 a[ref &#x3D; “eee”] 10 伪类选择器 li:last-child 10 标签选择器 div 1 伪元素选择器 li:after 1 相邻兄弟选择器 h1+p 0 子选择器 ul&gt;li 0 后代选择器 li a 0 通配符选择器 * 0 三、注意事项 !important声明的样式的优先级最高； 如果优先级相同，则最后出现的样式生效；覆盖原则。 继承得到的样式的优先级最低：和类继承差不多。 通用选择器(*)、子选择器(&gt;)和相邻同胞选择器(+)并不在这四个等级中，所以它们的权值都为0： 样式表的来源不同时，优先级顺序为：内联样式&gt;内部样式&gt;外部样式&gt;浏览器用户自定义样式&gt;浏览器默认样式。","tags":["前端开发","CSS"]},{"title":"display:none与visibility:hidden的区别","path":"/2024/08/26/display-none与visibility-hidden的区别/","content":"是否在渲染树中 display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间； visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。 是否是继承属性 display:none是非继承属性，子孙节点会随着父节点从渲染树消失，不是因为继承了display:none，相当于整个节点被移除了,通过修改子孙节点的属性也无法显示（都移除了如何获取子孙节点？设置属性感觉也没啥用）； visibility:hidden是继承属性，子孙节点消失是由于继承了hidden,通过设置visibility:Avisible可以让子孙节点显示； 修改常规文档流中元素的display通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘 如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取（读屏器会选择性读取，只会读取visibility:hidden的内容）。 这两者的关系类似于v-if和v-show之间的关系 v-if 和 v-show 都是Vue.js框架中用于条件性渲染元素的指令，但它们的工作机制和使用场景有所不同。 v-if 工作机制：v-if 是一个条件渲染指令，它是“真正”的条件渲染，因为它确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 性能开销：因为 v-if 的元素可能被销毁和重建，所以切换时会有更高的性能开销。 使用场景：当元素需要频繁切换时，使用 v-if 可能会导致性能问题，因为它会不断地创建和销毁元素。因此，v-if 更适合条件不经常改变的情况。 v-show 工作机制：v-show 只是简单地切换元素的 CSS 属性 display。元素始终被保留在DOM中，它只是简单地切换显示与隐藏。 性能开销：初始渲染时有更高的开销，因为无论条件是否为真，元素总是会被渲染并保留在DOM中，但是切换开销较小，因为只是改变了CSS。 使用场景：当元素需要非常频繁地切换显示状态时，使用 v-show 是更好的选择，因为它的性能开销较小。 之间的关系 共同点：都是用来根据条件展示或隐藏元素。 不同点： v-if 是“真正”的条件渲染，条件为假时不会渲染元素。 v-show 则始终渲染元素，只是简单地切换元素的CSS display 属性。 v-if 有更高的切换开销，v-show 有更高的初始渲染开销。 使用场景不同，v-if 适用于条件变化不频繁的情况，v-show 适用于条件变化非常频繁的情况。","tags":["前端软件开发"]},{"title":"Swin-Transformer论文分析","path":"/2024/08/26/Swin-Transformer论文总结/","content":"看起来是从图像角度进行计算，和vit原理差不多，都是将图像切成小块，每一个小块可以近似看为一个向量，注意力的计算也是基于这些向量进行的，二维的图像转为一维的向量进行训练学习。 全局自注意力机制，所有的token都可以相互联系起来，但这样计算量会特别特别大。Swin Transformer通过窗口（Window）来限制自注意力的范围，计算量就小很多, 简单来说，Swin Transformer把图像分成了很多个小窗口（Window），然后每个窗口里面的token只和窗口里的其他token互相作用。不过，如果窗口一直不动，每个窗口之间的token就不会交进行注意力的交互，这样会缺少全局信息（不够全局，在窗口内还是全局的）。所以, Swin Transformer就会每隔一层，移动一下窗口的位置（Shift Window），让这些窗口错开一部分。这样，原来在不同窗口里的token，就可以通过这次移动的窗口进行注意力的交互达到理论上的全局注意力机制。","tags":["算法"]},{"title":"行内元素和块级元素","path":"/2024/08/25/行内元素和块级元素/","content":"一. 元素种类 行内元素123456789&lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;del&gt; &lt;span&gt; &lt;img&gt; &lt;input&gt; &lt;select&gt; 行内元素（inline elements）在HTML中指的是那些不会自动在其前后创建新行的元素，它们只占据必要的宽度，并且可以与其他行内元素并排显示。以下是一些关于行内元素的特点和示例，以帮助您更好地理解： 特点 不换行：行内元素通常不会独自占据一行，它们会与周围的文本或行内元素共享一行。 宽度：行内元素的宽度是由其内容决定的，而不是由外部容器或CSS样式定义的。 高度和行高：行内元素可以设置高度和行高，但这些样式可能不会影响元素的实际布局，因为行内元素通常只占据一行文本的高度。 垂直对齐：行内元素通常沿着它们的基线对齐，这意味着它们会与周围的文本基线对齐。 示例假设有以下HTML代码： 123&lt;p&gt; 这是一个段落，其中包含了一些&lt;em&gt;行内元素&lt;/em&gt;，比如&lt; strong &gt;加粗文本&lt;/ strong &gt;和&lt; a href=&quot;https://example.com&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt; 在这个例子中，&lt;em&gt;、&lt;strong&gt;和&lt;a&gt;都是行内元素。当这段代码在浏览器中渲染时，它们的表现如下： &lt;em&gt;会使其内容变为斜体。 &lt;strong&gt;会使其内容变为粗体。 &lt;a&gt;会创建一个链接。这些元素不会独自占据一行，而是与周围的文本共享同一行，就像这样：这是一个段落，其中包含了一些行内元素，比如加粗文本和链接。 块级元素12345678&lt;h1&gt;~&lt;h6&gt;&lt;p&gt;&lt;div&gt;&lt;ul&gt;&lt;ol&gt;&lt;li&gt;&lt;div&gt;&lt;dl&gt; 总是在新行上开始，默认占据一整行；高度，行高以及外边距和内边距都可控制；宽带始终是与浏览器宽度一样，与内容无关；它可以容纳内联元素和其他块元素。 空元素1&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 二、行内元素和块级元素的转换123456//定义元素为块级元素display: block//定义元素为行内元素display inline//定义元素为行display: inline-block 三、块级元素和行内元素的区别我们区分块级元素和行内元素，首先行内元素是在一行中能有多个的，块级元素是自己占一行的。接着可以从三个方面来查看 是否占据一行，还是能多个处于一行中，行内是可以的； 是否可以设置宽高，行内是不可以的。 行内元素只可以容纳文本和其他行内元素，块级元素啥都可以容纳 总结 行内元素和块级元素很好区分，顾名思义，行内就是能都在一行里的，一行可以有多个&lt;a&gt;标签，可以有多个&lt;input&gt;标签，而同类的还有&lt;span&gt;&#x2F;&lt;img &gt;&#x2F;&lt;strong&gt;等，这不就很容易记住了。而块级元素就是要自己占一行的，那不就有&lt;div&gt;，还有我们使用的列表&lt;ul&gt;&#x2F;&lt;ol&gt;，除此之外还有&lt;h1&gt;～&lt;h6&gt;&#x2F;&lt;p&gt;等等。 code example 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;行内元素转块级元素示例&lt;/title&gt; &lt;style&gt; /* 默认的 span 元素是行内元素 */ span &#123; background-color: yellow; padding: 10px; &#125; /* 将 span 元素转换为块级元素 */ .block-span &#123; display: block; width: 200px; text-align: center; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是普通的段落。&lt;/p&gt; &lt;span&gt;这是一个行内元素，默认不会独占一行，行内元素会和周围的文本紧密排列。&lt;/span&gt;aaa &lt;p&gt;行内元素的表现不会影响其他内容的布局。例如，&lt;span&gt;这是另一个行内元素&lt;/span&gt;，它仍然在当前行内。&lt;/p&gt; &lt;p&gt;下面展示一个被转换为块级元素的 &lt;code&gt;span&lt;/code&gt; 元素：&lt;/p&gt; &lt;span class=&quot;block-span&quot;&gt;这个 span 元素被转换为块级元素，会独占一行。&lt;/span&gt;aaa &lt;p&gt;由于被设置为块级元素，即使紧跟在其后的文本也会被移到下一行：&lt;/p&gt; &lt;span class=&quot;block-span&quot;&gt;块级元素通常具有宽度和高度，独占一行。&lt;/span&gt;aaa &lt;p&gt;这就是行内元素与块级元素的不同展示效果。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","tags":["前端软件开发"]},{"title":"MMSegmentation基本概念-模型","path":"/2024/08/23/MMSegmentation基本概念-模型/","content":"ModelsWe usually define a neural network in a deep learning task as a model, and this model is the core of an algorithm. MMEngine abstracts a unified model BaseModel to standardize the interfaces for training, testing and other processes. All models implemented by MMSegmentation inherit from BaseModel, and in MMSegmentation we implemented forward and added some functions for the semantic segmentation algorithm. MMEngine抽象了一个统一的模型BaseModel, 目的是标准化训练，测试以及其它的流程。所有MMSegmentation实现的模型继承自BaseModel,在MMSegmentation中我们实现了前向传播和添加了一些语义分割算法的功能。 Common componentsSegmentorIn MMSegmentation, we abstract the network architecture as a Segmentor, it is a model that contains all components of a network. We have already implemented EncoderDecoder and CascadeEncoderDecoder, which typically consist of Data preprocessor, Backbone, Decode head and Auxiliary head. 在MMSegmentation中，我们将网络结构抽象为一个Segmentor, 这是一个包含网络所有组件的模型。我们已经实现了EncoderDecoder和CascadeEncoderDecoder，这两者典型地由Data preprocessor, Backbonem, Decode head和Auxiliary head构成。 Data preprocessorData preprocessor is the part that copies data to the target device and preprocesses the data into the model input format. 数据预处理器是将数据复制到目标设备并将数据预处理为模型输入格式的部分。 BackboneBackbone is the part that transforms an image to feature maps, such as a ResNet-50 without the last fully connected layer. 主干是将图像转换为特征图的部分，例如没有最后一个完全连接层的ResNet-50。 NeckNeck is the part that connects the backbone and heads. It performs some refinements or reconfigurations on the raw feature maps produced by the backbone. An example is Feature Pyramid Network (FPN). 颈部是连接骨干和头部的部分。它对骨干生成的原始特征图进行一些细化或重新配置。一个例子是特征金字塔网络（FPN）。 Decode headDecode head is the part that transforms the feature maps into a segmentation mask, such as PSPNet.解码头是将特征映射转换为分割掩码的部分，例如PSPNet。 Auxiliary headAuxiliary head is an optional component that transforms the feature maps into segmentation masks which only used for computing auxiliary losses.辅助头是一个可选组件，它将特征图转换为仅用于计算辅助损失的分割掩码。 Basic interfacesMMSegmentation wraps BaseModel and implements the BaseSegmentor class, which mainly provides the interfaces forward, train_step, val_step and test_step. The following will introduce these interfaces in detail. forwardThe forward method returns losses or predictions of training, validation, testing, and a simple inference process. forward。函数返回训练阶段的losses或predictions The method should accept three modes: “tensor”, “predict” and “loss”: “tensor”: Forward the whole network and return the tensor or tuple of tensor without any post-processing, same as a common nn.Module.“张量”：转发整个网络并返回张量的张量或元组，无需任何后处理，与普通的nn. Module相同。 “predict”: Forward and return the predictions, which are fully processed to a list of SegDataSample. 前向计算并返回预测，这些预测被完全处理到SegDataSample列表中。 “loss”: Forward and return a dict of losses according to the given inputs and data samples.根据给定的输入和数据样本转发和返回损失判断。 Note: SegDataSample is a data structure interface of MMSegmentation, it is used as an interface between different components. SegDataSample implements the abstract data element mmengine.structures.BaseDataElement, please refer to the [SegDataSample documentation](Note that this method doesn’t handle either backpropagation or optimizer updating, which are done in the method train_step.) and data element documentation in MMEngine for more information. Note that this method doesn’t handle either backpropagation or optimizer updating, which are done in the method train_step. Parameters: inputs (torch.Tensor) - The input tensor with shape (N, C, …) in general. data_sample (list[SegDataSample]) - The seg data samples. It usually includes information such as metainfo and gt_sem_seg. Default to None. mode (str) - Return what kind of value. Defaults to ‘tensor’. Returns: dict or list: If mode &#x3D;&#x3D; “loss”, return a dict of loss tensor used for backward and logging. If mode &#x3D;&#x3D; “predict”, return a list of SegDataSample, the inference results will be incrementally added to the data_sample parameter passed to the forward method, each SegDataSample contains the following keys: pred_sem_seg (PixelData): Prediction of semantic segmentation. seg_logits (PixelData): Predicted logits of semantic segmentation before normalization. If mode &#x3D;&#x3D; “tensor”, return a tensor or tuple of tensor or dict of tensor for custom use. prediction modes We briefly describe the fields of the model’s configuration in the config documentation, here we elaborate on the model.test_cfg field. model.test_cfg is used to control forward behavior, the forward method in “predict” mode can run in two modes: whole_inference: If cfg.model.test_cfg.mode &#x3D;&#x3D; ‘whole’, model will inference with full images. An whole_inference mode example config: 12345model = dict( type=&#x27;EncoderDecoder&#x27; ... test_cfg=dict(mode=&#x27;whole&#x27;)) slide_inference: If cfg.model.test_cfg.mode &#x3D;&#x3D; ‘slide’, model will inference by sliding-window. Note: if you select the slide mode, cfg.model.test_cfg.stride and cfg.model.test_cfg.crop_size should also be specified. An slide_inference mode example config: 12345model = dict( type=&#x27;EncoderDecoder&#x27; ... test_cfg=dict(mode=&#x27;slide&#x27;, crop_size=256, stride=170)) train_stepThe train_step method calls the forward interface of the loss mode to get the loss dict. The BaseModel class implements the default model training process including preprocessing, model forward propagation, loss calculation, optimization, and back-propagation. Parameters: data (dict or tuple or list) - Data sampled from the dataset. In MMSegmentation, the data dict contains inputs and data_samples two fields. optim_wrapper (OptimWrapper) - OptimWrapper instance used to update model parameters. Note: OptimWrapper provides a common interface for updating parameters, please refer to optimizer wrapper documentation in MMEngine for more information. Returns: Dict[str, torch.Tensor]: A dict of tensor for logging. val_stepThe val_step method calls the forward interface of the predict mode and returns the prediction result, which is further passed to the process interface of the evaluator and the after_val_iter interface of the Hook. Parameters: data (dict or tuple or list) - Data sampled from the dataset. In MMSegmentation, the data dict contains inputs and data_samples two fields. Returns: list - The predictions of given data. test_stepThe BaseModel implements test_step the same as val_step. Data PreprocessorThe SegDataPreProcessor implemented by MMSegmentation inherits from the BaseDataPreprocessor implemented by MMEngine and provides the functions of data preprocessing and copying data to the target device. The runner carries the model to the specified device during the construction stage, while the data is carried to the specified device by the SegDataPreProcessor in train_step, val_step, and test_step, and the processed data is further passed to the model. The parameters of the SegDataPreProcessor constructor: mean (Sequence[Number], optional) - The pixel mean of R, G, B channels. Defaults to None. std (Sequence[Number], optional) - The pixel standard deviation of R, G, B channels. Defaults to None. size (tuple, optional) - Fixed padding size. size_divisor (int, optional) - The divisor of padded size. pad_val (float, optional) - Padding value. Default: 0. seg_pad_val (float, optional) - Padding value of segmentation map. Default: 255. bgr_to_rgb (bool) - whether to convert image from BGR to RGB. Defaults to False. rgb_to_bgr (bool) - whether to convert image from RGB to BGR. Defaults to False. batch_augments (list[dict], optional) - Batch-level augmentations. Default to None. The data will be processed as follows: Collate and move data to the target device. Pad inputs to the input size with defined pad_val, and pad seg map with defined seg_pad_val. Stack inputs to batch_inputs. Convert inputs from bgr to rgb if the shape of input is (3, H, W). Normalize image with defined std and mean. Do batch augmentations like Mixup and Cutmix during training. The parameters of the forward method: data (dict) - data sampled from dataloader. training (bool) - Whether to enable training time augmentation. The returns of the forward method: Dict: Data in the same format as the model input.","tags":["MMSegmentation"]},{"title":"MMSegmentation从0.x迁移到1.x","path":"/2024/08/23/MMSegmentation从0-x迁移到1-x/","content":"New dependencies MMSegmentation 1.x 依赖于一些新的软件包，建议准备一个新的干净环境,然后根据安装教程重新安装。 手动安装以下软件包。 MMEngine：MMEngine 是 OpenMMLab 2.0 架构的核心，我们将许多与计算机视觉无关的内容从 MMCV 拆分到 MMEngine 中。 MMCV：OpenMMLab 的计算机视觉包。这不是一个新的依赖，但您需要将其升级到 2.0.0 或以上的版本。 MMClassification（可选）：OpenMMLab 的图像分类工具箱和基准。这不是一个新的依赖，但您需要将其升级到 1.0.0rc6 版本。 MMDetection(可选): OpenMMLab 的目标检测工具箱和基准。这不是一个新的依赖，但您需要将其升级到 3.0.0 或以上的版本。 Train launchThe main improvement of OpenMMLab 2.0 is releasing MMEngine which provides universal and powerful runner for unified interfaces to launch training jobs. Function Original New Conclusion Loading pre-trained checkpoint --load_from=$CHECKPOINT --cfg-options load_from=$CHECKPOINT 将load_from放到cfg-options下 Resuming Train from specific checkpoint --resume-from=$CHECKPOINT --resume=$CHECKPOINT resume-from简化为resume Resuming Train from the latest checkpoint --auto-resume --resume=&#39;auto&#39; –auto-resume默认为true修改为可以有多个resume的值的变量 Whether not to evaluate the checkpoint during training --no-validate --cfg-options val_cfg=None val_dataloader=None val_evaluator=None –no-validate默认为true修改为val_cfg, val_dataloader,val_evaluator这几个有多个值的变量 Training device assignment --gpu-id=$DEVICE_ID - 删掉了可以指定gpu-id的配置 Whether or not set different seeds for different ranks --diff-seed --cfg-options randomness.diff_rank_seed=True 将diff-seed放到cfg-options下 Whether to set deterministic options for CUDNN backend --deterministic --cfg-options randomness.deterministic=True 将deterministic放到cfg-options下 Test launchHere’s the provided information formatted into a Markdown table: Function 0.x 1.x Conclusion Evaluation metrics --eval mIoU --cfg-options test_evaluator.type=IoUMetric –eval 修改为–cfg-options mIou修改为有多个值的test_evaluator.type Whether to use test time augmentation --aug-test --tta aug-test修改为tta Whether save the output results without perform evaluation --format-only --cfg-options test_evaluator.format_only=True –format-only修改为–cfg-options，默认值为true修改为有多个值的test_evaluator.format_only Configuration fileModel settingsNo changes in model.backbone, model.neck, model.decode_head and model.losses fields.model.backbone, model.neck, model.decode_head and model.losses和MMSeg0.x相同 Add model.data_preprocessor field to configure the DataPreProcessor, including: 相对于MMSeg0.x添加了model.data_preprocessor 字段 mean (Sequence, optional): The pixel mean of R, G, B channels. Defaults to None. std (Sequence, optional): The pixel standard deviation of R, G, B channels. Defaults to None. size (Sequence, optional): Fixed padding size. size_divisor (int, optional): The divisor of padded size. seg_pad_val (float, optional): Padding value of segmentation map. Default: 255. padding_mode (str): Type of padding. Default: ‘constant’. constant: pads with a constant value, this value is specified with pad_val. bgr_to_rgb (bool): whether to convert image from BGR to RGB.Defaults to False. rgb_to_bgr (bool): whether to convert image from RGB to BGR. Defaults to False. Dataset settingsChanges in data: The original data field is split to train_dataloader, val_dataloader and test_dataloader. This allows us to configure them in fine-grained. For example, you can specify different sampler and batch size during training and test. The samples_per_gpu is renamed to batch_size. The workers_per_gpu is renamed to num_workers. data字段拆分为train_dataloader, val_dataloader, test_dataloader三个字段，可以在训练集，测试集分别指定不同的sampler和batch_size, samples_per_gpu重命名为batch_size， workers_per_gpu重命名为num_workers Original 1234567data = dict( samples_per_gpu=4, workers_per_gpu=4, train=dict(...), val=dict(...), test=dict(...),) New 123456789101112131415train_dataloader = dict( batch_size=4, num_workers=4, dataset=dict(...), sampler=dict(type=&#x27;DefaultSampler&#x27;, shuffle=True) # necessary)val_dataloader = dict( batch_size=4, num_workers=4, dataset=dict(...), sampler=dict(type=&#x27;DefaultSampler&#x27;, shuffle=False) # necessary)test_dataloader = val_dataloader Changes in pipeline: The original formatting transforms ToTensor、ImageToTensor、Collect are combined as PackSegInputs. 将ToTensor, ImageToTensor, Collect组合为一个字段PackSegInputs. We don’t recommend to do Normalize and Pad in the dataset pipeline. Please remove it from pipelines and set it in the data_preprocessor field. Normalize和Pad修改为在data_preprocessor中设置 The original Resize in MMSeg 1.x has been changed to RandomResize and the input arguments img_scale is renamed to scale, and the default value of keep_ratio is modified to False. Resize修改为RandomResize，不知道这两种Resize方式是否相同，img_scale重命名为scale,功能应该是相同的，keep_ration的默认值修改为False. The original test_pipeline combines single-scale test and multi-scale test together, in MMSeg 1.x we separate it into test_pipeline and tta_pipeline. train_pipeline: Original 123456789101112train_pipeline = [ dict(type=&#x27;LoadImageFromFile&#x27;), dict(type=&#x27;LoadAnnotations&#x27;, reduce_zero_label=True), dict(type=&#x27;Resize&#x27;, img_scale=(2560, 640), ratio_range=(0.5, 2.0)), dict(type=&#x27;RandomCrop&#x27;, crop_size=crop_size, cat_max_ratio=0.75), dict(type=&#x27;RandomFlip&#x27;, prob=0.5), dict(type=&#x27;PhotoMetricDistortion&#x27;), dict(type=&#x27;Normalize&#x27;, **img_norm_cfg), dict(type=&#x27;Pad&#x27;, size=crop_size, pad_val=0, seg_pad_val=255), dict(type=&#x27;DefaultFormatBundle&#x27;), dict(type=&#x27;Collect&#x27;, keys=[&#x27;img&#x27;, &#x27;gt_semantic_seg&#x27;]),] new: 12345678910111213train_pipeline = [ dict(type=&#x27;LoadImageFromFile&#x27;), dict(type=&#x27;LoadAnnotations&#x27;, reduce_zero_label=True), dict( type=&#x27;RandomResize&#x27;, scale=(2560, 640), ratio_range=(0.5, 2.0), keep_ratio=True), dict(type=&#x27;RandomCrop&#x27;, crop_size=crop_size, cat_max_ratio=0.75), dict(type=&#x27;RandomFlip&#x27;, prob=0.5), dict(type=&#x27;PhotoMetricDistortion&#x27;), dict(type=&#x27;PackSegInputs&#x27;)] test_pipeline: Original: 123456789101112131415test_pipeline = [ dict(type=&#x27;LoadImageFromFile&#x27;), dict( type=&#x27;MultiScaleFlipAug&#x27;, img_scale=(2560, 640), # img_ratios=[0.5, 0.75, 1.0, 1.25, 1.5, 1.75], flip=False, transforms=[ dict(type=&#x27;Resize&#x27;, keep_ratio=True), dict(type=&#x27;RandomFlip&#x27;), dict(type=&#x27;Normalize&#x27;, **img_norm_cfg), dict(type=&#x27;ImageToTensor&#x27;, keys=[&#x27;img&#x27;]), dict(type=&#x27;Collect&#x27;, keys=[&#x27;img&#x27;]), ])] New 12345678910111213141516171819202122test_pipeline = [ dict(type=&#x27;LoadImageFromFile&#x27;), dict(type=&#x27;Resize&#x27;, scale=(2560, 640), keep_ratio=True), dict(type=&#x27;LoadAnnotations&#x27;, reduce_zero_label=True), dict(type=&#x27;PackSegInputs&#x27;)]img_ratios = [0.5, 0.75, 1.0, 1.25, 1.5, 1.75]tta_pipeline = [ dict(type=&#x27;LoadImageFromFile&#x27;, backend_args=None), dict( type=&#x27;TestTimeAug&#x27;, transforms=[ [ dict(type=&#x27;Resize&#x27;, scale_factor=r, keep_ratio=True) for r in img_ratios ], [ dict(type=&#x27;RandomFlip&#x27;, prob=0., direction=&#x27;horizontal&#x27;), dict(type=&#x27;RandomFlip&#x27;, prob=1., direction=&#x27;horizontal&#x27;) ], [dict(type=&#x27;LoadAnnotations&#x27;)], [dict(type=&#x27;PackSegInputs&#x27;)] ])] 将transfor从test_pipeline中拎出来放到tta_pipeline(Test Time Augmentation Pipeline，用于提高模型预测性能的模块。这个模块通过对输入图像进行一系列的变换和增强，然后将这些变换后的图像输入到模型中，最后将这些预测结果进行融合，以得到最终的预测结果。这样做可以有效地提高模型的鲁棒性和准确性。）中。 Changes in evaluation: The evaluation field is split to val_evaluator and test_evaluator. And it won’t support interval and save_best arguments. The interval is moved to train_cfg.val_interval, and the save_best is moved to default_hooks.checkpoint.save_best. pre_eval has been removed.单一的evaluation拆分为val_evaluator和test_evaluator同时删除了interval和save_best参数，interval放到了train_cfg.val_interval下，save_best放到了default_hooks.checkpoint.save_best下，删掉了pre_eval ‘mIoU’ has been changed to ‘IoUMetric’. Original： 1evaluation = dict(interval=2000, metric=&#x27;mIoU&#x27;, pre_eval=True) New: 12val_evaluator = dict(type=&#x27;IoUMetric&#x27;, iou_metrics=[&#x27;mIoU&#x27;])test_evaluator = val_evaluator Optimizer and Schedule settingsChanges in optimizer and optimizer_config: Now we use optim_wrapper field to specify all configuration about the optimization process. And the optimizer is a sub field of optim_wrapper now.将optimizer封装到optim_wrapper下。 paramwise_cfg is also a sub field of optim_wrapper, instead of optimizer.原本在optimizer下的optim_wrapper移动到了paramwise_cfg下。 optimizer_config is removed now, and all configurations of it are moved to optim_wrapper. 删除了optimizer_config。 grad_clip is renamed to clip_grad. grad_clip重命名为clip_grad。 Original 12optimizer = dict(type=&#x27;AdamW&#x27;, lr=0.0001, weight_decay=0.0005)optimizer_config = dict(grad_clip=dict(max_norm=1, norm_type=2)) New 1234optim_wrapper = dict( type=&#x27;OptimWrapper&#x27;, optimizer=dict(type=&#x27;AdamW&#x27;, lr=0.0001, weight_decay=0.0005), clip_grad=dict(max_norm=1, norm_type=2)) Changes in lr_config: The lr_config field is removed and we use new param_scheduler to replace it. 用param_scheduler替换掉了lr_config, 不知道内部是否做了修改 The warmup related arguments are removed, since we use schedulers combination to implement this functionality. 删除了warmup相关的参数，改用schedulers combination实现对应的功能。 The new schedulers combination mechanism is very flexible, and you can use it to design many kinds of learning rate &#x2F; momentum curves. See the tutorial for more details. 新的schedulers combination可以实现多种learning rate &#x2F; momentum curves。 Original： 12345678lr_config = dict( policy=&#x27;poly&#x27;, warmup=&#x27;linear&#x27;, warmup_iters=1500, warmup_ratio=1e-6, power=1.0, min_lr=0.0, by_epoch=False) New: 123456789101112param_scheduler = [ dict( type=&#x27;LinearLR&#x27;, start_factor=1e-6, by_epoch=False, begin=0, end=1500), dict( type=&#x27;PolyLR&#x27;, power=1.0, begin=1500, end=160000, eta_min=0.0, by_epoch=False, )] Changes in runner: Most configuration in the original runner field is moved to train_cfg, val_cfg and test_cfg, which configure the loop in training, validation and test.大部分原来的runner字段被移动到了train_cfg，val_cfg和test_cfg中 Original： 1runner = dict(type=&#x27;IterBasedRunner&#x27;, max_iters=20000) New: 1234# The `val_interval` is the original `evaluation.interval`.train_cfg = dict(type=&#x27;IterBasedTrainLoop&#x27;, max_iters=20000, val_interval=2000)val_cfg = dict(type=&#x27;ValLoop&#x27;) # Use the default validation loop.test_cfg = dict(type=&#x27;TestLoop&#x27;) # Use the default test loop. In fact, in OpenMMLab 2.0, we introduced Loop to control the behaviors in training, validation and test. The functionalities of Runner are also changed. You can find more details of runner tutorial in MMEngine. Runtime settingsChanges in checkpoint_config and log_config: The checkpoint_config are moved to default_hooks.checkpoint and the log_config are moved to default_hooks.logger. And we move many hooks settings from the script code to the default_hooks field in the runtime configuration. checkpoint_config被移动到了default_hooks.checkpoint， log_config 被移动到了 default_hooks.logger，从script code移动了很多hooks settings到runtime configuration中的default_hooks。 123456789101112131415161718default_hooks = dict( # record the time of every iterations. timer=dict(type=&#x27;IterTimerHook&#x27;), # print log every 50 iterations. logger=dict(type=&#x27;LoggerHook&#x27;, interval=50, log_metric_by_epoch=False), # enable the parameter scheduler. param_scheduler=dict(type=&#x27;ParamSchedulerHook&#x27;), # save checkpoint every 2000 iterations. checkpoint=dict(type=&#x27;CheckpointHook&#x27;, by_epoch=False, interval=2000), # set sampler seed in distributed environment. sampler_seed=dict(type=&#x27;DistSamplerSeedHook&#x27;), # validation results visualization. visualization=dict(type=&#x27;SegVisualizationHook&#x27;)) In addition, we split the original logger to logger and visualizer. The logger is used to record information and the visualizer is used to show the logger in different backends, like terminal and TensorBoard. 将original logger划分为logger和visualizer. logger用于记录信息， visualizer被用于以不同的后端显示logger（terminal和TensorBoard） Original： 123456log_config = dict( interval=100, hooks=[ dict(type=&#x27;TextLoggerHook&#x27;), dict(type=&#x27;TensorboardLoggerHook&#x27;), ]) New: 12345678default_hooks = dict( ... logger=dict(type=&#x27;LoggerHook&#x27;, interval=100),)vis_backends = [dict(type=&#x27;LocalVisBackend&#x27;), dict(type=&#x27;TensorboardVisBackend&#x27;)]visualizer = dict( type=&#x27;SegLocalVisualizer&#x27;, vis_backends=vis_backends, name=&#x27;visualizer&#x27;) Changes in load_from and resume_from: The resume_from is removed. And we use resume and load_from to replace it. 删除了resume_from，使用resume和load_from替代，不知道是否需要修改代码以适配。 If resume&#x3D;True and load_from is not None, resume training from the checkpoint in load_from. If resume&#x3D;True and load_from is None, try to resume from the latest checkpoint in the work directory. If resume&#x3D;False and load_from is not None, only load the checkpoint, not resume training. If resume&#x3D;False and load_from is None, do not load nor resume. Changes in dist_params: The dist_params field is a sub field of env_cfg now. And there are some new configurations in the env_cfg. Changes in dist_params: The dist_params field is a sub field of env_cfg now. And there are some new configurations in the env_cfg. dist_params作为一个子字段放到了env_cfg下。 12345678910env_cfg = dict( # whether to enable cudnn benchmark cudnn_benchmark=False, # set multi process parameters mp_cfg=dict(mp_start_method=&#x27;fork&#x27;, opencv_num_threads=0), # set distributed parameters dist_cfg=dict(backend=&#x27;nccl&#x27;),) Changes in workflow: workflow related functionalities are removed. workflow相关的功能被删除。 New field visualizer: The visualizer is a new design in OpenMMLab 2.0 architecture. We use a visualizer instance in the runner to handle results &amp; log visualization and save to different backends. See the visualization tutorial for more details. visualizer在OpenMMLab2.0中是一个新设计。 New field default_scope: The start point to search module for all registries. The default_scope in MMSegmentation is mmseg. See the registry tutorial for more details. default_scope是一个新加的字段 在MMSegmentation中default_scope是mmseg。","tags":["MMSegmentation"]},{"title":"JavaScript","path":"/2024/08/22/JavaScript/","content":"xxxxxxxxxx let fruits &#x3D; new Map();​fruits.set(“apple”, “red”);fruits.set(“banana”, “yellow”);​console.log(fruits.get(“apple”));​console.log(fruits.has(“lemon”));&#x2F;&#x2F; red&#x2F;&#x2F; falsejavascript123456789101112131415161718192021222324252627282930313233343536373839// Array.from() 和 fill() 示例// 创建一个包含 5 个 0 的数组let array1 = Array.from(&#123; length: 5 &#125;, () =&gt; 0);// 两个参数，一个字典（key为length），一个函数（返回每个元素）console.log(&#x27;Array.from() 填充 0:&#x27;, array1); // 输出: [0, 0, 0, 0, 0]// 用嵌套的 Array.from() 创建二维数组let n = 3;let dp = Array.from(Array(n + 1), () =&gt; Array(n + 1).fill(0));console.log(&#x27;二维数组 (dp):&#x27;, dp);// 输出: 一个 (n+1) 大小的二维数组，所有元素都填充为 0// Array.of() 示例let array2 = Array.of(1, 2, 3, 4, 5);// 和python array2 = [1, 2, 3, 4, 5]差不多console.log(&#x27;Array.of():&#x27;, array2); // 输出: [1, 2, 3, 4, 5]// sort() 示例（降序排序）let array3 = [3, 1, 4, 1, 5];array3.sort((a, b) =&gt; b - a);// 从小到大排序就是(a, b) =&gt; a - b, 从大到小排序就是(a, b) =&gt; b - aconsole.log(&#x27;排序后的数组:&#x27;, array3); // 输出: [5, 4, 3, 1, 1]// copyWithin() 示例let array4 = [1, 2, 3, 4, 5];array4.copyWithin(0, 3);console.log(&#x27;copyWithin(0, 3) 结果:&#x27;, array4);// 将2号位开始到数组末尾的元素搬到一号位开始的位置// 输出: [4, 5, 3, 4, 5] -&gt; 从索引 3 开始的元素被复制到起始位置// find() 示例let found = array4.find(element =&gt; element &gt; 4);console.log(&#x27;找到第一个大于 4 的元素:&#x27;, found); // 输出: 5// findIndex() 示例let index = array4.findIndex(element =&gt; element === 3);console.log(&#x27;第一个值为 3 的元素索引:&#x27;, index); // 输出: 2// fill() 示例let array5 = [1, 2, 3, 4, 5];array5.fill(9, 1, 3);console.log(&#x27;fill(9, 1, 3) 结果:&#x27;, array5);// 输出: [1, 9, 9, 4, 5] -&gt; 从索引 1 到 3 之间填充 9"},{"title":"积分图像编程实现","path":"/2024/08/21/积分图像编程实现/","content":"维基百科：积分图原图： 积分图： 积分图的每一点（x, y）的值是原图中对应位置的左上角区域的所有值得和 而且，积分图可以只遍历一次图像即可有效的计算出来，因为积分图每一点的（x, y）值是： 一旦积分图计算完毕，对任意矩形区域的和的计算就可以在常数时间内完成。如右图中，阴影矩形区域的值：","tags":["算法"]},{"title":"vue前端开发框架概述","path":"/2024/08/21/vue前端开发框架概述/","content":"渐进式JavaScript框架渐进式（Progressive）：逐步集成：这意味着你可以从项目中的一部分开始使用Vue.js，而不需要全面重构。例如，你可以先在一个小部件中使用Vue.js，然后逐渐扩展到整个应用程序。易用性：Vue.js的设计注重易用性，使得开发者可以快速上手，即使他们之前没有使用过类似的框架。 JavaScript框架：基于JavaScript：Vue.js是一个基于JavaScript的库，它使用HTML、CSS和JavaScript来构建用户界面。框架特性：虽然Vue.js被宣传为一个框架，但它实际上是一个库，因为它不强制你遵循特定的项目结构或代码组织方式。但是，它提供了足够的工具和特性，如组件系统、状态管理、路由等，使其在功能上接近于一个框架。 完全响应式的渲染系统“完全响应式的渲染系统”是Vue.js的一个核心特性，它指的是Vue.js能够自动追踪依赖并在数据变化时更新DOM的能力。 响应式数据绑定Vue.js的响应式系统基于Object.defineProperty()（Vue 2.x）或Proxy（Vue 3.x）实现，它使得Vue实例中的数据对象变得“响应式”。这意味着当数据对象的属性被访问或修改时，Vue能够自动检测到这些变化，并且可以执行相应的操作。 响应式原理依赖收集：当组件渲染时，它会访问所需数据的属性，Vue会记录这些属性的访问，这个过程称为“依赖收集”。每个属性都关联一个或多个观察者（Watcher）。变更检测：当数据发生变化时，Vue会通知所有依赖于该数据的观察者。重新渲染：观察者接收到数据变更的通知后，会触发组件的重新渲染过程，Vue会高效地更新DOM以反映最新的数据状态。 完全响应式的特点自动更新：开发者不需要手动操作DOM来更新视图，Vue会自动完成这一过程。最小化DOM操作：Vue的渲染系统会智能地计算出需要变更的最小DOM集合，并只更新这部分，从而提高性能。声明式：Vue使用声明式渲染，开发者只需描述应用的状态，Vue会负责状态的变更到视图的映射。声明式编程是一种编程范式，它关注于“要做什么”，而不是“如何去做”。在声明式渲染中，你只需要描述应用的最终状态，而Vue.js会负责根据这些描述来更新实际的DOM。一个简单的Vue声明式渲染的例子： 123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;reverseMessage&quot;&gt;反转消息&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;); &#125; &#125;&#125;);&lt;/script&gt; 在这个例子中： 是一个插值表达式，它声明了标签的内容应该与Vue实例的message数据属性绑定。v-on:click&#x3D;”reverseMessage” 是一个事件监听器指令，它声明了当按钮被点击时，应该调用reverseMessage方法。当reverseMessage方法被调用，message的值会被反转，由于Vue的响应式系统，插值表达式会自动更新，显示反转后的消息，而不需要开发者手动操作DOM。 组件化：响应式系统在组件级别上工作，每个组件都有自己的响应式数据，组件的状态变化只会影响该组件的DOM，不会影响其他组件。 一个前端开发框架，封装了常用的前端开发wheels,提高了程序员前端开发的效率 组件化开发 声明式渲染 双向数据绑定 指令系统 过渡效果 路由管理 状态管理 工具链 社区和生态系统 文档和教程 跨平台开发","tags":["前端开发","Vue"]},{"title":"计算机学习之实践分析","path":"/2024/08/20/计算机学习之实践分析/","content":"有兴趣肯动手成为一种优势的前提是能够将这些实践经验用于学习对应的理论（这种理论在有实践经验下学习可以弥补和别人不动手直接学和自己肯动手这件事情本身所用的时间之差）"},{"title":"MMSegmentation如何集成tensorboard","path":"/2024/08/19/MMSegmentation如何配置tensorboard/","content":"VisualizationMMSegmentation 1.x provides convenient ways for monitoring training status or visualizing data and model predictions. Training status MonitorMMSegmentation 1.x uses TensorBoard to monitor training status. TensorBoard ConfigurationInstall TensorBoard following official instructions e.g. 12pip install tensorboardXpip install future tensorboard Add TensorboardVisBackend in vis_backend of visualizer in default_runtime.py config file:12345vis_backends = [dict(type=&#x27;LocalVisBackend&#x27;), dict(type=&#x27;TensorboardVisBackend&#x27;)] visualizer = dict( type=&#x27;SegLocalVisualizer&#x27;, vis_backends=vis_backends, name=&#x27;visualizer&#x27;) Modify the config file12345678910111213...vis_backends = [ dict(type=&#x27;LocalVisBackend&#x27;), dict(type=&#x27;TensorboardVisBackend&#x27;)]visualizer = dict( name=&#x27;visualizer&#x27;, type=&#x27;SegLocalVisualizer&#x27;, vis_backends=[ dict(type=&#x27;LocalVisBackend&#x27;), dict(type=&#x27;TensorboardVisBackend&#x27;) ])... Examining scalars in TensorBoardLaunch training experiment e.g. 12345python tools/train.py configs/pspnet/pspnet_r50-d8_4xb4-80k_ade20k-512x512.py --work-dir work_dir/test_visual``` Find the vis_data path of work_dir after starting training, for example, the vis_data path of this particular test is as follows: ```bashwork_dirs/test_visual/20220810_115248/vis_data The scalar file in vis_data path includes learning rate, losses and data_time etc, also record metrics results and you can refer logging tutorial in MMEngine to log custom data. The tensorboard visualization results are executed with the following command: 1tensorboard --logdir work_dirs/test_visual/20220810_115248/vis_data"},{"title":"从bilibili我是小土堆up主那里学习到的软件开发经验","path":"/2024/08/18/从bilibili我是小土堆up主那里学习到的软件开发经验/","content":"打造高效的软件开发工作流高效的软件开发工作流是软硬件协同，对瑞士军刀式的工具首先要正反两面地分析，不同工具组合带来的综合能力才是真正的“瑞士军刀”","tags":["开发效率"]},{"title":"工匠精神","path":"/2024/08/17/工匠精神/","content":"工匠精神在竞争激烈的社会中是保持竞争优势的重要素质工匠精神不是一味的增加工作时间，而是在看准方向后的认真工作，需要抵制诱惑，虽然在AI时代可能通过广泛的涉猎对使用AI有一定的好处，但从提升判断力的角度，只追求广度是不行的，光有广度不代表就有很强的判断力，且AI现在的体系还不能完全排除人工的介入，在确定方向后，对我自己的学习情况来说，一定程度上地发扬“工匠精神”是短期提升判断力的关键。"},{"title":"英语","path":"/2024/08/16/英语/","content":"多学会一门语言，就多掌握一种思维方式falter“Falter” means to hesitate or waver in one’s actions or intentions, often due to uncertainty or lack of confidence. It can also refer to a physical unsteadiness or a weakening in one’s performance or strength.Example sentence: The speaker faltered when she forgot her next point in the speech. His confidence in the business plan started to falter after the market analysis. Spur“Spur” can be both a noun and a verb.As a noun, a spur is a small pointed device attached to a rider’s boot, used to urge a horse to move faster. It can also refer to something that prompts or encourages a action or process.As a verb, to spur means to encourage or stimulate someone or something to do something more quickly or with more energy.Example sentences: Noun: The cowboy wore spurs to control his horse. Verb: The company’s new policy is designed to spur innovation among its employees. landscape“Landscape” refers to the physical features of a piece of land, including natural elements like mountains, rivers, and trees, as well as man-made structures like buildings and roads. It’s often used to describe the overall appearance of an area of land, whether in a natural, rural setting or an urban environment.Example sentence: “The photographer took a stunning picture of the mountain landscape at sunset.” fine-grained“Fine-grained” refers to something that is very detailed or intricate. It is often used to describe materials, data, or analysis that involves small, distinct parts or elements. For example, in the context of data analysis, “fine-grained data” would mean data that is very detailed and specific, allowing for a deep level of understanding or analysis.Example sentence: The researcher used fine-grained analysis to understand the intricate details of the data. unified“Unified” means to bring together separate elements into a single, cohesive whole. It often refers to the process of combining different things or groups to function as one. For example, “The company aims to unify its various departments to improve communication and efficiency.”In a sentence: “The new software successfully unified the data from different sources, making it easier to analyze.” delineating“Delineating” means outlining or defining something clearly. It’s often used to describe the act of drawing a clear boundary or explaining something in detail. For example, in a scientific report, you might delineate the different stages of a process.Example sentence: The architect delineated the plans for the new building, showing every detail of the structure. sliceThe word “slice” can be used both as a noun and a verb in English.As a noun: A thin, flat piece cut from something, such as a piece of cake, meat, or cheese. Example: She cut a slice of cake for everyone at the party. A share or portion of something. Example: He wants a bigger slice of the profits.As a verb: To cut something into thin, flat pieces. Example: She sliced the tomatoes for the salad. To hit a ball in a way that makes it spin sideways, causing it to curve in the air. Example: The golfer sliced his drive into the rough.In summary, “slice” refers to cutting something into thin pieces or a share of something, and can also describe a type of swing or hit in sports like golf. facilitating“Facilitating” means making something easier or more likely to happen. It involves helping a process or activity to run smoothly and effectively. For example, in a meeting, a facilitator helps guide the discussion and ensures everyone has a chance to speak.Example sentence: The new software is designed to facilitate communication between different departments in the company. dynamicDynamic is an adjective that describes something that is always changing or moving. It can also refer to a process or system that is active and capable of changing or being changed. For example, in a business context, a “dynamic market” is one that is constantly changing.Example sentence: The dynamic nature of technology means that new innovations are always emerging."},{"title":"从AI编程认知AI","path":"/2024/08/16/从AI编程认知AI/","content":"输入输出全是文本的场景，尝试用大模型去提效 软件开发领域市场调研需求分析PRD撰写图形元素绘制技术选型代码生成(文本输入+GPT4V)代码审查编写测试用例运维 最好最新的模型带来更好更新的能力编程能力是大模型各项能力的天花板 技术leader 训练数据质量高结果可衡量编程语言无二义性训练编程可提高大模型的推理能力 使用AI编程，除了解决编程问题以外，更重要是形成对AI的正确认知。 AI编程的适用场景1.技术我懂，不想自己写。 帮我完成重复性工作 帮我完成也要费费脑子才能写出来代码2.技术不大懂，让AI先做，自己边用边学。 当心ta犯错 当心给的不是最佳方案 如果完全不懂技术，AI编程的帮助不大 如果一个机器绝对不会犯错，它就不可能是智能的。-阿兰图灵AI的幻觉不可完全消除，只能尽可能压制。所以，使用者的判断力，决定了AI能力的上限.就像团队领导，是团队的上限一样。 AI能力定律：AI能力的上限，是使用者的判断力 。AI能力 &#x3D; min(AI能力，使用者判断力)。 AI提效定律：AI提升的效率，与使用者的判断力成正比，与生产力成反比 。效率提升幅度 &#x3D; 使用者判断力&#x2F;使用者生产力。 解读 使用者的判断力，是最重要的。 提升判断力，比提升实操能力更重要。所谓”眼高手低”者的福音。（认知水平高也需要持续地努力，不要认为懒就是眼高） 广阔的视野是判断力的养料。 任何东西都有两面性，GPT也不例外，需要抑制使用它的缺点，发扬使用它的优点，可以不那么严谨地类比搜索引擎对使用它的人影响。","tags":["prompt"]},{"title":"软件工程师沉淀","path":"/2024/08/15/软件工程师沉淀/","content":"到底是学的多好还是学的深入好?如果学的是是技术的经典理论的话，那么毫无疑问是学的多更好，前提是能够学懂学好。如果是学习技术应用的话，需要知道的是应用是基于底层技术的上层建筑，如果从底层技术的角度分析，那么大多数技术应用在技术底层是同质化严重的，如果沉迷于学的多，对于通过项目来引导理论学习的人来说，可能会无法触及的更深层次的技术理论，从而在对技术的理解上显得局限，虽然这个和性格也有一定关系，但我认为软件工程师认真地学精可能比粗略地学广泛更有意义。 技术不是逃避现实问题的手段，剑需要有人能够挥动才能发挥作用。"},{"title":"翁恺Java语言程序设计学习心得","path":"/2024/08/12/翁恺Java语言程序设计学习心得/","content":"对我而言是一门编程启蒙课，更多的是偏认知的学习，比如: 对于程序员学习角度来说，不要害怕去在电脑上编程，大不了重启一下电脑，对电脑没啥影响，可以学习到东西才是相对重要的。 对于程序实现的信心：只要我想做某个程序，且这个程序比较有趣，有足够多的时间和精力去做时，我是能够做出一些可运行的版本甚至是让我自己觉得有成就感的程序的。 好的程序员从我观察来看都具备非常优秀的软件思维，但这究竟是不是我现阶段应该重点关注的重点，我现在的观点是不是，从github的优秀开源项目中可以看出，好的软件开发项目不是一蹴而就的，即便是厉害的程序员，都是采用一种迭代式开发的流程，如果一开始就想构思出一个非常完美的软件项目，很容易陷入一种空想主义中而脱离实际开发情况，从我的角度来看，在“做”中不断锤炼优秀的软件思维才是合理的程序员成长路径，一个有大量开发经验即便不主动学习优秀软件思维的程序员或多或少也能自己总结出很多软件思维的，我的悟性尚能满足我学习的需要，我所需要做的就是不断训练自己在编程中兼顾实现与编程思维两者的平衡，程序的价值最终可能不仅只是技术本身，还有产品相关的能力，这也是程序员必须思考的问题，持续进行版本迭代也很重要，这可以帮助程序员建立全局观念，不局限于低效的代码学习中，技术的本质是分析和解决问题的能力，对于程序员来说，同样是技术人员，只是工具是电脑，我的目标应该是成为一名优秀的软件工程师。"},{"title":"pytorch中相关概念","path":"/2024/08/10/pytorch中相关概念/","content":"tensor在PyTorch中，torch.Tensor是存储和变换数据的主要工具。 Tensor与Numpy的多维数组非常相似。 Tensor还提供了GPU计算和自动求梯度等更多功能，这些使Tensor更适合深度学习。 123456x = torch.empty(5,3)x = torch.rand(5,3)x = torch.randn(2,3)x = torch.zeros(5,3,dtype=long)x = torch.tensor([5.5,3])... torch.nn.Conv2d","tags":["深度学习","pytorch"]},{"title":"如何读懂大型软件项目源代码?","path":"/2024/08/07/如何读懂大型软件项目源代码/","content":"用好Notion软件，利用此软件可以按层级关系将零散代码逻辑在脑海中形成一个整体框架，也可以结合xmind等软件更直接地展示代码结构。 运行软件项目，通过输入输出来给人脑提供关键代码链路的思绪。比如如果项目是用python语言构建的，通过添加print语句实现变量的跟踪。还可以利用代码调试功能，比如断点，逐步执行代码，实时查看变量变化和函数调用情况。 利用好visio这类软件表示更多的逻辑关系。还可以使用 UML 图（如类图、时序图）来表示系统的静态结构和动态行为，这可以帮助更好地理解面向对象设计。 分清楚影响理解框架代码的原因是啥，如果是各个小的模块理解错误，那就需要逐个击破来理解整体。在理解小模块时，可以结合单元测试。编写和运行单元测试不仅能验证模块功能，还能帮助理解模块的输入输出和依赖关系。 对大的目录进行归纳总结，最好是记录在Notion上，记录关键模块、类、函数的作用和关系，以便日后查阅，因为代码较多，后续如果再来看可能忘记了，忘记了就需要再看一遍，相当于思维不集中会影响效率，有些时候可能总结的内容（也就是压缩过的内容）就足以理解了 需要高度集中，最好进入心流状态，最好用一整段时间去理解，下次理解相当于需要再从代码和文档中找到当时的理解水平。 IDE的全局关键字检索功能很有用，比如vscode可以显示所有包含指定关键字的文件引用，可以帮助构建代码框架逻辑。VSCode甚至系统都要将其视为软件的一部分，任何能够辅助代码理解的设计都可以用上，软件项目开发者设计项目时参考了面向对象设计规范，同样分析别人写的代码也可以采用面向对象的方法对代码进行简化。越是优秀的代码越可以通过面向对象的方法进行简化。除了 VSCode，还可以使用更专业的代码搜索工具，如 Sourcegraph 或 Opengrok，支持跨项目搜索和代码导航。 面向对象思维，通过对象，模块，组件来构建系统的认识。可以学习设计模式（Design Patterns），如《设计模式：可复用面向对象软件的基础》一书中提到的23种经典设计模式，帮助理解和应用面向对象思想。 明确改动哪些地方对系统运行有影响，哪些地方改动对系统没有影响及如何在系统上增加功能，如何在增加功能的同时不破坏原有系统的优良设计，如何重构原来系统中不合理的逻辑设计。在进行代码改动前，可以使用代码覆盖率工具（如 Coverage.py）和静态代码分析工具（如 SonarQube），评估改动的潜在影响和风险。 阅读官方文档，理解开发者的设计思路。还可以查阅社区文档、技术博客和开发者论坛，获取更多实战经验和最佳实践。 算法能力的学习，大型软件项目一般开发人员水平较高，用到了大量数据结构与算法的思想，如果算法能力不足再看到相关代码实现会觉得理解不足或觉得这些算法是框架本身的创新。建议系统学习算法与数据结构，可以参考《算法导论》（CLRS）这本书，并在 LeetCode、HackerRank 等平台上实践。 如果能问原开发者还是要先问，理解框架的目的就是应用框架，如何快速的掌握一个框架的能力是追求的目标，然后再谈框架的进阶理解，否则进阶学习也是低效的。在问原开发者时，可以提前准备好问题，并尝试提出一些自己的理解和解决方案，展示你的思考过程，往往能得到更有针对性的指导。 不要排斥打开编辑器看项目源码，就和新手程序员不会看报错信息一样，因为其中包含着指引，这是大量项目经验才能养成这种习惯，如果想要快速迭代技术能力，需要学会去延伸。 程序员的理解能力很重要。对任何能够通过编译器器检查的代码先要有基本的尊重，如果想站在别人的代码基础上提高开发效率，必须要理解别人的代码，这期间可以反思哪些代码质量不高，可以如何改进，程序员是一种特殊的用户，适当抱着看看用户是如何想的思维进行代码理解工作。对于本来就优秀的代码，要能够像看报错信息那样有耐心的理解。","tags":["项目开发经验"]},{"title":"python面向对象总结","path":"/2024/08/03/python面向对象总结/","content":"何为面向对象？类：图纸父类：可以理解为基础类，这里需要正确理解父类这个名词所包含的等级高的信息，父类中的属性和方法是一个基础子类：从父类中衍生出来的类，具备父类中的基础，可以在父类上做扩展方法，也可以重写父类的方法和属性注意：父类不代表比子类更丰富，子类拓展父类，这里不能通过等级层次去理解，更合理的方法是从进化的角度分析这两个概念 对象：根据图纸造出来的车继承：python中子类会继承父类的方法和属性，包括私有属性和私有方法，但通常不建议使用它们 封装：主要利用私有属性和私有方法实现封装，好处就是修改这个类的内部方法而不影响使用这个类的代码（比如有更优的算法可以实现排序，那就可以直接替换封装好的类的排序方法而不用改动调用这个类的代码） 多态：多态允许使用一个单一类型的实体（如变量，函数，接口）来代表多种类型的对象，简单来说，多态就是“一个接口，多种实现”。 代码例子： 123456789101112131415161718192021222324252627282930313233class Animal: def speak(self): passclass Dog(Animal): def speak(self): return &quot;Woof!&quot;class Cat(Animal): def speak(self): return &quot;Meow!&quot;class Duck(Animal): def speak(self): return &quot;Quack!&quot;def animal_sound(animal): print(animal.speak())# 创建不同的动物对象dog = Dog()cat = Cat()duck = Duck()# 使用相同的函数调用不同对象的方法animal_sound(dog) # 输出: Woof!animal_sound(cat) # 输出: Meow!animal_sound(duck) # 输出: Quack!# 多态性在集合中的应用animals = [Dog(), Cat(), Duck()]for animal in animals: animal_sound(animal) 可以看到多态的几个关键特点: 方法重写: 每个子类(Dog, Cat, Duck)都重写了父类Animal的speak()方法。这允许每个子类提供自己的实现。统一接口: 所有的动物类都有一个speak()方法,这提供了一个统一的接口。运行时多态: animal_sound()函数接受一个Animal类型的参数,但它可以处理任何Animal的子类。在运行时,Python会调用对象实际类型的speak()方法。灵活性: 我们可以轻松地添加新的动物类(如Cow),只要它实现了speak()方法,就可以无缝地与现有代码工作。 如何理解多态？通过编写处理父类对象的代码，这些代码可以用于所有的子类对象，即通过父类就可以实现（批量&#x2F;统一）管理不同的子类对象，这些子类对象继承父类有多种实现，差不多等于多态的子类对象。 如何理解对象和类class的关系？图纸和图纸造出来的东西的关系，在看项目源代码时，看到class很容易就想是不是这个类里面的代码完成了对应的功能，从最终执行来说，确实是这样，但准确来说这不是面向对象编程(oop)的思想，按照oop来说是这个class构造的对象实现了相关的功能，oop中一切皆是对象，这里我还没有从传统的顺序执行的代码编程中跳出来。 设计类class的原则单一职责原则（SRP）：一个类应该只有一个引起变化的原因。这意味着一个类应该只负责一项功能或一组紧密相关的功能。开放&#x2F;关闭原则（OCP）：类应该对扩展开放，对修改关闭。这意味着你应当能够扩展一个类的行为，而不需要修改其源代码。里氏替换原则（LSP）：派生类必须能够替换其基类。这意味着基类和派生类应该能够互相替换，而不影响程序的正确性。接口隔离原则（ISP）：不应该强迫客户依赖于它们不使用的接口。这意味着一个类不应该实现它不需要的方法。依赖倒置原则（DIP）：高层模块不应该依赖于低层模块，它们都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。封装：隐藏内部实现细节，只暴露必要的接口。这有助于减少系统各部分之间的依赖关系。重用：尽可能重用代码。这可以通过创建可重用的类和模块来实现。灵活性：设计时要考虑未来可能的变化，使类和模块易于修改和扩展。简洁性：避免不必要的复杂性。类应该简单、直接，易于理解。可测试性：类应该易于测试。这通常意味着它们应该具有清晰的职责，并且应该尽量减少依赖关系。 包装类（Wrapper Class）子类和包装类的区别和联系a. 继承关系子类：继承自一个父类，子类拥有父类的属性和方法，并可以对其进行扩展或重写。包装类：包装类通常是final类，不能被继承。这意味着你不能创建一个继承自包装类的子类。例如，Integer类是final的，不能被继承。b. 扩展能力子类：子类可以通过继承父类的属性和方法，并添加新的功能。通过多态，子类对象可以被看作父类对象使用。包装类：包装类不能被继承，因此不能扩展。但是它们提供了基本类型的对象化功能和一些额外的实用方法。c. 多态性子类：子类对象可以被赋值给父类引用，体现了多态性。例如，Animal类的子类Dog可以被赋值给Animal类型的变量。包装类：包装类不是基本类型的子类，所以不能将基本类型赋值给包装类变量，反之亦然。需要通过装箱和拆箱来转换。 总结联系：包装类是基本类型的对象化表示，通过装箱和拆箱机制，使得基本类型可以作为对象使用。它们和基本类型密切相关，但并不继承自基本类型。区别：包装类通常是final类，不能继承，不能扩展。而子类可以继承和扩展父类的功能，支持多态性。包装类主要用于在需要对象的地方表示基本类型，同时提供了额外的实用功能。 自定义类的包装类自定义包装类可以为原始类提供额外的功能、接口或封装逻辑，同时保持对原始类的控制。比如，你可以为一个类提供额外的验证逻辑、线程安全功能，或者通过包装类实现某些设计模式。 示例：自定义类及其包装类我们先定义一个简单的类，然后为它编写一个包装类。 原始类：Person 123456789101112131415161718192021222324252627282930public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;name=&#x27;&quot; + name + &quot;&#x27;, age=&quot; + age + &quot;&#125;&quot;; &#125;&#125; 包装类：PersonWrapper我们可以创建一个包装类 PersonWrapper，它包含一个 Person 对象，并提供额外的功能。 123456789101112131415161718192021222324252627282930313233343536373839public class PersonWrapper &#123; private Person person; public PersonWrapper(Person person) &#123; this.person = person; &#125; public String getName() &#123; return person.getName(); &#125; public int getAge() &#123; return person.getAge(); &#125; // 提供额外的功能 public void printGreeting() &#123; System.out.println(&quot;Hello, &quot; + person.getName() + &quot;! You are &quot; + person.getAge() + &quot; years old.&quot;); &#125; // 你还可以通过包装类对原始类的行为进行控制或修改 public void setName(String name) &#123; System.out.println(&quot;Setting name to: &quot; + name); person.setName(name); &#125; public void setAge(int age) &#123; if (age &gt; 0) &#123; person.setAge(age); &#125; else &#123; System.out.println(&quot;Invalid age!&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;PersonWrapper&#123;person=&quot; + person + &quot;&#125;&quot;; &#125;&#125; 使用包装类 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; Person person = new Person(&quot;Alice&quot;, 30); PersonWrapper personWrapper = new PersonWrapper(person); // 使用包装类调用原始类的方法 System.out.println(&quot;Name: &quot; + personWrapper.getName()); System.out.println(&quot;Age: &quot; + personWrapper.getAge()); // 使用包装类提供的额外功能 personWrapper.printGreeting(); // 通过包装类修改原始类的属性 personWrapper.setName(&quot;Bob&quot;); personWrapper.setAge(25); System.out.println(personWrapper); &#125;&#125; 包装类的应用场景自定义包装类的用例很多，包括但不限于： 增强功能：为已有的类增加新的方法或属性，而不需要修改原始类。代理模式：包装类可以在某些情况下代理对原始类的访问，常用于控制访问或延迟初始化。装饰模式：通过包装类为原始类添加新功能，而不改变其结构。适配器模式：包装类可以作为适配器，将一个类的接口转换为另一个类的接口。总结虽然在语言内置的包装类中，通常是为基本类型设计的，但你完全可以为自定义类创建包装类。这种设计可以帮助你扩展类的功能，增强代码的灵活性和可维护性。 class就是对多个对象进行如何交互的说明, new一个class的对象后就可以对多个对象进行交互，这些待交互的对象又是通过其它的class创建的，可以一直追溯到计算机的底层原理。(可以结合gcc新版本是用旧版本的gcc编译的)"},{"title":"使用MMSegmentation进行语义分割","path":"/2024/07/21/使用MMSegmentation进行语义分割/","content":"文章来源：https://zhuanlan.zhihu.com/p/393070556 一、前言本实例将通过使用语义分割，将道路在实际场景中分割出来，从而为无人驾驶小车提供道路信息和前进方向信息。 语义分割作为计算机视觉中一项基础任务，同时在自动驾驶&#x2F;视频编辑等领域中有重要的应用，因此一直受到学术界和工业界的广泛关注。在近几年的会议中，语义分割的论文层出不穷，但是市面上一直缺乏一款能够相对公平比较各种方法的框架。为了方便研究员和工程师们，MMLab开源了一套基于 PyTorch 实现的标准统一的语义分割框架：MMSegmentation。 https://github.com/open-mmlab/mmsegmentation 在 MMSeg 下，其复现和比较了很多语义分割的算法，并对训练测试的超参进行了优化和统一，在精度，速度，稳定性等方面都超过目前开源的其他代码库。 MMSegmentationMMSegmentation 保持了 MM 系列一贯的风格，拥有灵活的模块化设计和全面的高性能model zoo。目前支持18种算法，大部分算法都提供了多种 setting 以及在 Cityscapes，ADE20K，Pascal VOC 2012上的训练结果（目前应该是语义分割中最大的 模型库）。 https://github.com/open-mmlab/mmsegmentation/blob/master/docs/dataset_prepare.md#nighttime-driving) MMSeg 作为全新的语义分割框架，和其他的框架相比，它提供了更强更快的主流算法，统一超参的公平比较，附带丰富的配置文件和五花八门的 tricks，而且非常灵活易于拓展。 二、制作数据集使用Labelme来标注自己的数据集： https://github.com/wkentaro/labelme https://blog.csdn.net/u014061630/article/details/88756644 1. Labelme介绍Labelme 是一个图形界面的图像标注软件。用 Python 语言编写的，图形界面使用的是 Qt（PyQt）。 labelme作用： 对图像进行多边形，矩形，圆形，多段线，线段，点形式的标注（可用于目标检测，图像分割，等任务）。 对图像进行进行 flag 形式的标注（可用于图像分类 和 清理 任务）。 视频标注 生成 VOC 格式的数据集（for semantic &#x2F; instance segmentation） 生成 COCO 格式的数据集（for instance segmentation） 2.Labelme安装首先安装Anaconda： https://www.cnblogs.com/dream-it-possible/p/14301540.html 然后运行以下命令： 1234567891011121314151617181920#################### for Python 2 ####################conda create --name=labelme python=2.7source activate labelme# conda install -c conda-forge pyside2conda install pyqtpip install labelme# 如果想安装最新版本，请使用下列命令安装：# pip install git+https://github.com/wkentaro/labelme.git#################### for Python 3 ####################conda create --name=labelme python=3.6source activate labelme# conda install -c conda-forge pyside2# conda install pyqtpip install pyqt5 # pyqt5 can be installed via pip on python3pip install labelme 使用labelme命令打开标注界面 点击Open_Dir打开需要标注的数据集，这里分两类数据集，可行驶区域(darea)，背景(background)，标注如下图所示。 点击左侧create polygons，依次标定点，使其形成闭合区域，写明所标类别，这里背景可以选择不标注。 标定后保存，会自动生成一个.json的文件，这个.json文件和你的图片放在一起就好。 使用命令 1git clone https://github.com/wkentaro/labelme.git 下载labelme支持文件。 但是需要注意的是，mmsegmentation同mmdetection一样，有一些固定的数据集格式。在目标检测中，最为常见的当属COCO和VOC两种格式了。 对于语义分割来说，我们这里按照VOC数据对标注好的数据进行转化。转化方式非常简单，只使用labelme即可。 读者可以在&#x2F;labelme&#x2F;examples&#x2F;semantic_segmentation&#x2F;下：制作一份labels.txt文件：__ignore__和_background_是要写在最前面的。然后后面依次写上你的类名即可。 运行指令： 1python ./labelme2voc.py data_annotated data_dataset_voc --labels labels.txt 其中： data_annotated: 是用Labelme标注好的数据文件夹(图片与.json一一对应)。 data_dataset_voc：是生成的VOC格式的数据集。 得到数据集如下： 其中，JPEGImages是原始图片，SegmentationClass存储的是.npy格式的标注数据。SegmentationClassPNG是标注图片。SegmentationClassVisualization是原图与标注区域的mask格式。 就此数据集准备完毕。 三、环境搭建1.环境搭建这里建议使用anaconda安装对应环境 先使用conda创建一个独立的测试环境 12conda create --name=mmsegmentation python=3.7.0conda activate open-mmlab 接下来安装pytorch首先使用命令查看当前环境的cuda版本： 在C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA目录下查看cuda版本 或cmd执行 1nvcc -V 可以看到这里cuda版本为11.1，对照自己的cuda和pytorch版本，具体可参考：https://pytorch.org/get-started/locally/ 这里我们安装pytorch1.8.1，使用如下命令： 1pip install torch==1.8.0+cu111 torchvision==0.9.1+cu111 -f https://download.pytorch.org/whl/torch_stable.html 注意这里的cu111指cuda版本为11.1，读者需要替换为自己所需的版本 下面安装mmcv库，一定要注意对照自己的cuda和pytorch版本，具体可参考：https://mmcv.readthedocs.io/en/latest/get_started/installation.html 1pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/cu111/torch1.8.0/index.html 接下来下载mmsegmentation支持文件 1pip install git+https://github.com/open-mmlab/mmsegmentation.git # install the master branch 通过以上命令安装mmsegmentation运行必要环境，此外，还需在mmsegmentation根目录下运行以下命令进行补充。 1pip install -r requirements.txt 待安装完毕环境即搭建完成。 2.验证环境为了验证 MMSegmentation 和它所需要的环境是否正确安装，我们可以使用样例 python 代码来初始化一个 segmentor 并推理一张 demo 图像。 1234567891011121314151617181920212223from mmseg.apis import inference_segmentor, init_segmentorimport mmcvconfig_file = &#x27;configs/pspnet/pspnet_r50-d8_512x1024_40k_cityscapes.py&#x27;checkpoint_file = &#x27;checkpoints/pspnet_r50-d8_512x1024_40k_cityscapes_20200605_003338-2966598c.pth&#x27;# 从一个 config 配置文件和 checkpoint 文件里创建分割模型model = init_segmentor(config_file, checkpoint_file, device=&#x27;cuda:0&#x27;)# 测试一张样例图片并得到结果img = &#x27;test.jpg&#x27; # 或者 img = mmcv.imread(img), 这将只加载图像一次．result = inference_segmentor(model, img)# 在新的窗口里可视化结果model.show_result(img, result, show=True)# 或者保存图片文件的可视化结果# 您可以改变 segmentation map 的不透明度(opacity)，在(0, 1]之间。model.show_result(img, result, out_file=&#x27;result.jpg&#x27;, opacity=0.5)# 测试一个视频并得到分割结果video = mmcv.VideoReader(&#x27;video.mp4&#x27;)for frame in video: result = inference_segmentor(model, frame) model.show_result(frame, result, wait_time=1) 当您完成 MMSegmentation 的安装时，上述代码应该可以成功运行。 此外还可以使用demo脚本可视化单张图片， 1python demo/image_demo.py $&#123;IMAGE_FILE&#125; $&#123;CONFIG_FILE&#125; $&#123;CHECKPOINT_FILE&#125; [--device $&#123;DEVICE_NAME&#125;] [--palette-thr $&#123;PALETTE&#125;] 样例： 12python demo/image_demo.py demo/demo.jpg configs/pspnet/pspnet_r50-d8_512x1024_40k_cityscapes.py \\ checkpoints/pspnet_r50-d8_512x1024_40k_cityscapes_20200605_003338-2966598c.pth --device cuda:0 --palette cityscapes 推理的 demo 文档可在此查询：demo&#x2F;inference_demo.ipynb 。 四、配置文件编写与必要的设置对于mmsegmentation来说，如果读者想快速使用的话。config文件几乎是你唯一需要改动的东西。mmseg的模型使用，训练配置，数据地址都是靠config指明的。 在mmseg的官网中，有关config的资料很清晰，但是细节并不到位。 config是有继承关系的，根文件就是_base_中的一个个文件。虽如此，但仍然不建议初次使用的读者使用官网提供的简略写法。 在mmsegmentation的configs下，存放了各式各样的模型的配置文件，这些配置文件大多数都是针对的大型开源数据集。我们需要改的不是网络结构，主要是你的数据集地址，你定义的类别数，以及必要的训练设置。 这里可以通过运行一遍train来让系统自动生成一个config文件，然后复制出来进行自己的更改，将tools中的train.py复制到mmsegmentation根目录下，并运行以下代码： 1python train.py configs/deeplabv3/deeplabv3_r50-d8_512x512_20k_voc12aug.py 运行后报错正常，此时根目录下会生成work_dirs文件夹，并在其中生成我们所需的config文件： 将其拷贝出来，就可以基于此修改我们的配置文件了。 对于config文件，我们只需要关注&#x3D;&#x3D;数据集、类别、训练配置&#x3D;&#x3D;。 整个config文件大致可分为三个部分，即model , data 以及一些训练的配置。 1.数据集地址我们首先修改训练数据的地址 在config文件的第43行，是我们的数据集要遵照的格式，因为在准备数据集阶段我们已经修改为VOC格式，因此这里不用修改。 第44行是我们数据集的文件目录，这里我将其放入根目录data文件下。 再往下，进入data字典下，我们改动第87行的数据地址。第88行的img_dir是指语义分割数据集的原始图片，我们存到了JPEGImages下；ann_dir存放的是标注文件，我们存放的地址是SegmentationCLassPNG。注意，原始VOC还进行了数据增强，读者把带有Aug对应的地方删掉即可。第90行的split对应的是指定哪些图片存放train.txt 同理还需要test.txt 和val.txt，下面我们将制作这三个txt文本。 首先执行以下代码将全部数据图片的名称提取并保存在一个txt文件中 1234567891011import ospath = &quot;F:\\Dataset\\data_dataset_voc\\JPEGImages&quot;filenames=os.listdir(os.getcwd())for name in filenames: filenames[filenames.index(name)]=name[:-4]out=open(&#x27;names.txt&#x27;,&#x27;w&#x27;) #输出的txt文件名称for name in filenames: out.write(name+&#x27; &#x27;)out.close() 然后将txt中图片名称随机分为3类，即训练集、测试集和验证集： 12345678910111213141516171819202122232425import randomnum_line = 0def write_to_txt(file, start, end): with open(file, &#x27;w&#x27;) as name: for i in data[start:end]: name.write(&#x27;&#x27;.join(i) + &quot; &quot;) name.close()if __name__ == &#x27;__main__&#x27;: data = [] with open(&#x27;names.txt&#x27;, &#x27;r&#x27;) as f: for line in f: data.append(list(line.strip(&#x27; &#x27;).split(&#x27;,&#x27;))) num_line = num_line + 1 f.close() print(num_line) #数据集总数 random.shuffle(data) write_to_txt(&quot;train.txt&quot;,0,400) #这里需要自己根据自己数据集数量进行分配 write_to_txt(&quot;test.txt&quot;,400,450) write_to_txt(&quot;val.txt&quot;,450,len(data) + 1) 最后修改好的数据集部分代码如下 train部分 val部分 test部分 2.类别配置下面开始修改类别，先在配置文件中修改读者需要的类别数，标出的类别改成读者自己的，类别数等于n+1，也就是类别数量+背景。 我们只需要 行驶区域(darea)，背景(background)这两类，所以我们的num_classes&#x3D;2 这里需要修改两处，分别是第23行和第36行。 修改后，还需要修改一些底层配置。 首先是在mmsegmentation/mmseg/datasets下，找到voc.py（因为我们的格式是VOC），做如下修改。 其中PALETTE你可以简单理解为颜色，background对应[0, 0, 0]就是黑色，依次类推。 然后在mmsegmentation/mmseg/core/evaluation下，找到class_names.py，做类似修改： 到这里类别部分就修改好了 3.修改必要的训练配置这里要修改的地方不多，一般只简单改改训练迭代总数。下面的167行，读者的数据集不大的话，不需要迭代这么多次。 至此，我们的配置文件修改好了。然后我们给修改好的配置文件改个名字。 五、运行我们再次运行之前的指令: 1python tools/train.py segdemo.py 开始训练！！！ 训练结束后，模型保存在work_dirs/deeplabv3_r50-d8_512x512_20k_voc12aug/下， 接下来就可以测试我们的模型效果了，在根目录下新建一个python文件，并输入以下代码： 1234567891011from mmseg.apis import inference_segmentor , init_segmentorimport mmcvconfig_file = &#x27;segdemo.py&#x27;checkpoints_file = &#x27;work_dirs/deeplabv3_r50-d8_512x512_20k_voc12aug/latest.pth&#x27;model = init_segmentor(config_file, checkpoints_file, device = &#x27;cuda:0&#x27;)img = &#x27;mytest.jpg&#x27;result = inference_segmentor(model, img)model.show_result(img,result,out_file=&#x27;none_opacity_result.jpg&#x27;,opacity=0.5) 保存为testdemo.py，在根目录下打开终端，输入命令： 1python testdemo.py 运行后，将自动将结果保存在根目录下，文件名称为none_opacity_result.jpg，这里通过修改11行的out_file和opacity可以修改输出文件名称和输出效果透明度。 当opacity&#x3D;0.1时，得到结果： 当opacity&#x3D;0.5时，得到结果： 当opacity&#x3D;1时，得到结果： 在获取到道路信息后，我们可以开始尝试为无人驾驶汽车指明前进的方向。在实际的工程中，我们采用了强化学习方法来获取无人驾驶汽车前进方向以避免道路两旁行人或障碍物的影响。在本次实例中，我们暂时使用图像处理的方式来初步获取方向信息。对于强化学习方法，感兴趣的读者可以自己尝试实现。 通过以下python程序来对图像进行简单的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import matplotlib.image as mpimgfrom pylab import *img_plt = mpimg.imread(&#x27;none_opacity_result.jpg&#x27;)point_x = [0]*320point_y = [0]*320left_flag=0right_flag=0left_val=0right_val=0i=0for line in range(180): for row in range(320): #print(line,row,img_plt[line,row,0],left_flag,right_flag) if img_plt[line,row,0] &gt;= 100 and left_flag == 0: left_flag = 1 left_val = row if (img_plt[line,row,0] &lt;=50 and left_flag == 1) or(row==319 and img_plt[line,row,0]&gt;=128 and left_flag == 1): left_flag = 0 right_val = row right_flag = 1 if right_flag == 1 : middle = (left_val+right_val)//2 #img_plt[line,middle,1] = 200 point_x[i]=middle point_y[i]=line i=i+1 right_flag=0 left_flag = 0i=i-1imshow(img_plt)x = [0,0]y = [0,0]x[0] = point_x[0]x[1]=point_x[i]y[0]=point_y[0]y[1]=point_y[i]plot(x, y, &#x27;r*&#x27;)plot(x[:2], y[:2])show() 最后输出得到小车前进路径：","tags":["语义分割","人工智能","软件框架"]},{"title":"self attention机制","path":"/2024/07/13/self-attention机制/","content":"self attention模块输入输出都可以看作是向量每个向量都要和其他向量在self attention模块中进行交互以下是两种两个向量之间交互的方法 一个向量和sequence中其他向量交互（两个向量之间交互的拓展），输出即为相关度 计算与输入位置对应的输出向量（考虑了其他所有向量的信息，在这里哪个向量的alpha更大，即相关性强，计算输出向量的求和那里对相关性强的输入向量对应的V矩阵系数乘的也越多） 这个self attention模块充分利用了GPU的并行能力，所有的操作都可以整合到矩阵计算中并行计算。","tags":["算法"]},{"title":"编程学习观点","path":"/2024/07/12/编程学习观点/","content":"培养对酷的编程项目如何构建的热情，尝试阅读理解消化源码，不要只停留在应用层。 QBX理论Q:需求量大B:基础X:稀缺性","tags":["技术领悟"]},{"title":"浏览器跨域","path":"/2024/07/10/浏览器跨域/","content":"一个域下的JS脚本在未经允许的情况下，不能访问另一个域的内容，同源指的是协议域名和端口均相等的情况为同一个域。 跨域由于同源策略的限制，请求发送到后端，后端返回数据时被浏览器的跨域报错拦截。问：跨域的请求在服务端会不会真正执行？服务端就算是想拦截，也没法判断请求是否跨域，HTTP Request的所有Header都是可以被篡改的，它用什么去判断请求是否跨域呢？很明显服务端心有余而力不足啊！options:预检请求有一个很重要的作用就是询问服务端是不是允许这次请求，如果当前请求是个跨域的请求，你可以理解为：询问服务端是不是允许请求在当前域下跨域发送。当然，它还有其他的作用，比如询问服务端支持哪些HTTP方法。预检请求虽然不会真正在服务端执行逻辑，但也是一个请求啊，考虑到服务端的开销，不是所有请求都会发送预检的。一旦浏览器把请求判定为简单请求，浏览器就不会发送预检了。所以，如果你发送的是一个简单请求，这个请求不管是不是会受到跨域的限制，只要发出去了，一定会在服务端被执行，浏览器只是隐藏了返回值而已。对于前端开发而言，大部分的跨域问题，都是通过代理解决的。代理使用的场景是：生产环境不发生跨域，但开发环境发生跨域。所以，只需要在开发环境使用代理解决跨域即可一开发代理。 服务器与服务器通信不受跨域的影响，解决跨域也就可以从这个角度入手。浏览器不允许跨域的原因？防止黑客入侵 为啥html标签可以跨域？html标签只能调用get方法 在有服务器权限的情况下 服务器配置CROS实现跨域跨域资源共享Cross Origin Resourse-Sharing一般后端开启。是基于HTTP1.1的一种跨域解决方案。服务端设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。一个请求可以附带很多信息，会对服务器造成不同程度的影响，有的请求只是获取一些新闻，有的请求会改动服务器的数据。针对不同的请求，CORS规定了3种不同的交互模式 简单请求 需要预检的请求 附带身份凭证的请求 简单请求当请求同时满足以下条件时，浏览器会认为它是一个简单请求：1.请求方法属于下面的一种：getposthead2.请求头仅包含安全的字段，常见的安全字段如下：AcceptAccept-LanguageContent-LanguageContent-TypeDPRDownlinkSave-DataViewport-WidthWidth3.请求头如果包含Content-Type,仅限下面的值之一：text&#x2F;plainmultipart&#x2F;form-dataapplication&#x2F;x-www-form-urlencoded4.请求中的任意XMLHttpRequest对象均没有注册任何事件监听器；MLHttpRequest对象可以使用MLHttpRequest.upload属性访问。5.请求中没有使用ReadableStream对象。如果以上条件同时满足，浏览器判定为简单请求。当浏览器判定某个ajax跨域请求是简单请求时，会发生以下的事情1.请求头中会自动添加Origin字段比如，在页面http://my.com/index.html中有以下代码造成了跨域&#x2F;&#x2F;简单请求fetch(‘http://crossdomain.com/api/news‘);请求发出后，请求头会是下面的格式：GET &#x2F;api&#x2F;news&#x2F;HTTP&#x2F;1.1Host:crossdomain.comConnection:keep-alive12Referer:http://my.com/index.htmlOrigin:http://my.com 最后一行，Origin字段会告诉服务器，是哪个源地址在跨域请求2.服务器响应头中应包含Access-Control-Allow-Origin当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加Access-.Control-Allow-Origin字段该字段的值可以是： *：表示我很开放，什么人我都允许访问 具体的源：比如http://my.com,表示我就允许你访问 实际上，这两个值对于客户端http://y.com而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许 假设服务器做出了以下的响应：HTTP&#x2F;1.1 200OK 1Access-Control-Allow-0rigin:http://my.com 消息体中的数据当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给js,以完成后续的操作需要预检请求但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行1.浏览器发送预检请求，询问服务器是否允许2.服务器允许3.浏览器发送真实请求4.服务器完成真实的响应 比如，在页面http://my.com/index.html中有以下代码造成了跨域 1234567891011121314//需要预检的请求fetch(&#x27;http://crossdomain.com/api/user&#x27;,method:&#x27;P0ST&#x27;,//post请求headers://设置请求头a:1,b:2,&#x27;content-type&#x27;:&#x27;application/json&#x27;,&#125;,body:JSON.stringify(&#123;name:&#x27;袁小进&#x27;，age:18&#125;),//设置请求体&#125;) 浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互1.浏览器发送预检请求，询问服务器是否允许OPTIONS &#x2F;api&#x2F;user HTTP&#x2F;1.1Host:crossdomain.com 123origin:http://my.comAccess-Control-Request-Method:POSTAccess-Control-Request-Headers:a,b,content-type 可以看出，这并非我们想要发出的真实请求，请求中不包含我们的请求头，也没有消息体。这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。预检请求没有请求体，它包含了后续真实请求要做的事情预检请求有以下特征： 请求方法为OPTIONS 没有请求体 请求头中包含 Origin:请求的源，和简单请求的含义一致 Access-Control–Request-Method:后续的真实请求将使用的请求方法 Access–Control-Request-Headers:后续的真实请求会改动的请求头 2.服务器允许服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式HTTP&#x2F;1.1 200OKDate:Tue,21 Apr 2020 08:03:35 GMT 1234Access-Control-Allow-origin:http://my.comAccess-Control-ALlow-Methods:POSTAccess-Control-Allow-Headers:a,b,content-typeAccess-Control-Max-Age:86400 对于预检请求，不需要响应任何的消息体，只需要在响应头中添加： Access–Control-Allow-Origin:和简单请求一样，表示允许的源 Access-Control-Allow-Methods:表示允许的后续真实的请求方法 Access-Control-Allow-Headers:表示允许改动的请求头 Access-Control-Max-Age:告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了3.浏览器发送真实请求预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据POST &#x2F;api&#x2F;user HTTP&#x2F;1.1Host:crossdomain.comConnection:keep-alive123Referer:http://my.com/index.htmlOrigin:http://my.com&#123;&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:18&#125; 4服务器响应真实请求HTTP&#x2F;1.1 200OKDate:Tue,21 Apr 2020 08:03:35 GMT1Access-Control-Allow-origin:http://my.com 添加用户成功可以看出，当完成预检之后，后续的处理与简单请求相同附带身份凭证请求默认情况下，ajax的跨域请求并不会附带cookie,这样一来，某些需要权限的操作就无法进行不过可以通过简单的配置就可以实现附带cookie1234567//xhrvar xhr new XMLHttpRequest();xhr.withCredentials true;//fetch apifetch(url,credentials:include&#x27;,&#125;): 当一个请求需要附带cookie时，无论它是简单请求，还是预检请求，都会在请求头中添加cookie字段而服务器响应时，需要明确告知客户端：服务器允许这样的凭据告知的方式也非常的简单，只需要在响应头中添加：Access-Control-Allow-Credentials:true即可对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。另外要特别注意的是：对于附带身份凭证的请求，服务器不得设置Access-Contro-Allow-Origin的值为*。这就是不推荐使用的原因 额外补充 在跨域访问时，JS只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content–Type、Expires、Last-Modified、Pragma,如果要访问其他头，则需要服务器设置本响应头。Access-Control-Expose-Headers:头让服务器把允许浏览器访问的头放入白名单，例如：Access-Control-Expose-Headers:authorization,a,b这样JS就能够访问指定的响应头了。代理适用场景：生产环境不发生跨域，但开发环境发生跨域。开发代理：只需要在开发环境使用代理解决跨域。 12345module.exports =devServer:&#123;//配置开发服务器proxy:&#123;//配置代理&quot;/api&quot;:&#123;//若请求路径以/api开头target:&quot;http://dev.taobao.com&quot;,//将其转发到http://dev.taobao.com nginx代理反向代理功能是nginx的三大主要功能之一（静态wb服务器、反向代理、负载均衡）。反向代理：帮服务器拿到数据，然后选择合适的服务器。和CORS原理同，需要配置请求响应头Access-Control-Alow-Origin等字段。怎么做反向代理与负载均衡Ngx作为反向代理服务器，就是把http请求转发到另一个或者一些服务器上。通过把本地一个url前缀映射到要跨域访问的web服务器上，就可以实现跨域访问。对于浏览器来说，访问的就是同源服务器上的一个ul。而Nginxi通过检测url前缀，把http请求转发到后面真实的物理服务器。并通过rewrite命令把前缀再去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求是来自代理服务器的。 正向代理就是冒充客户端，反向代理就是冒充服务端。 WebSocket协议（与HTTP同级）因为WebSocketi请求头信息中有origin字段，表示请求源自哪个域，服务器可以根据这个字段判断是否允许本次通信。document.domain+iframe原理：相同主域名不同子域名下的页面，该方式只能用于二级域名相同的情况下，比如a.test.com和b.test.com适用于该方式。只需要给页面添加document..domain&#x3D;’test.com’表示二级域名都相同就可以实现跨域location.hash iframe通过C页面实现A和B通信window.name(共享变量)+iframe使用Apache做转发逆向代理，让跨域变成同域。2. JSONP（利用script标签和后端配合）前后端配合。只支持GET方法且不安全。利用src发送请求，传递一个回调。不受跨域问题限制：script,link,img,href,src,因为这些操作都不会通过响应结果进行可能出现安全问题的操作。通过标签指向一个需要访问的地址并提供一个回调函数来接收数据。 1234567891011//去创建一个script标签var script = document.createElement(&quot;script&quot;);//script的src属性设置接口地址并带一个callback回调函数名称script.src =&quot;http://127.0.0.1:8888/index.php?callback=jsonpCallback&quot;;//插入到页面document.head.appendchild(script);//通过定义函数名去接收后台返回数据function jsonpCallback(data)&#123;//注意jsonp返回的数据是json对象可以直接使用//ajax取得数据是json字符串需要转换成json对象才可以使用。&#125; 设置本地代理服务器 Nginx代理","tags":["前端开发"]},{"title":"mmsegmentation框架可视化训练指标","path":"/2024/07/01/mmsegmentation框架可视化训练指标/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import matplotlib import matplotlib.pyplot as pltmatplotlib.rc(&quot;font&quot;,family=&#x27;SimHei&#x27;) # 中文字体plt.plot([1,2,3], [100,500,300])plt.title(&#x27;matplotlib中文字体测试&#x27;, fontsize=25)plt.xlabel(&#x27;X轴&#x27;, fontsize=15)plt.ylabel(&#x27;Y轴&#x27;, fontsize=15)plt.show()import pandas as pd# 日志文件路径log_path = &#x27;./work_dirs/ZihaoDataset-PSPNet/20230818_210528/vis_data/scalars.json&#x27;with open(log_path, &quot;r&quot;) as f: json_list = f.readlines()len(json_list)eval(json_list[4])# pandas &gt;= 2.0使用pd.concat替换appendfor each in json_list[:-1]: new_row = pd.DataFrame([eval(each)]) # Convert the string to a DataFrame if &#x27;aAcc&#x27; in each: df_test = pd.concat([df_test, new_row], ignore_index=True) else: df_train = pd.concat([df_train, new_row], ignore_index=True)df_traindf_testdf_train.to_csv(&#x27;图表/训练日志-训练集.csv&#x27;, index=False)df_test.to_csv(&#x27;图表/训练日志-测试集.csv&#x27;, index=False)from matplotlib import colors as mcolorsimport randomrandom.seed(124)colors = [&#x27;b&#x27;, &#x27;g&#x27;, &#x27;r&#x27;, &#x27;c&#x27;, &#x27;m&#x27;, &#x27;y&#x27;, &#x27;k&#x27;, &#x27;tab:blue&#x27;, &#x27;tab:orange&#x27;, &#x27;tab:green&#x27;, &#x27;tab:red&#x27;, &#x27;tab:purple&#x27;, &#x27;tab:brown&#x27;, &#x27;tab:pink&#x27;, &#x27;tab:gray&#x27;, &#x27;tab:olive&#x27;, &#x27;tab:cyan&#x27;, &#x27;black&#x27;, &#x27;indianred&#x27;, &#x27;brown&#x27;, &#x27;firebrick&#x27;, &#x27;maroon&#x27;, &#x27;darkred&#x27;, &#x27;red&#x27;, &#x27;sienna&#x27;, &#x27;chocolate&#x27;, &#x27;yellow&#x27;, &#x27;olivedrab&#x27;, &#x27;yellowgreen&#x27;, &#x27;darkolivegreen&#x27;, &#x27;forestgreen&#x27;, &#x27;limegreen&#x27;, &#x27;darkgreen&#x27;, &#x27;green&#x27;, &#x27;lime&#x27;, &#x27;seagreen&#x27;, &#x27;mediumseagreen&#x27;, &#x27;darkslategray&#x27;, &#x27;darkslategrey&#x27;, &#x27;teal&#x27;, &#x27;darkcyan&#x27;, &#x27;dodgerblue&#x27;, &#x27;navy&#x27;, &#x27;darkblue&#x27;, &#x27;mediumblue&#x27;, &#x27;blue&#x27;, &#x27;slateblue&#x27;, &#x27;darkslateblue&#x27;, &#x27;mediumslateblue&#x27;, &#x27;mediumpurple&#x27;, &#x27;rebeccapurple&#x27;, &#x27;blueviolet&#x27;, &#x27;indigo&#x27;, &#x27;darkorchid&#x27;, &#x27;darkviolet&#x27;, &#x27;mediumorchid&#x27;, &#x27;purple&#x27;, &#x27;darkmagenta&#x27;, &#x27;fuchsia&#x27;, &#x27;magenta&#x27;, &#x27;orchid&#x27;, &#x27;mediumvioletred&#x27;, &#x27;deeppink&#x27;, &#x27;hotpink&#x27;]markers = [&quot;.&quot;,&quot;,&quot;,&quot;o&quot;,&quot;v&quot;,&quot;^&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;,&quot;s&quot;,&quot;p&quot;,&quot;P&quot;,&quot;*&quot;,&quot;h&quot;,&quot;H&quot;,&quot;+&quot;,&quot;x&quot;,&quot;X&quot;,&quot;D&quot;,&quot;d&quot;,&quot;|&quot;,&quot;_&quot;,0,1,2,3,4,5,6,7,8,9,10,11]linestyle = [&#x27;--&#x27;, &#x27;-.&#x27;, &#x27;-&#x27;]def get_line_arg(): &#x27;&#x27;&#x27; 随机产生一种绘图线型 &#x27;&#x27;&#x27; line_arg = &#123;&#125; line_arg[&#x27;color&#x27;] = random.choice(colors) # line_arg[&#x27;marker&#x27;] = random.choice(markers) line_arg[&#x27;linestyle&#x27;] = random.choice(linestyle) line_arg[&#x27;linewidth&#x27;] = random.randint(1, 4) # line_arg[&#x27;markersize&#x27;] = random.randint(3, 5) return line_argmetrics = [&#x27;loss&#x27;, &#x27;decode.loss_ce&#x27;, &#x27;aux.loss_ce&#x27;]plt.figure(figsize=(16, 8))x = df_train[&#x27;step&#x27;]for y in metrics: try: plt.plot(x, df_train[y], label=y, **get_line_arg()) except: passplt.tick_params(labelsize=20)plt.xlabel(&#x27;step&#x27;, fontsize=20)plt.ylabel(&#x27;Loss&#x27;, fontsize=20)plt.title(&#x27;训练集损失函数&#x27;, fontsize=25)plt.legend(fontsize=20)plt.savefig(&#x27;图表/训练集损失函数.pdf&#x27;, dpi=120, bbox_inches=&#x27;tight&#x27;)plt.show()metrics = [&#x27;decode.acc_seg&#x27;, &#x27;aux.acc_seg&#x27;]plt.figure(figsize=(16, 8))x = df_train[&#x27;step&#x27;]for y in metrics: try: plt.plot(x, df_train[y], label=y, **get_line_arg()) except: passplt.tick_params(labelsize=20)plt.xlabel(&#x27;step&#x27;, fontsize=20)plt.ylabel(&#x27;Metrics&#x27;, fontsize=20)plt.title(&#x27;训练集准确率&#x27;, fontsize=25)plt.legend(fontsize=20)plt.savefig(&#x27;图表/训练集准确率.pdf&#x27;, dpi=120, bbox_inches=&#x27;tight&#x27;)plt.show()df_test.columnsmetrics = [&#x27;aAcc&#x27;, &#x27;mIoU&#x27;, &#x27;mAcc&#x27;, &#x27;mDice&#x27;, &#x27;mFscore&#x27;, &#x27;mPrecision&#x27;, &#x27;mRecall&#x27;]plt.figure(figsize=(16, 8)x = df_test[&#x27;step&#x27;]for y in metrics: try: plt.plot(x, df_test[y], label=y, **get_line_arg()) except: passplt.tick_params(labelsize=20)plt.ylim([0, 100])plt.xlabel(&#x27;step&#x27;, fontsize=20)plt.ylabel(&#x27;Metrics&#x27;, fontsize=20)plt.title(&#x27;测试集评估指标&#x27;, fontsize=25)plt.legend(fontsize=20)plt.savefig(&#x27;图表/测试集分类评估指标.pdf&#x27;, dpi=120, bbox_inches=&#x27;tight&#x27;)plt.show() 参考MMSegmentation_Tutorials&#x2F;20230816&#x2F;【H1】可视化训练日志-训练过程总体评估指标.ipynb at main · TommyZihao&#x2F;MMSegmentation_Tutorials · GitHub","tags":["深度学习"]}]