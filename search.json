[{"title":"手写实现深拷贝一基础版","path":"/2024/10/13/手写实现深拷贝一基础版/","content":"123456789101112131415161718192021222324252627282930313233343536function deepClone(source) &#123; if(typeof source !== &quot;object&quot; || source == null)&#123; return source; &#125; const target = Array.isArray(source) ? [] : &#123;&#125;; for(const key in source)&#123; if( typeof source[key] === &quot;object&quot; &amp;&amp; source[key] !== null)&#123; target[key] = deepClone(source[key]); &#125; else &#123; target[key] = source[key]; &#125; &#125; return target;&#125;const original = &#123; number: 123, string: &quot;hello&quot;, array: [1,2,3], obj: &#123; prop1: &quot;test&quot;, prop2: &#123; nested: &quot;test2&quot;, &#125;, &#125;,&#125;;const cloned = deepClone(original);console.log(cloned);//&#123;// number: 123,// string: &#x27;hello&#x27;,// array: [ 1, 2, 3 ],// obj: &#123; prop1: &#x27;test&#x27;, prop2: &#123; nested: &#x27;test2&#x27; &#125; &#125;//&#125; 针对循环引用对象会报栈溢出的错误"},{"title":"深拷贝的实现方式以及优缺点分析","path":"/2024/10/13/深拷贝的实现方式以及优缺点分析/","content":"12345678910111213141516171819202122232425262728293031323334const obj = &#123; name: &quot;John&quot;, age: 30, address: &#123; city: &quot;New York&quot;, country: &quot;USA&quot;, &#125;,&#125;;const deepCopy = JSON.parse(JSON.stringify(obj));console.log(deepCopy);// 修改原对象obj.name = &quot;Alice&quot;;obj.address.city = &quot;San Francisco&quot;;console.log(obj);console.log(deepCopy);//&#123;// name: &#x27;John&#x27;,// age: 30,// address: &#123; city: &#x27;New York&#x27;, country: &#x27;USA&#x27; &#125;//&#125;//&#123;// name: &#x27;Alice&#x27;,// age: 30,// address: &#123; city: &#x27;San Francisco&#x27;, country: &#x27;USA&#x27; &#125;//&#125;//&#123;// name: &#x27;John&#x27;,// age: 30,// address: &#123; city: &#x27;New York&#x27;, country: &#x27;USA&#x27; &#125;//&#125; JSON.stringify无法拷贝函数12345678910const obj = &#123; a: 1, b: function() &#123; console.log(&quot;hello&quot;); &#125;&#125;;const newObj = JSON.parse(JSON.stringify(obj));console.log(newObj);// &#123; a: 1 &#125; JSON.stringify无法拷贝特殊对象，如Date、正则表达式123456789101112131415const obj = &#123; date: new Date(), regex: &#x27;/test/&#x27;,&#125;const newObj = JSON.parse(JSON.stringify(obj));console.log(&quot;旧对象&quot;, obj.date);console.log(&quot;旧对象&quot;, obj.regex);console.log(&quot;新对象&quot;, newObj.date);console.log(&quot;新对象&quot;, newObj.regex);//旧对象 2024-10-13T05:42:50.531Z//旧对象 /test///新对象 2024-10-13T05:42:50.531Z（输出字符串，而不是Date对象）//新对象 /test/（输出空对象，而不是RegExp对象） JSON.stringify不会拷贝原型链上的属性12345678910const protoObj = &#123;c: 3&#125;;const obj = Object.create(protoObj);obj.a = 1;obj.b = 2;const newObj = JSON.parse(JSON.stringify(obj));console.log(obj.c);console.log(newObj.c);// 3// undefined JSON.stringify会忽略symbol和undefined属性12345678const obj = &#123; a: undefined, b: Symbol(&#x27;test&#x27;),&#125;;const newObj = JSON.parse(JSON.stringify(obj));console.log(newObj);// &#123;&#125;"},{"title":"docker总结","path":"/2024/10/12/docker技术总结/","content":"Docker容器：结合虚拟机隔离与高效资源利用的最佳实践在现代软件开发和部署中，容器技术正逐渐取代传统的虚拟机解决方案。Docker作为其中最流行的容器平台，凭借其高效的资源利用和灵活的环境隔离性，成为了开发者和运维人员的必备工具。那么，Docker容器到底是如何在保持隔离的同时提升效率的呢？它真的能取代虚拟机吗？让我们深入探讨。 虚拟机与Docker的区别1. 虚拟机的隔离性与开销虚拟机技术通过虚拟化，将一台物理服务器分割成多个虚拟的“机器”，每个虚拟机都运行在独立的操作系统上，包括完整的内核和用户空间。这种方式提供了非常强的隔离性：每个虚拟机之间完全独立，宛如多台真实的物理服务器。 但是，这种隔离的代价是较高的资源开销。每个虚拟机都需要加载自己的操作系统内核，这不仅使得启动时间长，而且消耗大量的计算、存储和内存资源。这对于一些场景（如微服务架构、持续集成&#x2F;持续部署）来说，显得过于笨重和低效。 2. Docker的轻量级容器Docker容器则提供了一种更高效的方式：容器共享宿主机的操作系统内核，不再为每个实例加载独立的操作系统。每个Docker容器运行在一个轻量级的、独立的用户空间中，它通过Docker镜像定义应用程序和依赖库，保持了独立的文件系统和运行环境。 这意味着Docker容器能够像虚拟机一样提供隔离效果，但不需要虚拟化整个操作系统内核。这极大地降低了资源消耗，使容器的启动和停止非常迅速，可以在几秒内完成。 Docker容器的核心优势1. 独立文件系统与应用环境隔离Docker容器提供了一个独立的文件系统，应用程序及其依赖库都封装在镜像里。即使宿主机环境不同，容器内的应用运行效果也始终如一。这种用户空间的隔离让开发者可以放心地在不同环境中部署应用，而不必担心系统配置或依赖冲突的问题。 2. 共享宿主机内核Docker容器的轻量化设计源于其共享宿主机的操作系统内核。容器不需要加载自己的内核，而是直接利用宿主机的内核进行系统调用和资源管理。与虚拟机需要额外的硬件虚拟化和完整的操作系统开销不同，容器直接与宿主系统交互，这让它更加高效。 3. 启动迅速，资源开销小由于容器不需要启动一个完整的操作系统，它的启动时间非常短，可以在几秒钟内完成。相比虚拟机需要几分钟才能完全启动，Docker容器更加适合频繁的启动和销毁操作，这对于微服务架构和自动化CI&#x2F;CD管道尤为重要。 4. 隔离与安全性虽然容器共享内核，但通过Linux的命名空间（namespaces）和控制组（cgroups）机制，Docker实现了资源、进程和网络等方面的隔离，保证了容器之间的独立性和安全性。虽然这种隔离性不如虚拟机那么彻底，但在大多数应用场景下，已经足够安全和高效。 Docker是否能取代虚拟机？从上面的分析可以看出，Docker并不是虚拟机的完全替代品，但它在许多场景下具有更大的优势： 高效资源利用：Docker容器通过共享内核，避免了虚拟机加载整个操作系统的资源开销，显得更加轻量化。 灵活部署和扩展：容器启动迅速，支持快速扩容和缩容，非常适合微服务架构和大规模的分布式系统。 环境一致性：通过容器化，开发、测试和生产环境可以保持高度一致，解决了传统部署中的“环境不一致”问题。 但是，Docker并不完全替代虚拟机，尤其是在某些高隔离和硬件依赖性高的场景中，虚拟机依然有其独特的优势。例如，虚拟机可以在不同的内核上运行，提供更严格的安全隔离。而Docker容器由于共享宿主机的内核，隔离强度不如虚拟机，存在内核级别的安全隐患。 总结Docker容器在结合虚拟机隔离优势的同时，避免了虚拟机的资源浪费。它通过共享宿主机内核，提供了一个轻量级、高效的运行环境，特别适合现代的云原生应用和微服务架构。虽然它不完全取代虚拟机，但在资源消耗、启动速度和环境一致性等方面，Docker无疑是更好的选择。 对于大多数开发者和运维人员来说，Docker已经成为部署和管理应用的标准工具。而在那些对安全隔离要求极高的场景下，虚拟机依然是不可替代的解决方案。未来的趋势可能是两者结合，既享受容器的灵活性，又兼顾虚拟机的高隔离性。 参考文献： Docker官方文档 虚拟化与容器技术的对比分析 通过合理选择和组合这两种技术，可以在不同的场景中取得最佳的性能和灵活性。"},{"title":"让自己开发的软件产品保持latest_version_release的意义","path":"/2024/10/12/让自己开发的软件产品保持latest-version-release的意义/","content":"有助于不断加深自己对技术的理解热启动站在高位思考"},{"title":"数组的浅拷贝","path":"/2024/10/12/数组的浅拷贝/","content":"123const arr1 = [1,2,3];const arr2 = arr1.slice();console.log(arr2); //[ 1, 2, 3 ] 123const arr1 = [1,2,3];const arr2 = arr1.slice(2, 3);// 左闭右开console.log(arr2); //[ 3 ] 123const arr1 = [1,2,3];const arr2 = [0,1,2].concat(arr1);console.log(arr2); //[ 0, 1, 2, 1, 2, 3 ] 123const arr1 = [1,2,3];const arr2 = [].concat(arr1);console.log(arr2);// [ 1, 2, 3 ]"},{"title":"对象的浅拷贝","path":"/2024/10/12/对象的浅拷贝/","content":"123const obj1 = &#123;a : 1, b : 2&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);console.log(obj2); //&#123; a: 1, b: 2 &#125; 123const obj1 = &#123;a : 1, b : 2&#125;;const obj2 = &#123;...obj1&#125;;console.log(obj2); //&#123; a: 1, b: 2 &#125; 123456789const obj1 = &#123;a:1,b:2,c:&#123;d:4&#125;&#125;;const obj2 = &#123;&#125;;for (const key in obj1) &#123; if(obj1.hasOwnProperty(key))&#123;// for in 会遍历原型上的属性，所以需要判断是否为自身的属性 obj2[key] = obj1[key]; &#125;&#125;console.log(obj2); //&#123; a: 1, b: 2, c: &#123; d: 4 &#125; &#125; 1234567const obj1 = &#123;a:1,b:2,c:&#123;d:4&#125;&#125;;const obj2 = &#123;&#125;Object.keys(obj1).forEach(key =&gt; &#123; obj2[key] = obj1[key];// Object.keys()只会遍历对象自身的可枚举属性，所以不需要判断是否为自身的属性&#125;)console.log(obj2); //&#123; a: 1, b: 2, c: &#123; d: 4 &#125; &#125;"},{"title":"深拷贝与浅拷贝的区别","path":"/2024/10/12/深拷贝与浅拷贝的区别/","content":"123456789101112131415161718192021let originalObject = &#123; name: &quot;John&quot;, age: 30, hobbies: [&quot;reading&quot;, &quot;coding&quot;],&#125;//浅拷贝对象const shallowCopyObj = Object.assign(&#123;&#125;, originalObject);// 修改拷贝对象的属性shallowCopyObj.name = &quot;Alice&quot;;shallowCopyObj.hobbies.push(&quot;painting&quot;);console.log(originalObject);console.log(shallowCopyObj);//&#123; name: &#x27;John&#x27;, age: 30, hobbies: [ &#x27;reading&#x27;, &#x27;coding&#x27;, &#x27;painting&#x27; ] &#125;//&#123;// name: &#x27;Alice&#x27;,// age: 30,// hobbies: [ &#x27;reading&#x27;, &#x27;coding&#x27;, &#x27;painting&#x27; ]//&#125; 如果对象的属性为引用类型或复杂类型，修改拷贝对象的属性，会影响到原对象，修改原对象的属性，也会影响到拷贝对象。"},{"title":"数组索引背后隐藏了哪些类型转换？","path":"/2024/10/12/数组索引背后隐藏了哪些类型转换？/","content":"12345678let a = new Array();a[0] = 1;a[&quot;0&quot;] = 2;a[0]++;console.log(&#x27;a[&quot;0&quot;]的输出是&#x27;, a[&quot;0&quot;]);console.log(&#x27;a[0]的输出是&#x27;, a[0]);//a[&quot;0&quot;]的输出是 3//a[0]的输出是 3 1234let arr = [];arr[5] = &quot;Hello&quot;;console.log(arr[&quot;5&quot;]);// Hello 12345let obj = [];let key = &#123;a:1&#125;;obj[key] = &quot;value&quot;;console.log(obj[&quot;[object Object]&quot;])// value 1234567let arr = [];function myFunction() &#123; return &quot;promptonce&quot;;&#125;arr[myFunction] = &quot;函数作为索引&quot;;console.log(arr[myFunction]);// 函数作为索引 12345let arr = [];let symIndex = Symbol(&quot;index&quot;);arr[symIndex] = &quot;Hello&quot;;console.log(arr[symIndex]);// Hello 123456789let arr = [];let symIndex = Symbol(&quot;index&quot;);arr[symIndex] = &quot;Hello&quot;;let string = symIndex.toString();console.log(string)console.log(arr[string]);// Symbol(index)// undefined"},{"title":"像素总结","path":"/2024/10/10/像素总结/","content":"512x512RGB图像可以理解为由512x512x3个逻辑上的编码,计算机来决定如何渲染到屏幕上 电子图像的PPI1英寸x1英寸的电子图片在某一行取一英寸，这一英寸有多少个像素点。 打印机的DPI表示打印机的信息转化能力（一英寸输出多少个像素点且不损失信息） 高ppi如果人眼离的较远，且图像较小时可能无法区分相邻像素点，从而降低人眼的信息获取质量 PPI与DPI的对应： 如果这张512x512的图片被定义为1英寸x1英寸，那么它的PPI就是512。（将512x512x3的数据表示在1英寸x1英寸的空间上） 当我们把这张图片打印出来时，如果打印机的DPI也是512，那么理论上，打印出来的图像每个像素点会对应一个墨点，效果会比较理想。 假设我们有一张512x512像素的照片，想要打印成一张4英寸x4英寸的照片。 计算PPI： 512像素 &#x2F; 4英寸 &#x3D; 128 PPI。 选择打印机： 如果我们的打印机最大支持1200 DPI，那么我们可以将图像的尺寸调整为4英寸x4英寸，分辨率设置为128 PPI进行打印，这样可以充分利用打印机的性能。 如果打印机只有300 DPI： 那么打印出来的图像会有一些模糊，因为每个墨点要对应多个像素。"},{"title":"JS中判断数组的方式有哪些?","path":"/2024/10/07/JS中判断数组的方式有哪些/","content":"12345let obj = &#123;&#125;;let arr = [1,2,3];console.log(&quot;对象的类型是&quot;, typeof obj);// 对象的类型是 objectconsole.log(&quot;数组的类型是&quot;, typeof arr);// 数组的类型是 object 12345678let obj = &#123;&#125;;let arr = [1,2,3];let objType = Object.prototype.toString.call(obj);let arrType = Object.prototype.toString.call(arr);console.log(&quot;对象的类型是&quot;, objType);// 对象的类型是 [object Object]console.log(&quot;数组的类型是&quot;, arrType);// 数组的类型是 [object Array] 通过原型链判断12let obj = [];console.log(obj.__proto__ === Array.prototype) 通过Array.isArray()判断ES6语法，如需运行在低版本浏览器上需要使用babel转换 12let obj =[];console.log(Array.isArray(obj)); 通过 instanceof 判断12let obj = [];console.log(obj instanceof Array)"},{"title":"css提高性能的方法","path":"/2024/10/07/css性能优化/","content":"压缩 CSS 文件：减少文件大小，去掉不必要的空格和注释，这样文件体积更小，加载速度更快。 移除未使用的样式：很多时候，写了样式没用上，导致 CSS 文件臃肿，清理掉没用的部分，减少体积。 合并和分割 CSS 文件：合并多个 CSS 文件减少 HTTP 请求；也可以按需加载，只在需要时加载特定页面的样式。 简化选择器：选择器不要太复杂，层级太深会增加计算负担，影响性能。尽量用类选择器，少用通配符和属性选择器。 避免 @import：@import 导入 CSS 会增加额外请求，加载速度慢。尽量用 &lt;link&gt; 直接引入外部文件。 减少重绘和回流：避免频繁使用会引起回流的属性，比如 width、height，动画时多用 transform 和 opacity 这种对性能影响小的属性。 优化字体加载：Web 字体加载会影响页面渲染速度，尽量少用字体，设置 font-display: swap，让文字先显示，再加载字体。 使用关键 CSS：首屏显示的 CSS 放在 &lt;head&gt; 里，确保页面先渲染出来，剩下的样式可以延迟加载。 使用现代布局方式：像 CSS Grid 和 Flexbox 这些布局方式，比传统的 float 布局性能更好、代码更简洁。 利用 CSS 变量：减少重复定义，提高代码的可维护性和简洁性。"},{"title":"缓存总结","path":"/2024/10/07/缓存总结/","content":"强缓存就是在规定的时间内，浏览器直接从本地缓存中拿数据，不需要向服务器发送请求。这样，页面加载会更快。强缓存一般通过设置 Expires 或 Cache-Control 来控制缓存时间。 协商缓存则是浏览器会先向服务器询问，之前缓存的内容有没有更新。如果服务器确认没有更新，浏览器继续使用缓存数据。如果内容有变化，服务器会返回新的资源。协商缓存的机制常见于 Last-Modified 和 ETag 这两个头信息。"},{"title":"进制总结","path":"/2024/10/06/进制总结/","content":"进制（Number Base）是表示数值的方式之一，用不同的数字和符号来表示不同的数值。最常见的进制有二进制、十进制、八进制和十六进制等。接下来，详细介绍这些不同的进制及它们之间的转换。 1. 什么是进制？进制是指用多少个不同的符号来表示一个数值的系统。例如，十进制使用0到9共十个符号；而二进制使用0和1两个符号。因此，”进制”就是表示数值的基本符号种类的数量。 2. 常见进制及其特点 二进制（Binary，基数为2） 符号：0, 1 二进制的每一位只表示0或1。 常用于计算机和数字电路，因为电子元件只有开（1）或关（0）的状态。 例如，二进制数 101 表示十进制中的数字 5（从右到左依次表示 ( 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0 )）。 十进制（Decimal，基数为10） 符号：0, 1, 2, 3, 4, 5, 6, 7, 8, 9 是我们日常生活中最常用的进制。 例如，数字 123 表示 ( 1 \\times 10^2 + 2 \\times 10^1 + 3 \\times 10^0 &#x3D; 123 )。 八进制（Octal，基数为8） 符号：0, 1, 2, 3, 4, 5, 6, 7 每一位表示8的幂，常用于计算机中早期的一些操作系统和硬件。 例如，八进制数 17 表示十进制中的数字 15（从右到左依次表示 ( 1 \\times 8^1 + 7 \\times 8^0 &#x3D; 15 )）。 十六进制（Hexadecimal，基数为16） 符号：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F 用数字0-9和字母A-F表示，其中A表示10，B表示11，依此类推到F表示15。 十六进制常用于计算机编程，因为它可以简洁地表示二进制数。1个十六进制位可以表示4个二进制位（如F表示1111）。 例如，十六进制数 1A 表示十进制中的数字 26（从右到左依次表示 ( 1 \\times 16^1 + 10 \\times 16^0 &#x3D; 26 )）。 3. 进制转换 二进制到十进制 方法：按位展开成2的幂次方求和。 例如：二进制 1101 转换为十进制就是 ( 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0 &#x3D; 13 )。 十进制到二进制 方法：不断除以2，记录余数，然后逆序排列余数。 例如：十进制 13 转换为二进制就是： ( 13 \\div 2 &#x3D; 6 ) 余 1 ( 6 \\div 2 &#x3D; 3 ) 余 0 ( 3 \\div 2 &#x3D; 1 ) 余 1 ( 1 \\div 2 &#x3D; 0 ) 余 1 结果逆序为 1101。 十进制到八进制 方法：不断除以8，记录余数，然后逆序排列余数。 例如：十进制 64 转换为八进制就是： ( 64 \\div 8 &#x3D; 8 ) 余 0 ( 8 \\div 8 &#x3D; 1 ) 余 0 ( 1 \\div 8 &#x3D; 0 ) 余 1 结果逆序为 100。 十进制到十六进制 方法：不断除以16，记录余数（如果余数大于9，就用对应的字母），然后逆序排列余数。 例如：十进制 26 转换为十六进制就是： ( 26 \\div 16 &#x3D; 1 ) 余 10（即 A） ( 1 \\div 16 &#x3D; 0 ) 余 1 结果逆序为 1A。 4. 进制之间的快速转换 二进制到八进制 和 二进制到十六进制 可以通过分组快速转换： 二进制到八进制：每三位二进制数对应一位八进制数。例如：二进制 101110 可以分成 101 和 110，分别对应八进制的 5 和 6，所以结果是 56。 二进制到十六进制：每四位二进制数对应一位十六进制数。例如：二进制 11101100 可以分成 1110 和 1100，分别对应十六进制的 E 和 C，所以结果是 EC。 5. 进制的实际应用 二进制：计算机底层运算、逻辑电路等。 八进制：早期计算机系统，现代使用较少。 十进制：日常生活中最常用，如数学运算。 十六进制：编程中表示颜色代码（如 #FF00FF）、内存地址等。 总结 进制是用来表示数值的一种符号系统。 不同的进制系统有不同的符号数量和表示规则。 各进制之间的转换需要掌握其表示方式和运算规则。 计算机领域中最常用的是二进制和十六进制。十进制是日常生活中最为熟悉和使用的系统。 掌握进制及其转换对理解计算机的工作原理和程序设计非常有帮助。"},{"title":"DIFF算法","path":"/2024/10/03/DIFF算法/","content":"DIFF 算法的作用：同层树节点比较的算法那么 DIFF 算法是如何工作的？一、首先是先计算新老 DOM 的最小变化该算法会先遍历一遍老的 DOM. 然后在遍历新的DOM，最后会判断是改变&#x2F;新增&#x2F;删除来重新排序。这样无疑是非常耗费计算的，我们看一看出总共遍历了三回、如果有一千个节点．那么就湖发生了十亿次的计算。二. diff 算法的优化diff 算法的优化也就是这个算法的核心部分了，简单来说就是针对具有相同父节点的同层新旧子节点进行比较，不相同的话就会新增或者删除，而不是使用逐层搜索递归遍历的方式。时间复杂度为 O(n)。 只比较同一层级，不跨级比较 标签不同，直接删除，不继续比较 标签名相同， key相同，就认为是相同节点，不继续深度比较"},{"title":"Vuex","path":"/2024/10/03/Vuex/","content":"Vuex 通过集中存储和管理应用中的所有状态，避免了组件之间的状态不一致或数据混乱的问题。它的运作方式类似于 Flux 模式，能够帮助开发者更加有序地管理和维护应用的状态。 具体来说，Vuex 主要通过五个核心概念来工作： state：集中存储应用的状态，相当于数据的存储中心。 getter：类似于计算属性，从 state 中派生出新的数据给组件使用。 mutation：唯一修改 state 的方式，必须是同步操作。 action：可以包含异步操作，然后通过调用 mutation 来更新 state。 modules：将 store 划分为多个模块，每个模块可以拥有自己的 state、mutation、action、getters。 Vuex 的这种集中式的状态管理模式非常适合复杂的应用，尤其是当应用中的组件间状态需要共享时。"},{"title":"Vue中的keep-alive","path":"/2024/10/02/Vue中的keep-alive/","content":"Vue 中的 keep-alive用 keep-alive 包裏组件时．会缓存不活动的组件实例，而不是销毁．使得我们返回的时候能重新激活。 keep-alive主要用于保存组件状态或避免重复创建。避免重复渲染导致的性能间题。常见场景页面的缓存，如上面的保存浏览商品页的滚动条位置筛选信息等 注意这个和这个 Keep-Alive 是不一样的．这个属性的作用是、往往我们三次握手后，传输完数据就会断开连接进行四次挥手、关闭 TCP 连接．但是当我们在头信息中加入了该属性&#96;那么 TCP 会在发送后仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求、保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。"},{"title":"Vue中Scoped原理","path":"/2024/10/02/Vue中Scoped原理/","content":"Vue 中的 scoped 样式的作用是为了让组件的样式只在该组件的范围内生效，避免影响全局或其他组件。它的实现通过给每个组件生成一个唯一的标识符（如 data-v-xxxxxx），并将这个标识符附加到组件内的 DOM 元素和样式上。这样一来，样式表中的选择器只会影响带有相应标识符的 DOM 元素，而不会污染其他组件的样式。 总结特点： 1. 局部样式作用域：组件内的样式只能作用于组件自身的标签，且不会影响外部或其他组件。 2. 自动添加标识：Vue 会自动为组件的 DOM 和样式添加特定的 data-v- 属性，确保样式的唯一性和作用范围。 这个机制有效地解决了样式冲突问题，尤其在大型应用中，它可以确保不同组件的样式独立。"},{"title":"Vue过滤器","path":"/2024/09/30/Vue过滤器/","content":"Vue 过滤器的功能就是对数据进行格式化处理。它提供了两种常见的方式：一个是在双花括号插值中使用管道符号“|”来进行过滤，比如将消息首字母大写；另一个是在 v-bind 中使用过滤器来对绑定的值进行格式化，比如格式化 ID。 开发者可以通过定义过滤器来自定义常见的格式转换规则，例如把字符串的首字母大写。这个过滤器可以定义在组件内部，也可以定义为全局过滤器。 总结一下：Vue 过滤器相当于一种方便的工具，帮助开发者在显示数据之前对其进行简单的处理，使得代码更简洁。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue Filter Example&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Vue 过滤器示例&lt;/h1&gt; &lt;!-- 输入框 --&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; placeholder=&quot;输入一些文字&quot;&gt; &lt;!-- 使用过滤器 --&gt; &lt;p&gt;原始消息: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;过滤后的消息: &#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例 new Vue(&#123; el: &#x27;#app&#x27;, // 数据对象 data: &#123; message: &#x27;&#x27; &#125;, // 定义过滤器 filters: &#123; capitalize: function (value) &#123; if (!value) return &#x27;&#x27; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"Segformer技术分析","path":"/2024/09/29/Segformer技术分析/","content":"SegFormer避免了使用显式位置编码，所以在处理不同分辨率的图像时，不需要进行复杂的插值操作，原因主要是它通过卷积操作和层次结构来隐式地捕捉位置信息，而不是依赖于固定的、与图像分辨率相关的位置编码。 在传统的Transformer模型（例如ViT）中，位置编码是为每个输入特征（如图像的每个patch）明确指定的位置信息。当分辨率改变时，patch的数量也会随之变化，模型无法直接理解新分辨率下的位置信息，因此需要对位置编码进行插值，让它适应新的patch数量和图像分辨率。这是一个复杂的过程，容易引入误差。 而SegFormer通过以下方式避免了这一问题： 卷积的局部感知特性：SegFormer在编码阶段使用了卷积来生成Overlap Patch Embeddings。卷积操作自带局部的空间感知能力，因此它能在不同分辨率下自动调整，依旧保持对邻近像素关系的理解，不需要显式位置编码来帮助模型识别位置。 层次化的特征提取：SegFormer通过层次结构逐级缩减特征图，提取不同分辨率的特征，从而保留了多尺度的空间信息。这种方式让模型在不依赖固定位置编码的情况下，也能从全局和局部两个层面理解图像的空间结构。 因此，当图像的分辨率改变时，SegFormer可以自适应地调整，而不用像ViT那样需要重新插值位置编码。"},{"title":"cookie和session","path":"/2024/09/29/cookie和session/","content":"Cookie 和 Session 是两种在网络请求中用来存储用户数据的机制。 Cookie 当你第一次访问某个网站时，服务器会把一些数据（叫做 Cookie）发到你的浏览器。 之后，每次你访问这个网站时，浏览器都会把这些 Cookie 发回给服务器。 Cookie 主要存储在本地电脑中，并且有大小限制，一般不能超过 4KB。 Cookie的保存形式分为会话Cookie和持久Cookie 会话 Cookie 和 持久 Cookie 的区别就在于它们的有效期和存储位置。 会话 Cookie（Session Cookie）： 只在当前会话（即浏览器打开的这段时间）内有效。 当你关闭浏览器后，会话 Cookie 就会被自动删除。 会话 Cookie 主要用于临时信息存储，比如登录状态，关掉浏览器后就不再保存这些信息了。 持久 Cookie（Persistent Cookie）： 它有明确的过期时间，可以在浏览器关闭后仍然保留，直到到达设定的过期时间或用户手动删除它。 持久 Cookie 常用于存储长期信息，比如网站的自动登录功能、用户偏好设置等。 总结就是：会话 Cookie 随浏览器关闭而消失，而 持久 Cookie 会保留到指定时间或被用户手动删除。 Session Session 是一种存储在服务器端的机制，它保存的是用户的会话信息。 当你登录某个网站后，服务器会生成一个 Session，保存你的登录状态等信息。之后每次你访问网站，服务器会根据你带上的 Cookie 来识别你，并找到对应的 Session 来确认你是谁。 Session 没有大小限制，但它会占用服务器的资源。 区别 Cookie 存在你的浏览器里，而 Session 存在服务器端。 Cookie 有大小和存储时间的限制，而 Session 通常没有这些限制。 优点与缺点 Cookie 比较方便，因为它存储在本地。但不太安全，容易被恶意利用。 Session 更安全，但需要服务器资源。 SSO（单点登录） SSO 就是让你只需要登录一次，就能访问多个系统。这对于使用多个系统的环境非常方便。 SSO的优点降低访问第三⽅⽹站风险（⽤户密码不存储或外部管理）；从不同的⽤户名和密码的组合减少密码疲劳；减少花费的时间重新输⼊密码相同的⾝份；降低IT成本适当降低⼀些IT帮助台调⽤有关密码；SSO集中的所有其他应⽤程序和系统，⽤于⾝份验证服务器的⾝份验证，并与技术相结合是为了确保⽤户不必主动输⼊凭据⼀次以上"},{"title":"在浏览器中输入网址后发生了什么","path":"/2024/09/29/在浏览器中输入网址后发生了什么/","content":"当在浏览器中输入一个网址并按下回车键后，大致发生了以下几个步骤： 解析URL：浏览器会分析你输入的网址，把它分解成协议（如http或https）、域名（如example.com）等部分。 生成HTTP请求：浏览器会根据解析好的网址，生成一个HTTP请求，准备向服务器获取网页内容。 DNS查询：浏览器接着会向DNS服务器查询你输入的域名对应的IP地址，以便找到具体的服务器位置。 与服务器建立连接：获取到IP地址后，浏览器会与目标服务器建立连接（如果是https，还会进行加密连接的建立）。 发送HTTP请求：浏览器将之前生成的HTTP请求发给服务器，请求获取网页资源。 服务器响应：服务器收到请求后，返回对应的网页数据（如HTML、CSS、图片等）。 渲染网页：浏览器接收服务器的响应数据后，开始解析和渲染网页，将它显示在屏幕上。 这些步骤迅速而连续地发生，最终会看到想要的网页。"},{"title":"OSI七层模型","path":"/2024/09/28/OSI七层模型/","content":"OSI七层模型是一种网络通讯的规则框架，它把数据传输分成了七个步骤，帮助不同的设备之间进行通信。这七个步骤（或层）分别是： 物理层：就是各种硬件的物理连接，如网线、光纤等，它主要负责把0和1这些数字信号在设备之间传输。 数据链路层：负责数据传输的准确性，确保数据不会出错，并规定如何进行数据的基本传输方式。 网络层：决定数据通过网络的路径，让数据能从一个设备顺利到达另一个设备，常用的协议如IP就是在这一层。 传输层：确保数据能完整无误地传到对方。常见的协议有TCP（可靠传输）和UDP（快速传输）。 会话层：控制两台设备之间的通信会话，确保数据的连续性，比如什么时候开始传输，什么时候结束。 表示层：对数据进行转换或加密，确保数据能被设备理解，比如文件的压缩和解压。 应用层：直接跟用户打交道，比如我们上网时用的浏览器或者收发邮件的软件就是应用层的一部分。 简单来说，OSI模型就是让不同设备可以按步骤有序地进行信息交流的一种规则。"},{"title":"JavaScript字典序比较","path":"/2024/09/28/JavaScript字典序比较/","content":"字典序算法详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140var strCode = function(s)&#123;\tlet tokens = s.split(&#x27;&#x27;)\tif(tokens.length === 1)&#123; return (&#x27;z&#x27;.charCodeAt(0) - tokens[0].charCodeAt(0)) * (10 ** 0)\t&#125;\tlet result = 0\tfor(let i = tokens.length - 1, j = 1; i &gt; 0 ; i--,j++)&#123; result += (&#x27;z&#x27;.charCodeAt(0) - tokens[i].charCodeAt(0)) * (10 ** j)\t&#125;\treturn result;&#125;function compareStrings_(s1, s2) &#123;\tlet tokens1 = s1.split(&#x27;&#x27;)\tlet tokens2 = s2.split(&#x27;&#x27;)\tfor(let i = 0; i &lt; tokens1.length; i++)&#123; tokens1[i] = tokens1[i].charCodeAt(0)\t&#125;\tfor(let i = 0; i &lt; tokens2.length; i++)&#123; tokens2[i] = tokens2[i].charCodeAt(0)\t&#125;\tlet result = 0;\tlet minLen = -1;\tif(tokens1.length &lt; tokens2.length)&#123; minLen = tokens1.length; result = -1\t&#125;else if(tokens1.length &gt; tokens2.length)&#123; minLen = tokens2.length; result = 1;\t&#125;else &#123; minLen = tokens1.length; result = 0;\t&#125;\t//console.log(tokens1,tokens2,minLen,result)\t//双指针比较\tlet pointer1 = 0\tlet pointer2 = 0\tif(tokens1[0] &gt; tokens2[0])&#123; return 1\t&#125;else if(tokens1[0] === tokens2[0])&#123;\t&#125;else&#123; return -1;\t&#125;\twhile(tokens1[pointer1] === tokens2[pointer2])&#123; pointer1++; pointer2++; if(tokens1[pointer1] &gt; tokens2[pointer2])&#123; result = 1 break; &#125; if(tokens1[pointer1] &lt; tokens2[pointer2])&#123; result = -1 break; &#125; if(pointer1 === minLen || pointer2 === minLen)&#123; break &#125;\t&#125;\treturn result;&#125;function compareStrings(s1, s2) &#123; return s1.localeCompare(s2);&#125;function randomString(length) &#123; const chars = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;; let result = &#x27;&#x27;; for (let i = 0; i &lt; length; i++) &#123; result += chars[Math.floor(Math.random() * chars.length)]; &#125; return result;&#125;function testCompareFunctions(iterations = 1000, maxStrLen = 10) &#123; const progressBarLength = 50; // 进度条长度 for (let i = 0; i &lt; iterations; i++) &#123; const len1 = Math.floor(Math.random() * maxStrLen) + 1; // 随机生成字符串长度 const len2 = Math.floor(Math.random() * maxStrLen) + 1; const s1 = randomString(len1); // 随机生成第一个字符串 const s2 = randomString(len2); // 随机生成第二个字符串 const result1 = compareStrings_(s1, s2); // 用自定义的 compareStrings_ 函数 const result2 = compareStrings(s1, s2); // 用内置的 localeCompare 函数 // 将 localeCompare 的结果标准化为 -1, 0, 1 以进行比较 const normalizedResult2 = result2 === 0 ? 0 : (result2 &gt; 0 ? 1 : -1); if (result1 !== normalizedResult2) &#123; console.log(`Test failed for inputs: &quot;$&#123;s1&#125;&quot; and &quot;$&#123;s2&#125;&quot;`); console.log(`compareStrings_ result: $&#123;result1&#125;`); console.log(`localeCompare result: $&#123;normalizedResult2&#125;`); return; // 一旦发现不一致，停止测试并打印错误信息 &#125; // 进度条每隔一定的迭代次数更新 if (i % Math.floor(iterations / 100) === 0 || i === iterations - 1) &#123; const progress = (i / iterations) * 100; // 计算百分比 const progressChars = Math.floor((progress / 100) * progressBarLength); // 进度条符号的数量 const progressBar = &#x27;=&#x27;.repeat(progressChars) + &#x27; &#x27;.repeat(progressBarLength - progressChars); // 构建进度条 process.stdout.write(`\\r[$&#123;progressBar&#125;] $&#123;progress.toFixed(2)&#125;%`); // \\r 使光标回到行首，覆盖之前的输出 &#125; &#125; console.log(&#x27; All tests passed!&#x27;);&#125;function testPerformance(iterations = 1000000, maxStrLen = 10) &#123; const strings = []; // 预生成随机字符串对 for (let i = 0; i &lt; iterations; i++) &#123; const len1 = Math.floor(Math.random() * maxStrLen) + 1; const len2 = Math.floor(Math.random() * maxStrLen) + 1; const s1 = randomString(len1); const s2 = randomString(len2); strings.push([s1, s2]); &#125; // 测试自定义 compareStrings_ 的性能 console.time(&#x27;Custom compareStrings_&#x27;); for (let i = 0; i &lt; iterations; i++) &#123; compareStrings_(strings[i][0], strings[i][1]); &#125; console.timeEnd(&#x27;Custom compareStrings_&#x27;); // 测试内置 localeCompare 的性能 console.time(&#x27;Built-in localeCompare&#x27;); for (let i = 0; i &lt; iterations; i++) &#123; strings[i][0].localeCompare(strings[i][1]); &#125; console.timeEnd(&#x27;Built-in localeCompare&#x27;);&#125;// 运行测试testCompareFunctions(1000); // 这里设置较小的迭代次数，方便观察进度// 运行性能测试testPerformance(1000); // 设置 1000 次测试//[================================================= ] 99.90%//All tests passed!//Custom compareStrings_: 0.395ms//Built-in localeCompare: 0.158ms"},{"title":"TCP三次握手四次挥手","path":"/2024/09/28/TCP三次握手四次挥手/","content":"TCP的三次握手和四次挥手就是为确保数据可靠传输的一种机制。我们来简单讲一下： 三次握手： 第一次握手：客户端发送一个SYN（同步序列编号）包，告诉服务器“我要开始连接，准备好了吗？”。 第二次握手：服务器收到后，回复一个SYN（synchronize）+ACK（Acknowledgment）包，表示“我准备好了，咱们可以开始连接，但你要确认一下”。 第三次握手：客户端收到后，回一个ACK包，表示“好的，我确认了，正式连接”。 这样，三次握手后，双方建立了可靠连接，开始数据传输。 四次挥手： 第一次挥手：客户端发送FIN（finish）包，表示“我不再传数据了，你准备断开吧”。 第二次挥手：服务器收到后，回复ACK包，表示“我知道了，但我还有数据要发”。 第三次挥手：服务器发FIN包，表示“我数据发完了，可以断开了”。 第四次挥手：客户端收到后，发ACK包，表示“好的，断开吧”。 这四次挥手确保数据完全发送并成功断开连接，避免信息丢失。 简单来说，三次握手建立连接，四次挥手安全断开，都是为确保数据传输完整性和可靠性。"},{"title":"理解JavaScript中this的行为:普通函数vs箭头函数","path":"/2024/09/27/理解JavaScript中this的行为-普通函数vs箭头函数/","content":"在 JavaScript 中，this 是一个非常重要但也容易引起混淆的概念。特别是在普通函数和箭头函数之间，this 的行为有着显著的区别。在这篇文章中，我们将通过一个代码示例，深入理解 this 在不同场景下的指向。 代码示例1234567891011121314151617181920var a = 1;function fn1() &#123; console.log(this.a);&#125;const fn2 = () =&gt; &#123; console.log(this.a);&#125;const obj = &#123; a: 10, fn1: fn1, fn2: fn2&#125;fn1(); // 输出: 1fn2(); // 输出: 1obj.fn1(); // 输出: 10obj.fn2(); // 输出: 1 让我们逐行解析这段代码，弄清楚为什么会得到这样的输出。 全局变量 a首先，我们定义了一个全局变量 a，并赋值为 1： 1var a = 1; 在浏览器环境中，使用 var 声明的全局变量会成为 window 对象的属性。所以此时，window.a 的值为 1。 普通函数 fn1接下来定义了一个普通函数 fn1： 123function fn1() &#123; console.log(this.a);&#125; 在 JavaScript 中，普通函数的 this 指向取决于它被调用的上下文。也就是说，谁调用了这个函数，this 就会指向谁。 箭头函数 fn2然后，我们定义了一个箭头函数 fn2： 123const fn2 = () =&gt; &#123; console.log(this.a);&#125; 与普通函数不同，箭头函数不会绑定自己的 this。它会继承定义时所在的上下文的 this 值。因此，fn2 的 this 始终是它在定义时的环境中的 this。 定义对象 obj我们定义了一个对象 obj，包含属性 a 和两个方法 fn1、fn2： 12345const obj = &#123; a: 10, fn1: fn1, fn2: fn2&#125; 这里的 a 是对象 obj 的属性，而 fn1 和 fn2 分别引用前面定义的普通函数和箭头函数。 函数调用分析1. 调用 fn1()1fn1(); // 输出: 1 这是直接调用 fn1。由于 fn1 是在全局作用域中调用的，因此它的 this 默认指向全局对象 window。于是 this.a 相当于 window.a，它的值为 1。 2. 调用 fn2()1fn2(); // 输出: 1 fn2 是一个箭头函数。箭头函数的 this 是在定义时决定的。在这里，fn2 是在全局作用域中定义的，因此它的 this 也是指向全局对象 window，所以输出的 this.a 也是 1。 3. 调用 obj.fn1()1obj.fn1(); // 输出: 10 这次调用 fn1 是通过对象 obj 来进行的。在这种情况下，this 指向调用函数的对象 obj，所以 this.a 实际上是 obj.a，即 10。 4. 调用 obj.fn2()1obj.fn2(); // 输出: 1 虽然 fn2 是通过对象 obj 调用的，但由于 fn2 是箭头函数，它的 this 并不会被调用方式所影响。fn2 的 this 是在定义时就已经决定了的，它指向全局对象 window，因此 this.a 仍然是 window.a，值为 1。 小结通过这个例子，我们可以清楚地看到 JavaScript 中 this 的不同表现： 普通函数：this 的指向取决于它的调用方式。谁调用了这个函数，this 就指向谁。 箭头函数：this 不会绑定调用时的对象，而是继承自定义时的上下文 this。 执行结果总结： fn1() 输出 1：普通函数，在全局作用域中调用，this 指向 window。 fn2() 输出 1：箭头函数，继承全局 this，所以输出 window.a。 obj.fn1() 输出 10：普通函数，通过对象调用，this 指向 obj。 obj.fn2() 输出 1：箭头函数，依旧继承定义时的 this，输出 window.a。 结论在 JavaScript 中，理解 this 的指向对于编写和调试代码非常重要。普通函数的 this 根据调用方式而变化，而箭头函数的 this 是固定的。掌握了这些规则，可以帮助我们更好地编写和调试代码，避免 this 指向错误带来的困扰。"},{"title":"PNG图片格式总结","path":"/2024/09/26/PNG图片格式总结/","content":"PNG有RGBA模式和RGB模式，灰度模式和调色板索引模式PNG可以实现无损压缩 1. 灰度模式（Grayscale Mode）灰度模式表示图像中的每个像素只有亮度信息，而没有颜色信息。简单来说，灰度图像只有黑白两种颜色的不同程度，从完全黑到完全白，中间有多个灰色渐变。 灰度模式的特点： 每个像素只使用一个数值（通常是 8 位，范围从 0 到 255）来表示亮度。值为 0 表示完全黑，255 表示完全白。 与彩色图像相比，灰度图像占用的存储空间更少，因为它不需要存储红、绿、蓝三种颜色信息。 应用场景：灰度模式常用于黑白照片、扫描的文本图像，以及不需要颜色信息的其他图像。 2. 调色板索引模式（Palette-Indexed Mode）调色板索引模式（有时也叫索引颜色模式）是一种节省存储空间的颜色表示方式，尤其适用于颜色数量有限的图像。在这种模式下，图像并不直接存储每个像素的颜色值，而是存储一个“索引”，这个索引指向调色板中的具体颜色。 调色板索引模式的特点： 图像的颜色信息被限制在一个调色板中，调色板通常最多包含 256 种颜色（8 位索引），每个颜色索引对应具体的 RGB 颜色。 每个像素只保存颜色索引，而不是直接的颜色值。这种方式可以极大地减少图像文件的大小，尤其是在图像颜色数量较少的情况下。 应用场景：调色板索引模式常用于网页图像、简单的图标、GIF 动画等场景，特别是颜色变化不多的图像。例如，简单的卡通画、徽标或按钮图像。 灰度模式 vs 调色板索引模式： 灰度模式：适合只有亮度变化的黑白图像，每个像素记录的是亮度信息。 调色板索引模式：适合颜色有限的图像，通过索引值指向调色板中的颜色，节省存储空间。 总的来说，这两种模式都是为了减少图像的存储需求而设计的，但应用场景有所不同。灰度模式用于单色图像，而调色板索引模式则用于有限颜色的彩色图像。"},{"title":"hexo部署静态资源到github服务器","path":"/2024/09/25/hexo部署静态资源到github服务器/","content":"hexo d失败可以用git clone github仓库地址然后用hexo public目录替换后使用授权github仓库账号执行git push操作替代hexo d fatal: bad tree object 76efcae7c5c88277bd54626c763b790961115445fatal: the remote end hung up unexpectedlysend-pack: unexpected disconnect while reading sideband packetfatal: the remote end hung up unexpectedlyerror: failed to push some refs to ‘https://xxx.git‘FATAL Something’s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess. (D:\\promptonce-blog ode_modules\\hexo-deployer-git ode_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:519:28) at cp.emit (D:\\promptonce-blog ode_modules\\cross-spawn\\lib\\enoent.js:34:29) at ChildProcess._handle.onexit (node:internal&#x2F;child_process:294:12) 清空public目录下的文件克隆托管hexo博客的github仓库，将除.git的文件及目录复制到public目录中将原来根目录的.git目录删掉将克隆下来的目录的.git移动到根目录执行命令 123hexo cleanhexo ghexo d"},{"title":"MMSegmentation实验结果保存命名格式总结","path":"/2024/09/23/MMSegmentation实验结果保存命名格式总结/","content":"日期_模型名_骨干网络_其他重要参数_训练步骤_批次大小_目标尺寸"},{"title":"GPT时代的程序员生存之道","path":"/2024/09/22/GPT时代的程序员生存之道/","content":"GPT时代的程序员生存之道"},{"title":"promise出现的原因和promise方法","path":"/2024/09/22/promise出现的原因和promise方法/","content":"一、Promise出现的原因背景在JavaScript中，异步编程是非常常见的需求，例如处理网络请求、文件读取、定时操作等。在早期，我们通常使用回调函数（callback）来处理异步操作，但随着代码复杂度的增加，回调函数的使用也带来了一些问题，例如： 回调地狱（Callback Hell）：当多个异步操作需要按顺序执行时，回调函数会嵌套得非常深，导致代码难以阅读和维护。 12345678asyncOperation1(function(result1) &#123; asyncOperation2(result1, function(result2) &#123; asyncOperation3(result2, function(result3) &#123; // 继续嵌套 &#125;); &#125;);&#125;); 错误处理复杂：每个回调函数都需要单独处理错误，这使得代码更为冗长且不易统一管理。 Promise的引入为了解决这些问题，ECMAScript 6（ES6）引入了Promise。Promise是一种用于管理异步操作的对象，提供了一种更为清晰和强大的方式来处理异步代码。 二、Promise的基本方法和用法1. 创建一个Promise你可以通过new Promise来创建一个Promise对象。它接受一个执行函数（executor），该函数有两个参数：resolve和reject。 12345678910let promise = new Promise(function(resolve, reject) &#123; // 异步操作 let success = true; if (success) &#123; resolve(&quot;操作成功&quot;); &#125; else &#123; reject(&quot;操作失败&quot;); &#125;&#125;); 2. 使用PromisePromise对象有三个主要方法：then、catch和finally，用于处理异步操作的结果。 then：用于处理成功的结果。 1234promise.then(function(result) &#123; console.log(result); // 操作成功&#125;); catch：用于处理失败的结果。 1234promise.catch(function(error) &#123; console.error(error); // 操作失败&#125;); finally：无论Promise成功还是失败，最终都会执行的代码。 1234promise.finally(function() &#123; console.log(&quot;操作完成&quot;);&#125;); 3. 链式调用Promise可以通过链式调用的方式来简化异步操作的串联，避免回调地狱。 1234567891011asyncOperation1() .then(result1 =&gt; asyncOperation2(result1)) .then(result2 =&gt; asyncOperation3(result2)) .then(result3 =&gt; &#123; // 处理最终结果 &#125;) .catch(error =&gt; &#123; // 统一处理错误 console.error(error); &#125;); 4. 常见的Promise方法 Promise.all：接收一个包含多个Promise的数组，只有当所有Promise都成功时，才会执行then，否则执行catch。 12345678Promise.all([promise1, promise2, promise3]) .then(results =&gt; &#123; // 所有Promise都成功 &#125;) .catch(error =&gt; &#123; // 任意一个Promise失败 &#125;); Promise.race：接收一个包含多个Promise的数组，只要有一个Promise成功或失败，就立即执行相应的then或catch。 12345678Promise.race([promise1, promise2, promise3]) .then(result =&gt; &#123; // 第一个成功的Promise &#125;) .catch(error =&gt; &#123; // 第一个失败的Promise &#125;); 总结Promise提供了一种更为优雅和简洁的方式来处理JavaScript中的异步操作，解决了回调函数嵌套和错误处理复杂的问题。理解和掌握Promise对现代JavaScript编程至关重要。 Promise 的状态一旦确定（resolved 或 rejected），就无法更改。同步代码先执行，Promise 回调是异步的，会在同步代码执行完毕后再执行。 12345678910console.log(1);new Promise(function (resolve, reject) &#123; reject(); resolve();&#125;).then(function () &#123; console.log(2);&#125;, function () &#123; console.log(3);&#125;);console.log(4); 输出 1 4 3"},{"title":"为何要将产品当成自己的孩子？","path":"/2024/09/20/为何要将产品当成自己的孩子？/","content":"只追求广度是不行的，光有广度不代表就有很强的判断力 如果学的是是技术的经典理论的话，那么毫无疑问是学的多更好，前提是能够学懂学好。如果是学习技术应用的话，需要知道的是应用是基于底层技术的上层建筑，如果从底层技术的角度分析，那么大多数技术应用在技术底层是同质化严重的，如果沉迷于学的多，对于通过项目来引导理论学习的人来说，可能会无法触及的更深层次的技术理论，从而在对技术的理解上显得局限，虽然这个和性格也有一定关系，但我认为软件工程师认真地学精可能比粗略地学广泛更有意义。"},{"title":"webpack","path":"/2024/09/20/webpack/","content":"Webpack 是一个强大的 模块打包工具，广泛应用于前端项目中。它的主要作用是将各种资源（JavaScript、CSS、图片等）当作模块进行处理，最后生成优化后的静态文件，提升项目的加载性能和开发体验。 简单来说，Webpack 可以将多个文件合并为一个或者多个打包文件，减少请求次数，提高性能，同时还能进行代码拆分、按需加载等优化。 Webpack 的核心概念： Entry（入口）：Webpack 从哪个文件开始进行打包。通常是你应用的主文件（例如 index.js），Webpack 会根据依赖关系递归解析所有依赖的模块。 Output（输出）：打包后的文件输出到哪里，通常是一个目录下的某个文件，比如 dist/main.js。 Loaders（加载器）：Webpack 本身只理解 JavaScript 文件，但通过加载器，你可以让它处理其他类型的文件，比如 CSS、图片、甚至 Sass 或 TypeScript 文件。 Plugins（插件）：插件用于扩展 Webpack 的功能，比如压缩打包后的文件、注入环境变量、分离 CSS 等。 Mode（模式）：Webpack 有 development（开发模式） 和 production（生产模式） 两种模式，开发模式注重调试和快速编译，而生产模式则侧重于优化性能，比如压缩代码、移除无用代码等。 Webpack 的使用流程： 安装 Webpack：在项目中通过 npm 安装 Webpack 和它的 CLI 工具。 1npm install --save-dev webpack webpack-cli **创建 webpack.config.js**：这是 Webpack 的配置文件，用于定义入口、输出、加载器和插件等。 123456789101112131415161718const path = require(&#x27;path&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, // 入口文件 output: &#123; filename: &#x27;bundle.js&#x27;, // 打包后的文件名 path: path.resolve(__dirname, &#x27;dist&#x27;), // 输出路径 &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 匹配所有的 CSS 文件 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], // 使用两个加载器来处理 CSS &#125;, ], &#125;, mode: &#x27;development&#x27;, // 开发模式&#125;; 运行打包命令：在终端中运行 npx webpack，Webpack 会根据配置文件进行打包，输出最终文件到指定目录。 1npx webpack Webpack 的主要功能： 代码拆分（Code Splitting）：Webpack 支持将代码拆分成多个包（chunks），只在需要时加载，提升应用的加载速度。 按需加载（Lazy Loading）：通过动态 import()，可以让某些模块在用户实际需要时才加载，这对大型应用非常有用。 模块热替换（Hot Module Replacement, HMR）：在开发过程中，当代码修改时，Webpack 能让你不刷新整个页面而只替换修改的模块，从而提升开发效率。 Tree Shaking：Webpack 能在打包时移除没有用到的代码（通常是未使用的 ES6 模块），从而减少打包文件的大小。 兼容各种模块化方案：Webpack 支持 AMD、CommonJS、ES6 模块等各种模块化标准，并能将这些模块统一打包为一个文件。 Webpack 例子：假如你有一个项目使用了 CSS 和图片，你可以这样配置 Webpack 来处理这些资源： 123456789101112131415161718192021222324252627282930const path = require(&#x27;path&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;), &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, // 处理 CSS 文件 use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], &#125;, &#123; test: /\\.(png|jpg|gif)$/, // 处理图片文件 use: [ &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name].[hash].[ext]&#x27;, // 输出文件名格式 outputPath: &#x27;images&#x27;, // 输出路径 &#125;, &#125;, ], &#125;, ], &#125;, mode: &#x27;production&#x27;, // 生产模式&#125;; Webpack 的优点： 强大的模块打包能力：Webpack 支持将所有资源视作模块，统一进行管理，极大简化了前端开发流程。 灵活的配置：无论是简单的单页面应用，还是复杂的多页面应用，Webpack 都可以通过配置来满足不同的需求。 丰富的插件生态：通过 Webpack 插件，你可以扩展它的功能，比如压缩文件、生成 HTML 文件、分析打包结果等。 总结：Webpack 是现代前端开发中最常用的构建工具之一，它可以将项目中的各种资源（JS、CSS、图片等）进行打包、优化，提升项目的性能和开发体验。它的强大之处在于高度可配置性和丰富的插件生态，能够满足从小型项目到大型复杂项目的各种需求。"},{"title":"Vue路由传参","path":"/2024/09/20/Vue路由传参/","content":"路由传参方式可划分为 params 传参和 query 传参，而 params 传参又可分为在 url 中显示参数和不显示参数两种方式方式A ：这种需要在路由配置好可以传递参数 xxx 的，不是最方便的路由配置 1234&#123; path ： &#x27;/child/:XXX&#x27;, component ：（ child&#125; 父组件 1&lt;router—link to=&quot;/child/XXX&quot;&gt;:&lt;/router—link&gt; 子组件读取 1this.num = this.$route.params.XXX 方式B ：这种同样需要在路山配置好可以传递参数 XXX 的，不过是用到 push方法的路由配置 1234&#123; path:&#x27;/child/:XXX&#x27; component ：Child&#125; 父组件this.$router. push({、 &#x2F;chiId&#x2F;${XXXFpath ：子组件读取this.num &#x3D; this.Sroute.params.XXX上面两种方式都会在地址显示出传递的参数、类似 get 请求方式 c ．这种不需要在路由配置好根据路由的名称、需要保持一致路由配置不需要配置，但是子组件的 name 必须与父组件传递的路由一致父组件th iS ， $router.push({params ：{X)O(: ，1子组件读取this.num &#x3D; this 、 $route.params.XXX &#x2F;&#x2F;妈呀方式 D ，这种不需要在路由配置好根据路由的名称&#96;通过 que 缪来传递路由配置不需要配置，但是子组件的 name 必须与父组件传递的路由一致{父组件this.$router.push({path: ‘&#x2F;child’query: {子组件读取this.num &#x3D; this.$route.query.XXX总的来说使用方式 C 和 D 最为多，毕竟不需要对路由配置做修改 代码例子1234567891011121314151617181920212223&lt;!-- ParentComponent.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;Parent Component&lt;/h2&gt; &lt;button @click=&quot;goToChildWithParams&quot;&gt;Go to Child with Params&lt;/button&gt; &lt;button @click=&quot;goToChildWithQuery&quot;&gt;Go to Child with Query&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; // 使用params传参 goToChildWithParams() &#123; this.$router.push(&#123; path: `/child/$&#123;123&#125;` &#125;); &#125;, // 使用query传参 goToChildWithQuery() &#123; this.$router.push(&#123; path: &#x27;/child-query&#x27;, query: &#123; id: 123 &#125; &#125;); &#125; &#125;&#125;;&lt;/script&gt; 123456789101112131415161718192021222324252627&lt;!-- ChildComponent.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;Child Component&lt;/h2&gt; &lt;p&gt;Param ID: &#123;&#123; paramId &#125;&#125;&lt;/p&gt; &lt;p&gt;Query ID: &#123;&#123; queryId &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; computed: &#123; // 获取 params 参数 paramId() &#123; // this.$route.params.id 是通过路径传递的参数 console.log(&#x27;Route Params:&#x27;, this.$route.params); return this.$route.params.id; &#125;, // 获取 query 参数 queryId() &#123; // this.$route.query.id 是通过 query 传递的参数 console.log(&#x27;Route Query:&#x27;, this.$route.query); return this.$route.query.id; &#125; &#125;&#125;;&lt;/script&gt;"},{"title":"网站配置https","path":"/2024/09/20/网站配置https/","content":"1. 什么是 HTTPS？HTTPS（超文本传输安全协议）是 HTTP 的加密版本，通过 SSL&#x2F;TLS 协议来确保数据传输的安全性。也就是说，别人不能轻易地偷看你们之间的通信内容啦！ 2. HTTPS 配置流程步骤 1: 获取 SSL 证书首先你需要一个 SSL 证书。这个证书就像是网站的“身份证”，能保证访问者正在访问的确实是你的网站哦！你有两个选择： 购买 SSL 证书：许多域名提供商（如 Namecheap、GoDaddy）都有提供。 使用免费 SSL 证书：推荐使用 Let’s Encrypt，这是一个免费的证书颁发机构（CA），超棒的！ 步骤 2: 安装 SSL 证书获得证书后，要把它安装到你的服务器上。安装的具体方法取决于你的网站服务器种类，我们来看常见的两种情况。 a. Nginx 服务器 将 SSL 证书和私钥上传到服务器。 修改 Nginx 配置文件（通常在 /etc/nginx/sites-available/ 里面）： 1234567891011121314151617181920212223server &#123; listen 80; server_name example.com www.example.com; return 301 https://$host$request_uri; # 重定向到 https&#125;server &#123; listen 443 ssl; server_name example.com www.example.com; ssl_certificate /path/to/ssl/certificate.crt; ssl_certificate_key /path/to/private/key.key; # 启用 HTTPS 的一些推荐配置 ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers HIGH:!aNULL:!MD5; location / &#123; # 网站的根目录 root /var/www/html; index index.html; &#125;&#125; 保存配置，然后重启 Nginx： 1sudo systemctl restart nginx b. Apache 服务器 打开 Apache 配置文件（通常在 /etc/apache2/sites-available/ 里面）： 1234567891011121314151617181920&lt;VirtualHost *:80&gt; ServerName example.com Redirect permanent / https://example.com/&lt;/VirtualHost&gt;&lt;VirtualHost *:443&gt; ServerName example.com SSLEngine on SSLCertificateFile /path/to/ssl/certificate.crt SSLCertificateKeyFile /path/to/private/key.key SSLCertificateChainFile /path/to/ca_bundle.crt DocumentRoot /var/www/html &lt;Directory /var/www/html&gt; Options Indexes FollowSymLinks AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 启用 SSL 模块并重启 Apache： 12sudo a2enmod sslsudo systemctl restart apache2 步骤 3: 强制 HTTPS虽然你已经配置好 HTTPS 了，但是还需要确保所有用户都通过 HTTPS 来访问你的站点呢~ 最简单的方法就是在 Nginx 或 Apache 里设置 301 重定向，前面我们已经有提到啦，就是那个把 HTTP 重定向到 HTTPS 的部分。 步骤 4: 测试你的 HTTPS哇，终于配置好了！接下来打开浏览器，访问你的网站 https://your-domain.com，看看是不是成功显示一个小锁头🔒啦？如果有小锁头，恭喜你，HTTPS 配置成功！ 别忘了用在线工具 SSL Labs 来测试你的 SSL 证书是否配置得完美哦~ tomcat配置证书和Nginx配置https证书有何区别？"},{"title":"深度学习中nchw_to_nlc函数总结","path":"/2024/09/19/深度学习中nchw-to-nlc函数总结/","content":"下面的例子展示了如何手动实现 NCHW 到 NLC 的转换，使用纯 Python 列表和基础的列表操作。 NCHW -&gt; NLC 的手动实现12345678910111213141516171819202122232425262728293031323334import numpy as np# 创建一个 4D 张量 (NCHW)，Batch Size = 2, Channels = 3, Height = 4, Width = 4nchw_tensor = np.random.randn(2, 3, 4, 4) # 使用numpy来初始化张量print(&quot;NCHW 格式的张量：&quot;)print(nchw_tensor.shape) # 输出 (2, 3, 4, 4)# 手动转换 NCHW -&gt; NLCbatch_size, channels, height, width = nchw_tensor.shape# 初始化一个新的列表以存储转换后的数据nlc_tensor = []# 遍历每个 batchfor b in range(batch_size): # 存储每个 batch 的结果 batch_result = [] # 对于每个 batch，我们需要将 (Height, Width) 展开为一个长度 (Length)，然后通道排到最后 for h in range(height): for w in range(width): # 对于每个 (h, w) 位置，取出所有的通道值，并将它们组合成一个长度为 channels 的列表 pixel_data = nchw_tensor[b, :, h, w] batch_result.append(pixel_data) # 把这个 batch 的结果加到最终的输出列表中 nlc_tensor.append(batch_result)# 转换为 NumPy 数组，得到最终的形状nlc_tensor = np.array(nlc_tensor)print(&quot; 转换为 NLC 格式的张量：&quot;)print(nlc_tensor.shape) # 输出应为 (2, 16, 3)，其中 16 = 4 * 4（合并了 H 和 W） 代码解释： 创建初始张量： nchw_tensor 是一个 4D 的 NumPy 数组，形状为 (2, 3, 4, 4)，即 Batch Size = 2，Channels = 3，Height = 4，Width = 4。 手动遍历维度： 使用四重嵌套循环，其中： 第一层循环遍历每个批次 (b)； 第二、三层循环遍历 Height 和 Width 的每一个位置 (h, w)； 对于每个 (h, w) 位置，提取所有的通道数据，并将它们作为一组。 将每组通道数据按顺序存入 batch_result 列表中。 合并 Height 和 Width： 对于每个 batch，将 (Height, Width) 的像素展开为一个长度，得到的张量形状为 (Batch Size, Length, Channels)。其中 Length = Height * Width。 最终结果： 手动构造的 nlc_tensor 最终转换为 NumPy 数组，它的形状是 (2, 16, 3)，符合 NLC 格式。 输出：12345NCHW 格式的张量：(2, 3, 4, 4)转换为 NLC 格式的张量：(2, 16, 3) 手动实现的缺点： 虽然这个手动实现清楚地展示了张量的维度转换过程，但相对于使用库函数，它效率低，尤其是在数据规模较大时。 使用嵌套循环手动处理数据比用高效的库（如 PyTorch、NumPy 等）更慢，且代码冗长。 总结：虽然在实际工作中通常使用框架的内置函数（如 permute、reshape 等）进行张量操作，但理解手动转换的过程可以帮助你更好地掌握这些操作的本质。这个手动示例展示了如何通过基本的 Python 列表和循环，将 NCHW 格式的张量转换为 NLC 格式。"},{"title":"Hello World","path":"/2024/09/19/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"快速排序算法","path":"/2024/09/18/快速排序算法/","content":"利用递归，划分子区间"},{"title":"RESTful_API","path":"/2024/09/18/RESTful-API/","content":"RESTful API（Representational State Transfer API）是一种设计风格，用于构建基于Web的应用程序和服务。它允许客户端（比如浏览器或移动应用）通过HTTP协议与服务器进行通信，通常涉及以下几个重要概念： 1. 资源（Resources） 资源是指你希望通过API管理的数据实体，比如用户、订单或产品。每个资源都有一个唯一的标识符（通常是一个URL）。 例如，如果你在构建一个电子商务网站，/products 可能是一个表示所有产品的资源，/products/123 可能表示一个特定的产品。 2. HTTP 方法RESTful API使用HTTP方法来执行不同的操作： GET：获取资源的表示。比如，GET /products 获取所有产品，GET /products/123 获取ID为123的产品。 POST：创建一个新的资源。比如，POST /products 发送一个新的产品数据，创建一个新产品。 PUT：更新一个现有的资源。比如，PUT /products/123 更新ID为123的产品的详细信息。 DELETE：删除一个资源。比如，DELETE /products/123 删除ID为123的产品。 3. 无状态（Stateless）每个请求都是独立的，服务器不会保存客户端的状态。每个请求必须包含所有信息以完成请求，例如，身份验证信息和请求数据。服务器不需要记住客户端的状态。 4. 可缓存（Cacheable）响应应标记为可缓存或不可缓存，以提高性能。比如，如果获取的数据不经常变化，可以将其缓存，以减少对服务器的请求。 5. 统一接口（Uniform Interface）RESTful API具有统一的接口，这意味着无论客户端如何与API交互，接口的行为是一致的。主要包括： 资源的标识：资源通过URI（统一资源标识符）标识。 资源的表现：资源可以通过不同的格式（如JSON或XML）表示。 自描述消息：消息中包含足够的信息，使接收方能够理解如何处理。 超媒体作为应用程序状态的引擎（HATEOAS）：服务器提供的响应包括了进一步操作的链接，帮助客户端动态导航API。 6. 层次结构（Layered System）API可以由多个层次组成，每一层可以处理请求和响应，客户端无法直接知道服务器的具体实现。这种层次化使得系统更加可扩展和维护。 示例假设你有一个管理图书的API，以下是一些常见的RESTful API操作示例： 获取所有图书1GET /books 获取特定图书1GET /books/1 创建新图书123456POST /booksContent-Type: application/json&#123; &quot;title&quot;: &quot;New Book&quot;, &quot;author&quot;: &quot;Author Name&quot;&#125; 更新特定图书123456PUT /books/1Content-Type: application/json&#123; &quot;title&quot;: &quot;Updated Book Title&quot;, &quot;author&quot;: &quot;Updated Author Name&quot;&#125; 删除特定图书1DELETE /books/1"},{"title":"腾讯云函数","path":"/2024/09/18/腾讯云函数/","content":"腾讯云函数（Cloud Functions for Tencent Cloud，简称 SCF）是一个事件驱动的无服务器计算平台，主要用于简化和加速云端应用的开发。它支持你在云上运行代码，而无需管理服务器基础设施。以下是一些常见的使用场景： 1. 事件驱动的计算 数据处理：当数据存储到腾讯云对象存储（COS）中时，自动触发函数进行数据处理或转换，比如对上传的图片进行压缩或格式转换。 消息处理：从消息队列（如 CMQ、CKafka）中获取消息，并处理这些消息，比如订单处理、日志分析等。 2. Web 应用的后端服务 API 接口：用于构建和部署 API 接口。你可以用腾讯云函数实现轻量级的 RESTful API，不需要管理传统服务器。 后台任务：处理来自前端的请求，比如用户注册、登录等操作。 3. 自动化操作 定时任务：设置定时触发函数执行任务，例如定期备份数据库、清理过期数据等。 自动化运维：自动执行运维脚本，例如监控系统状态、自动扩展资源等。 4. 集成与互操作 第三方服务集成：通过触发器或事件，将云函数与其他云服务或第三方服务集成。例如，响应来自外部 API 的请求，或在数据变更时更新外部服务。 自定义逻辑：实现自定义业务逻辑，比如在用户上传文件后，自动发送通知或更新用户数据。 5. 无服务器计算 微服务架构：在微服务架构中，云函数可以作为独立的微服务组件，处理特定的业务逻辑和功能。 弹性伸缩：云函数具有自动伸缩能力，根据请求的数量自动调整计算资源，适合处理变化不定的负载。 6. 安全和审计 安全操作：在特定事件发生时自动执行安全操作，比如扫描恶意软件、检查数据合规性等。 日志记录：自动记录操作日志，用于审计和分析。 这些场景展示了腾讯云函数的灵活性和广泛应用，可以根据具体需求进行配置和扩展，使得开发者能够专注于业务逻辑，而无需担心基础设施的维护。"},{"title":"cloudflare","path":"/2024/09/17/cloudflare/","content":"在当今的数字时代，网站的性能、安全性和可靠性对各种规模的企业都至关重要。而Cloudflare正是革新了网站内容交付和保护方式的公司。 Cloudflare是什么？Cloudflare是一家美国公司，提供一系列旨在提高网站和互联网应用程序的安全性、性能和可靠性的服务。其服务包括内容分发网络（CDN）、DDoS防护、Web应用防火墙（WAF）和DNS服务等。 Cloudflare的核心原理Cloudflare的运作基于几个关键原则： DNS重定向 反向代理 缓存 全球分布式网络 安全过滤 协议优化 边缘计算 智能路由 让我们详细探讨每一个原理。 1. DNS重定向当你访问受Cloudflare保护的网站时，会发生以下过程： 123456789101112sequenceDiagram participant 用户 participant DNS participant Cloudflare participant 源服务器 用户-&gt;&gt;DNS: 请求网站IP DNS-&gt;&gt;Cloudflare: 返回Cloudflare IP 用户-&gt;&gt;Cloudflare: 请求内容 Cloudflare-&gt;&gt;源服务器: 如果未缓存则获取内容 源服务器-&gt;&gt;Cloudflare: 返回内容 Cloudflare-&gt;&gt;用户: 提供内容 DNS查询返回的是Cloudflare的IP地址，而不是原始服务器的IP。这意味着所有流量首先通过Cloudflare。 2. 反向代理Cloudflare充当用户和原始服务器之间的中间人。它接收所有发往网站的请求，可以过滤、修改或优化这些请求，然后再转发给原始服务器。 3. 缓存Cloudflare可以缓存静态内容，如图片、CSS和JavaScript文件。对于经常请求的内容，Cloudflare可以直接从其服务器提供，减少对原始服务器的负载并加快交付速度。 4. 全球分布式网络Cloudflare在全球拥有数百个数据中心。用户请求被路由到最近的数据中心，显著减少延迟并改善加载时间。 5. 安全过滤所有通过Cloudflare的流量都经过安全检查。这使得Cloudflare能够在恶意流量（包括DDoS攻击）到达原始服务器之前就将其阻止。 6. 协议优化Cloudflare支持最新的网络协议，如HTTP&#x2F;3，即使原始服务器不支持。它可以在客户端和服务器之间进行协议转换，确保最佳性能。 7. 边缘计算通过Cloudflare Workers，开发者可以在Cloudflare网络的边缘运行代码。这支持实时内容修改、A&#x2F;B测试等功能，无需更改原始服务器设置。 8. 智能路由Cloudflare的Argo智能路由技术实时优化网络路径。它分析网络状况，选择数据传输的最快路径。 为什么Cloudflare很重要利用这些原理，Cloudflare显著提高了网站性能、安全性和可靠性。以下是它的重要性： 提升速度：更快的加载时间带来更好的用户体验，可能对SEO产生积极影响。 增强安全性：对各种网络威胁的保护确保了您的网站和用户安全。 减轻服务器负载：通过自身处理许多请求，Cloudflare减轻了源服务器的负担。 经济高效的扩展：Cloudflare的服务可以帮助网站应对流量高峰，无需升级服务器基础设施。 全球覆盖：即使是小型网站也能受益于全球服务器网络，为世界各地的用户提供更好的性能。 结论Cloudflare已成为现代网络基础设施不可或缺的一部分。理解其工作原理可以帮助网站所有者和开发者更好地利用其功能，创造更快、更安全、更可靠的在线体验。 无论您是经营个人博客还是管理大型电子商务网站，Cloudflare的技术都可以帮助您更高效、更安全地交付内容。随着互联网的不断发展，像Cloudflare这样的服务将在塑造我们的在线世界中发挥越来越重要的作用。"},{"title":"Linux","path":"/2024/09/17/Linux/","content":"centos命令行操作，配合带远程文件管理器的终端（cursor&amp;vscode remotessh插件）即可完成大部分编程工作。没有GUI页面。"},{"title":"PPT制作总结","path":"/2024/09/15/PPT制作总结/","content":"高效美观地传递信息"},{"title":"Google Colab","path":"/2024/09/15/Google-Colab/","content":"谷歌硬盘保存代码及数据"},{"title":"编码隐匿在计算机软硬件背后的语言","path":"/2024/09/15/编码隐匿在计算机软硬件背后的语言/","content":"人们在相互沟通时使用了各种不同的编码，因为在不同的应用场合，其中的一些较其他的更为简便。例如，语言不能在纸上存储，所以使用了文字；语言、文字不适合用来在黑夜中安静地传递消息，故摩尔斯电码是一个方便的替代品。只要一种编码可以适用于其他编码所不能适用的场合，它就是一种有用的编码。 总结:为特定环境编码提高效率，满足需求"},{"title":"Gulp","path":"/2024/09/15/Gulp/","content":"Gulp 是一个基于 Node.js 的自动化构建工具，专门用于前端开发工作流的优化。它可以帮助开发者自动执行一些常见的任务，比如压缩文件、编译 Sass&#x2F;LESS、优化图片、自动刷新浏览器等，大大简化了开发过程中的重复劳动。 Gulp 的核心概念： 任务（Tasks）：Gulp 的核心就是任务。每个任务是一个函数，定义好后，Gulp 会按你的需求执行它们，比如压缩文件或转译代码。 管道流（Pipelines）：Gulp 使用流（streams）处理文件数据，你可以通过管道的方式让文件经过多个处理步骤，非常高效。 插件（Plugins）：Gulp 有很多插件来处理具体的任务，比如 gulp-sass 用于编译 Sass，gulp-uglify 用于压缩 JS 文件。 Gulp 的常见用途： 编译预处理语言：比如将 Sass 或 LESS 编译成 CSS。 压缩文件：将 JavaScript、CSS 压缩，减少体积，提高加载速度。 实时刷新：通过监听文件的变化，自动刷新浏览器。 文件合并：将多个 JS 或 CSS 文件合并成一个文件，减少 HTTP 请求。 优化图片：通过压缩图像文件来提高网页性能。 Gulp 的使用步骤： 安装 Gulp：在项目中通过 npm 安装 Gulp。 12npm install --global gulp-clinpm install --save-dev gulp **创建 gulpfile.js**：这是 Gulp 的配置文件，定义各种任务。 12345678// gulpfile.jsconst gulp = require(&#x27;gulp&#x27;);// 定义一个任务gulp.task(&#x27;default&#x27;, (done) =&gt; &#123; console.log(&#x27;Hello Gulp!&#x27;); done();&#125;); 运行任务：在终端中运行 gulp 命令，它会执行你定义的默认任务。 1gulp Gulp 例子：假设你想用 Gulp 编译 Sass 文件并压缩输出的 CSS，你可以这样配置： 12345678910111213141516171819const gulp = require(&#x27;gulp&#x27;);const sass = require(&#x27;gulp-sass&#x27;)(require(&#x27;sass&#x27;));const cleanCSS = require(&#x27;gulp-clean-css&#x27;);// 编译 Sass 并压缩 CSSgulp.task(&#x27;sass&#x27;, function() &#123; return gulp.src(&#x27;src/scss/*.scss&#x27;) // 源文件路径 .pipe(sass().on(&#x27;error&#x27;, sass.logError)) // 编译 Sass .pipe(cleanCSS()) // 压缩 CSS .pipe(gulp.dest(&#x27;dist/css&#x27;)); // 输出路径&#125;);// 监听文件变化gulp.task(&#x27;watch&#x27;, function() &#123; gulp.watch(&#x27;src/scss/*.scss&#x27;, gulp.series(&#x27;sass&#x27;)); // 监听 Sass 文件的变化&#125;);// 默认任务gulp.task(&#x27;default&#x27;, gulp.series(&#x27;sass&#x27;, &#x27;watch&#x27;)); Gulp 的优点： 快速且高效：由于它是基于流的操作，不需要生成临时文件，处理速度很快。 插件丰富：Gulp 拥有庞大的插件生态，能够满足几乎所有前端自动化任务。 易于使用：配置文件简单明了，逻辑清晰。"},{"title":"哈希表","path":"/2024/09/15/哈希表/","content":"哈希表将value和key关联起来，通过value计算出key实现快速判断一个元素是否出现集合里。 参考文章代码随想录"},{"title":"Vue中$nextTick的使用","path":"/2024/09/15/Vue中-nextTick的使用/","content":"$nextTick官方解释：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM因为vue中不是数据一发生改变就马上更新视图层的，如果这样会带来比较差的性能优化，而是在vue中会添加到任务队列中，待执行栈的任务处理完才执行。所以vue中我们改变数据时不会立即触发视图，但是如果我们需要实时获取到最新的DOM,这个时候可以手动调用nextTick。 性能优化体现在哪里?Vue 的性能优化主要体现在它的 异步更新策略 和 批量 DOM 更新 机制，而 $nextTick 就是为了配合这些机制而存在的。让我用更简单的方式解释一下哈： 异步更新：当数据发生变化时，Vue 并不会立刻更新 DOM。相反，Vue 会将这些变化放到一个队列中，然后在当前的事件循环（event loop）结束时再统一处理这些更新。这样就避免了每次数据变化时立刻对 DOM 进行操作，减少了不必要的频繁更新。 批量更新：Vue 会对相同的 DOM 进行 批量更新，即如果在同一事件循环中多次修改数据，Vue 只会更新一次 DOM。这也是 Vue 的一种优化手段，不会因为多次数据变化导致多次 DOM 操作。 为什么这样做是性能优化呢？ 减少重绘重排：每次 DOM 更新都会引起页面的重绘或重排，这是非常耗性能的操作。通过异步和批量更新，Vue 可以把多次变化合并成一次更新，从而减少性能开销。 降低浏览器负担：频繁操作 DOM 是很消耗资源的，尤其是在复杂的页面中。Vue 通过将更新推迟到当前事件循环结束后，能够让浏览器有时间完成其他更重要的任务。 所以，$nextTick 就是为了帮助你在 Vue 进行异步更新 DOM 的同时，如果你需要立刻获取更新后的 DOM，可以使用 $nextTick 来确保你拿到的 DOM 是最新的。这种机制既保证了性能，也保证了功能的正确性。"},{"title":"中缀表达式转后缀表达式","path":"/2024/09/14/中缀表达式转后缀表达式/","content":"从左到右依次扫描中缀表达式遇到元素为数字直接输出遇到算数运算符入栈遇到”(“入栈遇到”)”, 匹配左括号，所以栈顶元素依次出栈，直到”(“, 左括号也要出栈，然后直接扔掉，不放于结果后遇到符号，但栈顶符号优先大于当前元素，所以出栈〈栈中符号优先级如果都不小于当前元素则全部出栈）。当前元素入栈。最后如果栈中还有元素，则栈中符号依次出栈。"},{"title":"前中后缀表达式","path":"/2024/09/14/前中后缀表达式/","content":"中缀表达式：运算符夹在操作数中间，比如 A + B。我们平时最常用的就是这种表达方式。 后缀表达式（也叫逆波兰表达式）：运算符放在操作数的后面，比如 A B +。这种方式没有括号，计算顺序完全取决于操作符的先后位置。"},{"title":"完全二叉树","path":"/2024/09/14/完全二叉树/","content":"完全二叉树只允许最后一行不为满 最后一行必须从左往右排序 最后一行元素之间不可以有间隔"},{"title":"策略模式","path":"/2024/09/14/策略模式/","content":"策略模式允许用户在运行时选择算法或行为的具体实现。使用策略模式可以定义一系列的算法，并将每一个算法封装起来，使他们可以相互替换，这样算法的变化不会影响到使用算法的客户端"},{"title":"Vue中的ref","path":"/2024/09/13/Vue中的ref/","content":"ref常用来辅助开发者，获取DOM元素或组件的引用，以及用于在父子组件中获取对方的某个元素进行取值，调用方法等。在每个Vue的组件实例上，都包含一个$refs对象，里面存储着对应的DOM元素或组件的引用·默认情况下，组件的$refs指向一个空对象·如果想要使用ref引用页面上的组件实例，则可以按照如下方式：·使用ref属性，为对应的组件添加引用名称 12345678&lt;my-counter ref=&quot;counterRef&quot;&gt;&lt;/my-counter&gt;&lt;button@click=&quot;getRef&quot;&gt;获取$refs引用&lt;/button:&gt;methods:getRef()&#123;//通过this.$refs.引用的名称，可以引用组件的实例console.log(this.$refs.counterRef)//引用到组件的实例之后，就可以调用组件上的methods方法this.$refs.counterRef.add() 这个方法可以说很便利，但是不要太依赖了，往往在不能通过其他方法获取的时候回才比较建议使用，毕竟我们因该尽量减少添加，而是复用可以复用的部分。 $refs只会在组件渲染完成之后生效，并且不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”一你应该避免在模板或计算属性中访问tip:如果获取不到的时候，可以试一试使用nextTick"},{"title":"虚拟DOM","path":"/2024/09/13/虚拟DOM/","content":"一、什么是虚拟DOM呢？再过去或者我们原生JavaScript的时候，我们可以发现，当我们需要改变视图的数据的时候，我们往往需要先获取到这个DOM元素，然后对其进行更新。也就是：数据改变–&gt;操作D0M–&gt;视图更新但是我们在VUE或者React中是直接改变Data就能实现视图的更新了。数据改变–&gt;视图更新那么要是我们每一次数据改变都需要操作DOM,那就非常麻烦，而且慢。因为JavaScript:执行时很快的，但是操作DOM就不是了。所以就有了虚拟DOM了数据改变–&gt;操作虚拟D0M(计算变更)–&gt;操作真实的D0M–&gt;视图更新那么什么虚拟DOM呢？可以说虚拟DOM本质上是JS和DOM之间的映射，表现为是一个能描述DOM结构及其属性信息的JS对象。那么下面我们看一个例子为什么这么说吧： 1234567891011121314151617181920212223242526//我们定义的D0M&lt;div id=&quot;app&quot;&gt;&lt;p class=&quot;text&quot;&gt;hello&lt;/p&gt;&lt;h1 class=&quot;text&quot;&gt;hello world!!!&lt;/h1&gt;&lt;/div&gt;//转换为虚拟D0M&#123;tag:&#x27;div&#x27;,props:id:&#x27;app&#x27;&#125;,chidren:&#123;tag:&#x27;p&#x27;,props:className:&#x27;text&#x27;&#125;,chidren:hello&#x27;&#125;,tag:&#x27;h1&#x27;,props:className:&#x27;text&#x27;&#125;,chidren:&#x27;hello world!!！&#x27; 实际上就是通过JavaScript对象来作为基础的树，用对象的属性来描述节点，然后通过映射成真实的DOM结构。二、那么这么做有什么好处呢1、优化性能我们常说要减少重排的发生，那是为什么呢，因为那会涉及到DOM树的重新渲染。而操作DOM树是比较慢的，且DOM元素的数量是很庞大的，当操作DOM很容易带来页面的性能问题。很容易给用户带来不好的体验，而这点是很重要的，可以说我们前端页面是与用户的第一个窗口。比如，正常情况下，当我们要更新10个节点的时候，浏览器就会计算10次，一次一次的进行更新。而在使用虚拟DOM，他相对就好像多了一个缓存区，当DOM操作（渲染更新）比较频繁时，它会先将前后两次的虚拟D0M树进行对比，定位出具体需要更新的部分，生成一个“补丁集”（也就是一个S对象），最后只把“补丁”一次性打在需要更新的那部分真实的D0M树上，避免了很多没必要的计算，提高了性能。2、抽象化渲染过程很多人认为虚拟DOM最大的优势是diff算法，减少JavaScript操作真实DOM的带来的性能消耗。虽然这一个虚拟DOM带来的一个优势，但并不是全部。虚拟D0M最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的DOM,可以是安卓和I○S的原生组件，可以是近期很火热的小程序，也可以是各种GUI。解耦了视图层和渲染平台，带来了更多的可能性有点像我们语言中，都会编译成AST,而在这个阶段，可以实现多种转化，就像Babel，和ESList等。3、缺点也是有的：在初次渲染的时候，会多出一层虚拟DOM的计算，而且使用虚拟D○M也不一定是高效的，往往当我们每一次改动不大的时候，才是相对高效的，但是如果我们改动大的话，相比还多出了更多的计算，是不利的。总结虚拟DOM本质上是JS和DOM之间的映射，表现为一个能描述DOM结构及其属性信息的JS对象。没有使用虚拟DOM时，当我们改变数据-&gt;就需要操作DOM-&gt;然后视图更新，当是当我们使用虚拟DOM,就是我们改变数据-&gt;框架就会操作虚拟DOM进行计算变更-&gt;之后映射到真实的DOM上-&gt;完成视图更新。当我们说虚拟DOM的优点，我们常说虚拟DOM提高效率，其实这需要根据场景而言的！当操作DOM的数量比较少的时候，使用虚拟DOM反而效率低，因为添加了更多的计算等操作。而当操作大量DOM的时候，使用虚拟DOM会将多次操作合并为一次更新，减少JavaScript操作真实DOM的带来的性能消耗。另外一个重要的优点是虚拟DOM抽象了原本的渲染过程，实现了跨平台，跨端的能力！不再局限于浏览器！"},{"title":"Vue中的key","path":"/2024/09/12/Vue中的key/","content":"关于key,我们常常在v-for中会接触到，当我们需要进行列表循环的时候，如果没有使用key,就会有警报提示。 123456//场景一：循环列表&lt;div v-for=&quot;num in numbers&quot; :key=&quot;index&quot;&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;//场景二：通过时间戳强制重新渲染&lt;div :key=&quot;+new Date()&quot;&gt;+new Date()&lt;/div&gt; 那么为什么需要key呢？因为使用key相当于给node添加上一个唯一的id,主要是在DOM DIFF算法中使用的下面我们看个例子：1.如果上面的场景一items的值为[1,2,3,4,5,6,7,8,9,10]那么就是渲染出十个div是吧。如果没有key,那么当我们现在items的值变为[0,1,2,3,4,5,6,7,8,9呢，那么机会第一个原来是”1”的div内容变为0，而原来是”2”的div内容变为”1”..以此类推。（因为没有key属性，Vue无法跟踪每个节点，使用的是“就地复用”得策略，通过这样的方法来完成变更)但是如果key的情况下，Vue能跟踪每个节点，就会直接新增一个div添拥到内容是”1”的div前面。根据key,更准确，更快的找到对应的vnode节点。设置key能够大大减少对页面的DOM操作，提高了diff效率，更加的高效更新虚拟D0M2.还有的用途就是我们的场景二用来强制替换元素，当key改变时，Vue认为个新的元素产生了, 从而会新插入一个元素来替换掉原有的元素。所以上面的元素会被删除而重新添加。但是如果没有添加key的话，就会直接替换dv里面的内容。而不是删除添加元素。注意点尽量不要使用索引index做key的值，要使用唯一的标识值，比如id之类的，因为如果使用数组索引index为key,当向数组中指定位置插入一个新元素后，因为这时候会重新更新index索引，对应着后面的虚拟DOM的key值全部更新了，这时候做的更新是没有必要的，就像没有加key一样，因此index虽然能够解决key不冲突的问题，但是并不能解决复用的情况。如果没有唯一ID的情况下，可以使用用组件的uid拼接index的形式，因为uid是唯一的。或者生成一个时间戳~。总结关于在v-for中使用key是因为使用key相当于给节点添加上一个唯一的id,在DOM DIFF算法中能更高效的更新虚拟DOM。当没有使用的时候，如果我们需要对一个循环渲染的列表插入一个，那么实际上会“就地复用”的策略，比如我们需要在最前面插入一个，那么就会后面的全部往后变更，发生多次DOM操作，这是因为u无法跟踪每个节点，而使用ky后，节点标识，定位到最前面，然后插入修改，只发生一次DOM操作，大大优化了性能。"},{"title":"computed和watch的区别","path":"/2024/09/12/computed和watch的区别/","content":"computed和watch的区别一、这两者解决的问题当我们的数据发生改变的时候，所有和该数据有关的数据都自动更新，执行我们定义的方法。不同于methods是需要相关的方法和交互来实现调用执行的。二、computed和watch以及methods的区别1、性质上methods:定义函数，手动调用computed:计算属性，return返回结果，自动调用watch:观察，监听，发生改变就调用2、使用场景methods：一般不处理数据的逻辑，用于获取数据，和改变状态等情况computed：多用于一个数据受多个数据影响的情况，具有缓存的特性，避免每次重新计算watch：多用于一个数据影响多个数据的情况，且类似异步等情况的时候建议使用3、执行时间computed和methods的初始化是在beforeCreated和created之间完成的。（以及Props,data都是）4、缓存computed:有缓存，重新渲染时，要是值没有改变，会直接返回之前的watch:无缓存，重新渲染时，要是值没有改变，也会执行5、是否异步computed:不支持异步，但异步监听的时候，无法监听数据变化watch:支持异步监听三、computed和methods的区别无论是定义为一个计算属性还是一个函数方法，对于结果来说都是一样的，不同点在于，计算属性是根据依赖值变化才发生改变，而函数方法需要调用执行。"},{"title":"IEEE论文模板总结","path":"/2024/09/11/IEEE论文模板总结/","content":"Title Titles should be written in uppercase and lowercase letters, not all uppercase. Abstract Abstract must be an accurate, stand-alone reflection of the contents of the article. They shall not contain displayed mathematical equations, numbered reference citations, nor footnotes. They should include three or four different keywords or phrases, as this will help readers to find it. It is important to avoid over-repetition of such phrases as this can result in a page being rejected by search engines. Ensure that your abstract reads well and is grammatically correct. Index Terms Enter keywords or phrases in alphabetical order, separated by commas. Using the IEEE Thesaurus can help you find the best standardized keywords to fit your article. Use the thesaurus access request form for free access to the IEEE Thesaurus 样式是有系统或用户定义保存的一系列排版格式，包括字体、段落、制表符和边距等。使用样式，可以轻松地对文档进行排列，并保持格式的严格一致。 模板(.dotx) File Formats for Graphics Format and save your graphics using a suitable graphics processing program that will allow you to create the images as PostScript (PS), Encapsulated PostScript (.EPS), Tagged Image File Format (.TIFF), Portable Document Format (.PDF), JPEG, or Portable Network Graphics (.PNG). These programs can re-size them and adjust the resolution settings. If you created your source files in one of the following programs you will be able to submit the graphics without converting to a PS, EPS, TIFF, PDF, or PNG file: Microsoft Word, Microsoft PowerPoint, or Microsoft Excel. Though it is not required, it is strongly recommended that these files be saved in PDF format rather than DOC, XLS, or PPT. Doing so will protect your figures from common font and arrow stroke issues that occur when working on the files across multiple platforms. When submitting your final files, your graphics should all be submitted individually in one of these formats along with the manuscript. Sizing of Graphics Most charts, graphs, and tables are one column wide (3.5 inches &#x2F; 88 mm &#x2F; 21 picas) or page wide (7.16 inches &#x2F; 181 millimeters &#x2F; 43 picas). The maximum depth a graphic can be is 8.5 inches (216 millimeters &#x2F; 54 picas). When choosing the depth of a graphic, please allow space for a caption. Figures can be sized between column and page widths if the author chooses, however, it is recommended that figures not be sized less than column width unless when necessary.The final printed size of author photographs is exactly1 in wide by 1.25 in tall (25.4 mm x 31.75 mm &#x2F; 6 picas x 7.5 picas). Author photos printed in editorials measure 1.59 in wide by 2 in tall (40 mm x 50 mm &#x2F; 9.5 picas x 12 picas). Resolution The proper resolution of your figures will depend on the type of figure it is as defined in the “Types of Figures” section. Author photographs, color, and grayscale figures should be at least 300dpi. Line art, including tables should be a minimum of 600dpi. Vector Art In order to preserve the figures’ integrity across multiple computer platforms, we accept files in the following formats: .EPS&#x2F;.PDF&#x2F;.PS. All fonts must be embedded or text converted to outlines in order to achieve the best-quality results. Color Space The term “color space” refers to the entire sum of colors that can be represented within the said medium. For our purposes, the three main color spaces are grayscale, RGB (red&#x2F;green&#x2F;blue), and CMYK (cyan&#x2F;magenta&#x2F;yellow&#x2F;black). RGB is generally used with on-screen graphics, whereas CMYK is used for printing purposes.All color figures should be generated in RGB or CMYK color space. Grayscale images should be submitted in grayscale color space. Line art may be provided in grayscale OR bitmap colorspace. Note that “bitmap colorspace” and “bitmap file format” are not the same thing. When bitmap color space is selected, .TIF&#x2F;.TIFF&#x2F;.PNG are the recommended file formats. Accepted Fonts Within Figures When preparing your graphics, IEEE suggests that you use one of the following Open Type fonts: Times New Roman, Helvetica, Arial, Cambria, or Symbol. If you are supplying EPS, PS, or PDF files, all fonts must be embedded. Some fonts may only be native to your operating system; without the fonts embedded, parts of the graphic may be distorted or missing.A safe option when finalizing your figures is to strip out the fonts before you save the files, creating “outline” type. This converts fonts to artwork which will appear uniformly on any screen. CONCLUSION conclusion section is not required. Although a conclusion may review the main points of the article, do not replicate the abstract as the conclusion. A conclusion might elaborate on the importance of the work or suggest applications and extensions."},{"title":"v-show和v-if的区别","path":"/2024/09/11/v-show和v-if的区别/","content":"1 、本质上 v-show 是把标签里的 display 设置为 none ，所以页面上是可见的 v-if 是动态的操作 DOM 元素，页面上不可见的 2 、性能上 要是需要频繁的操作的话，肯定是v-show ，因为他只是操作css的值，不会频繁触发重排。但是v-if是不断的向DOM 树添加或删除元素，在比较少改变的时候比较合适的 v-show无论任何条件，初始都会渲染， v-if是惰性的，如果初始条件为false ，初始不会渲染DOM ，为true才会渲染。因此v-if有更高的切换开销，而 v-show 有更高的初始渲染开销"},{"title":"Vue-router中hash模式和history模式的区别","path":"/2024/09/11/Vue-router中hash模式和history模式的区别/","content":"最明显的是在显示上， hash 模式的 URL 中会夹杂着#号，而 history 没有。 Vue 底层对它们的实现方式不同。 hash 模式是依靠 onhashchange 事件（监听 location.hash 的改变），而 history 模式是主要是依靠的 HTML5 history 中新增的两个方法， pushState() 可以改变 url 地址且不会发送请求，replaceState() 可以读取历史记录栈，还可以对浏览器记录进行修改。 当真正需要通过 URL 向后端发送 HTTP 请求的时候，比如常见的用户手动输入 URL 后回车，或者是刷新（重启）浏览器，这时候 history 模式需要后端的支持。因为 history 模式下，前端的 URL 必须和实际向后端发送请求的 URL一致，例如有一个 URL 是带有．路径 path 的（例如 www.lindaidai.wang/blogs/id) ，如果后端没有对这个路径做处理的话，就会返回 404 错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个 404 页面"},{"title":"订单网站团队协作开发回顾","path":"/2024/09/10/订单网站团队协作开发回顾/","content":"进度把控能力任务拆解能力"},{"title":"windows高效工具列表","path":"/2024/09/09/windows高效工具列表/","content":"notion sublime text vscode syncthing atom github noi microsoft powertoys bitwarden git microsoft whiteboard"},{"title":"OJ在线编程常见输入输出练习场总结","path":"/2024/09/09/OJ在线编程常见输入输出练习场总结/","content":"对于javascript语言, 掌握readline()函数和split()函数的使用编写代码速度要看内功，代码只是形式，编写代码过程中先在纸上完成题目的分析和方法的筛选，这一步先不要用代码作为分析语言，用纯逻辑分析，逻辑要严密，相当于在大脑中先运行排除掉一些后续翻译代码潜在的的bug，然后代入一个测试用例模拟运行分析是否可行，在纸上分析觉得可以的话就可以开始编码（题目简单基础的话可以只在大脑中完成），遇到bug就结合纸上的模拟运行的记录进行debug, 很多面试题都是考察经典的计算机编程理论"},{"title":"passwordtry","path":"/2024/09/08/passwordtry/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107const rl = require(&quot;readline&quot;).createInterface(&#123; input: process.stdin &#125;);var iter = rl[Symbol.asyncIterator]();const readline = async () =&gt; (await iter.next()).value;void async function () &#123; // // Write your code here // while(line = await readline())&#123; // let tokens = line.split(&#x27; &#x27;); // let a = parseInt(tokens[0]); // let b = parseInt(tokens[1]); // console.log(a + b); // &#125; let n = parseInt(await readline()) let correct = await readline() let test = [] for(let i = 0; i &lt; n; i++)&#123; test.push(await readline()) &#125; // console.log(test) let qpl = [] let arr = [] let idxarr = new Array(test.length).fill(0) // console.log(idxarr) const permute = (test) =&gt; &#123; let result = []; // 用于存放最终的所有排列 let arr = []; // 当前的排列结果 let used = new Array(test.length).fill(false); // 标记哪些元素已经使用过 const backtracking = () =&gt; &#123; // 当排列长度等于输入数组长度时，表示找到一个完整的排列 if (arr.length === test.length) &#123; result.push(arr.slice()); // 将当前排列的拷贝加入结果 return; &#125; // 遍历数组中的每一个元素 for (let i = 0; i &lt; test.length; i++) &#123; // 如果当前元素已经使用过，跳过 if (used[i]) continue; // 将当前元素加入排列，并标记为已使用 arr.push(test[i]); used[i] = true; // 递归调用，继续生成下一个元素的排列 backtracking(); // 回溯：撤销当前的选择，恢复状态 arr.pop(); used[i] = false; &#125; &#125;; backtracking(); // 开始回溯 return result; // 返回所有生成的排列&#125;;// 示例调用let permutations = permute(test);// console.log(permutations);// 将permutations数组按字符串长度从小到大的顺序排序//想要排序的对象：是 permutations 数组的排列，而不是排列内的元素。排序标准：是根据每个排列的长度（permutations[i].length），而不是排列内元素的大小。for(let i = 0; i &lt; permutations.length; i++)&#123; for( let j = permutations[i].length - 1; j &gt; 0; j--)&#123; for( let k = 0; k &lt; j; k++)&#123; if(permutations[i][k] .length&gt; permutations[i][k+1].length)&#123; let temp = permutations[i][k]; permutations[i][k] = permutations[i][k+1]; permutations[i][k+1] = temp; &#125; &#125; &#125;&#125;// console.log(permutations)let minTry = nlet maxTry = 1for(let i = 0; i &lt; permutations.length; i++)&#123; let currentTry = 0 let wrongAnswer = [] for( let j = 0; j &lt; permutations[i].length ; j++)&#123; let flag1 = false for(let k = 0; k &lt; wrongAnswer.length; k++)&#123; if(permutations[i][j] == wrongAnswer[k])&#123; flag1 = true; break &#125; &#125; if(flag1)&#123; continue; &#125; currentTry++; if(permutations[i][j] == correct)&#123; break; &#125; else &#123; wrongAnswer.push(permutations[i][j]) &#125; &#125; if(currentTry &lt; minTry)&#123; minTry = currentTry &#125; if(currentTry &gt; maxTry)&#123; maxTry = currentTry &#125;&#125;console.log(minTry,maxTry)&#125;() 通过绘制树形图来理解。涉及到数组的排列和组合可以通过结合树形图和回溯来理解，直接从数组角度不太好想。 你想要排序的对象：是 permutations 数组的排列，而不是排列内的元素。 排序标准：是根据每个排列的长度（permutations[i].length），而不是排列内元素的大小。"},{"title":"ajax","path":"/2024/09/08/ajax/","content":"AJAX（Asynchronous JavaScript and XML）是一种用于创建交互式网页的技术。它允许网页在不重新加载整个页面的情况下，与服务器交换数据和更新部分网页内容。以下是AJAX的一些核心概念： 1. 同步与异步 同步请求：在发送请求后，浏览器会等待服务器响应，在此期间，浏览器无法进行其他操作。 异步请求：在发送请求后，浏览器不必等待服务器响应，用户可以继续与页面进行交互。 2. AJAX的工作原理 创建XMLHttpRequest对象：这是AJAX的基础，用于在后台与服务器交换数据。1var xhr = new XMLHttpRequest(); 配置请求：设置请求的类型（GET或POST）、URL以及是否异步处理。1xhr.open(&quot;GET&quot;, &quot;example.php&quot;, true); 发送请求：将请求发送到服务器。1xhr.send(); 监听状态变化：通过onreadystatechange事件监听器来处理服务器响应。123456xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; // 请求已完成，且服务器响应正常 console.log(xhr.responseText); &#125;&#125;; 3. XMLHttpRequest对象的属性和方法 readyState：表示请求的状态，有5个值，从0到4分别表示不同阶段。 status：表示服务器响应的状态码，如200表示成功。 responseText：获取字符串形式的响应数据。 responseXML：获取XML形式的响应数据。 **open(method, url, async)**：配置请求。 **send(data)**：发送请求。 4. AJAX的优点 提升用户体验：无需刷新页面即可更新内容。 减少服务器压力：只需更新部分内容，减轻服务器负担。 前后端分离：前端负责展示，后端负责数据处理，便于维护和扩展。 5. AJAX的缺点 破坏了浏览器的后退功能：由于AJAX更新页面内容不刷新整个页面，可能导致浏览器历史记录无法正确记录。 搜索引擎优化（SEO）问题：爬虫可能无法抓取到通过AJAX加载的内容。总之，AJAX技术在现代网页开发中具有重要作用，它使得网页具有更好的交互性和用户体验。随着技术的发展，AJAX也逐渐被更先进的API（如Fetch API）所取代，但了解AJAX仍然是前端开发者必备的基础知识。","tags":["前端开发"]},{"title":"简单工厂模式","path":"/2024/09/08/简单工厂模式/","content":"简单工厂模式（Simple Factory Pattern) ：又称为静态工厂方法 (Static Factory Method) 模式》它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。"},{"title":"单例模式","path":"/2024/09/07/单例模式/","content":"单例模式饿汉式12345678910111213141516171819202122232425262728293031var Singleton = (function() &#123; var instance; function createInstance() &#123; // 这里可以添加一些属性和方法来初始化实例 return &#123; name: &#x27;Singleton&#x27;, getName: function() &#123; console.log(this.name); &#125; &#125;; &#125; return &#123; getInstance: function() &#123; if (!instance) &#123; instance = createInstance(); &#125; return instance; &#125; &#125;;&#125;)();// 使用单例var singleton1 = Singleton.getInstance();singleton1.getName(); // 输出：Singletonvar singleton2 = Singleton.getInstance();singleton2.getName(); // 输出：Singletonconsole.log(singleton1 === singleton2); // true，它们是同一个实例 懒汉式123456789101112131415161718192021222324252627var LazySingleton = (function() &#123; var instance; function createInstance() &#123; // 创建一个新对象，并添加方法和属性 var object = new Object(&quot;I am the instance&quot;); return object; &#125; return &#123; getInstance: function() &#123; if (!instance) &#123; instance = createInstance(); &#125; return instance; &#125; &#125;;&#125;)();// 使用单例var singleton1 = LazySingleton.getInstance();console.log(singleton1); // 输出：I am the instancevar singleton2 = LazySingleton.getInstance();console.log(singleton2); // 输出：I am the instanceconsole.log(singleton1 === singleton2); // 输出：true，证明它们是同一个实例 单例模式是一种在软件工程中常用的设计模式，它确保一个类仅有一个实例，并提供一个全局访问点来访问这个实例。以下是单例模式的一些优缺点：优点： 控制了实例的数量：单例模式确保系统中一个类只有一个实例，这有助于节约系统资源，特别是当对象的创建开销较大时。 全局访问点：单例模式提供了一个全局访问点，这使得它可以方便地被其他对象访问。 避免共享资源的多重占用：在系统中，某些类对于实例化多个对象可能没有意义，或者可能会导致错误，单例模式可以防止这种情况的发生。 允许对实例进行优化：由于单例模式限制了实例的个数，因此可以在不影响系统其他部分的情况下对实例进行优化。缺点： 违反单一职责原则：单例类除了自身的业务逻辑外，还负责控制实例的创建，这可能会使得类承担过多的职责。 不利于测试：单例模式使得单例类很难进行单元测试，因为它通常涉及到静态方法和全局状态。 可能导致代码的不透明性：客户端代码可能不知道它们正在使用单例，因为它们是通过全局访问点来获取实例的，这可能会使得代码更难以理解和维护。 并发问题：在多线程环境下，单例模式可能会导致并发问题，因为多个线程可能会同时尝试创建单例类的实例。 难以扩展：由于单例模式限制了实例的数量，因此在某些情况下可能难以扩展，尤其是在需要多个实例的情况下。 可能导致资源闲置：如果单例持有资源（如数据库连接），而该资源在长时间内未被使用，则可能导致资源浪费。 总的来说，单例模式在特定场景下非常有用，例如管理数据库连接或配置文件，但是它也可能导致一些设计上的问题，因此在选择使用单例模式时需要权衡其优缺点。"},{"title":"77.组合,216.组合总和III,17.电话号码的字母组合","path":"/2024/09/06/77-组合-216-组合总和III-17-电话号码的字母组合/","content":"77.组合 代码随想录 leetcode 可以用回溯，但不知道如何回溯 定义了两个数组，一个用于函数返回的结果，一个用于记录返回结果的单元即数组的元素，在分析出这个题用回溯算法可以解决后，第一步需要做的就是定义变量，代码就是根据多种定义的变量编写的逻辑。 arr.slice() 创建一个包含原有数组中一个或多个元素的新数组 216.组合总和III17.电话号码的字母组合","tags":["leetcode"]},{"title":"Vue中实现组件通信的方式","path":"/2024/09/06/Vue中实现组件通信的方式/","content":"在VUE中实现通信有很多种的方式，每一种都有其对应的使用情况。首先我们看看有哪些方式： props emit v-model refs provide&#x2F;inject eventBus uex&#x2F;pinia(状态管理工具) 常见的是上面的这几种，少见的其实还可以算上插槽slot,混入，路由携带参数，localStorage,$parent&#x2F;$children等 props常常使用在父组件传递給子组件通信的过程中，首先在子组件中使用props,来接收对应的属性，而在父组件中使用子组件的地方，添加上面定义的属性。（就是通过:props&#x3D;’xxx’来传递变量，子组件有一个和data并列的props属性，用来接收变量） emit这个就和上面的相反，是使用在子组件给父组件传递值的中。子组件中声明对应的事件，当子组件触发事件，就会通过this.$emit(‘事件’，数据)传递到，而在父组件中使用子组件的地方，添加上面定义的事件，这个可以获取子组件传来的值。（emit相反，用于子组件向父组件传递消息，子组件：this.$emit(‘updateMessage’, this.localMessage); 父组件：&lt;ChildComponentA @updateMessage&#x3D;”handleMessageUpdate” &#x2F;&gt;，父组件编写handleMessageUpdate函数接收子组件传来的值 123456methods: &#123; // 处理从子组件发来的事件 handleMessageUpdate(newMessage) &#123; this.xxx = newMessage; &#125;&#125; ） provide&#x2F;inject这对组合往往使用在层级比较深的时候，比如A组件下可能还有B组件，B组件下有C组件..E组件而使用这对API,就能无论层级有多深都能获取到 eventBus也就是事件总线，简单粗暴，可以到处飞。可以不管你是不是父子关系，通过新建一个Vue事件bus对象，然后通过bus.emit触发事件，bus.on监听触发的事件。但不建议乱用，不好维护。 vuex对于大型的项目来说往往是很必要的，尤其单页面应用，很多页面嵌套页面，关系很多。而使用VUEX就能便捷的统一管理。 总结常见的组件通信方式有通过props&#x2F;emit&#x2F;provide和inject&#x2F;eventBus&#x2F;vuex等，一般根据不同的场景来决定使用的方式。比如父子组件通信使用props,反过来使用emit。而当层级很多的时候使用provide,全局的状态管理使用vuex等。"},{"title":"MMSegmentation1.x环境配置","path":"/2024/09/05/MMSegmentation1-x环境配置/","content":"全新安装电脑配置：RTX3060 12G 系统: Windows11 安装nvidia cuda11.7 安装anaconda3 打开官方github地址，切换到1.x分支, 按照安装指令安装 安装pytorch可以通过whl包安装, 注意要安装的pytorch版本要和cuda版本及python版本对应 安装GDAL可以通过whl包安装, 注意要安装的GDAL版本要和python版本对应 迁移 安装nvidia cuda11.7 复制env目录到新电脑的anaconda3 env目录下 打开anaconda3终端，进入env目录，执行activate mmdetection1.x命令"},{"title":"235.二叉搜索树的最近公共祖先,701.二叉搜索树中的插入操作,450.删除二叉搜索树中的节点","path":"/2024/09/04/235-二叉搜索树的最近公共祖先-701-二叉搜索树中的插入操作-450-删除二叉搜索树中的节点/","content":"​235. 二叉搜索树的最近公共祖先 只能想到普通的二叉树搜索最近的公共祖先的方法，不知道如何利用二叉搜索树的性质。 二叉搜索树根节点的值大于左子树的所有值小于右子树的所有值，从上到下便利到第一个位于p，q区间内的说明p，q位于当前便利节点的两侧，根据二叉树的图形，当前节点一定是p，q最近的公共祖先节点，因为如果不是接下来向左或向右都会错过成为另一个节点的祖先的机会，所以返回这个节点即可。 单层递归逻辑中，当p，q的值都大于或都小于当前遍历节点的值时，依次递归右子树或左子树后接收返回值需要判断是否为null再返回，递归下一层时漏写参数。 4. 单层递归逻辑中，当p，q的值都大于或都小于当前遍历节点的值时，依次递归右子树或左子树后接收返回值需要判断是否为null再返回，递归下一层时再次注意不要漏写参数。用了一天的零散时间。 701.二叉搜索树中的插入操作 根据二叉搜索树的性质，无论插入的数值是啥，都可以通过遍历到一个左右节点为null的节点进行插入。 插入是在二叉搜索树的叶子节点进行插入操作。 迭代法中没有考虑二叉搜索树为空的情况以及当前遍历节点左右子树其中一个为空另一个不为空的情况；递归法终止条件是返回一个新创建的节点。 4. 迭代法中没有考虑二叉搜索树为空的情况以及当前遍历节点左右子树其中一个为空另一个不为空的情况；递归法终止条件是返回一个新创建的节点。用了一天的零散时间。 450.删除二叉搜索树中的节点 不知道咋做。 递归的返回值是删除节点后的根节点，删除二叉搜索树中的节点分几种情况，第一种是待删除的节点为叶子节点，这种直接将null返回到上层递归进行处理即可，如果删除节点不是叶子节点且左右子树中一个为空一个不为空，则返回不为空的那一个（作为删除待删除节点后到二叉搜索树的根节点）到上一层递归中进行处理。如果待删除节点左右子树不为空，则先定义一个临时指针，初始值为当前指针的右子树位置，依次往左子树左边遍历，直到临时指针的左指针为null时暂停，将之前遍历的指针（临时指针的初始位置）的左子树放置到临时指针的右子树位置，返回之前遍历的指针（临时指针的位置）。 3. 递归的返回值是删除节点后的根节点，删除二叉搜索树中的节点分几种情况，第一种是待删除的节点为叶子节点，这种直接将null返回到上层递归进行处理即可，如果删除节点不是叶子节点且左右子树中一个为空一个不为空，则返回不为空的那一个（作为删除待删除节点后到二叉搜索树的根节点）到上一层递归中进行处理。如果待删除节点左右子树不为空，则先定义一个临时指针，初始值为当前指针的右子树位置，依次往左子树左边遍历，直到临时指针的左指针为null时暂停，将之前遍历的指针（临时指针的初始位置）的左子树放置到临时指针的右子树位置，返回之前遍历的指针（临时指针的位置）；递归函数内部再次递归时漏写参数。 4. 递归的返回值是删除节点后的根节点，删除二叉搜索树中的节点分几种情况，第一种是待删除的节点为叶子节点，这种直接将null返回到上层递归进行处理即可，如果删除节点不是叶子节点且左右子树中一个为空一个不为空，则返回不为空的那一个（作为删除待删除节点后到二叉搜索树的根节点）到上一层递归中进行处理。如果待删除节点左右子树不为空，则先定义一个临时指针，初始值为当前指针的右子树位置，依次往左子树左边遍历，直到临时指针的左指针为null时暂停，将之前遍历的指针（临时指针的初始位置）的左子树放置到临时指针的右子树位置，返回之前遍历的指针（临时指针的位置）；递归函数内部再次递归时注意不要漏写参数。用了两天的零散时间。","tags":["leetcode"]},{"title":"530.二叉搜索树的最小绝对差,501.二叉搜索树中的众数,236.二叉树的最近公共祖先","path":"/2024/09/04/530-二叉搜索树的最小绝对差-501-二叉搜索树中的众数-236-二叉树的最近公共祖先/","content":"​530.二叉搜索树的最小绝对差 第一遍没有看懂题, 用层序遍历将所有树节点保存到一个数组中，然后依次遍历数组中每一个元素（即节点），将节点值作为基准元素递归遍历以这个节点为根节点的二叉树，计算根节点和当前遍历节点的值差的绝对值，然后和全局最小值进行比较，如果比全局最小值更小则更新全局最小值，最后返回全局最小值。 此题中说了是找二叉搜索树的最小绝对差，这颗树是有顺序的，左子树的值小于根节点的值小于右子树的值，用中序遍历转为转为数组也可以比较简单计算出最小绝对差，更好的方法是用一个指针变量记录前一个遍历节点的值（这里利用了二叉搜索树是有序的这个性质，最小绝对差的两个元素一定是相邻的两个元素），通过不断地递归中序遍历整棵树，同时更新pre指针变量，依次计算差的绝对值，然后和全局最小绝对差进行比较，如果当前差的绝对值更小则更新全局最小绝对差，最后返回全局最小绝对差。 不知道如何用javascript表示一个最大的数，忘记了是将当前遍历节点值和前一个结点值做差再和全局最小值做比较，这里用了当前遍历结点值直接和全局最小值做了比较，不够细致。忘记了更新pre指针，有偷懒的想法，因为看卡哥视频讲解中将一些关键代码都记录下来了，没有严格要求自己。 javascript中Math.max()对应的是-Infinity，要细致地读题，充分利用题目中的条件；刷题时尽量不要偷懒背题不思考；用了一天的零散时间。 501.二叉搜索树中的众数 1. 通过中序遍历将二叉搜索树所有结点值转为一个数组，然后本题就变成了求一个数组最长的连续重复子数组对应的数值的问题，然后用快慢指针先找到最大重复次数，然后同样用快慢指针再循环一遍数组找到所有等于最大重复次数的数值将其保存到一个结果数组中返回。 用双指针的思路，定义一个指针记录前一个遍历的结点，再定义一个全局最大重复次数的最大值，再定义一个全局变量result收集结果集，中序遍历过程中，定义一个count记录当前重复了多少次，如果当前重复次数和全局最大重复次数相等，则收集结果集，如果当前重复次数大于全局最大重复次数，更新全局最大重复次数的同时还要清空结果集，因为之前的结果集已经不满足条件了，最后返回结果集。 在用1中的思路时，当得到二叉搜索树中序遍历结点值数组后，用快慢指针遍历时在边界条件那里想了很长时间。在用2中的思路时更新前一个pre指针写到了判断当前结点和前一个结点的判断逻辑中去了，中序遍历过程中用于记录当前重复次数的count大于全局最大重复次数的代码处理逻辑中，只更新了全局最大重复次数和清空了结果数组，没有将新的结点值添加到结果数组中。 4. 在用1中的思路中，当得到二叉搜索树中序遍历结点值数组后，用快慢指针遍历时在边界条件外层写一个条件后可以通过内层循环逻辑去适配这个边界条件，不用同时外层考虑两个边界条件，这样可能会思路会乱。在用2中的思路时更新前一个pre指针写到了判断当前结点和前一个结点的判断逻辑中去了，中序遍历过程中用于记录当前重复次数的count大于全局最大重复次数的代码处理逻辑中，如果中序遍历过程中当前重复次数大于全局最大重复次数了，说明此时找到了更满足题条件的解，应当清空数组但也需要将当前结点值保存下来，否则结果集就会漏解。用了两天的零散时间。 二叉树的最近公共祖先 读题后感觉需要题目说的是判断两个结点是否有共同的最近祖先，不知道咋做。 本题用了回溯的思想，首先需要明确是从下往上找，所以用后续遍历，在左右子树上如果找到了这两个子节点中的其中一个都可以返回到上一级递归中，上一级递归中判断左右子树是否分别有这两个结点，如果有，那说明这一级递归中的结点就是最近的公共祖先，如果只有左子树有其中一个给定子节点，右子树没有给定的另一个子节点，说明当前递归层中的结点不是公共祖先，那么则返回右的这个子节点，交由上一级递归中的结点去判断，反之如果右子树有左子树没有也是同样的逻辑，如果左右子树都没有，那么就返回null。递归的终止条件是如果当前遍历结点为null或者为两个给定子节点中的其中一个则返回当前结点。 分别递归左右子树的时候递归函数中少写了参数，又有背卡哥视频的代码，对原理理解的还不是很透彻。 尽量理解原理做题而不是靠记忆。用了两天的零散时间","tags":["leetcode"]},{"title":"654.最大二叉树,617.合并二叉树,700.二叉搜索树中的搜索,98.验证二叉搜索树","path":"/2024/09/04/654-最大二叉树-617-合并二叉树-700-二叉搜索树中的搜索-98-验证二叉搜索树/","content":"​654.最大二叉树 不知道咋做。 找到数组最大值，将数组划分为左右数组，然后递归构造二叉树，当数组长度为1时，构造二叉树节点然后返回。 在递归生成左右子树时需要判断划分的数组长度是否不为1,生成的节点递归创建左右子树有意义。 用了一天的零散时间。 617.合并二叉树 不知道咋做。 同时操作两棵树t1,t2, 可以直接用t1或t2根节点返回，递归的终止条件是如果t1为null,则返回t2, 如果t2为null则返回t1, 比如同时遍历t1和t2时，两颗树都有值直接进行相加操作，其中一个为null则返回另一个节点，依次递归处理左子树和右子树。 3. 同时操作两棵树t1,t2, 可以直接用t1或t2根节点返回，递归的终止条件是如果t1为null,则返回t2, 如果t2为null则返回t1, 比如同时遍历t1和t2时，两颗树都有值直接进行相加操作，其中一个为null则返回另一个节点，依次递归处理左子树和右子树。 4. 用了两天的零散时间。 二叉搜索树中的搜索 不知道咋做。 二叉搜索树根节点的值大于左子树的值，小于右子树的值，根据数值的大小自动选择递归调用选择返回左子树 &#x2F; 右子树节点。迭代法通过循环和节点值选择方向。 3. 二叉搜索树根节点的值大于左子树的值，小于右子树的值，根据数值的大小自动选择递归调用选择返回左子树 &#x2F; 右子树节点。迭代法通过循环和节点值选择方向。 4. 用了两天的零散时间。 98.验证二叉搜索树 不知道咋做。 通过生成一个中序遍历的数组，检查数组是否单调递增即可判断是否是二叉搜索树；通过设置一个变量记录前一个变量节点的数值，然后在每次遍历时通过比较前序遍历的中节点的值和记录的变量的大小关系，如果当前节点的值大于变量记录的值，则可能是二叉搜索树，否则不是二叉搜索书。 用生成数组判断递增中用到了双指针，后一个指针当&gt;&#x3D; length - 1时就需要跳出循环，while循环最下面判断后指针位于数组最后一个元素位置则跳出循环;JavaScript中定义最小值-Math.min() 4.用了两天的零散时间。","tags":["leetcode"]},{"title":"513.找树左下角的值,112. 路径总和,106.从中序与后序遍历序列构造二叉树","path":"/2024/09/04/513-找树左下角的值-112-路径总和-106-从中序与后序遍历序列构造二叉树/","content":"​513.找树左下角的值 层序遍历可以做，不知道用递归咋做。 2.认真读题，首先是必须同时满足深度最大和左边两个条件，通过一个全局变量maxDepth保存最大深度，result保存最大深度对应的节点值，这个值必须是左节点，本题没有对中节点的处理逻辑，前中后序遍历都可以，只需满足左节点比右节点先遍历，递归结束后，返回result。 javascript不能直接在函数外层用let定义变量（maxDepth, result）,递归过程中这些值不能更新，可以通过用一个函数f在内部嵌套递归函数，函数f中定义的变量递归函数可以访问到和更新。 用了两天的零散时间。 路径总和 需要在递归计算过程中去判断是否节点值和为sum, 不知道单层递归逻辑是啥。 2.递归遍历节点过程中对sum进行可以减去节点值，当遍历到叶子节点判断sum是否为0则知道这个遍历路径是否满足条件，如果不满足条件，则会进行回溯，继续寻找其他路径。当为sum为0且当前节点为叶子节点则找到一条路径，返回true。 3.第一次递归就需要进行一个sum - root.val操作传递给递归函数，在对左右子树分别进行递归处理后需要返回false, 因为左右子树都没有找到满足条件的路径，则说明树没有符合节点和相加为sum的路径，则返回false。 用了两天的零散时间。 106.从中序与后序遍历序列构造二叉树 不知道咋做，觉得很麻烦。 从中序和后续遍历序列构造二叉树也是一个递归过程，先从后续遍历的最后一个位置确定根节点，这个值用来创建根节点n，二叉树在创建过程中也可以看成是无数个根节点创建而成的，然后根据这个根节点的值将中序遍历序列划分为左中序序列和有中序遍历序列，根据左中序序列的数组长度和右中序序列的数组长度将后续遍历序列也划分为左后续序列和右后续序列，然后递归处理左中序序列，左后序序列赋值给n的左孩子，递归处理右中序序列，右后序序列赋值给n的右孩子，最后返回节点n。 从中序和后续遍历序列构造二叉树也是一个递归过程，先从后续遍历的最后一个位置确定根节点，这个值用来创建根节点n，二叉树在创建过程中也可以看成是无数个根节点创建而成的，然后根据这个根节点的值将中序遍历序列划分为左中序序列和有中序遍历序列，根据左中序序列的数组长度和右中序序列的数组长度将后续遍历序列也划分为左后续序列和右后续序列，然后递归处理左中序序列，左后序序列赋值给n的左孩子，递归处理右中序序列，右后序序列赋值给n的右孩子，最后返回节点n。划分中序右序列那里需要从根节点位置的下一位作为开始节点位置。 用了两天的零散时间。","tags":["leetcode"]},{"title":"110.平衡二叉树,257.二叉树的所有路径,404.左叶子之和,222.完全二叉树的节点个数","path":"/2024/09/04/110-平衡二叉树-257-二叉树的所有路径-404-左叶子之和-222-完全二叉树的节点个数/","content":"​110.平衡二叉树 （优先掌握递归） 不知道咋做。 在求二叉树的高度的代码上改，二叉树的高度肯定是大于等于0的，这里利用高度不可能是-1但可以表示当前子树不是平衡二叉树，子树不是平衡二叉树递归回来也不是平衡二叉树。 3. 在求二叉树的高度的代码上改，二叉树的高度肯定是大于等于0的，这里利用高度不可能是-1但可以表示当前子树不是平衡二叉树，子树不是平衡二叉树递归回来也不是平衡二叉树。 4。用了零散时间看，大概用了两天。 二叉树的所有路径 （优先掌握递归） 不知道咋做，但知道和遍历顺序有关。 递归进入下一层后要能够回到之前的状态，这样才能够遍历到以某个节点的另一条路径，回藏在递归中。 javascript本身就是赋值引用，所以不用单独针对递归进行处理。 用了零散时间，大概用了两天。 404.左叶子之和 （优先掌握递归） 这个是不是在递归过程中要用if判断。 首先是叶子节点，然后是左叶子节点，所以无法从当前节点进行判断是否是左叶子节点，只能从节点的父节点进行判断，如果当前节点的左孩子不为空，且左孩子的左孩子、右孩子为空，则找到了一个左叶子，右子树可能也有左叶子节点，也要递归，最后将左右的叶子节点相加返回。 3.首先是叶子节点，然后是左叶子节点，所以无法从当前节点进行判断是否是左叶子节点，只能从节点的父节点进行判断，如果当前节点的左孩子不为空，且左孩子的左孩子、右孩子为空，则找到了一个左叶子，右子树可能也有左叶子节点，也要递归，最后将左右的叶子节点相加返回。 4.用了零散时间，大概用了两天。 222.完全二叉树的节点个数（优先掌握递归） 不知道咋做。 没有完全理解，这个博客拖了太久了，这个题二刷再研究吧，因为可以用后续遍历，这里直接用的普通的后续遍历，遍历到空节点返回0,然后分别递归左右子树计算节点数和再加1得到以当前节点为根节点的数的节点数和然后返回。 3. 没有完全理解，这个博客拖了太久了，这个题二刷再研究吧，因为可以用后续遍历，这里直接用的普通的后续遍历，遍历到空节点返回0,然后分别递归左右子树计算节点数和再加1得到以当前节点为根节点的数的节点数和然后返回。 &#x2F;","tags":["leetcode"]},{"title":"226.翻转二叉树,101.对称二叉树,104.二叉树的最大深度,111.二叉树的最小深度","path":"/2024/09/04/226-翻转二叉树-101-对称二叉树-104-二叉树的最大深度-111-二叉树的最小深度/","content":"​226.翻转二叉树 根节点可以交换左右指针，其他层逻辑不清楚，觉得应该不是简单的交换指针。 从下到上，依次交换节点的左右指针即可，关键在于选择遍历顺序，可以选择前序遍历和后序遍历，后续遍历（左右中，右左中）是先处理下层节点再处理当前层节点，处理每个节点都是执行一个交换指针操作。 交换指针的逻辑，javascript交换指针函数需要传递root,不能改变root.left和root.right的值达到交换指针的效果。 4.用了一个小时左右。 对称二叉树 根节点可以比较左右指针，其他层如何比较不知道。 2. 以根节点的子节点leftnode,rightnode这一层为例，首先判断leftnode,rightnode是否为空，leftnode和rightnode都为空，满足对称返回true, leftnode，rightnode其中一个为空则返回false,如果leftnode,rightnode都不为空则判断leftnode,rightnode两个节点的值是否相等，不相等则返回false,相等则继续递归比较leftnode.left和rightnode.right是否想等，leftnode.right和rightnode.left是否相等。如果这两次判断都为true,则结果为true,否则结果为false。递归结束条件为当前遍历节点为空。 3. 以根节点的子节点leftnode,rightnode这一层为例，首先判断leftnode,rightnode是否为空，leftnode和rightnode都为空，满足对称返回true, leftnode，rightnode其中一个为空则返回false,如果leftnode,rightnode都不为空则判断leftnode,rightnode两个节点的值是否相等，不相等则返回false,相等则继续递归比较leftnode.left和rightnode.right是否想等，leftnode.right和rightnode.left是否相等。如果这两次判断都为true,则结果为true,否则结果为false。递归结束条件为当前遍历节点为空。 用了一个小时左右。 104.二叉树的最大深度 只想到了层序遍历可以计算深度。 根节点的最大高度就是二叉树的最大深度，二叉树要求高度，通过后序遍历（即左右中）往上计算，叶子节点的高度为1，对于左右中的遍历顺序来说，中节点的最大深度高度为左右子节点高度中的最大值+1，递归结束条件为遍历节点为空，此时高度为0。 3. 根节点的最大高度就是二叉树的最大深度，二叉树要求高度，通过后序遍历（即左右中）往上计算，叶子节点的高度为1，对于左右中的遍历顺序来说，中节点的最大深度高度为左右子节点高度中的最大值+1，递归结束条件为遍历节点为空，此时高度为0。 用了一个小时左右。 111.二叉树的最小深度 只想到了层序遍历可以计算深度。 同样可以转换为计算二叉树的最小高度，采用左右中的遍历顺序，注意二叉树最小深度的定义，是从根节点到叶子节点的长度，不是空节点，所以需要添加判断条件 — 当左子树为空有子树为空时返回右子树的高度+1；当左子树不为空右子树为空时，返回左子树的高度+1；当左右子树都为空时，说明此时为叶子节点，高度为1；当左右子树都不为空时，分别计算左右子树的高度，取最小值再+1即为中节点对应高度；递归结束条件为当前节点为空。 3. 当左子树为空有子树为空时返回右子树的高度+1；当左子树不为空右子树为空时，返回左子树的高度+1。 用了一个小时左右。","tags":["leetcode"]},{"title":"N叉树遍历相关(144,94,102,102,107,199,429,515,16,117,104,111)","path":"/2024/09/04/N叉树遍历相关(144,94,102,102,107,199,429,515,16,117,104,111)/","content":"​144. 二叉树的前序遍历 1.用递归。 2.递归结束条件是root为null。 3.&#x2F; 4.用了半个小时。 二叉树的后序遍历1.用递归。 2.递归结束条件是root为null。 3.递归那里忘记传入数组。 4.用了半个小时。 二叉树的中序遍历1.用递归。 2.递归结束条件是root为null。 3.&#x2F; 4.用了一分钟。 二叉树的层序遍历 1.首先想用循环，但又感觉做不出来。 利用队列的先进先出特性，同时记录一下树每一层的节点个数size，在开始读树的新一层时更新size, 循环size次将同一层的节点值保存进一个数组vector，size次后将vector作为一个元素保存进结果数组，当队列长度为0时代码执行结束。 3.最外层循环的边界条件没想清楚，左右节点入队时要判断是否为空。 用了一个小时左右。 二叉树的层序遍历 II 二叉树层序遍历为基础改的题。 没有看。 3.javascript array的unshift是从前面添加数组元素。 用了十分钟左右。 二叉树的右视图 二叉树层序遍历为基础改的题。 没有看。 3.javascript中获取数组最后一个元素不能通过arr[-1]来获取。 用了十分钟左右。 429 ． N 叉树的层序遍历 二叉树层序遍历为基础改的题。 没有看。 3.多子节点是存放在一个数组中。 用了半个小时左右。 515 ．在每个树行中找最大值 二叉树层序遍历为基础改的题。 没有看。 3.多子节点是存放在一个数组中。 用了半个小时左右。 16 ．填充每个节点的下一个右侧节点指针 二叉树层序遍历为基础改的题。 没有看。 3.javascript中可以通过Math.max.apply(null, arr)获取arr的最大值。 用了半个小时左右。 117 ．填充每个节点的下一个右侧节点指针 二叉树层序遍历为基础改的题。 没有看。 3.在如何连接指针那里想了一下，将二叉树层序遍历存放节点值修改为存放节点对象，就可以通过遍历二维数组中的每个层节点数组进行指针指向操作，不知道是否还有更好的方法。 将二叉树层序遍历存放节点值修改为存放节点对象，就可以通过遍历二维数组中的每个层节点数组进行指针指向操作；用了一个小时左右。 104 ·二叉树的最大深度 二叉树层序遍历为基础改的题。 没有看。 3.在如何获得二叉树最大深度那里想了一下，遍历每一层节点值将其保存进一个数组作为二维数组的元素，有多少个这样的元素二叉树的深度就是多少，不知道是否还有更好的方法。 遍历每一层节点值将其保存进一个数组作为二维数组的元素，有多少个这样的元素二叉树的深度就是多少；用了半个小时左右。 111 ．二叉树的最小深度 二叉树层序遍历为基础改的题。 没有看。 3.在如何获得二叉树最小深度那里想了一下，遍历每一层时将节点保存进一个数组中，然后将层节点数组作为二维数组的一个元素，循环遍历这个二维数组中的每一个元素，如果该元素的左右子节点均为空，则这个元素所在的最外层索引下标+1即为二叉树的最小深度，不知道还有没有更好的方法。 遍历每一层时将节点保存进一个数组中，然后将层节点数组作为二维数组的一个元素，循环遍历这个二维数组中的每一个元素，如果该元素的左右子节点均为空，则这个元素所在的最外层索引下标+1即为二叉树的最小深度；用了一个小时左右。","tags":["leetcode"]},{"title":"计算数组平均值","path":"/2024/09/04/计算数组平均值/","content":"计算数组平均值使用 reduce 方法1234const numbers = [1, 2, 3, 4, 5];const sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);const average = sum / numbers.length;console.log(average); // 输出: 3 使用 forEach 方法12345const numbers = [1, 2, 3, 4, 5];let sum = 0;numbers.forEach(number =&gt; sum += number);const average = sum / numbers.length;console.log(average); // 输出: 3 使用 map 和 reduce 方法12345678const numbers = [1, 2, 3, 4, 5];const sumAndCount = numbers.reduce((acc, val) =&gt; &#123; acc.sum += val; acc.count++; return acc;&#125;, &#123; sum: 0, count: 0 &#125;);const average = sumAndCount.sum / sumAndCount.count;console.log(average); // 输出: 3 获取数组最大值使用 Math.max 和 apply123const numbers = [1, 2, 3, 4, 5];const max = Math.max.apply(null, numbers);console.log(max); // 输出: 5 使用 Math.max 和扩展运算符123const numbers = [1, 2, 3, 4, 5];const max = Math.max(...numbers);console.log(max); // 输出: 5 使用 reduce 方法123const numbers = [1, 2, 3, 4, 5];const max = numbers.reduce((a, b) =&gt; Math.max(a, b));console.log(max); // 输出: 5 使用 sort 方法1234const numbers = [1, 2, 3, 4, 5];numbers.sort((a, b) =&gt; b - a);const max = numbers[0];console.log(max); // 输出: 5 使用 for 循环12345678const numbers = [1, 2, 3, 4, 5];let max = numbers[0];for(let i = 1; i &lt; numbers.length; i++) &#123; if(numbers[i] &gt; max) &#123; max = numbers[i]; &#125;&#125;console.log(max); // 输出: 5 计算次方使用 Math.pow1234const base = 2;const exponent = 3;const result = Math.pow(base, exponent);console.log(result); // 输出: 8 使用 ** 运算符1234const base = 2;const exponent = 3;const result = base ** exponent;console.log(result); // 输出: 8 获取二维数组内层最小数组的长度12345const arrayOfArrays = [[1, 2, 3], [1, 2], [1, 2, 3, 4, 5], [1]];const minLength = arrayOfArrays.reduce((min, arr) =&gt; &#123; return Math.min(min, arr.length);&#125;, Infinity);console.log(minLength); // 输出: 1 或者使用 map 和 Math.min 1234const arrayOfArrays = [[1, 2, 3], [1, 2], [1, 2, 3, 4, 5], [1]];const lengths = arrayOfArrays.map(arr =&gt; arr.length);const minLength = Math.min(...lengths);console.log(minLength); // 输出: 1 以上内容涵盖了在 JavaScript 中对数组进行操作和计算的一些基本知识点。"},{"title":"150.逆波兰表达式求值","path":"/2024/09/04/150-逆波兰表达式求值/","content":"​150. 逆波兰表达式求值 知道会用到栈，要用到入栈和弹出操作。 遇到数就入栈，遇到操作符就弹出两个操作数，用操作符进行计算，然后将结果入栈，直到遍历完后缀表达式，栈中最后一个元素就是逆波兰表达式计算结果。 注意两个数在和操作符的相对位置，弹出的第一个数应该在操作符的右边，弹出的第二个数应该在操作符的左边，循环遍历逆波兰表达式判断是否位操作符时tokens[i]没有写[i]导致程序用例不能完全通过。 用了一个小时左右。","tags":["leetcode"]},{"title":"232.用栈实现队列,225.用队列实现栈,20.有效的括号,1047.删除字符串中的所有相邻重复项","path":"/2024/09/04/232-用栈实现队列-225-用队列实现栈-20-有效的括号-1047-删除字符串中的所有相邻重复项/","content":"​232.用栈实现队列 知道要用两个栈实现，具体咋做忘了。队列的特性是先进先出，栈是先进后出，入队操作直接入栈就行，实现出队操作，入栈的第一个元素在栈最下面出来需要借助另一个栈b，先将所有元素入栈b，这样出栈的时候就是入队的第一个元素了，javascript中的栈竟然是直接用数组代替的，直接就可以进行pop操作和push操作。实现了pop函数在实现peek操作的时候可以直接调用pop来简化代码这个编程习惯真好。不知道栈如何实现。用了一个小时左右。225. 用队列实现栈 模模糊糊知道要用两个队列来实现，具体咋做忘了。用一个队列也可以实现栈，比如栈是先进后出，在一个队列里这个元素要出来必须等前面的元素出来才可以，可以让这个元素之前的元素出队再入队，这样就可以达到出栈元素的目的。javascript中队列竟然也是用数组实现的，出队元素是通过执行数组的shift方法达到获取移除第一个元素的作用。用了一个小时左右。 20. 有效的括号 有栈的代码了这个题感觉ok。&#x2F;需要建立左符号和右符号的关系，遇到右符号不是比较出栈元素和这个元素是否相等，而是判断这两个符号是否配对；遍历完字符串后，栈是否为空都有返回值。用了半个小时左右。 1047. 删除字符串中的所有相邻重复项 先想到用双指针，没做出来。原来用栈这么简单，结果就藏在栈里面的内容中，遍历一个新元素就检查栈顶是否和这个新元素相同，相同就出栈，不相同就入栈，将栈中的结果反转一下就是满足题意的结果。这个题用之前写过的类定义的栈会超时间，感觉可能和最后反转拼接操作有关，不知道具体啥原因，最后用了一个数组来实现存放元素，移除元素的逻辑，最后时间复杂度降低了。用了一个小时左右。","tags":["leetcode"]},{"title":"151.翻转字符串里的单词,卡码网:55.右旋转字符串","path":"/2024/09/04/151-翻转字符串里的单词-卡码网-55-右旋转字符串/","content":"​151.翻转字符串里的单词 感觉需要用到反转字符串操作，但空格不知道如何处理。 先反转整个字符串，然后对单词进行反转，需要注意空格的处理。 3.坚持循环不变量原则，while循环中尽量将循环变量自增操作放置在最后，这样可以让循环变量自增后有一次判断，带入测试用例推导花了一些时间。主要是涉及到对末尾空格的处理，可能有多个空格或一个空格，这个空格需要删除。 4.用了一个小时左右。 卡码网：55.右旋转字符串 想用双指针，发现用不了。 2.先反转整个字符串，然后分段进行反转拼接即可。 3.javascript如何处理输入操作，输入处理的代码是网上找的，还没有掌握, 在concat那里少写了一个reverse函数导致结果顺序不对。 reverse函数是原地操作 123let a = [1,2,3]let b = a.reverse()console.log(a, b)//[ 3, 2, 1 ] [ 3, 2, 1 ] 4.用了半个小时左右。","tags":["leetcode"]},{"title":"344.反转字符串,541.反转字符串II","path":"/2024/09/04/344-反转字符串-541-反转字符串II/","content":"​344. 反转字符串 感觉需要用到指针，但不知道咋做。 倒序就是一个交换left,right指针对应指针值的过程。 纠结在javascript中能不能用字符串索引（就是当数组用），javascript中不能像数组那样索引元素。 再一次见识到了双指针的力量。用了半个小时左右。 反转字符串 II 读不懂题。 卡哥真牛啊，纸上推一下吧，用小人脑虚拟出来的小计算机测试一下不好想的地方（谁和计算机比计算能力哟）。 （如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）前半段字符串反转，这句话是遍历到后面才会遇到的，题目中放在了前面，（如果剩余字符少于 k 个，则将剩余字符全部反转），这两句话前面遍历遇到，题目中放在了后面，这个算法其实还是在考reverse函数的实现，（如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）这本质上就是在计算机试结果。写边界条件确定整个题的循环不变量是啥，严格按照循环变量来写边界条件，出错率低。 4. （如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）前半段字符串反转，这句话是遍历到后面才会遇到的，题目中放在了前面，（如果剩余字符少于 k 个，则将剩余字符全部反转），这两句话前面遍历遇到，题目中放在了后面，这个算法其实还是在考reverse函数的实现，（如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）这本质上就是在计算机试结果。写边界条件确定整个题的循环不变量是啥，严格按照循环变量来写边界条件，出错率低。","tags":["leetcode"]},{"title":"454.四数相加II,383.赎金信,15.三数之和,18.四数之和","path":"/2024/09/04/454-四数相加II-383-赎金信-15-三数之和-18-四数之和/","content":"​454.四数相加II 暴力算法。 先两个循环将和放到map中，再两个循环求和查询map，计算总数求和，将一个4层循环复杂度降低了。要查找一个元素是否出现用map, map也是一个hash结构。 3.没啥问题。 用了半个小时左右。 赎金信 没读懂。 和有效字母异位词方法差不多。 没啥问题。 4.用了半个小时左右。 三数之和 1.暴力算法。 2.用hash法去重麻烦，双指针好理解。 3.快速排序代码不熟悉，最外层循环的边界条件，当left&#x3D;&#x3D;right后left和right要移动(left左移,right右移)，不然会一直循环下去。 4.用了一个小时左右，快速排序代码不熟悉，最外层循环的边界条件，当left&#x3D;&#x3D;right后left和right要移动(left左移,right右移)，不然会一直循环下去。 四数之和 题目说了是用一个数组，用map也不好处理去重。 在双指针上增加一层循环，然后修改对应边界条件，添加去重逻辑，剪枝逻辑。 外层循环和内层循环的边界条件，剪枝操作那里为啥是break? 4.用了两个小时左右。","tags":["leetcode"]},{"title":"242.有效的字母异位词,349. 两个数组的交集,202.快乐数,1. 两数之和","path":"/2024/09/04/242-有效的字母异位词-349-两个数组的交集-202-快乐数-1-两数之和/","content":"​ 242.有效的字母异位词 对每一个字符串用一个字典统计每个字母出现的次数，最后比较两个字典是否key和value都相同。都相同则是有效字母异位词, javascript中如何实现字典的key和value的比较? 这个编程问题可以分解为多个查询问题，涉及到查询，用hash法肯定是最快和简单的，只需要用长度为26，值全为0的数组模拟一个hash表,遍历第一个字符串时查询hash表对应字母然后执行加1操作，然后遍历第二个字符串时查询hash表对应字母执行减1操作，遍历完两个字符串后，循环一次hash表检查是否都为0, 都为0则是有效的字母异位词，同样这种策略也可以用于判断多个字符串是否是有效的字母异位词。 在JavaScript中，不能直接用inputStr[i] - ‘a’映射到对应下标，要用inputStr[i].charCodeAt(0) - ‘a’.charCodeAt(0)，charCodeAt(0)是用来获取ascii码的函数。 感受到了用hash法的简洁，用了一个小时左右，调试花了一些时间，在JavaScript中，不能直接用inputStr[i] - ‘a’映射到对应下标，要用inputStr[i].charCodeAt(0) - ‘a’.charCodeAt(0)，charCodeAt(0)是用来获取ascii码的函数。 两个数组的交集 遍历第一个数组，对于每一个元素都去第二个数组中查找，如果找到了，就将这个元素保存到结果数组中，同时在第二个数组中将所有对应这个元素值的元素都删除，遍历完第一个数组后返回结果数组。 也利用了hash法在查找元素方面的优点，这里由于元素长度不固定，用数组就不太适合，利用set这个数据结构(底层实现是红黑树，可以用于这种查找元素范围不固定的情况)，将第一个数组转为set1，这样就自动完成了去重操作，然后遍历第二个数组，对每一个元素，在set1中执行查询操作，找到了就添加到结果set2中，利用set2完成去重操作，最后将set2转为数组返回。 不知道如何用javascript创建set类型，没有理解这个题用set的原因，利用了hash法在查找元素方面的优点，这里由于元素长度不固定，用数组就不太适合，利用set这个数据结构(底层实现是红黑树，可以用于这种查找元素范围不固定的情况)，将第一个数组转为set1，这样就自动完成了去重操作，然后遍历第二个数组，对每一个元素，在set1中执行查询操作，找到了就添加到结果set2中，利用set2完成去重操作，最后将set2转为数组返回。 4，用了一个小时左右，利用set完成去重操作和提高查找效率。 快乐数 觉得这个题是一个数学问题，不知道咋做，大致知道要用循环提取数字每一位。 循环计算各位的数字平方和的过程中，如果当前计算过的数和之前计算过的数字重复了，那么再进行操作就会陷入无限循环中，确认当前计算过的数是否在之前出现了，这又是一个查找元素的问题，那么又要回归到用哈希法上来，用set保存每次计算得到的各位平方和，然后每次计算出新的各位平方和判断是否在set中出现过，如果出现过，则跳出循环返回false, 如果没有出现过则将当前的各位平方和保存到set中，直到和为1返回true, 这有点像计算机的算力解决一个数学问题，如果和不为1且没有出现重复值时，继续循环，不可能不一直循环下去同时值也不为1。 3.计算各位和的函数没有抽离处理，也没有意识到这是一个可以抽离的公共函数，导致代码比较混乱，定义set的代码写到循环里去了，然后每次都会清空set，没有达到代码的效果。 4, 需要养成好的代码习惯，这个题用了一个小时左右。 两数之和 两重循环，第二重循环不能用第一层循环的值，判断第一层循环和第二层循环的两个数是否和为target, 如果和为target，则返回下标数组。 还是利用hash法查询元素快的优点，先将第一个数组转为一个map，因为查的是数组元素的值, 所以key就是数组元素的值, 而key对应的value就存放数组元素的下标，然后遍历第二个数组，每次就查询target - nums2[index]的元素是否在set中，如果在，将target - nums2[index]这个值对应的value，和第二次循环的index一起作为一组下标结果返回。 3.不知道javascript中map如何实现、如何获取map元素和设置map元素。利用hash法查询元素快的优点，先将第一个数组转为一个map，因为查的是数组元素的值, 所以key就是数组元素的值, 而key对应的value就存放数组元素的下标，然后遍历第二个数组，每次就查询target - nums2[index]的元素是否在set中，如果在，将target - nums2[index]这个值对应的value，和第二次循环的index一起作为一组下标结果返回。 4.let map &#x3D; {};map[key]&#x3D;value;var a &#x3D; map[key];解题用了一个小时左右。 ​","tags":["leetcode"]},{"title":"24. 两两交换链表中的节点,19.删除链表的倒数第N个节点,面试题 02.07. 链表相交,142.环形链表II","path":"/2024/09/04/24-两两交换链表中的节点-19-删除链表的倒数第N个节点-面试题-02-07-链表相交-142-环形链表II/","content":"​ 24.两两交换链表中的节点 第一想法是不知道这个题如何做，知道有改变指针这个操作。 双指针也太好用了，用双指针整个过程就是一个双指针移动加修改指针的过程，就像织毛衣一样的感觉。这里竟然要保存两个临时指针变量。 要保存两个临时指针变量，结合示意图分析实现起来还可以，主要是指针赋值那里想清楚，输入用例一遍过。 分析能否用双指针的意识，这个编程题用了半个小时左右。 19.删除链表的倒数第N个节点 第一想法先计算得到链表的总长度，根据倒数多少个节点计算正向应该遍历多少个节点count，然后正向遍历到了待删除结点的前一个结点执行删除操作。 用双指针正好表示了倒数多少个这个概念，先让快指针移动n+1个位置（不是移动n位是因为用了虚拟头节点，然后需要在待删除结点的前一个节点才能执行操作），然后一起移动快慢指针，当快指针到达链表末尾的位置，慢指针在的位置正好是待删除的元素的前一个节点位置，执行删除操作即可。 快慢指针开始时指向虚拟头节点，然后可以通过一个示意图来推导一下执行n+1才是对应待删除节点的前一个位置，一起移动快慢指针循环的边界条件时fast指针是否为空，而不是fast.next,可以想一想fast指针应该是在最后一个节点的位置,此时fast指针的下一个节点为null,不能进入循环执行移动操作，正好满足fast指针在最后一个节点位置。 一起移动快慢指针循环的边界条件时fast指针是否为空，而不是fast.next,可以想一想fast指针应该是在最后一个节点的位置,此时fast指针的下一个节点为null,不能进入循环执行移动操作，正好满足fast指针在最后一个节点位置。这个题目用了接近一个小时的时间。 面试题 02.07. 链表相交1.看不懂题 2.再回去读题，大致懂了是需要先找出最短的链表，最极端的就是短的链表头节点就是相交的位置，这种链表相交可以节省计算机的存储空间，找到这两个链表长度的差值dista后，将长链表的cur指针向后移动这个差值（正数）个位置，然后从这里依次遍历长短链表，对应位置指针相同则返回，遍历完都没有找到指针相同的位置则返回null. 3.根据链表长度不同执行了两端差不多的代码，后一段代码拷贝过来时没有将循环的条件改过来，导致用例报错。用了一个小时左右，主要时题干没有读懂。 142.环形链表II1.不知道咋做 2.真聪明，又是双指针，数学证明有点多。 3.不熟悉这类需要数学推导证明的编程题，完全没有想到用数学方法。 4.数学推导证明完了，用结论写代码实现起来比较简单，这个题先背方法，一刷就先记得这个结论吧，先不追求掌握的很深入，二刷深入研究一下。","tags":["leetcode"]},{"title":"203.移除链表元素,707.设计链表,206.反转链表","path":"/2024/09/04/203-移除链表元素-707-设计链表-206-反转链表/","content":"​203.移除链表元素 1.这个移除链表的原理已经懂了。 2.和我的方法差不多，但卡哥的代码没有用到temp变量，节省了内存。 3.当遇到要删除的元素时，prev指向待删除元素的下一个节点后，这个时候prev是否需要移动要看cur移动后对应的节点是否还是待删除的元素，如果是prev就不需要移动，因为还是待删除节点的前一个节点，如果不是prev就需要移动一位。 4.整体还行，半个小时左右，主要是prev是否移动那里没有想清楚。 707.设计链表 1.觉得这个题太复杂了，涉及到链表操作太多，对javascript class语法不太熟悉。删除节点那里比较容易实现，又有index这个参数，感觉代码量较大。 2.首先没有意识去定义size变量，计算机的存储空间那么大，总是觉得引入变量会让题变得复杂，其实要看你引入的变量有没有意义。dummyhead的设置感觉会让代码简洁的多。 3.javascript定义链表那里有点不熟练，null写成了None, 这是python代码写多了吗？然后就是读题，这个题是设计链表，题目已经明确规定了链表的定义，只需要严格按照这个题目的要求进行实现，比如哪些index是合法的，在index合法和index不超过size那里需要注意，不超过size是可以取到size的。边界条件比如while循环判断cur是否为空还是cur.next是否为空，一个是代入极端情况检验，一个是看之后的代码用了哪些，比如用了cur.next.val,那么cur.next就不能为空。 4.这个题用了一个小时左右，速度慢一是排斥做这种题干复杂的题，其实实现了一个函数就将一个函数折叠起来看起来就要好的多，然后是javascript定义ListNode和class语法还不熟悉，关于链表操作原理多理解其实已经不难了，多注意一下就行。 206.反转链表 1.不知道咋做，又一个反向指多感觉，但感觉实现起来比较复杂。 2.双指针正好可以反向指还可以移动，这个反转链表的操作可以拆解为多次反向指的操作，但要合理地连接起来。 3.双指针法实现起来比较简单，一遍过。 4.用了二十分钟左右，分析问题的能力和计算机模拟的思维能力是我觉得这道题比较难的地方。","tags":["leetcode"]},{"title":"977. 有序数组的平方、59.螺旋矩阵II\"","path":"/2024/09/04/977-有序数组的平方、59-螺旋矩阵II/","content":"​977.有序数组的平方 1.最先是对题目有点看不懂，为啥会强调非递减，元素平方后负数会变为正数，原有的非递减顺序会改变。最直接想到的是直接数组每个元素求平方然后对数组排序。 2.非递减这个条件利用的好，较大的数位于数组两端，这就为用双指针解法创造了条件，这个题目没有要求数组原地操作，所以定义left,right指针指向原数组，k指针指向函数返回的新数组，依次比较left,right指向元素平方和的大小，较大的值赋值给k指针指向的位置，较大的指对应的指针移动（向右或向左），k指针后移，知道left&gt;right结束。 3.第一次用暴力解法做，在排序哪里用了冒泡排序，但内层循环本来是遍历的j, 结果用了外层循环的i，导致用例报错。用双指针法在循环结束条件处应该是当left&lt;&#x3D;right继续循环，因为当left&#x3D;right时left或right指向的元素一直没有放到新数组中去，但最后一次需要放进去。 4.学会了要充分利用题中的条件，比如非递减用双指针就比较好。然后就是边界条件用一个特殊情况去分析是否取等号，这个题学习了近一个小时。 59.螺旋矩阵II 1.第一次看到这个题目，不知道这个题如何做，只知道可能要利用下标关系，没有发现这个过程有何规律。 2.首先是这个规律看得很准，就是将这个过程分解为几圈和中间位置的处理，只有n为奇数时才会有中间位置，中间位置也就是模拟过程的最后一步，转多少圈可以通过n&#x2F;2取整来计算，最关键的还是要定义好循环不变量，比如用左闭右开的原则就要坚持每条边都用左闭右开的原则。每次转完一圈后就更新转圈的起始位置，横纵坐标加1就可以完成，然后在转每一个圈中，左闭右开这个边界通过引入一个offset变量控制，初始值为1, 转完一圈后offset加1。如果是奇数，最后一步还需要将中心位置赋值。 3.首先没有搞清楚循环的条件是啥，应该是转多少圈，用n&#x2F;2取整获得转的圈数。然后是数组索引的部分，没有想清楚哪里用startX,startY,i,j这些变量，用startX,startY初始化i,j后需要用i,j来定位，i,j是记录着当前位置的信息，startX,startY本身只在转完一圈后再执行+1的操作。 4.体会到了用好循环不变量的重要性，整个思维过程比较严谨且可控，学习了一个小时左右，第一次真正实现了这种精确的计算机模拟算法。","tags":["leetcode"]},{"title":"704. 二分查找、27. 移除元素。","path":"/2024/09/04/704-二分查找、27-移除元素/","content":"​704.二分查找 第一想到的算法就是遍历数组判断是否等于要查找的元素，学习到一些编程技巧后知道用二分查找效率更高。 对区间的明确定义可以让逻辑更加清晰，闭区间就是可以取到的，开区间就是不能取到的，开区间不能取到所以用左闭右开时right要设置为nums.length,也就是要多一位，左闭右闭就不用多一位。同样的逻辑也可以用在计算完middle更新left或right那里, 用左闭右开时更新right时就不用减去1,因为取不到，用左闭右闭就需要减去1。 3. 开区间不能取到所以用左闭右开时right要设置为nums.length,也就是要多一位。同样的逻辑也可以用在计算完middle更新left或right那里, 用左闭右开时更新right时就不用减去1,因为取不到。 4.明确了区间定义后实现起来就容易多了，降低了想的难度，学习了一个小时。 27.移除元素 第一想到的算法就是形象地想从数组中直接将这个元素清除，有点和打麻将拿出一张牌有点像，需要移动后面的元素。 首先是暴力解法，就是遍历到要删除的元素然后将后续的元素依次向前移动覆盖。然后是双指针解法，理解双指针在这个题中的定义非常重要，快指针是遍历旧数组的指针，慢指针是新数组的指针，只需要快指针循环一次，就可以完成暴力解法两层的循环，开始时快慢指针在同一个位置，如果fast指针所指元素是要删除的元素，fast指针继续移动，slow指针不懂，移动后如果fast指针所指元素不是要删除的元素，则对slow指针所指的位置赋值为fast指针所指的值，slow指针移动, fast指针继续移动，直到遍历到末尾结束，slow指针对应新数组长度。 暴力实现最开始用的是for循环，测试用例报错，原因在于用for循环遍历到要删除的位置，然后内层循环后续的元素向前依次移动，这个时候外层循环指向的位置可能仍然是需要删除的元素，但外层for循环已经去到了下一个位置，看了卡哥代码，是将外层循环的指针回退了一位，我用的while循环感觉逻辑更清晰。用双指针方法最开始没有理解双指针在这个题中的定义，导致写出了两层循环，代码反而更复杂，然后如果fast指针所指元素不是要删除的元素，则对slow指针所指的位置赋值为fast指针所指的值，slow指针移动, fast指针继续移动，这个逻辑也能处理nums数组第一个元素不是要删除元素的情况，虽然有点冗余计算，但代码逻辑比较简单。 ​","tags":["leetcode"]},{"title":"域名解析的好处","path":"/2024/09/03/域名解析的好处/","content":"tomcat配置多网站时，Nginx可以根据不同域名解析到不同的网站端口，其他操作比如回调都是基于域名的，不会因为tomcat配置多网站选择的端口问题而影响其他服务。当更换服务器后，只需要修改域名解析，不需要改动其他相关联的服务代码，因为都是基于域名的。","tags":["前端软件开发"]},{"title":"高分辨率小屏设备远程控制低分辨率大屏设备方案","path":"/2024/09/03/高分辨率小屏设备远程控制低分辨率大屏设备方案/","content":"启动parsec-vdd添加一块屏幕在window显示设置中调整显示方式为仅在这块新增的屏幕上显示调整屏幕分辨率为适合小屏设备（能占据全屏幕）的分辨率"},{"title":"conda","path":"/2024/08/31/conda/","content":"Conda is a cross-platform, language-agnostic binary package manager."},{"title":"Vue-router","path":"/2024/08/28/Vue-router/","content":"一、路由常见的属性路由的两个属性$router和$route。$router1.$router.app2.$router.mode3.$router.currentRoute4.router.addRoutes(routes)5.router.beforeEach(to,from,next)6.router.afterEach()7.router.go(n)8.router.push(location)9.router.replace(location)10.router.back()11.router.forward()12.router.resolve(location)13.router.onReady(callback,[errorCallback])14.router.onError(callback)$route1.$route.path2.$route.query3.$route.params4.$route.hash5.$route.fullPath6.$route.name7.$route.matched8.$route.redirectedFrom Vue-router 是 Vue.js 中用于管理前端路由的一个插件，它可以帮助我们在单页面应用（SPA）中轻松地在不同的视图（页面）之间切换，而无需重新加载整个页面。 Vue-router 有两个重要的对象：$router 和 $route，分别代表路由实例和当前路由的状态。 1. $router 对象：$router 是整个路由实例，包含了控制路由的各种方法和属性。主要用来编程式导航，即通过代码改变路由。 常见的 $router 属性和方法： $router.app：当前应用的根 Vue 实例。 $router.mode：当前路由的工作模式（比如 hash 或 history）。 $router.currentRoute：获取当前路由对象，等价于 $route。 **$router.addRoutes(routes)**：动态添加更多的路由规则。 **router.beforeEach(to, from, next)**：全局前置导航守卫，路由跳转前的处理逻辑。 **router.afterEach()**：全局后置钩子，路由跳转后的处理。 **router.push(location)**：跳转到新的 URL，等价于用户点击链接。 **router.replace(location)**：类似 push，但不会留下历史记录。 **router.go(n)**：类似浏览器的前进后退，参数是步数，如 router.go(-1) 回到上一页。 **router.back()、router.forward()**：浏览器历史记录中的前进和后退。 2. $route 对象：$route 代表当前激活的路由，包含了当前 URL 解析后的信息。 常见的 $route 属性： $route.path：当前路由的路径。 $route.query：URL 中的查询参数，如 ?id=123 中的 id。 $route.params：动态路由的参数，如 /user/:id 中的 id。 $route.hash：当前路由的 hash 值（即 URL 中 # 后的部分）。 $route.fullPath：完整的 URL，包括查询参数和 hash。 $route.name：当前路由的名称（如果路由是有命名的）。 $route.matched：当前路由匹配的路由记录。 $route.redirectedFrom：重定向来源的路由。 总结： $router：用来控制路由跳转和导航（主动改变 URL）。 $route：表示当前路由的信息（被动获取 URL 状态）。 通过 Vue-router，开发者可以轻松管理 SPA 应用中的页面切换和路由逻辑，同时支持路由守卫、动态路由和编程式导航等高级功能。 App.vue 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Vue Router Example&lt;/h1&gt; &lt;nav&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/nav&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;button @click=&quot;goBack&quot;&gt;Go Back&lt;/button&gt; &lt;button @click=&quot;goForward&quot;&gt;Go Forward&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import router from &#x27;./router&#x27;;export default &#123; name: &#x27;App&#x27;, router, methods: &#123; goBack() &#123; this.$router.back(); &#125;, goForward() &#123; this.$router.forward(); &#125; &#125;, mounted() &#123; console.log(&#x27;Current Route:&#x27;, this.$route.path); console.log(&#x27;Query Params:&#x27;, this.$route.query); console.log(&#x27;Route Params:&#x27;, this.$route.params); console.log(&#x27;Route Name:&#x27;, this.$route.name); &#125;&#125;;&lt;/script&gt; router.js 123456789101112131415161718192021222324252627import Vue from &#x27;vue&#x27;;import Router from &#x27;vue-router&#x27;;import Home from &#x27;./components/Home.vue&#x27;;import About from &#x27;./components/About.vue&#x27;;Vue.use(Router);const routes = [ &#123; path: &#x27;/&#x27;, component: Home, name: &#x27;home&#x27; &#125;, &#123; path: &#x27;/about&#x27;, component: About, name: &#x27;about&#x27; &#125;];const router = new Router(&#123; mode: &#x27;history&#x27;, routes&#125;);router.beforeEach((to, from, next) =&gt; &#123; console.log(&#x27;Before each route:&#x27;, to.path); next();&#125;);router.afterEach((to, from) =&gt; &#123; console.log(&#x27;After each route:&#x27;, to.path);&#125;);export default router;"},{"title":"Vue的生命周期","path":"/2024/08/28/Vue的生命周期/","content":"一、各个生命周期的作用 Vue 的生命周期就是 Vue 实例从创建到销毁的过程，包括了它的初始化、渲染、更新、销毁等多个阶段。每个阶段 Vue 都会触发特定的生命周期钩子函数，让开发者有机会在不同的时间点执行代码。 首先在Vue生命周期中有十个阶段： 11、beforeCreate(创建前) 在实例初始化之后，进行数据侦听和事件&#x2F;侦听器的配置之前同步调用。因为data和methods中的数据都还没有初始化，常常在该阶段执行与Vue数据无关的事件，比如我们的loading等待事件。这是 Vue 实例刚开始初始化的阶段，此时实例还没有创建，数据和事件都还未准备好，DOM 结构也还没生成。 12、created(创建后) 在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件&#x2F;侦听器的回调函数。然而，挂载阶段还没开始，且$el property目前尚不可用。 在该阶段已经完成data和methods的初始化了，只是页面还未渲染，可以在该阶段来发起请求获取数据等，以及操作data和调用methods等Vue 实例已经创建好了，此时可以访问 data 和 methods，但 DOM 还没渲染。适合在这个阶段执行一些数据初始化或 Ajax 请求。 13、beforeMount(挂载前) 在挂载开始之前被调用：相关的render函数首次被调用。该钩子在服务器端渲染期间不被调用Vue 实例的模板已经编译好，准备将编译后的模板挂载到页面的 DOM 上，但 DOM 还未真正渲染。 14、mounted(挂载后) 实例被挂载后调用，这时el被新创建的vm.$el替换了。如果根实例挂载到了一个文档内的元素上，当mounted被调用时vm.$el也在文档内。注意mounted不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在mounted内部使用vm.$nextTick该钩子在服务器端渲染期间不被调用这时候Vue实例完成初始化，且挂载渲染到页面了，最早我们可以在这个阶段来操作页面上的DOM节点。Vue 实例已经挂载到页面上，DOM 已经渲染完成，适合在这里进行与 DOM 相关的操作。 15、beforeUpdate(更新前) 在数据发生改变后，DOM被更新之前被调用。这里适合在现有DOM将要被更新之前访问它，比如移除手动添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行该阶段此时实例中的数据已经是最新的啦，但是页面的还未更新在数据发生变化并且即将重新渲染 DOM 前触发。在这个阶段，你可以看到旧的 DOM 状态，但还没有更新。 16. updated（更新后） 数据更新完成，DOM 已经被重新渲染，适合执行需要与更新后的 DOM 交互的操作。 17. beforeDestroy（销毁前） Vue 实例即将销毁，在这里可以进行一些清理操作，比如移除事件监听器或清除定时器。 18. destroyed（销毁后） Vue 实例已经销毁，所有数据绑定、事件监听等都已经清除，DOM 结构也被移除了。"},{"title":"Vue的优点和特点","path":"/2024/08/28/Vue的优点和特点/","content":"一、优点1.首先是双向绑定这也是我们使用框架的一大优势，VUE使用MVVC架构，在VUE.2X中使用Object.definProperty (来劫持绑定数据，在VUE.3X中使用Proxy劫持。如果按照最初的开发，我们前端开发不仅仅是需要完成业务代码的实现，同时还需要对每个DOM元素进行获取绑定时间和数据。而双向绑定使得我们只需要专注于业务代码的实现上。 2.简单易学VUE以简单，易上手的特点，在国内很多企业得到使用。同时作为国人开发的框架，中文文档，相关的论坛，生态完善，也便于我们学习和遇到问题寻找解决方案。 3.虚拟D0M使用虚拟DOM,结合DIFF算法能减少性能损耗。他会把我们多次的操作合并为一次，推送到真实的DOM。另外补充，我们说虚拟DOM减少损耗是有条件，是指在频繁操作的情况下，不然肯定简单的获取操作最快的，期间没有很多计算等处理。 4.组件化的思想实现组件的封装（比如itopmap.com中的openlayermap.vue），我们往往是使用组件开发的思想去封装组件，这样不仅便于复用也好维护修改！ 二、缺点1.生态不够完善相比angular和react来说，生态环境较为不足，在构建大型的应用方面，企业使用react的比较多。而中小型企业使用VUE比较多。 三、react与VUE的区别和优缺点VUE和React的共同点是，都是组件化的思想，虚拟DOM,数据绑定，而不同点在于，首先两者的设计思想不同，前者定位降低前端开发的门槛，而后者推崇函数式编程。另外在React中，是使用JSX的写法，把HTML和CSS都写入到JavaScript中。还有的就是他们的DIFF算法实现也不太一样。"},{"title":"前端安全","path":"/2024/08/28/前端安全/","content":"XSS跨站脚本攻击Cross Site Scripting为了和CSS区别，CSS指的是层叠样式表(Cascading Style Sheets)用户输入或使用其他方式向代码中注入其他S,然后S代码被执行。1.可能是写一个死循环、获取cookie登录2.监听用户行为3.修改DOM伪造登录表单4.页面生成浮窗广告 反射型 XSS代码通过URL注入。因为恶意脚本通过作为网络请求的参数，经过服务器，然后反射到HTML文档中执行解析，服务器不会存储这些恶意脚本。反射型XSS漏洞常见于通过URL传递参数的功能，如网站搜索、跳转等。 存储型 XSS代码发送到服务器数据库，前端请求数据时，将XSS代码发送到前端。场景：留言区提交一段脚本执行，若前后端未做好转义的工作，评论内容存在数据库，页面渲染过程中直接执行相当于是执行一段未知逻辑的S代码。如论坛发帖、商品评论、用户私信等。 文档型 XSS攻击不会经过服务端，作为中间人的角色，数据传输过程劫持到网络数据包，然后修改里面的HTML文档。劫持包括：1.WIF路由劫持2.本地恶意软件DOM型XSS跟前两种XSS的区别：DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种XSS都属于服务端的安全漏洞。防范：一个信念，两个利用1.对输入转码过滤2利用CSP浏览器内容安全策略，核心就是服务器决定浏览器加载哪些资源，功能：1.限制其他域下的资源加载2.禁止向其它域提交数据3.提供上报机制3.HttpOnlyIttpOnly类型的cookie阻止JS对其的访问（标记或授权对话）阻止XSS攻击：服务器对脚本进行过滤或转码，利用CSP策略，使用HttpOnly;CSRF-跨站伪造请求（钓鱼）Cross-Site Request Forgery攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证（比如cookie)，绕过后台的用户验证，因此可以冒充用户对被攻击的网站执行某项操作。利用所在网站的目前登录信息，悄悄提交各种信息，比XSS更恶劣。本质：利用cooki会在同源请求中携带发送给服务器的特点，以此冒充用户。利用服务器的验证漏洞和用户之前的登录状态模拟用户操作。点击链接后，可能发生3件事1.自动发送GET请求。利用src发送请求2.自动发送POST请求3.诱导点击发送GET请求防范1.SameSiteSameSite可以设置为三个值，Strict、Lax和None。a.在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求sanyuan.com网站只能在sanyuan.com域名当中请求才能携带Cookie,在其他网站请求都不能。b.在Lax模式，宽松一点，但是只能在get方法提交表单况或者a标签发送get请求的情况下可以携带Cookie,其他情况均不能。c.在None模式下，也就是默认模式，请求会自动携带上Cookie..2验证来源站点请求头中的origin和refererorigin,只包含域名信息，referer包含具体的URL路径。3.CSRF Roken利用token(后端生成的一个唯一登陆态，传给前端保存)每次前端请求都会带token,后端检验通过才同意请求。·敏感操作需要确认·敏感信息的cookie只能有较短的生命周期4安全框架如Spring Security.SQL注入攻击SQL注入攻击，将恶意的Sq查询或添加语句插入到应用的输入参数中，再在后台Sq服务器上解析执行。如何让Web服务器执行攻击者的SQL语句？SQL注入的常规操作就是将有毒的SQL语句放置于Fo表单或请求参数之中，然后提交到后端服务器，如果后端服务器没有做输入安全检查，直接将变量取出执行SQL语句，就容易中招。预防方式如下：·严格检查输入变量的类型和格式·过滤和转义特殊字符·对访问数据库的Web应用程序采用Web应用防火墙其他种类的攻击：DDoS全称Distributed Denial of Service:分布式拒绝服务攻击。是拒绝服务攻击的升级版。拒绝攻击服务顾名思义，让服务不可用。常用于攻击对外提供服务的服务器，像常见的：·Web服务。邮件服务·DNS服务·即时通讯服务DNS劫持JSON劫持暴力破解HTTP报头追踪漏洞信总泄露目录遍历漏洞命令执行漏洞文件上传漏洞等等","tags":["前端软件开发"]},{"title":"SPA首屏优化","path":"/2024/08/28/SPA首屏优化/","content":"浏览器从响应用户输入网址地址，到首屏内容渲染完成时间，整个网页不一定要完全渲染完成，但需要展示当前视窗内容加载慢的原因 网络延时 资源文件体积过大 资源加载重复发送请求 加载脚本时，渲染内容阻塞 解决 减少入口文件体积 静态资源本地缓存 UI框架按需加载 图片资源压缩 组件重复打包 开启GZip压缩 使用SSR 减少入口文件体积 路由懒加载，将不同路由对应组件分割成不同代码块，待路由被请求时单独打包路由，使得入口文件变小以函数形式动态加载路由，可以把各自的路由文件分别打包，只在解析给定路由时，才会加载路由组件 静态资源本地缓存 HTTP缓存和localStorage 按需加载 对UI库按需引用 图片资源压缩 对icon,使用在线字体图标 组件重复打包 若A.js是一个常用库，多个路由使用它会造成重复下载 在webpack的config中，修改CommonChunkPlugint的配置 minChunks为3表示会把使用3次及以上的包抽离，放进公共依赖文件 使用SSR 服务端渲染，Server Side,组件或页面通过服务器生成html字符串，发送到浏览器"},{"title":"其他文件优化","path":"/2024/08/28/其他文件优化/","content":"1.服务端开启文件压缩功能2.执行JS代码过长会卡住渲染，对于需要很多时间计算的代码可以使用WebworkerwebWorker是运行在后台的JS,另开一个子线程，不会影响性能"},{"title":"图片","path":"/2024/08/28/图片/","content":"电商类项目，存在大量图片，banner广告图、菜单导航栏、列表头图等图片众多以及体积过大影响页面加载速度为啥？有些图片请求并发，Chrome最多支持并发请求数有限，其他请求被push进队列中等待或停滞，直到上轮请求完成后才被发出，一部分资源需要排队等待时间，过多的图片影响页面加载展示合适图片格式1.WebP格式具有更好的图像数据压缩算法，更小的图片体积，拥有肉眼识别无差异的图像质量，缺点是兼容性并不好2.小图使用PNG,对于大部分图标，完全可以使用SVG代替3.照片使用JPEG4.雪碧图（将多个图标文件整合到一张图片中）可能请求非常多的小图片，会受到浏览器并发HTTP请求数的限制1.图片压缩2.不用图片，用CSS代替3.对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用CDN加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片JPEG&#x2F;JPG1.高质量有损压缩，体积小，不支持透明2.应用于轮播图大的背景图、bannerPNG1.无损压缩，质量好，体积大，支持透明2.应用小的10g0SVG1.体积小，不失真，兼容好2.应用于图标GIF1.支持透明Webp有损压缩与无损压缩（可逆压缩）的图片文件格式比PNG&#x2F;PEG格式小支持透明度体积和效果上都做的不错 12345&lt;picture&gt;&lt;source type=&quot;image/webp&quot;srcset=&quot;/static/img/perf.webp&quot;&gt;&lt;source type=&quot;image/jpeg&quot;srcset=&quot;/static/img/perf.jpg&quot;&gt;&lt;img src=&quot;/static/img/perf.jpg&quot;&gt;&lt;/picture&gt; webpack压缩配置image-webpack-loader雪碧图CSS Sprites,精灵图，图像合成技术，主要用于小图片显示同原域名请求有最大并发限制，Chrome为6个，如页面有10个小图，需要10次请求，2次并发若把10个图合成一个大图，只需1次请求1.减少请求次数2.减少服务器压力3.诚少并发4.提高加载速度5.减少鼠标滑过的一些bug6.解决网页设计师在图片命名上的困扰iconfont通过字体方式展示图标，用户图标渲染、简单图形、特殊字体等1.轻量，已修改2.诚少请求次数内联Base64图片转为base64串，解析图片不会请求下载，而是解析字符串缺点1.比使用二进制体积增大33%2.全部内联后，原本可并行加载的图片会串行放入请求适用于更新频率低、首屏或骨架图上的小图标CSS代替图实现修饰效果，半透明、阴影、圆角、渐变等"},{"title":"渲染优化","path":"/2024/08/28/渲染优化/","content":"懒执行将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。懒加载将不关键的资源延后加载一尽量只加载用户正浏览或即将会浏览的图片只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西对于图片来说，先设置图片标签的src属性为一张占位图，真实的图片资源放入自定义属性data-src中，当进入自定义区域时，就将自定义属性替换为sc属性，这样就会下载图片资源节流防抖防抖：单位时间内多次触发，只执行最后的那一次，原理：延迟执行，期间但凡有新的触发就重置定时器节流：单位时间只触发一次，原理：上锁，只有满足一定间隔时间才能执行"},{"title":"性能优化","path":"/2024/08/28/性能优化/","content":"1.网站打开速度2.动画流畅3.表单提交速度4.列表滚动页面切换是否卡顿优化手法1.聚焦用户2.尽快响应用户输入3.动画执行流肠4.最大化主线程空闲时间5.网页可交互性"},{"title":"鉴权","path":"/2024/08/28/鉴权/","content":"Cookie服务端响应客户端请求时，会返回一个cookie,后续客户端的请求携带这个cookie特点1.存储在客户端，可随意纂改2.影响性能，最大为4kb3.一个浏览器对于一个网站只能存不超过20个Cookie,而浏览器一般只允许存放300个Cookie4.移动端对Cookie支持不友好5.一般情况下存储的是纯文本，对象需要序列化之后才可以存储，解析需要反序列化通过设置正确的domain和path,减少数据传输，节省带宽 Cookie-sessioncookie需要的存的东西越来越多，但是cookie大小有限制所以后端返回sessionId,客户端将sessionid存在cookie中缓存数据库：所有机器根据sessionId去缓存系统获取用户信息和认证局限性1.依赖Cookie,但Cookie可被禁用2.系统不停请求缓存服务器查找信息，内存开销增加3.存在单点登录失败的可能性若负责session的机器挂了，整个登录就挂了，但项目中，负责session的机器也是有多台机器的集群进行负载均衡增加可靠性 SSO(单点登录)三种类型Single Sign On在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统单点登录1.同一站点下2.相同的顶级域名3.不同的顶级城名相同域名和相同顶级域名下可共享cookie但是不同域呢？ CAS(中央认证服务)原理 流程和Cookie-session模式相同 Json Web Token最简单的token组成：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+哈希算法压缩成一定长的十六进制字符串，防止恶意三方拼接token请求)JWTheader(头部)、payload(负载)、signature(签名)这三个部分组成，中间用.来分隔开：Header.Payload.Signaturejwt:“eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiJhliwiaWFOIjoxNTUxOTUxOTk4fQ.2jf3kl_uKWRkwjOP6uQRJFqMlwSABcgqqcJofFH5XCo” 弊端 1.JWT的退出是假的登录失效，只要之前的token没过期依然可以用2.安全性依赖密钥3.加密生成的数据长 优点 1.不依赖Cookie2.没有单点登录的cookie-sessionId模式好扩展3.服务器保持无状态性session和token的对比就是「用不用cookie」和「后端存不存」的对比","tags":["前端软件开发"]},{"title":"前端路由","path":"/2024/08/28/前端路由/","content":"把不同路由对应不同内容或页面的任务交给前端来做，之前通过服务端根据的不同返回不同的页面实现前端路由实质上就是检测URL的变动，截获URL地址，通过解析、匹配路由规定实现UI更新单页面应用中的路由分为hash和history模式 hash模式监听浏览器地址hash值变化，执行事件hash会在浏览器URL后增加#号一个完整的的URL包含：协定、域名、端口、虚拟目录、文件名、参数、锚比如https://www.google.com/#abc中的hash值为abc特点：hash的变化不会刷新页面，也不会发送给服务器但hash的变化会被浏览器记录下来，来指导浏览器中的前进和后退window.location.hash变化触发窗口onhashchange事件，监听hash变化触发路由时视图容器更新一多数前端框架哈希路由的实现原理触发hashchange的情况 URL变化（包括浏览器的前进、后退）修改window.location.hash 浏览器发送http://www.baidu.com/至服务器，请求完毕后设置散列值为#/home 只修改hash部分，不发请求 a标签可设置页面hash,浏览器自动设置hash 12345window.location.hash=&#x27;abc&#x27;;let &#123;hash&#125;=window.locationwindow.addEventListener(&#x27;hashchange&#x27;,function()&#123;//监听hash变化&#125;) 特点 兼容性好路径在#后面，不好看 history模式H5新特性，允许直接修改前端路由，更新URL但不重新发请求，history可自定义地址window.history属性指向History对象，表示当前窗口的浏览历史，保存了当前窗口访问过的所有页面网址由于安全原因，浏览器不允许脚本读取这些地址，但允许在地址间导航 1234//后退到前一个网址history.back()//等同于history.go(-1) 浏览器工具栏的“前进”和“后退”按钮，就是对History对象进行操作History对象主要有两个属性History.length:当前窗口访问过的网址数量（包括当前网页）History.state:History堆栈最上层的状态值（详见下文） 12345//当前窗口访问过多少个网页window.history.length//History对象的当前状态//通常是undefinedwindow.history.state history.back(history.forward()history.go()用于在历史之中移动 History.back()：移动到上一个网址，等于点击浏览器后退键。对于第一个访问的网址，该方法无效 History.forward()：移动到下一个网址，等于点击浏览器前进键。对于最后一个访问的网址，该方法无效果 History.go()：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，go(1)相当于forward(),go(-1)相当于back()。如果参数超过实际存在的网址范围，该方法无效；如果不指定参数，默认0,相当于刷新页面 history.pushState()在历史中添加一条记录，不会导致页面刷新 1window.history.pushState(state,title,url) state:对象，触发popstate事件将该对象传递到新页面。不需要可以填null tit1e:新页面标题。但现在所有浏览器都忽视这个参数，所以可以填空串 url：新网址，必须与当前页面在同域。地址栏将显示这个网址假定当前网址是example.com&#x2F;1.html,使用pushState()在浏览记录(History对象)中添加一个新记录 12var stateobj =foo:&#x27;bar&#x27;&#125;history.pushState(stateobj,&#x27;page 2&#x27;,&#x27;2.html&#x27;); 添加新记录后，浏览器地址栏显示example.com&#x2F;2.html,但不会跳转到2.html,也不会检查2.html是否存在，它只是成为浏览历史的最新记录。这时，在地址栏输入一个新的地址（如访问go0g1.com),然后点击倒退按钮，页面的URL将显示2.htmL;再点击一次倒退，URL将显示1.htmlpushState()不触发页面刷新，只导致History对象变化，地址栏有反应使用该方法后，可以用History.state读出状态对象 123var stateobj =foo:&#x27;bar&#x27;&#125;;history.pushstate(stateobj,&#x27;page 2&#x27;,&#x27;2.html&#x27;);history.state /&#123;foo:&quot;bar&quot;&#125; 如果oushState的URL参数设置了一个新的锚点值（即hash),不会触发hashchange事件。反过来，如果URL的锚点值变了，会在History对象创建一条浏览记录如果pushState()方法设置了一个跨域网址，报错 123/报错//当前网址为http://example.comhistory.pushState(null,&#x27;&#x27;,&#x27;https://twitter.com/hello&#x27;); pushStat想要插入一个跨域的网址，导致报错。防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转history.replaceState()修改History当前记录，其他与oushState()一模一样假定当前网页是example.com&#x2F;example.html 123456789101112history.pushstate(&#123;page:1&#125;,&#x27;title 1&#x27;,&#x27;?page=1&#x27;)//URL显示为http://example.com/example.html?page=1history.pushState(&#123;page:2&#125;,&#x27;title 2&#x27;,&#x27;?page=2&#x27;);//URL显示为http://example.com/example.html?page=2history.replaceState(&#123;page:3&#125;,&#x27;title 3&#x27;,&#x27;?page=3&#x27;);//URL显示为http://example.com/example.html?page=3history.back()//URL显示为http://example.com/example.html?page=1history.back()//URL显示为http://example.com/example.htmlhistory.go(2)//URL显示为http://example.com/example.html?page=3 popstate事件当同一个文档的浏览历史变化触发popstate注意“仅调用pushState()&#x2F;replaceState(),不会触发。只有点击浏览器倒退&#x2F;前进，或调用History.back()、History.forward()、History.go()才会触发·只针对同一个文档，如果浏览历史切换，导致加载不同文档，不会触发popstate指定回调函数 123456789window.onpopstate function (event)&#123;console.log(&#x27;location:&#x27;document.location);console.log(&#x27;state:&#x27;JSON.stringify(event.state));&#125;//或者window.addEventListener(&#x27;popstate&#x27;,function (event)&#123;console.log(location:&#x27;document.location);console.log(&#x27;state:&#x27;JSON.stringify(event.state));)； 回调函数参数event事件对象，它的state:指向当前状态对象，这个state.也可以通过history对象读取 1var currentstate=history.state; 页面第一次加载不会触发popstate事件特点路径正规兼容性不比hash,需服务端支持对于一个应用而言，url的改变（不包括hash值改变）只能由下面三种情况引起： 点击浏览器的前进或后退按钮&#x3D;&gt;可以监听popstate事件 点击a标签 JS触发history.pushState()、history.replaceState()","tags":["前端软件开发"]},{"title":"输入URL回车后","path":"/2024/08/28/输入URL回车后/","content":"简易版1.URL解析2.查找缓存3.域名解析：浏览器缓存&gt;系统缓存&gt;本地hosts&gt;根域名&gt;顶级域名&gt;二级域名&gt;三级域名4.TCP三次握手5.发送HTTP请求6.服务器处理请求并返回报文7.浏览器解析渲染页面8.TCP四次挥手关闭TCP连接","tags":["前端软件开发"]},{"title":"微前端","path":"/2024/08/28/微前端/","content":"一种类似于微服务的架构，它将微服务的理念应用于浏览器端，将Wb应用由单一的应用转变为多个小型前端应用聚合为一的应用各个前端应用可以使用不同技术栈、独立运行、独立开发、独立部署不是框架或工具，而是一套架构体系解决问题1.将庞大应用拆分，每个部分可以单独部署、维护，提升效率2.整合系统，在基本不修改原来系统逻辑的同时兼容新老老套系统并行运行技术方案思想就是拆解和整合应用，通常是一个父应用加上一些子应用·Nginx路由转发实现不同路径映射到不同应用，这不属于是前端层面的改造，更多是运维的配置简单、快速、易配置，切换应用时触发浏览器刷新会引用体验·iframe嵌套子应用嵌套iframe,父子通信可采用POSTMessage?或contentWindow实现实现简单、子应用间自带沙箱隔离互不影响、iframe样式显示有兼容性、太过简单显得lowWeb Components子应用采用纯Web Components技术编写，是全新的开发模式可单独部署，系统改造成本高，子应用通信复杂易踩坑·组合式应用路由分发子应用独立构建和部署，父应用管理路由、应用加载、启动、卸载和通信纯前端改造、体验好、可无感切换，需设计和开发父子应用于同一页面运行，需解决子应用样式冲突、变量对象污染、通信等技术点应用隔离分为主应用和微应用微应用间的S执行环境隔离、CSS隔离CSS隔离主微应用同屏渲染时，可能有样式会相互污染，需要彻底隔离CSS污染，可采用CSS module或命名空间的方式，保证不相互干扰，或者webpack的postcss:插件，打包时加上特定的前缀微应用间的CSS隔离，应用加载时，将应用所有的1ik和stylei进行标记，卸载应用时再同步卸载即可JS隔离使用沙箱机制，避免对全局window和全局事件的修改浏览器可结合with关键字或Proxy实现浏览器端沙箱保证局部S运行时，对对外部对象的访问和修改在可控范围内"},{"title":"CDN","path":"/2024/08/28/CDN/","content":"Content Delivery Network,内容分发网络我们访问一个页面的时候，会请求很多资源，包括各种图片、声音、影片、文字等信息。这和我们要购买多种货物一样网站可以预先把内容分发至全国各地的加速节点。用户可以就近获取内容，避免网络拥堵、地域、运营商等因素带来的访问延迟问题“内容分发网络”像前面提到的”全国仓配网络”，解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景用户可就近取得所需内容，解决Internet网络拥挤的状况CDN本质是一大堆遍布在全球各个角落的缓存服务器。通过与DNS的配合，找到最靠近用户的一台CDN缓存服务器，将数据快速分发给用户减少对整体骨干网的流量负担，提高用户体验DNS解析之后，浏览器向服务器请求内容后发生长途骨干网的传输最耗时，需经过网站服务器所在的机房、骨干网、用户所在城局域网、用户所在接入网等，物理传输距离遥远1亿人同时请求12306上一张一模一样的图片，对国家的互联网基础设施是一个灾难CDN提前把数据存在离用户最近的数据节点，避免长途跋涉经过长途骨干网，最终减少骨干网负担、提高访问速度请求图片数据，先去CDN缓存服务器获取，若获取到数据直接返回，否则才经过长途骨干网，最终达到网站服务器获取数据CDN其实还缩短了请求数据的距离用户分布全国各地，一般会在离用户在较近的地方设置CDN缓存服务器，酱紫各个地区的用户能直接请求对应的CDN服务器，不需要来回跑大半个中国！过程1.发起请求，本地DNS解析，将域名解析权交给域名CNAME指向的CDN专用DNS服务器2.CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回浏览器3.浏览器向CDN全局负载均衡设备发起URL请求4.CDN全局负载均衡设备根据用户IP，以及URL,选择一台用户所属区域的区域负载均衡设备，向其发请求5.区域负载均衡设备为用户选最合适的CDN缓存服务器（考虑的依据包括：服务器负载情况，距离用户的距离等)，返回给全局负载均衡设备6.全局负载均衡设备将选中的CDN缓存服务器IP返回给用户7.根据用户IP,判断最近边缘节点8.根据用户请求URL中内容，判断有用户所需内容的边缘节点9.查询边缘节点负载情况，判断有服务能力的边缘节点0.全局负载均衡设备将服务器IP返回给用户1.用户向CDN缓存服务器发起请求，缓存服务器响应用户请求，最终将内容返回组成(CDN)由多个节点组成。一般，CDN网络主要由中心节点、边缘节点两部分构成中心节点中心节点包括CDN网管中心和全局负载均衡DNS重定向解析系统，负责整个CDN网络的分发及管理边缘节点CDN边缘节点主要指异地分发节点，有负载均衡设备、高速缓存服务器两部分负载均衡设备负责每个节点中各个Cache的负载均衡，保证节点工作效率；同时负责收集节点与周围环境的信息，保持与全局负载均衡DNS的通信，实现整个系统的负载均衡高速缓存服务器(Cache)负责存储客户网站信息，像一个靠近用户的网站服务器一样响应本地用户的请求通过全局负载均衡DS的控制，用户的请求被透明指向离他最近的节点，节点中Cache服务器像网站的原始服务器一样，响应终端用户的请求中心节点像仓配网络中负责货物调配的总仓，边缘节点就是负责存储货物的各个城市的本地仓库","tags":["前端软件开发"]},{"title":"Ajax、Fetch和Axios","path":"/2024/08/28/Ajax、Fetch和Axios/","content":"AjaxAjax(Asynchronous JavaScript and XML,异步JavaScript.与XML技术)，使网页实现异步更新，不重新加载网页的情况下，对网页部分进行更新不是一种新技术，而是2005年被提出的新术语由XMLHttpRequestp的API实现请求步骤 123456789101112//创建XMLHttpRequest对象const ajax new XMLHttpRequest();//规定请求的类型、URL以及是否异步处理请求，通过MLHttpRequest对象的open()方法与服务端建立连接ajax.open(&#x27;GET&#x27;,url,true);//发送信息至服务器时内容编码类型ajax.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);//发送请求ajax.send(null);//监听服务端的通信状态，接受服务器响应数据ajax.onreadystatechange function ()if (ajax.readyState ==4 &amp;(ajax.status =200 ajax.status =304))&#123;&#125;&#125; 特点：·局部刷新页面，无需重载整个页面·基于原生XHR开发，而XHR本身架构不清晰·对基于异步的事件不友好Fetchfetch是底层API,代替XIHR,是真实存在的，基于promise实现不是Ajax的封装，而是原生JS,没有使用XMLHttpRequest对象特点： 使用promise,.支持async&#x2F;await 提供的API丰富 脱离XHR 不携带cookie,需要手动添加配置项 AxiosAxios是一个基于promise封装的HTTP客户端，可以用在浏览器和node.js中它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范特点： 从浏览器中创建XMLHttpRequests 从node.js创建http请求 支持Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF 1234567891011axios(&#123; url:&#x27;xxx&#x27;,//设置请求的地址 method: &quot;GET&quot;,//设置请求方法 params:&#123;//get请求使用params进行参数凭借，如果是post请求用data type:&#x27;&#x27;, page:1 &#125;&#125;).then(res =&gt; //res为后端返回的数据 console.log(res);&#125;) 设置接口请求前缀利用ode环境变量判断，区分开发、测试、生产环境 1234if (process.env.NODE_ENV ===&#x27;development&#x27;)&#123;axios.defaults.baseURL = &#x27;http://dev.xxx.com&#x27;else if (process.env.NODE_ENV ===&#x27;production&#x27;)&#123;axios.defaults.baseURL = &#x27;http://prod.xxx.com&#x27; 本地调试时，在config.js中配置proxy实现代理转发设置请求头和超时时间 123456789101112const service axios.create(&#123;timeout:30000,//请求30s超时headers:get:&#x27;Content-Type&#x27;:application/x-www-form-urlencoded;charset=utf-8&#x27;/在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来&#125;,post:&#x27;Content-Type&#x27;:&#x27;application/json;charset=utf-8&#x27;//在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来&#125;,&#125;) 封装请求方法 1234567891011121314//get请求export function httpGet(&#123;url,params =&#123;&#125;)&#123;return new Promise((resolve,reject)=&gt;&#123;axios.get(url,params&#125;).then((res)=&gt;&#123;resolve(res.data)&#125;).catch(err =&gt;reject(err)&#125;)&#125;) 请求拦截器在每个请求里加上token,统一处理维护方便响应拦截器在接收到响应后先做一层判断，比如状态码判断登录状态、授权 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 扩充后的影视、动漫角色名称列表 const characterKeywords = [&#x27;Spider-Man&#x27;, &#x27;Batman&#x27;, &#x27;Superman&#x27;, &#x27;Naruto&#x27;, &#x27;Goku&#x27;, &#x27;Iron Man&#x27;, &#x27;Captain America&#x27;, &#x27;Thor&#x27;, &#x27;Wonder Woman&#x27;, &#x27;Black Widow&#x27;, &#x27;Hulk&#x27;, &#x27;Loki&#x27;, &#x27;Sasuke&#x27;, &#x27;Itachi&#x27;, &#x27;Gon Freecss&#x27;, &#x27;Killua Zoldyck&#x27;, &#x27;Ichigo Kurosaki&#x27;, &#x27;Rukia Kuchiki&#x27;, &#x27;Light Yagami&#x27;, &#x27;L&#x27;, &#x27;Eren Yeager&#x27;, &#x27;Mikasa Ackerman&#x27;, &#x27;Armin Arlert&#x27;, &#x27;Sailor Moon&#x27;, &#x27;Tuxedo Mask&#x27;, &#x27;Vegeta&#x27;, &#x27;Piccolo&#x27;, &#x27;Gohan&#x27;, &#x27;Trunks&#x27;, &#x27;Frieza&#x27;, &#x27;Cell&#x27;, &#x27;Majin Buu&#x27;, &#x27;Alucard&#x27;, &#x27;Inuyasha&#x27;, &#x27;Kagome Higurashi&#x27;, &#x27;Sango&#x27;, &#x27;Miroku&#x27;, &#x27;Edward Elric&#x27;, &#x27;Alphonse Elric&#x27;, &#x27;Winry Rockbell&#x27;, &#x27;Natsu Dragneel&#x27;, &#x27;Lucy Heartfilia&#x27;, &#x27;Gray Fullbuster&#x27;, &#x27;Erza Scarlet&#x27;, &#x27;Luffy&#x27;, &#x27;Zoro&#x27;, &#x27;Nami&#x27;, &#x27;Usopp&#x27;, &#x27;Sanji&#x27;, &#x27;Chopper&#x27;, &#x27;Robin&#x27;, &#x27;Franky&#x27;, &#x27;Brook&#x27;, &#x27;Asta&#x27;, &#x27;Yuno&#x27;, &#x27;Noelle Silva&#x27;, &#x27;Deku&#x27;, &#x27;Bakugo&#x27;, &#x27;Todoroki&#x27;]; let usernames = []; let iterationCount = 0; const maxIterations = 20; const minValidUsers = 10; async function iterateAndValidate() &#123; if (iterationCount &gt;= maxIterations || usernames.length &gt;= minValidUsers) &#123; return; &#125; let username = &#x27;&#x27;; const randomKeyword = characterKeywords[Math.floor(Math.random() * characterKeywords.length)]; username = `$&#123;randomKeyword&#125;`; try &#123; const response = await axios.get(`https://api.github.com/users/$&#123;username&#125;`); usernames.push(username); &#125; catch (error) &#123; // 忽略不存在的用户 &#125; iterationCount++; return iterateAndValidate(); &#125; iterateAndValidate().then(() =&gt; &#123; const userInfoPromises = usernames.map(username =&gt; axios.get(`https://api.github.com/users/$&#123;username&#125;`)); return Promise.all(userInfoPromises); &#125;).then(responses =&gt; &#123; // 对多个用户信息进行分析 const totalFollowers = responses.reduce((acc, response) =&gt; acc + response.data.followers, 0); const averageFollowers = totalFollowers / responses.length; console.log(`平均粉丝数：$&#123;averageFollowers&#125;`); const popularUsers = responses.filter(response =&gt; response.data.followers &gt; averageFollowers); console.log(&#x27;粉丝数高于平均的用户：&#x27;); popularUsers.forEach(user =&gt; console.log(user.data.login)); const userInfoDiv = document.createElement(&#x27;div&#x27;); userInfoDiv.innerHTML = `&lt;p&gt;平均粉丝数：$&#123;averageFollowers&#125;&lt;/p&gt;&lt;p&gt;粉丝数高于平均的用户：$&#123;popularUsers.map(user =&gt; user.data.login).join(&#x27;, &#x27;)&#125;&lt;/p&gt;`; document.body.appendChild(userInfoDiv); &#125;).catch(error =&gt; &#123; console.error(&#x27;发生错误：&#x27;, error); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"addEventListener和onClick()","path":"/2024/08/28/addEventListener和onClick/","content":"addEventListener是为元素绑定事件的方法，接收三个参数： 第一个参数：绑定的事件名 第二个参数：执行的函数 第三个参数： false:默认，代表冒泡时绑定 true:代表捕获时绑定onclick和addEventListener事件区别是：onclick事件会被覆盖，而addEventListener可以先后运行不会被覆盖，addEventListener可以监听多个事件"},{"title":"JSON.stringify()","path":"/2024/08/28/JSON-stringify/","content":"转换过程中会忽略值为undefined的字段需要检测一下，若某个字段为undefined,则将其值修改为空字符串1、若目标对象存在toJSON()方法，它负责定义哪些数据被序列化 123456789let obj = &#123; x:1, y:2, toJSON:function() &#123; return &#x27;a string create by toJSON&#x27;; &#125;&#125;console.log(JSON.stringify(obj));//&#x27;a string create by toJSON&#x27; 2、Boolean、Number、String对象被装换为对应原始值 1234567const obj = &#123; a:new Number(11), b:new String(&#x27;aaa&#x27;), c:new Boolean(true)&#125;console.log(JSON.stringify(obj));//&#123;&quot;a&quot;:11,&quot;b&quot;:&quot;aaa&quot;,&quot;c&quot;:true&#125; 3、undefined、Function和Symbol不是有效的JSON值，要么被忽略（在对象中找着）,要么被更改为null(在数组中找着) 12345678910const obj = &#123; name:Symbol(&#x27;aaa&#x27;), age:undefined, isHigh:function()&#123;&#125;&#125;console.log(JSON.stringify(obj));//&#123;&#125;const arr = [Symbol(&#x27;aaa&#x27;),undefined,function()&#123;&#125;,&#x27;fighting&#x27;]console.log(JSON.stringify(arr));//[null,null,null,&quot;fighting&quot;] 4、所有Symbol-keyed属性被忽略 123456const obj = &#123;&#125;obj[Symbol(&#x27;a&#x27;)]=&#x27;aa&#x27;;obj[Symbol(&#x27;b&#x27;)]=&#x27;bb&#x27;;console.log(obj);console.log(JSON.stringify(obj));//&#123;Symbol(a):&#x27;aa&#x27;,Symbol(b):&#x27;bb&#x27;&#125; 5、Date的实例返回一个字符串实现toJSON0方法（和date.toISOString0一一使用ISO标准返回Date对象的字符串格式相同) 12console.log(JSON.stringify(new Date()));//&quot;2024-09-06T10:34:46.203Z&quot; 6、Infinity、NaN和nul都被认为是null 12345678const obj = &#123; a:Infinity, b:NaN, c:null, val:20&#125;;console.log(JSON.stringify(obj));//&#123;&quot;a&quot;null,&quot;b&quot;null,&quot;c&quot;:null,&quot;val&quot;:20&#125; 7、所有其他Object实例（包括Map、Weakmap、Set和WeakSet))序列化为其可枚举的属性 123456789101112131415let enumobj =&#123;&#125;//直接在一个对象上定义新的属性或修改现有属性，并返回该对象Object.defineProperties(enumobj, &#123; &#x27;name&#x27;: &#123; value:&#x27;a&#x27;, enumerable:true &#125;, &#x27;age&#x27;: &#123; value:99, enumerable:false &#125;,&#125;);console.log(JSON.stringify(enumobj))//&#123;&quot;name&quot;:&quot;a&quot;&#125; 8、遇到循环抛出TypeError(循环对象值)异常 123456const obj = &#123; a:&#x27;aa&#x27;&#125;obj.subObj = obj;console.log(JSON.stringify(obj));//VM357:5 Uncaught TypeError:Converting circular structure to JSON 9、对BigInt值字符串化时抛出TypeError(BigInt值无法在钉SON中序列化) 12345const obj = &#123; a:BigInt(999999999999999999999)&#125;;console.log(JSON.stringify(obj));//VM362:4 Uncaught TypeError:Do not know how to serialize a BigInt"},{"title":"parselnt&parseFloat","path":"/2024/08/28/parselnt-parseFloat/","content":"parseInt(): 将字符串转换为整数。 语法: parseInt(string, radix) string: 要被解析的字符串 radix: 可选,表示数字的基数(进制),范围2-36,默认为10 从字符串的开头解析,直到遇到非数字字符。 如果字符串的第一个字符不能被转换为数字,返回NaN。 示例: 12345parseInt(&quot;10&quot;); // 返回 10parseInt(&quot;10.5&quot;); // 返回 10parseInt(&quot;10 20 30&quot;); // 返回 10parseInt(&quot;10&quot;, 2); // 返回 2 (二进制解析)parseInt(&quot;0xA&quot;); // 返回 10 (十六进制解析) parseFloat(): 将字符串转换为浮点数。 语法: parseFloat(string) 从字符串开头解析,直到遇到非数字字符(除了第一个小数点)。 只解析十进制数,不接受基数参数。 如果字符串的第一个字符不能被转换为数字,返回NaN。 示例: 12345parseFloat(&quot;10&quot;); // 返回 10parseFloat(&quot;10.5&quot;); // 返回 10.5parseFloat(&quot;10.5.6&quot;); // 返回 10.5parseFloat(&quot;10 20 30&quot;); // 返回 10parseFloat(&quot;3.14e-2&quot;); // 返回 0.0314 主要区别: parseInt主要用于整数,parseFloat可以处理小数。 parseInt可以指定进制,parseFloat只处理十进制。 parseFloat能识别科学记数法(如3.14e-2)。","tags":["前端软件开发"]},{"title":"JavaScript中日期时间格式转换","path":"/2024/08/28/JavaScript中日期时间格式转换/","content":"获取当天时间： 123456789101112131415//获取当前时间var date = new Date();var year = date.getFullYear();var month = date.getMonth()+1;var day = date.getDate();//这两个是针对小于十的时候，会为个位数if (month &lt; 10)&#123; month =&quot;0&quot;+month;&#125;if (day 10)&#123; day =&quot;0&quot;+day;&#125;var nowDate = year &quot;&quot;month +&quot;-&quot;day;//往往格式成这种样式是后台处理好的，或者我们会使用一些插件，又或者我们在vu中会使用过滤器来处理。//输出结果格式：2021-11-08 一、基本的函数：·getDate(0返回一个月中的某一天(1-31)·getMonth(O返回月份(0-1I)·getFullYear(0以四位数字返回年价(20I1)·getHours(0返回小时(0-23)·getMinutes(0返回分钟(0-59)·getSeconds(0返回秒数(0-59)·get Time(0返回1970年1月1日至今的毫秒数(1566715528024)二、获取时间澄的方法let timestamp &#x3D;(new Date()).valueof();&#x2F;&#x2F;或者let timestamp&#x3D;new Date().getTime();三、练习圈问题：返回“现在距离今年元旦还有X天X小时X分钟X秒”function timemove(){&#x2F;获取当前时问let d1 new Date();&#x2F;获取下一年let nextYear d1.getFullYear()+1;&#x2F;&#x2F;定义目标时间let d2 new Date(nextYear +”&#x2F;1&#x2F;1 00:00:00”);&#x2F;&#x2F;定义剩余时间1etd&#x3D;d2-d1;&#x2F;是-个时间戳&#x2F;&#x2F;计算剥余天数let Day parseInt(d 1000 &#x2F;60 60 24);&#x2F;计算剩余小时let Hours parseInt(d 1000 60 60%24);&#x2F;&#x2F;计算剩余分钟let Minutes parseInt(d 1008 &#x2F;60%60);&#x2F;&#x2F;计算剩余秒let Seconds parseInt(d 1000%60);&#x2F;拼接变量let time&#x3D;Day+”天”+Hours+”小时”+Minutes+”分钟”+Seconds+”秒”；&#x2F;将拼接好的变量显示在页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;日期格式转换器&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css&quot; integrity=&quot;sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z&quot; crossorigin=&quot;anonymous&quot;&gt; &lt;style&gt; body &#123; background-color: #f8f9fa; &#125; .container &#123; max-width: 600px; margin-top: 50px; &#125; .form-group &#123; margin-bottom: 1rem; &#125; .alert &#123; transition: all 0.3s ease-in-out; opacity: 0; &#125; .alert.show &#123; animation: fadeIn 0.5s forwards; &#125; .spinner-border &#123; display: none; &#125; .clock &#123; text-align: center; margin-bottom: 20px; position: relative; &#125; .clock canvas &#123; display: block; margin: 0 auto; &#125; @keyframes fadeIn &#123; from &#123; opacity: 0; transform: translateY(-20px); &#125; to &#123; opacity: 1; transform: translateY(0); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;text-center mb-4&quot;&gt;日期格式转换器&lt;/h1&gt; &lt;p class=&quot;lead text-center&quot;&gt;输入一个日期，选择输出格式，然后点击按钮查看结果。&lt;/p&gt; &lt;div class=&quot;clock&quot; id=&quot;clockContainer&quot;&gt; &lt;canvas id=&quot;clockCanvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;form id=&quot;dateForm&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;inputDate&quot;&gt;选择日期:&lt;/label&gt; &lt;input type=&quot;date&quot; class=&quot;form-control&quot; id=&quot;inputDate&quot; value=&quot;2024-09-22&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;formatSelect&quot;&gt;选择格式:&lt;/label&gt; &lt;select class=&quot;custom-select&quot; id=&quot;formatSelect&quot;&gt; &lt;option value=&quot;iso&quot;&gt;ISO格式 (YYYY-MM-DD)&lt;/option&gt; &lt;option value=&quot;us&quot;&gt;美国格式 (MM/DD/YYYY)&lt;/option&gt; &lt;option value=&quot;eu&quot;&gt;欧洲格式 (DD/MM/YYYY)&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary btn-block mr-2&quot; onclick=&quot;convertDate()&quot;&gt;转换日期&lt;/button&gt; &lt;div class=&quot;spinner-border spinner-border-sm text-primary&quot; role=&quot;status&quot; id=&quot;spinner&quot; style=&quot;display:none;&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Loading...&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;div class=&quot;alert alert-secondary mt-4&quot; role=&quot;alert&quot; id=&quot;result&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; const canvas = document.getElementById(&#x27;clockCanvas&#x27;); const ctx = canvas.getContext(&#x27;2d&#x27;); let currentTimestamp = null; function initializeClock() &#123; currentTimestamp = Date.now(); drawClock(); &#125; function drawClock() &#123; ctx.clearRect(0, 0, canvas.width, canvas.height); // 获取当前时间 const now = new Date(currentTimestamp); const hours = now.getHours(); const minutes = now.getMinutes(); const seconds = now.getSeconds(); // 画圆盘 ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, 80, 0, Math.PI * 2); ctx.strokeStyle = &#x27;#333&#x27;; ctx.lineWidth = 5; ctx.stroke(); // 绘制时标 for (let i = 0; i &lt; 12; i++) &#123; const angle = (Math.PI / 6) * i - Math.PI / 2; const x = 100 * Math.cos(angle) + canvas.width / 2; const y = 100 * Math.sin(angle) + canvas.height / 2; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + 10 * Math.cos(angle), y + 10 * Math.sin(angle)); ctx.strokeStyle = &#x27;#000&#x27;; ctx.lineWidth = 3; ctx.stroke(); &#125; // 绘制秒针 const secondAngle = ((seconds % 60) / 60) * 2 * Math.PI - Math.PI / 2; drawHand(secondAngle, 70, &#x27;red&#x27;, 2); // 绘制分针 const minuteAngle = ((minutes + seconds / 60) / 60) * 2 * Math.PI - Math.PI / 2; drawHand(minuteAngle, 60, &#x27;blue&#x27;, 3); // 绘制时针 const hourAngle = ((hours % 12 + minutes / 60) / 12) * 2 * Math.PI - Math.PI / 2; drawHand(hourAngle, 50, &#x27;black&#x27;, 4); requestAnimationFrame(drawClock); &#125; function drawHand(angle, length, color, lineWidth) &#123; ctx.beginPath(); ctx.lineWidth = lineWidth; ctx.strokeStyle = color; ctx.moveTo(canvas.width / 2, canvas.height / 2); ctx.lineTo( Math.cos(angle) * length + canvas.width / 2, Math.sin(angle) * length + canvas.height / 2 ); ctx.stroke(); &#125; window.onload = () =&gt; &#123; initializeClock(); setInterval(() =&gt; &#123; currentTimestamp += 1000; // 增加1秒 &#125;, 1000); &#125;; function formatDate(date, formatType) &#123; const pad = n =&gt; (&#x27;0&#x27; + n).slice(-2); switch (formatType) &#123; case &#x27;iso&#x27;: return `$&#123;date.getFullYear()&#125;-$&#123;pad(date.getMonth() + 1)&#125;-$&#123;pad(date.getDate())&#125;`; case &#x27;us&#x27;: return `$&#123;pad(date.getMonth() + 1)&#125;/$&#123;pad(date.getDate())&#125;/$&#123;date.getFullYear()&#125;`; case &#x27;eu&#x27;: return `$&#123;pad(date.getDate())&#125;/$&#123;pad(date.getMonth() + 1)&#125;/$&#123;date.getFullYear()&#125;`; default: return &#x27;&#x27;; &#125; &#125; function convertDate() &#123; const inputDate = document.getElementById(&#x27;inputDate&#x27;).value; const formatSelect = document.getElementById(&#x27;formatSelect&#x27;).value; const resultDiv = document.getElementById(&#x27;result&#x27;); const spinner = document.getElementById(&#x27;spinner&#x27;); const date = new Date(inputDate); if (isNaN(date.getTime())) &#123; spinner.style.display = &#x27;none&#x27;; resultDiv.className = &#x27;alert alert-danger show&#x27;; resultDiv.textContent = &#x27;请输入有效的日期！&#x27;; &#125; else &#123; spinner.style.display = &#x27;inline-block&#x27;; setTimeout(() =&gt; &#123; const formattedDate = formatDate(date, formatSelect); spinner.style.display = &#x27;none&#x27;; resultDiv.className = &#x27;alert alert-success show&#x27;; resultDiv.textContent = `转换后的日期是：$&#123;formattedDate&#125;`; &#125;, 500); // 模拟异步请求的时间延迟 &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"简单了解null和undefined","path":"/2024/08/28/简单了解null和undefined/","content":"句简单来说是：undefined代表了不存在的值，null代表了没有值。也就是，比如对一个值声明后，没有赋值，输出他就是undefined,是不存在的，而当赋值为null,那么输出就是null。这两者还有一些区别点要注意： 123456789//1undefined == null//true,这里相等是因为“==”对他们做了转换undefined === null //false//undefined的值是nulL派生来的，所以他们表面上是相等的//2let a;typeof a;//undefinedlet b=null;typeof b;//object 这里为什么typeof b输出为Object呢？null不是一个对象，尽管ypeof age输出的是Object,逻辑上讲，null值表示一个空对象指针，这是一个历史遗留问题，JS的最初版本中使用的是32位系统，为了性能考虑使用低位存储变量的类型信息，000开头代表是对象，null表示为全零，所以将它错误的判断为Object。 12if(!undefined) console.log(&quot;undefined is false&quot;);// undefined is falseif(!null) console.log(&quot;null is false&quot;);// null is false 12345678//对于nu11let nullValue = null;let nullToNumber = Number(nullValue);console.log(nullToNumber);//输出：0//对于undefinedlet undefinedValue;let undefinedToNumber = Number(undefinedValue);console.log(undefinedToNumber);//输出：NaN null可以被转为数字0. undefined不可以转为数字 12Object.getPrototypeof(Object.prototype);// null 项目实践中的区别null表示”没有对象”，即该处不应该有值。典型用法是：(1)作为函数的参数，表示该函数的参数不是对象。(2)作为对象原型链的终点。undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：(1)变量被声明了，但没有赋值时，就等于undefined。(2)调用函数时，应该提供的参数没有提供，该参数等于undefined。(3)对象没有赋值的属性，该属性的值为undefined。.(4)函数没有返回值时，默认返回undefined。","tags":["前端软件开发"]},{"title":"闭包和内存泄漏","path":"/2024/08/28/闭包和内存泄漏/","content":"有权访问另外一个函数作用域中变量的函数。闭包是指那些能够访问自由变量的函数.自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。闭包&#x3D;函数+函数能够访问的自由变量。每一个函数都会拷贝上级作用域，形成一个作用域链条。闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方。闭包的变量存在堆中，即解释了函数调用之后为什么闭包还能引用到函数内的变量。闭包的形成需要两个条件： 闭包是在函数被调用执行的时候才被确认创建的。 闭包的形成，与作用域链的访问顺序有直接关系。 只有内部函数访问了上层作用域链中的变量对象时，才会形成闭包，因此，我们可以利用闭包来访问函数内部的变量。 闭包，本质上是上级作用域内变量的生命周期，因为被下级作用域引用，没有得到释放，需要等到下级作用域执行完后才得到释放。 作用 独立作用域，避免变量污染 实现缓存计算结果 库的封装jQuery 运用防抖节流防抖：事件触发高频到最后一次操作，如果规定时间内再次触发，则重新计时。 1234567891011function debounce(fn,delay=300)&#123; let timer;//闭包引用外界变量 return function () &#123; consr args=arguments; if (timer)&#123; clearTimeout(timer); &#125; timer = setTimeout(()= &#123; fn.apply(this,args); &#125;, delay);&#125;; 模拟块级作用域12345678function OutPutNum(cnt)&#123; (function () &#123; for (let i=0;i&lt;cnt;i++)&#123; alert(i); &#125; &#125;)(); alert(i);&#125; 对象中创建私有变量","tags":["前端软件开发"]},{"title":"内存管理GC","path":"/2024/08/28/内存管理GC/","content":"栈中JS引擎自动清除栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收，而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。JS引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。自动垃圾回收机制：找出不使用的值，释放内存。函数运行结束，没有闭包或引用，局部变量被标记清除全局变量：浏览器卸载页面被清除垃圾回收算法不论哪个垃圾回收算法，都有一套共同的流程：1.标记内存空间中的活动对象（在使用中的对象）和非活动对象（可以回收的对象）。2.删除非活动对象，释放内存空间。3.整理内存空间，避免频繁回收后产生的大量内存碎片（不连续内存空间）。引用计数一个对象是否有被引用（循环引用导致内存泄露）策略：跟踪每个变量被使用的次数1.当声明了一个变量且将一个引用类型赋值给该变量时，这个值的引用次数为12.若同一个值又被赋给另一个值，引用数+13.如果该变量的值被其他的值覆盖了，则引用次数减14.当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为0的值占用的内存缺点：·需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。·解决不了循环引用导致的无法回收问题。标记清除将“不再使用的对象”定义为“无法到达的对象”工作流程：1.垃圾收集器在运行时给内存变量加上标记，假设内存汇总所有对象都是垃圾，全标记为02.从根部出发，寻找可到达的变量，并将其标记清除，改为13.留有标记的变量就是待删除的，即标记为0，销毁并回收它们占用的内存4.把所有内存中对象标记修改为0，等待下一轮垃圾回收优点：实现简单，一位二进制位就可以为其标记缺点：内存碎片化，空闲内存块不连续·分配速度慢，因为即使使用first-fit策略，其操作仍是一个O(n)的操作，最坏情况是每次都要遍历到最后，因为碎片化，大对象的分配速率会更慢复制算法为了解决上述问题，复制算法出现了。1.将整个空间平均分成from和to两部分。2.先在from空间进行内存分配，当空间被占满时，标记活动对象，并将其复制到to空间。3.复制完成后，将from和to空间互换。由于直接将活动对象复制到另一半空间，没有了清除阶段的开销，所以能在较短时间内完成回收操作，并且每次复制的时候，对象都会集中到一起，相当于同时做了整理操作，避免了内存碎片的产生。优点：吞吐量高、没有碎片缺点：首先，复制操作需要时间成本的，若堆空间很大且活动对象很多，则每次清理时间会很久；其次，将空间二等分的操作，让可用的内存空间直接减少了一半。标记整理也叫做标记压缩算法。结合了标记-清除和复制算法的优点。1.从一个GC root集合出发，标记所有活动对象。2.将所有活动对象移到内存的一端，集中到一起。3.直接清理掉边界以外的内存，释放连续空间。该算法既避免了标记-清除法产生内存碎片的问题，又避免了复制算法导致可用内存空间减少的问题。当然，该算法也不是没有缺点的，由于其清除和整理的操作很麻烦，甚至需要对整个堆做多次搜索，故而堆越大，耗时越多。识别内存泄露经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存的占用情况。在Chrome浏览器中，我们可以这样查看内存占用情况1.打开开发者工具，选择Performance面板2.在J顶部勾选Memory3.点击左上角的record按钮4在页面上进行各种操作，模拟用户的使用情况5.一段时间后，点击对话框的stop按钮，面板上就会显示这段时间的内存占用情况造成内存泄露1.意外的全局变量2.被遗忘的定时器和回调函数3.事件监听没有移除4.没有清理的DOM引用5.子元素存在的内存泄漏 V8对GC优化 ·栈中数据回收：执行状态指针ESP在执行栈中移动，移过某执行上下文，就会被销毁；·堆中数据回收：V8引擎采用标记清除算法；·V8把堆分为两个区域一新生代和老生代，分别使用副、主垃圾回收器；·副垃圾回收器负责新生代垃圾回收，小对象(1~8M)会被分配到该区域处理；·新生代采用scavenge算法处理：将新生代空间分为两半，一半空闲，一半存对象，对对象区域做标记，存活对象复制排列到空闲区域，没有内存碎片，完成后，清理对象区域，角色反转；·新生代区域两次垃圾回收还存活的对象晋升至老生代区域；·主垃圾回收器负责老生区垃圾回收，大对象，存活时间长；·新生代区域采用标记-清除算法回收垃圾：从根元素开始，递归，可到达的元素活动元素，否则是垃圾数据；n为了不造成卡顿，标记过程被切分为一个个子标记，交替进行。分代式垃圾回收以上所说的垃圾清理算法每次垃圾回收时都要检查内存中所有的对象，酱紫对一些大，老，存活时间长的对象来说，同新，小，存活时间短的对象一个频率的检查很不好，因为前者需要时间长且不需要频繁进行清理，后者恰恰相反，如何优化？分代式分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率新老生代V8的GC策略基于分代式垃圾回收机制，将堆内存分为新生代和老生代两区域，采用不同的垃圾回收策略进行垃圾回收新生代的对象是存活时间较短的对象，简单来说就是新产生的对象，通常只支持1-8M的容量，而老生代的对象为存活时间较长或常驻内存的对象， 新生代垃圾回收新生代中对象一般存活时间较短，采用scavenge算法处理，在Scavenge算法具体实现中，主要采用一种复制式的方法及Cheney.算法：其将新生代空间对半分为from-space和to-space两个区域。新创建的对象都被存放到from-space,当空间快被写满时触发垃圾回收。先对from-space中的对象进行标记，完成后将标记对象复制到to-space的一端，然后将两个区域角色反转，就完成了回收操作。由于每次执行清理操作都需要复制对象，而复制对象需要时间成本，所以新生代空间会设置得比较小(1~8M)。当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了25%，那么这个对象会被直接晋升到老生代空间中，设置为25%的比例的原因是，当完成Scavenge回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配 老生代垃圾回收老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。什么情况下对象会出现在老生代空间中：。新生代中的对象是否已经经历过一次Scavenge算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。·To空间的对象占比大小超过25%。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象清除阶段老生代垃圾回收器会直接将非活动对象清理掉前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而V8中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间在老生代中，以下情况会先启动标记清除算法：·某一个空间没有分块的时候·空间中被对象超过一定限制·空间不能保证新生代中的对象移动到老生代中由于S是单线程运行的，意味着垃圾回收算法和脚本任务在同一线程内运行，在执行垃圾回收时，后续脚本任务需要等垃圾回收完成后才能继续执行。若堆中的数据量非常大，一次完整垃圾回收的时间会非常长，导致应用的性能和响应能力直线下降。为了避免垃圾回收影响应用的性能，V8将标记的过程拆分成多个子标记，让垃圾回收标记和应用逻辑交替执行，避免脚本任务等待较长时间。"},{"title":"哪些事件支持冒泡","path":"/2024/08/28/哪些事件支持冒泡/","content":"可以通过event.bubbles属性判断该事件是否可以冒泡： 事件 是否冒泡 click 可以 dbclick 可以 keydown 可以 keyup 可以 mousedown 可以 mousemove 可以 mouseout 可以 mouseover 可以 mouseup 可以 scroll 可以 概括来说，鼠标事件，键盘事件，以及点击事件是支持冒泡的。 以下事件不支持冒泡： 事件 是否冒泡 blur 不可以 focus 不可以 resize 不可以 about 不可以 mouseenter 不可以 mouseleave 不可以 load 不可以 unload 不可以 而聚焦和失焦事件，加载事件，ui事件、鼠标移入移出事件是不支持冒泡的。","tags":["前端软件开发"]},{"title":"模块化","path":"/2024/08/28/模块化/","content":"特点1.解决命名污染，全局污染，变量冲突等2.内聚私有，变量不能被外部访问3.更好的分离，按需加载4.引入其他模块可能存在循环引用问题5.代码抽象，封装，复用和管理6.避免通过script标签从上至下加载资源7.大型项目资源难以维护，特别是多人合作的情况 CommonJS服务端解决方案。加载速度快（因为模块文件一般存在本地硬盘）每个文件是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 运行时加载，只能在运行时才能确定一些东西 同步加载，只有加载完成后，才能执行后续操作。因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。 导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。 模块在首次执行后会缓存，再次加载只返回缓存结果，若想再次执行，可清除缓存。 模块加载的顺序就是代码出现的顺序 基本语法 暴露模块：module.exports&#x3D;value或exports.xxx&#x3D;value 引入模块：require(xx),如果是第三方模块，x为模块名；如果是自定义模块，xx为模块文件路径 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports&#x2F;属性（即module.exports)是对外的接口。加载某个模块，其实是加载该模块的module..exports&#x2F;属性。 1234567891011//加载模块var example=require(&#x27;./example.js&#x27;);var config=require(config.js&#x27;);var http=require(&#x27;http&#x27;);//对外暴露模块module.exports.example = function ()&#125;module.exports = function(x)console.log(x)&#125;exports.xxx=value; require命令用于加载模块文件。require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。因为nodejs主要用于服务器编程，模块文件一般已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以使用CommonJS规范。如果是浏览器环境，要从服务器端加载模块，用CommonJS需要等模块下载完并运行后才能使用，将阻塞后面代码的执行，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范，解决异步加载的问题。AMD会编译成require&#x2F;exports来执行浏览器一般使用AMD规范，解决异步加载问题。RequireJS是一个工具库。主要用于客户端的模块管理。它可以让客户端的代码分成一个个模块，实现异步或动态加载，从而提高代码的性能和可维护性。它的模块管理遵守AMD规范。Require.js的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。基本语法定义暴露模块： 12345678//定义没有依赖的模块define(function()&#123; return 模块&#125;)//定义有依赖的模块define([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123;return 模块) 引入使用模块： 12345require([&#x27;module1&#x27;,&#x27;module2&#x27;],function(m1,m2)&#123; 使用m1/m2&#125; 采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数；也可以根据需要动态加载模块 AMD模块定义的方法非常清晰，不会污染全局环境，可清楚地显示依赖关系 CMDCMD规范专门用于浏览器端，异步加载模块，实用模块时才会加载执行。整个了CommonJS和AMD规范的特点。Sea.js中，所有JS模块都遵循CMD模块定义规范。 基本语法 定义暴露模块： 123456789101112131415//定义没有依赖的模块define(function(require,exports,module)&#123; exports.xxx value module.exports value&#125;)//定义有依赖的模块define(function(require,exports,module)&#123;//引入依赖模块（同步）var module2 require(&#x27;./module2&#x27;)//引入依赖模块（异步）require.async(&#x27;./module3&#x27;,function (m3)&#123;&#125;)//暴露模块exports.xxx value&#125; 引入使用模块： 123456define(function (require)&#123;var m1=require(&#x27;./module1&#x27;)var m4=require(&#x27;./module4&#x27;)m1.show()m4.show()&#125;) ES6使用import和export的形式来导入导出模块。这种方案和上面三种方案都不同。思想是尽量静态化，为了保证在编译时就能确定模块的依敕关系和输入输出的变量。异步导入，因为用于浏览器，需要下载文件，如果采用同步导入会对渲染有很大影响采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化会编译成require&#x2F;exports来执行·使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块。一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。在编译阶段，import会提升到整个模块的头部，首光执行。如果不需要知道变量名或函数就完成加载，就要用到export defaulti命令，为模块指定默认输出。·export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，importi命令后面才不用加大括号，因为只可能唯一对应export default命令。基本语法export1.如果不想对外暴露内部变量的真实名称，可以使用s关键字设置别名，同一个属性可以设置多个别名。在外部进行引入时，可以通过name2这个变量访问到king值。 12const name=&#x27;king&#x27;;export &#123;name as name2&#125;; 2.在同一个文件中，同一个变量名只能够xport一次，否则会抛出异常。 1234const name=&#x27;king&#x27;;const _name=&#x27;king&#x27;;export &#123;name as _name&#125;;export&#123;name&#125;;/抛出异常，name作为对外输出的变量，只能export一次 import1.import和export的变量名相同2.相同变量名的值只能import-一次3.import命令具有提升的效果 12345//export.jsexport const name=&#x27;king&#x27;;//import.jsconsole.log(name);//kingimport &#123;name&#125;from &#x27;./export.js&#x27; 本质：因为import是在编译期间运行的，在执行console语句之前就已经执行了importi语句。因此能够打印出name的值，即，King4.多次import时，只会加载一次以下代码汇总，我们import了两次export.js文件，但是最终只输出执行了一次“开始执行”，可以推断出import导入的模块是个单例模式。 1234567//export.jsconsole.log(&#x27;start&#x27;);export const name=&#x27;king&#x27;;export const age=19;//import.jsimport &#123;name&#125;from &#x27;./export.jsimport &#123;age&#125;from &#x27;./export.js&#x27;&#x27; 5.允许我们在需要的时候才动态加载模块，而不是一开始就加载所有模块，这样可以帮我们提高性能。这个新功能允许我们将import()作为函数调用，将其作为参数传递给模块的路径。它返回一个promise,它用一个模块对象来实现，可以访问该对象的导出。 1234import(&#x27;/modules/myModule.mjs&#x27;)then((module)=&gt;/Do something with the module.&#125;)； 对比总结ES6输出值的引用（对外接口只是一种静态定义，代码解读阶段生成），CommonJS模块输出值的拷贝（加载一个对象，及module.exports.属性，该对象只有在脚本运行时才会生成)ES6模块时动态引用，且不会缓存值，模块中的变量绑定其所在的模块ES6模块编译时输出接口，CommonJS模块运行时加载1.CommonJS规范主要用于服务端编程，同步加载模块，不适合浏览器环境，因为同步意味阻塞，而浏览器资源时异步加载的，因此诞生了AMD和CMD2.AMD规范在浏览器环境中异步加载模块，且可以并行加载多个模块。但是开发成本高，代码阅读困难，模块定义语义不顺畅3.CMD和AMD相似，依赖就近，延迟执行，易在nod©js运行。但是，依赖SPM打包，模块加载逻辑偏重4.ES6实现模块功能且实现简单，完全可以取代CommonJS和AMD规范，进而成为浏览器和服务器通用模块解决方案的笼儿。","tags":["前端软件开发"]},{"title":"事件流","path":"/2024/08/28/事件流/","content":"事件流描述从页面接收事件的顺序事件发生时会在元素节点和根节点之间按照特定的顺序传播，路径所经过的节点都会收到该事件一DOM事件流。两种事件流模型：1捕获：触发元素的事件时，该事件从该元素的祖先元素传递下去（不太具体的节点应该更早接收到事件，而最具体的节点最后收到事件)2.冒泡：到达此元素之后，又会向其祖先元素传播上去DOM标准规定事件流包括3个阶段：事件捕获、处于目标阶段和事件冒泡 事件捕获：实现目标在捕获阶段不会接收事件 处于目标阶：事件在上发生并处理。但是事件处理会被看成是冒泡阶段的一部分 冒泡阶段：事件又传播回文档 所有事件都要经过捕获阶段和处于目标阶段，但有些事件没有冒泡阶段。如focus(获得输入焦点)和失去输入焦点的blur事件。无法进行委托事件模型原始事件模型var btn &#x3D; document.getElementByld(.btn’);btn.onclick &#x3D; fun; 绑定速度快可能页面还未完全加载出来，事件可能无法正常运行 只支持冒泡，不支持捕获 同一个类型的事件只能绑定一次 var btn &#x3D; document.getElementById(.btn’);btn.onclick &#x3D; fun2;&#x2F;&#x2F;出错后绑定的事件会覆盖掉之前的事件删除DOM0级事件处理程序只要将对应事件属性置为ul即可btn.onclick &#x3D; null; 标准事件模型·事件捕获：从document-一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行·事件处理：到达目标元素，触发目标元素的监听函数·事件冒泡：从目标元素冒泡到document,依次检查经过的节点是否绑定了事件监听函数，如果有则执行事件绑定监听函数的方式如下：addEventListener(eventType,handler,useCapture)事件移除监听函数的方式如下：removeEventListener(eventType,handler,useCapture)·eventType:指定事件类型（不要加on)·handler是事件处理函数·useCapture是boolean类型用于指定是否在捕获阶段进行处理，一般设置为false.与IE浏览器保持一致举个例子：var btn &#x3D; document.getElementByld(.btn’);btn.addEventListener(‘click’,showMessage,false);btn.removeEventListener(‘click’,showMessage,false);特性可以在一个DOM元素上绑定多个事件处理器，不会冲突btn.addEventListener(‘click’,showMessagel,false);btn.addEventListener(‘click’,showMessage2,false);btn.addEventListener(‘click’,showMessage3,false);第三个参数(useCapture)设置为true就在捕获过程中执行，反之在冒泡过程中执行E事件模型·事件处理：事件到达目标元素，触发目标元素的监听函数。·事件冒泡：事件从目标元素冒泡到document·事件绑定监听函数的方式attachEvent(eventType,handler)·事件移除监听函数的方式detachEvent(eventType,handler)举个例子：var btn &#x3D; document.getElementByld(.btn’);btn.attachEvent(‘onclick’,showMessage);btn.detachEvent(‘onclick’,show Message);"},{"title":"改变this指向的方法","path":"/2024/08/28/改变this指向的方法/","content":"(bind&#x2F;call&#x2F;apply)三者都是用来重新定义this这个对象的一、三者的区别：1、调用上 123456789101112131415let name =&quot;www&quot;,age =&quot;17&quot;;let obj = &#123; name:&quot;aaa&quot;; objAge:this.age; myFun:function ()&#123; console.log(this.name+&quot;年龄&quot;+this.age)\t&#125;&#125;let db = &#123; name:&quot;bbb&quot;; age:12&#125;obj.myFun.call(db)//bbb年龄99obj.myFun.apply(db);//bbb年龄99obj.myFun.bind(db)();//bbb年龄99 首先我们可以看出，除了bind需要在方法后面添加”)”以外，其他的都是直接调用。这是因为bind()方法创建了一个新的函数，你必须调用显函数才会执行目标函数，而对于call和apply是使用后马上执行。1、参数上 12345678910111213141516let name =&quot;www&quot;,age =&quot;17&quot;;let obj = &#123; name &quot;aaa&quot;, objAge this.age, myFun:function(fm,t)&#123; console.log(this.name+&quot;年龄&quot;+this.age,&quot;来自&quot;+fm+&quot;去往&quot;+t) &#125;&#125;let db=&#123; name:&quot;bbb&quot;, age:12&#125;obj.myFun.call(db,&#x27;成都&#x27;，&#x27;上海&#x27;);//bbb年龄99来自成都去往上海obj.myFun.apply(db,[&#x27;成都&#x27;，&#x27;上海&#x27;]);//bbb年龄99来自成都去往上海obj.myFun.bind(db,&#x27;成都&#x27;，&#x27;上海&#x27;)();//bbb年龄99来自成都去往上海obj.myFun.bind(db,[&#x27;成都&#x27;，&#x27;上海&#x27;])();//bbb年龄99来自成都，上海去往undefined 可以看出，三个函数的第一个参数都是hs的指向对象，区别在于第二个参数。 对于Function.prototype.calL来说，第一个参数就是this的指向对象，其余参数是直接放进去，用逗号隔开就好了。 对于Function.prototype.apply来说，Function.apply(obj,args)方法能接收两个参数，obj:是this的指向对象。而args:这个是数组，它将作为参数传递，也就是说apply的所有参数都必须放在一个数组里面传进去 对于Function.prototype.bind来说，第一个参数就是this的指向对象，其余参数是直接放进去，用逗号隔开就好了。也就是说他和cl1是基本相同的，除了是返回是一个函数。 注意对于bind来说，多次的bind调用，this的指向仍然是第一次的function aa(){console.log(this)aa.bind(1).bind(2)()&#x2F;&#x2F;1 一、bind &#x2F; call &#x2F; apply的异同相同：都能改变this的指向，都是挂载在Function.prototype上不同：call和apply是使用后马上执行，而bind是返回一个新的函数，调用显函数才会执行目标函数。并且call和bind的参数格式是一样的，第一个参数是this的指向对象，其余参数用逗号，apply是参数需要放到数组中。 总结 关于修改this的指向的方法有三个，bind和call以及apply,他们的相同点都是能修改this的指向的问题的，并且都是挂载在Function.prototype上的。 不同点在于参数和执行上，call和bind的参数格式是一样的，第一个参数是this的指向对象，其余参数用逗号，而apply的参数需要放到数组中。在执行中，call和apply是使用后马上执行，而bind是返回一个新的函数，调用显函数才会执行目标函数。 其中需要注意的是，箭头函数的his是指向他所在的上下文中，并且是不能使用这三个方法修改的。","tags":["前端软件开发"]},{"title":"继承方式","path":"/2024/08/28/继承方式/","content":"构造函数会在每一个实例上都创建一遍！使用原型模式定义的属性和方法由所有实例共享！原型链 12345678910function Parent()&#123; this.name = &#x27;kevin&#x27;;&#125;Parent.prototype.getName=function() &#123; console.log(this.name);&#125;function Child() &#123;&#125;Child.prototype = new Parent(); //表明继承关系，还没有创建child1对象var child1 = new Child();// 创建child1对象console.log(child1.getName())//kevin 缺点1.引用类型的属性被所有实例共享2.创建Child实例时，不能向Parent传参借用构造函数（经典继承） 1234567891011function Parent()&#123; this.names=[&#x27;kevin&#x27;,&#x27;daisy&#x27;];&#125;function Child()&#123; Parent.call(this);&#125;var child1 = new Child();child1.names.push(&#x27;yayu&#x27;);console.log(child1.names);//[&quot;kevin&quot;,&quot;daisy&quot;,&quot;yayu&quot;]var child2 = new Child();console.log(child2.names);//[&quot;kevin&quot;,&quot;daisy&quot;] 1.避免了引用类型的属性被所有实例共享2.可以在Child中向Parent传参缺点方法都在构造函数中定义，每次创建实例都会创建一遍方法组合继承原型链继承+经典继承双创合璧 12345678910111213141516171819202122function Parent(name)&#123; this.name=name; this.colors=[&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;]; Parent.prototype.getName = function () &#123; console.log(this.name) &#125;&#125;function Child(name,age)&#123; Parent.call(this,name); this.age=age;&#125;Child.prototype = new Parent();//表明继承关系Child.prototype.constructor = Child;//修正了构造函数的指向。var child1 = new Child(&#x27;kevin&#x27;,&#x27;18&#x27;);child1.colors.push(&#x27;black&#x27;);console.log(child1.name);//kevinconsole.log(child1.age);//18console.log(child1.colors);//[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;black&quot;]var child2 = new Child(&#x27;daisy&#x27;,&#x27;20&#x27;);console.log(child2.name);//daisyconsole.log(child2.age);//20console.log(child2.colors);//[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;] 融合原型链继承和构造函数的优点，JS最常用继承模式原型式继承 12345function createobj(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125; 一个使用这种方法实现继承的例子 123456789101112131415161718192021// 定义一个父类对象let parentObj = &#123; name: &#x27;Parent&#x27;, sayHello: function () &#123; console.log(`Hello from $&#123;this.name&#125;`); &#125;&#125;;// 使用 createobj 函数实现继承function createobj(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;// 创建一个继承自 parentObj 的子类对象let childObj = createobj(parentObj);childObj.name = &#x27;Child&#x27;;// 调用继承自父类的方法childObj.sayHello(); ES5 Object.create的模拟实现，将传入对象作为创建的对象的原型包含引用类型的属性值都会共享相应的值一—和原型链继承一样 123456789101112131415function createobj(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name:&#x27;kevin&#x27;, friends:[&#x27;daisy&#x27;,&#x27;kelly&#x27;]&#125;var person1 = createobj(person);var person2 = createobj(person);person1.name = &#x27;person1&#x27;;console.log(person2.name);//kevinperson1.friends.push(&#x27;taylor&#x27;);console.log(person2.friends);//[&quot;daisy&quot;,&quot;kelly&quot;,&quot;taylor&quot;] 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式做增强对象，再返回对象 123456function createobj(o)&#123; var clone = Object.create(o); clone.sayName = function () console.log(&#x27;hi&#x27;); return clone;&#125; 缺点和借用构造函数一样，每次创建对象都会创建一遍方法寄生组合式继承组合继承最大缺点一调用2次父构造方法1.设置子实例的原型时2.创建子类型的实例时如何避免重复调用？如果我f们不使用Child.prototy pe&#x3D;new Parent(),而是间接让Child.prototype访问Parent..prototypel呢？ 123456789101112131415161718192021222324252627function Parent(name)&#123; this.name=name; this.colors=[&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;]; Parent.prototype.getName function () console.log(this.name)&#125;function Child(name,age)&#123;Parent.call(this,name);this.age age;//关键的三步var F = function (&#123;&#125;F.prototype = Parent.prototype;Child.prototype = new F();var child1 = new Child(&#x27;kevin&#x27;,&#x27;18&#x27;);console.log(child1);封装一下这个继承方法function object(o)function F()&#123;&#125;F.prototype o;return new F();function prototype(child,parent)&#123; var prototype = object(parent.prototype);//创建父类原型对象的副本 prototype.constructor = child;//增强对象，补充因重写原型而失去的默认的constructor/属性 child.prototype = prototype;//将创建的新副本指定给子类的原型对象&#125;//当我们使用的时候：prototype(Child,Parent); 优点一引用类型最理想的继承方式只调用一次Parent构造函数，避免了在Parent.prototype.上面创建不必要的、多余的属性同时，原型链能保持不变，能正常使用instanceof和isPrototypeOf ————————————-分割线———————————– 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 定义构造函数*（普通函数加个this）function Animal(name) &#123; this.name = name;&#125;// 定义构造函数的原型方法, 在构造函数的prototype上注册了speak方法Animal.prototype.speak = function() &#123; console.log(this.name + &#x27; makes a noise.&#x27;);&#125;;// 定义另一个构造函数function Dog(name) &#123; Animal.call(this, name); // 继承 Animal 的属性&#125;// Dog 继承 Animal 的方法，先声明prototype, 再指定prototype.constructorDog.prototype = Object.create(Animal.prototype);Dog.prototype.constructor = Dog;Dog.prototype.speak = function() &#123; console.log(this.name + &#x27; barks.&#x27;);&#125;;// 创建实例const myDog = new Dog(&#x27;Rex&#x27;);// 使用 instanceof 检查console.log(myDog instanceof Dog); // trueconsole.log(myDog instanceof Animal); // trueconsole.log(myDog instanceof Object); // true// 逐步调试：自定义 instanceof 实现, 用Object.getPrototypeOf循环遍历left的prototype, 查看是否和right的prototype相等function myInstanceof(left, right) &#123; console.log(`Checking if $&#123;left&#125; is an instance of $&#123;right.name&#125;`); // 如果左边是 null 或 undefined，直接返回 false if (left === null || typeof right !== &#x27;function&#x27;) &#123; return false; &#125; // 获取左边对象的原型 let proto = Object.getPrototypeOf(left); const prototype = right.prototype; // 沿着原型链查找 while (proto !== null) &#123; if (proto === prototype) &#123; return true; &#125; proto = Object.getPrototypeOf(proto); &#125; return false;&#125;// 调试 myInstanceof 函数console.log(myInstanceof(myDog, Dog)); // trueconsole.log(myInstanceof(myDog, Animal)); // trueconsole.log(myInstanceof(myDog, Object)); // trueconsole.log(myInstanceof(myDog, Array)); // false 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个构造函数 Personfunction Person(name, age) &#123; this.name = name; this.age = age;&#125;// 向构造函数的 prototype 添加一个方法Person.prototype.sayHello = function() &#123; console.log(&#x27;Hello, my name is &#x27; + this.name);&#125;;// 创建一个实例对象var person1 = new Person(&#x27;Alice&#x27;, 25);var person2 = new Person(&#x27;Bob&#x27;, 30);// 查看实例对象的属性和原型链console.log(&#x27;person1 的 name:&#x27;, person1.name); // 输出: Aliceconsole.log(&#x27;person1 的 age:&#x27;, person1.age); // 输出: 25// 调用 prototype 上的方法person1.sayHello(); // 输出: Hello, my name is Aliceperson2.sayHello(); // 输出: Hello, my name is Bob// 查看实例的 __proto__，它指向构造函数的 prototype, new 的对象具有__proto__属性，instance.__proto__和class的prototype相等console.log(&#x27;person1.__proto__ === Person.prototype:&#x27;, person1.__proto__ === Person.prototype); // true// 查看构造函数的 prototypeconsole.log(&#x27;Person.prototype:&#x27;, Person.prototype); // 输出: &#123; sayHello: f &#125;// 查看实例 person1 的 __proto__console.log(&#x27;person1.__proto__:&#x27;, person1.__proto__); // 输出: &#123; sayHello: f &#125;// 验证 person1 是否是 Person 的实例console.log(&#x27;person1 instanceof Person:&#x27;, person1 instanceof Person); // 输出: true// 查看 Object.prototype，所有对象最终的原型console.log(&#x27;Person.prototype.__proto__ === Object.prototype:&#x27;, Person.prototype.__proto__ === Object.prototype); // true// 创建一个普通的对象，不通过构造函数var obj = &#123; greeting: &#x27;Hi&#x27; &#125;;console.log(&#x27;obj.__proto__ === Object.prototype:&#x27;, obj.__proto__ === Object.prototype); // trueconsole.log(&#x27;obj 是 Object 的实例:&#x27;, obj instanceof Object); // true","tags":["前端软件开发"]},{"title":"构造函数","path":"/2024/08/28/构造函数/","content":"构造函数在JavaScript中，通过new来实例化对象的函数叫构造函数，也就是初始化一个实例对象，对象的prototype属性是继承一个实例对象。构造函数的命名一般会首字母大写 为什么需要使用构造函数？是为了创建对象JavaScript中创建对象有两种，一种是构建函数+prototype,另一种是用class。.这里我们不去讲解class,先放到构造函数上。 12345//当我们需要创建比较多信息时var person1=&#123;name:&#x27;aa&#x27;,age:6,gender:&#x27;男&#x27;，classRoom:&#x27;高-&#x27;&#125;：var person2=&#123;name:&#x27;bb&#x27;,age:6,gender:&#x27;女&#x27;，classRoom:&#x27;高-&#x27;&#125;；var person3=&#123;name:&#x27;cc&#x27;,age:6,gender:&#x27;女&#x27;，classRoom:&#x27;高-&#x27;&#125;；var person4=&#123;name:&#x27;dd&#x27;,age:6,gender:&#x27;男&#x27;，classRoom:&#x27;高-&#x27;&#125;； 那么如果需要创建很多呢？需要这样一个一个的写下去吗？但是实际上可以通过下面的形式来实现 1234567891011function Person(name,age,gender,classRoom)&#123; this.name name; this.ageage; this.gender gender; this.classRoom=&#x27;高一&#x27;&#125;Person.prototype.sayHi function () console.log(&quot;你好，我叫&quot;+this.name+&quot;是一个&quot;+this.sex+&quot;来自&quot;+classRoom);&#125;;let person1=new Person(&quot;a&quot;,l8,&#x27;男&#x27;)；//我们还可以不传classRoom,让他使用默认的let person2=new Person(&quot;b&quot;,l9,&#x27;女&#x27;)； 构造函数的执行过程构造函数的执行过程其实也就是new操作符的基本过程 创建一个新的对象，并且在内存中创建一个新的地址。&#x2F;&#x2F;let person1&#x3D;0: 继承原型&#x2F;&#x2F;person1.proto&#x3D;Person.prototype 改变构造函数的this指向，并且新对象添加构造函数的属性和方法&#x2F;执行Person函数，将name,age,sex参数传入Person中执行，此时函数内部this为new创建的person1对象，所以person1.name&#x3D;’a’;person1.age&#x3D;l8;person1.gender&#x3D;-‘男’； 根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理new操作符通过构造函数创建的实例，可以访问构造函数的属性和方法，同时实例与构造函数通过原型链连接起来了。 构造函数的返回值构造函数中，不要显示返回任何值 1234567891011121314151617//返回原始值function Person(name)&#123; this.namename; return&#x27;啦啦啦啦&#x27;&#125;let person1 = new Person(&quot;a&quot;);console.log(person1.name)//a//返回对象function Person(name)&#123; this.name name; return &#123; aaa:&quot;asdas&quot; &#125;&#125;let person1 = new Person(&quot;a&quot;);console.log(person1)//faaa &quot;asdas&quot;&#125;console.log(person1.name)//&#x27;undefined&#x27; 可以看到当返回原始值的时候，并不会正常返回这个原始值“啦啦啦啦”，而当返回直是对象的时候，这个返回值能被正常返回，但是这时候new就不生效了。所以，构造函数尽量不要返回值。因为返回原始值不会生效，返回对象会导致new操作符没有作用。 那么为什么会这样呢? 构造函数没有返回值的原因是因为它不是由你的代码直接调用的，它是由运行时的内存分配和对象初始化代码调用的。它的返回值（如果它在编译为机器代码时实际上有一个）对用户来说是不透明的一因此，你不能指定它。其实在JavaScript中， let a&#x3D;0也就是let a&#x3D;new Array[]; function a(){}也就是let a&#x3D;new Function(){}","tags":["前端软件开发"]},{"title":"箭头函数和普通函数的区别","path":"/2024/08/28/箭头函数和普通函数的区别/","content":"箭头函数的this为定义时所在的this,不绑定this(因为箭头函数没有Constructor),会捕获其所在上下文的this作为自己的this 若包裹在函数中，就是函数调用时所在的对象，放在全局就是window,箭头函数的this就是外层代码块的this,固定不变。 没有自己的this 继承来的this不会变 没有arguments,实际获得的arguments是外层函数的arguments call apply和bind无法改变this指向 不可用于构造函数，没有new关键字 无prototype 不能用于generator函数，没有yield关键字 定义对象的大括号不是一个单独的执行环境，它依旧处于全局环境中","tags":["前端软件开发"]},{"title":"函数","path":"/2024/08/28/函数/","content":"函数声明使用function的函数声明比函数表达式优先提升变量对象的创建过程中，函数声明比变量声明有更为优先的执行顺序无论在什么位置声明了函数，都可以在同一个执行上下文中直接使用 函数表达式也叫匿名函数函数表达式使用var&#x2F;let&#x2F;const声明，我们在确认他是否可以正确使用时，必须依照var&#x2F;let&#x2F;const的规则判断，即变量声明使用var进行变量声明，进行了两步操作 函数声明和函数表达式主要有以下区别： 一、语法形式 函数声明： 使用 function 关键字，后跟函数名，再加上括号和花括号包裹的函数体。 例如：123function add(a, b) &#123; return a + b;&#125; 函数表达式： 将一个匿名函数赋值给一个变量。 例如：123const subtract = function(a, b) &#123; return a - b;&#125;; 二、提升（Hoisting）特性 函数声明会在代码执行前被提升到其所在作用域的顶部，这意味着可以在函数声明之前调用该函数。而函数表达式只有在其所在的语句被执行到的时候才会被创建，不能在其定义之前被调用。 例如： 12345console.log(add(2, 3)); // 输出 5，函数声明可以在声明之前调用console.log(subtract(5, 2)); // 报错，因为函数表达式在定义之前不能调用const subtract = function(a, b) &#123; return a - b;&#125;; 三、命名方式 函数声明必须有一个名称，而函数表达式可以是匿名的（没有名称），也可以是具名的（有名称），但这个名称只在函数内部可见。 例如： 12345678function multiply(a, b) &#123; return a * b;&#125;const divide = function namedDivide(a, b) &#123; return a / b;&#125;;console.log(multiply(4, 2)); // 输出 8console.log(divide(8, 2)); // 输出 4，在函数内部可以使用 namedDivide 这个名称进行递归等操作，但在外部只能通过 divide 来调用 12345//变量声明var a = 20;//实际执行顺序var a = undefined;//变量声明，初始值undefined,变量提升，提升l顺序次于function声明a = 20;//变量赋值，该操作不会提升 同样道理，当我们使用变量声明的方式声明函数时一函数表达式。函数表达的提升方式与变量声明一致 1234567891011fn();//报错var fn=function ()&#123; console.log(&#x27;function&#x27;);&#125;//上述例子执行顺序为var fn=undefined;//变量声明提升fn();//执行报错fn = function () &#123; //赋值操作，此时将后边函数的引用赋值给f console.log(&#x27;function&#x27;)&#125; 因此，由于声明方式的不同，导致函数声明与函数表达式在使用上的一些差异需要注意，除此之外，这两种形式的函致在使用上并无不同 匿名函数没有被显示进行赋值操作的函数。使用场景一多作为一个参数传入另一个函数中函数自执行，其实是匿名函数的一种应用 在 JavaScript 中，匿名函数是没有名称的函数表达式。以下是定义和使用匿名函数的方法： 一、定义匿名函数 作为变量的值123const myFunction = function() &#123; console.log(&#x27;这是一个匿名函数作为变量的值。&#x27;);&#125;; 作为立即执行函数表达式（IIFE）123(function() &#123; console.log(&#x27;这是一个立即执行的匿名函数。&#x27;);&#125;)(); 二、使用匿名函数 作为回调函数12345678function doSomething(callback) &#123; console.log(&#x27;正在执行一些操作...&#x27;); callback();&#125;doSomething(function() &#123; console.log(&#x27;这是作为回调函数的匿名函数。&#x27;);&#125;); 在数组方法中使用1234const numbers = [1, 2, 3, 4, 5];numbers.forEach(function(number) &#123; console.log(number);&#125;); 回调函数匿名函数传入另一个函数之后，最终在另一个函数中执行，因此我们也常常称这个匿名函数为回调函数 高阶函数一个函数接收另一个函数作为参数或返回另一个函数1.map2.reduce参数：两个参数，一个为回调函数，另一个初始值。回调函数中四个默认参数，依次为积累值、当前值、当前索引和整个数组1.filter返回新数组2.sort 以下是使用这些高阶函数的 JavaScript 示例： 1234567891011121314151617const numbers = [1, 2, 3, 4, 5];// 使用 mapconst mappedNumbers = numbers.map((num) =&gt; num * 2);console.log(mappedNumbers); // [2, 4, 6, 8, 10]// 使用 reduceconst sum = numbers.reduce((accumulator, currentValue) =&gt; accumulator + currentValue, 0);console.log(sum); // 15// 使用 filterconst filteredNumbers = numbers.filter((num) =&gt; num % 2 === 0);console.log(filteredNumbers); // [2, 4]// 使用 sortconst sortedNumbers = numbers.sort((a, b) =&gt; a - b);console.log(sortedNumbers); // [1, 2, 3, 4, 5] 在这个例子中，首先定义了一个数组numbers。然后分别使用map对数组中的每个元素进行乘以 2 的操作，使用reduce计算数组元素的总和，使用filter筛选出偶数元素，使用sort对数组进行升序排序。 普通函数若是’use strict’,不能将全局对象window作为默认绑定。this&#x3D;undefined普通函数：定义时this指向函数作用域，但定时器之后执行函数时，this指向window普通函数的this一调用时所在的对象函数声明、函数表达式1.函数声明式：function functionName()}2.函数表达式：let name&#x3D;function()0 以下是关于普通函数以及严格模式下相关行为的 JavaScript 代码示例： 1234567891011121314151617181920212223242526272829303132333435// 非严格模式下的函数声明function declaredFunction() &#123; console.log(this);&#125;declaredFunction();// 非严格模式下的函数表达式let expressionFunction = function() &#123; console.log(this);&#125;;expressionFunction();// 定时器中的非严格模式函数setTimeout(function() &#123; console.log(this);&#125;, 1000);// 严格模式下的函数声明(function strictDeclaredFunction() &#123; &#x27;use strict&#x27;; console.log(this);&#125;)();// 严格模式下的函数表达式let strictExpressionFunction = function() &#123; &#x27;use strict&#x27;; console.log(this);&#125;;strictExpressionFunction();// 定时器中的严格模式函数setTimeout(function() &#123; &#x27;use strict&#x27;; console.log(this);&#125;, 2000); 在这个例子中，可以观察到非严格模式下普通函数在不同场景下的 this 指向，以及严格模式对 this 指向的影响。","tags":["前端软件开发"]},{"title":"类型转换","path":"/2024/08/28/类型转换/","content":"类型 6种基本类型null undefined number stringify boolean symbol1种引用类型object 对象转换为基本类型 对象转换为字符串 1234567891011//模拟toString返回的不是基本类型值，value0f返回的基本类型值var obj = &#123; tostring:function () return &#123;&#125; &#125;, valueof:function ()&#123; return null &#125;&#125;String(obj)//&quot;null&quot; 对象转为数字 先判断valueOf方法, 再判断toString方法 12345678910//value0f和toString返回的都不是基本类型值var obj = &#123;valueof:function ()&#123; return &#123;&#125;&#125;toString:function ()&#123; return &#123;&#125;&#125;&#125;Number(obj)//Uncaught TypeError:Cannot convert object to primitive value Object.create(null)创建的对象没有valueOf和toString方法，因此转换报错一般情况，我们不会重写valueOf和toString,大部分对象valueOfi返回的仍然是对象，因此对象转换为基本类型值可以直接看toString返回的值 显式强制类型转换 转换为字符串如果对象有自定义toString方法，则返回toString.方法的结果，若是toString返回的结果不是基本类型值，报错TypeError 12345678var obj = &#123; toString: function() &#123; return &#123;&#125; &#125;&#125;String(obj)//Uncaught TypeError:Cannot convert object to primitive valueobj +&quot;&quot;//Uncaught TypeError:Cannot convert object to primitive valueobj.toString()//&#123;&#125; -转换为boolean类型null undefined false +0 -0 NaN “”其他情况都是真值 转换为数字类型 12345Number(&#x27;&#x27;)//0Number(null)//0Number(undefined)//NaNNumber(true)//1Number(false)//0 对象首先被转换为相应基本类型值，再转换 12Number([])//0// [] value0f返回的是[]，因此继续调用toString得到基本类型值&quot;&quot;，转换为数字为0 隐式强制类型转换 转换为字符串 123456789var obj = &#123; valueof:function () return 1 &#125;, toString:function () return 2 &#125;&#125;obj+&#x27;&#x27;//&#x27;1&#x27; 123console.log(&quot;123&quot; == 123)console.log(true == 1)console.log(false == 0) x+”,会将x转换为字符串，+运算符其中一个操作数是字符串，会执行字符串拼接操作对象和字符串拼接时，对象转为基本类型按转为数字转换，先判断valueOf,再判断toString 转换为布尔值 发生布尔值隐式强制类型转换的情况1.if()语句中的条件判断表达式2.for(…;…;…)语句中的条件判断表达式（第二个）3.while()和do..while(..)循环中的条件判断表达式4.？:中的条件判断表达式5.逻辑运算符||(逻辑或)和&amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式） 转换为数字类型 12345678910+&#x27;2&#x27;//2&#x27;2&#x27;-0//2&#x27;2&#x27;/1//2&#x27;2&#x27;*1//2+&#x27;x&#x27;//NaN&#x27;x&#x27;-0//NaN&#x27;x&#x27;/1//NaN&#x27;x&#x27;*1//NaN1+&#x27;2&#x27;//121++&#x27;2&#x27;//3即：1+(+2&#x27;) 优先将数字转为字符串进行拼接 12console.log(3 + &#x27;4&#x27;); // 输出 &quot;34&quot;console.log(&#x27;3&#x27; + 4); //输出 &quot;34&quot; 1234567891011const obj = &#123; valueOf() &#123; return 42; &#125;, toString() &#123; return &quot;I am an object&quot;; &#125;&#125;console.log(obj + 1);console.log(&quot;Hello, &quot; + obj); 1234567891011const obj = &#123; valueOf() &#123; return &#123;&#125;; &#125;, toString() &#123; return &quot;I am an object&quot;; &#125;&#125;console.log(obj + 1);console.log(&quot;Hello, &quot; + obj); 当一个操作数是布尔值时，布尔值会被先转换为数字（true被转换为1, false被转换为0）,然后按照前面的规则执行加法运算。 12console.log(true + 3); // 4console.log(false + &#x27;3&#x27;);// &quot;false3&quot; 当一个操作数是null或undefined时，null和undefined分别被转换为数字0和NaN,然后按照前面的规则执行加法运算。 1234console.log(null+2); //2console.log(undefined+2); //NaNconsole.log(&#x27;Hello, &#x27;+ null); //Hello, nullconsole.log(&#x27;Hello, &#x27;+ undefined);//Hello, undefined 12345678910111213//减法运算符的规则console.log(5 - &quot;2&quot;);//3console.log(&quot;5&quot; - 2);//3console.log(true - 3);//-2console.log(null - 2);//-2console.log(undefined - 2);//NaN//乘法运算符的规则console.log(5 * &quot;2&quot;);//10console.log(&quot;5&quot; * 2);//10console.log(true * 3);//3console.log(null * 2);//0console.log(undefined * 2);//NaN 12345console.log(10 / &quot;2&quot;); // 输出5 (&#x27;2&#x27;被转换为数字2)console.log(&quot;10&quot; / 2); // 输出5 (&#x27;10&#x27;被转换为数字10)console.log(true / 2); // 输出0.5 (true被转换为数字1)console.log(null / 2); // 输出0 (null被转换为数字0)console.log(undefined / 2); // 输出NaN (undefined被转换为数字NaN) if语句后的隐式类型转换以下类型会被转换为false, 其他类型会被转换为true false 0 NaN null undefined 空字符串(“”) 12345678910111213141516171819let emptyString = &quot;&quot;;if (emptyString) &#123; console.log(&quot;不执行代码块&quot;);&#125; // 空字符串转换为false，因此不执行代码块let nonEmptyString = &quot;Hello&quot;;if (nonEmptyString) &#123; console.log(&quot;执行代码块&quot;);&#125; // 非空字符串转换为true，因此执行代码块let nullValue = null;if (nullValue) &#123; console.log(&quot;不执行代码块&quot;);&#125; // null转换为false，因此不执行代码块let objectValue = &#123;&#125;;if (objectValue) &#123; console.log(&quot;执行代码块&quot;);&#125; // 对象转换为true，因此执行代码块 123456console.log([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt))//[// 1,// NaN,// NaN//] &#x3D;&#x3D;和&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;允许在相等比较中进行强制类型转换，而&#x3D;&#x3D;&#x3D;不允许比较规则1、字符串和数字比较，字符串先转换为数字，再比较2、其他类型和布尔类型比较，布尔类型转换为数字，再比较3、对象和非对象比较，对象转换成基本类型值，按转换为数字的流程转换后进行比较。对象转换优先级最高 12345678910let myObject = &#123; valueOf() &#123; return 1; &#125;, toString() &#123; return &quot;2&quot; &#125;&#125;console.log(myObject == &quot;2&quot;);// falseconsole.log(myObject == 1);// true 如果一个操作数是对象，另一个操作数是字符串或者数字，会首先调用对象的valueOf方法, 将对象转化为基本类型，再进行比较。 当valueOf()返回的不是基本类型的时候，才会调用toString()方法。 12345678910let myObject = &#123; valueOf() &#123; return &#123;&#125;; &#125;, toString() &#123; return &quot;2&quot; &#125;&#125;console.log(myObject == &quot;2&quot;);// trueconsole.log(myObject == 1);// false 123456789101112let a = &#123; value: 1, valueOf() &#123; return this.value++; &#125;, toString() &#123; return this.value++; &#125;&#125;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log(&quot;条件语句返回值为true&quot;);&#125; 4、null和undefined,nul&#x3D;&#x3D;undefined,其他类型和null均不相等，undefined也是如此5、特殊情况 12NaN =NaN /false-0==+0//true 两个对象比较，判断的是两个对象是否是同一个引用 12345678910&quot;0&quot;==false //true//第2条规则，false转换为数字，结果为0，等式变为&quot;0&quot;=0//两边类型不一致，继续转换，第1条规则，&quot;0”转换为数字，结果为0，等式变为0=0false =[]//true//第3条规则，[】转换基本类型值，[].toString(),结果为&quot;&quot;，等式变为&quot;=false//两边类型不一致，继续转换，第2条规则，false转换为数字，结果为0，等式变为&quot;==0//两边类型不一致，继续转换，第1条规则，&quot;转换为数字，结果为0，等式变为0==00=[]//true//第3条规则，[]转换基本类型值，[].toString(),结果为&quot;，等式变为0=&quot;&quot;//两边类型不一致，继续转换，第1条规则，“”转换为数字，结果为0，等式变为0=0","tags":["前端软件开发"]},{"title":"不同等号的区别","path":"/2024/08/28/不同等号的区别/","content":"&#x3D;&#x3D;&#x3D;这个比较简单。下面的规则用来判断两个值是否&#x3D;&#x3D;&#x3D;相等： 如果类型不同，就不相等 如果两个都是数值，并且是同一个值，那么相等；(！例外)的是，如果其中至少一个是NaN,那么不相等。（判断一个值是否是NaN,只能用isNaN()来判断) 如果两个都是字符串，每个位置的字符都一样，那么相等；否则不相等。 如果两个值都是true,或者都是false,那么相等。 如果两个值都引用同一个对象或函数，那么相等；否则不相等。 如果两个值都是null,或者都是undefined,那么相等。 &#x3D;&#x3D; 如果两个值类型相同，进行&#x3D;&#x3D;&#x3D;比较。 如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： 如果一个是null、一个是undefined,那么相等。 如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 如果任一值是true,把它转换成1再比较；如果任一值是false,把它转换成0再比较。 如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString;例外的是Date,Date利用的是toString转换。非js核心的对象，另说（比较麻烦，我也不大懂） 任何其他组合，都不相等。 有时会在结构读取属性值时会在前面加上“？”这个是可选链，表示判断空值的情况。","tags":["前端软件开发"]},{"title":"for_in和for_of的区别","path":"/2024/08/28/for-in和for-of的区别/","content":"一句话总结：for.,.in是为遍历对象属性而构建的，遍历的是index,而for,,,of是为了遍历数组的，遍历的是value 12345678910111213141516171819202122232425const arobj = 100:1, d:2, a:9, 1:3, 5:99, b:8&#125;Object.prototype.fun =()=&gt;&#123;&#125;arobj.name = &quot;lallala&quot;const arr=[1,2,4,8,9,10]Array.prototype.method ()=&gt;&#123;&#125;arr.name =&quot;bababa&quot;;for (const item in arobj)&#123; console.log(arobj[item])//3 99 1 2 9 8 lallala ()=&gt;&#123;&#125;for (const item in arr)&#123; console.log(item)//0 1 2 3 4 5 name method fun&#125;for (const item of arobj)&#123; console.log(item)//Uncaught TypeError:arobj is not iterable&#125;for (const item of arr)&#123; console.log(item)//1 2 4 8 9 10&#125; 一、for..in1.for..in适合遍历对象，遍历数组的时候会出现奇奇怪怪的问题2.for.in遍历会遍历所有的可枚举属性，包括原型链上的，可以使用hasOwnProperty来过滤3.for..in中index索引为字符串型数字，不能直接进行几何运算二、for..of1.适合比遍历所有拥有迭代器的对象的集合","tags":["前端软件开发"]},{"title":"判断数据类型","path":"/2024/08/28/判断数据类型/","content":"一、常见判断：typeof 这个方法很常见，一般用来判断基本数据类型，如：string,number,boolean,symbol,bigint(es10新增一种基本数据类型bigint),undefined等。返回数据类型的字符串形式 typeof目前能返回string,number,boolean,symbol,bigint,unfined,object,function这八种判断类型，但是注意null返回的是Object。而且对于引用类型返回的是object因为所有的对象的原型最终都是Object。 1234567891011121314//例子typeof &quot;safsadff&quot;;//&quot;string&quot;typeof 145;//&quot;number&quot;typeof false;//&quot;boolean&quot;typeof undefined;//&quot;undefined&quot;typeof function (&#123;&#125;//&quot;function&quot;typeof &#123;&#125;//&quot;object&quot;typeof Symbol();//&quot;symbol&quot;typeof null;//&quot;object&quot;typeof[];//&quot;object&quot;typeof new Date();//&quot;object&quot;typeof new RegExp();//&quot;object&quot;typeof new Number(33)//&quot;object&quot;typeof Null //&quot;undefined&quot; 为什么typeof null是Object答：因为在钉avaScript中，不同的对象都是使用二进制存储的，如果二进制前三位都是0的话，系统会判断为是Objecta类型，而null的二进制全是0，自然也就判断为Object这个bug是初版本的JavaScriptr中留下的，扩展一下其他五种标识位： 000对象 1整型 010双精度类型 100字符串 110布尔类型 二、已知对象判断：instanceof 用来判断引用数据类型的，判断基本数据类型无效，如：Object,Function,Array,Date,RegExp等，instanceof主要的作用就是判断一个实例是否属于某种类型 instanceof也可以判断一个实例是否是其父类型或者祖先类型 instanceof原理实际上就是查找目标对象的原型链 12345//例子[]instanceof Array;/true[]instanceof object;/true[1,2,3]instanceof Array /truenew Date()instanceof Date /true 手写实现一个 1234567891011121314//手写实现function myInstance(L,R)&#123;//L代表instanceof左边，R代表右边var RP R.prototypevar LP L._proto_while (true)if (LP =null)&#123;return false&#125;if (LP =RP)&#123;return trueLPLP._proto_&#125;&#125;console.log(myInstance(,object)); 三、根据对象的构造器：constructor 与instanceof相似，但是对于instanceof只能再检测用类型，而constructor还可以检测基本类型，因为constructor是原型对象的属性指向构造函数。 注意 null和undefined是无效的对象，因此是不会有constructor存在的，所以无法根据constructor来判断。 JS对象的constructor是不稳定的，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失，constructor会默i认为Object 类继承的也会出错，因为Object被覆盖了，检测结果就不对了 四、对象原型链判断：Object.prototype.toString.cal(这个是判断类型最准的方法) toString是Object原型对象上的-个方法，该方法默认返回其调用者的具体类型，更严格的讲，是toStringi运行时this指向的对象类型，返回的类型格式为[object,XXx],XXx是具体的数据类型，其中包括：Sng,Number,Boolean,Undefined,Null,Function,Date,Array,RegExp,Error,HTMLDocument..基本上所有对象的类型都可以通过这个方法状取到。 必须通过Object.prototype..toString.call来获取，而不能直接new Date().toString),从原型链的角度讲，所有对象的原型链最终都指向了Object,按照S变量查找规则，其他对象应该也可以直接访问到Object的toString方法，而事实上，大部分的对象都实现了自身的toString方法，这样就可能会导致Object的toString被终止查找，因此要用cal来强制执行Object的toString方法。 缺点：不能再细分 123456789//例子Object.prototype.toString.call(&quot;a&quot;)[object String]&quot;Object.prototype.toString.call(undefined)[object Undefined ]Object.prototype.tostring.call(null)[object Null]&quot;Object.prototype.tostring.call(new Date())[object Date]&quot; 简单来说，JavaScript中我们有四种方法来判断数据类型。一般使用ypeof来判断基本数据类型，不过需要注意当遇到u的问题，这里不足就是不能判断对象具休类型(typeof xjj只是Object不能看出是person):而在要判断一个对象的具体类型，就可以用nstanceof,但是也可能不准确，对于一些基础数据类型，数组等会被判断为object。结合typeof和instanceof的特点，还能使用constructor来判断，他能判断基本类型和引用类型，但是对于null和undefined是无效的，以及constructor不太稳定。最后如果需要判断准确的内置类型，就可以使用object.prototy pe.toString.call,是根据原型对象上的tostring方法获取的，该方法默认返回其调用者的具体类型。","tags":["前端软件开发"]},{"title":"数据类型","path":"/2024/08/28/数据类型/","content":"原始类型Undefined,Null,Boolean,Number,String（没有int,object类型）ES6新增了Symbol和BigInt. Symbol代表独一无二的值，最大的用法是为对象定义唯一的属性名 BigInt可表示任意大小的整数，指安全存储、操作大整数。 数据处理 parseInt(5.4)只保留整数部分，有基模式 解析一个字符串，并返回一个整数。parseInt相比Number,就没那么严格了，parseInt数逐个解析字符，遇到不能转换的字符就停下来。parseInt(string,radix)string必需，表示要被解析的字符串。radix可选，表示要解析的数字的基数。该值介于2~36之间。如果省略该参数或其值为’0’，则数字将以10为基础来解析。如果它以”0x”或”0X””开头，将以16为基数。如果该参数小于2或者大于36，则’parseInt()&#x2F;将返回NaN’。 parseFloat()把值转换成浮点数，没有基模式 Number()把给定的值转换成数字（可以是整数或浮点数），Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值。 Math.floor(4.33)向下取整 Math.ceil(6.7)向上取整 Math.round(6.19)四舍五入 Math.abs(-1)绝对值 String()把给定的值转换成字符串 toFixed(2)四舍五入 null&amp;undefined 这两个基本数据类型分别都只有一个值，就是undefined和null。 undefined代表的含义是未定义，null代表的含义是空对象。一般变量声明了但还没有定义的时候会返回undefined,null主要用于赋值给一些可能会返回对象的变量，作为初始化。 undefined在js中不是一个保留字，这意味着我们可以使用undefined来作为一个变量名，这样的做法是非常危险的，它会影响我们对undefined值的判断。但是我们可以通过一些方法获得安全的undefined值，比如说void(). 当我们对两种类型使用typeof进行判断的时候，Nul类型化会返回”object’”,这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回true,使用三个等号时会返回false。 typeof null为”Object”在第一版JS中，变量的值被设计保存在一个32位内存单元中。该单元包含一个1或3位的类型标标志，和实际数据值。类型标志存储在单元的最后。包括以下2几种情况1.000:object,数据为对象的引用2.1：int,数据为31位的有符号整型3.010:double,数据为一个双精度浮点数的引用4.100:string,数据为一个字符串的引用5.110:boolean,数据为布尔类型的值特殊情况：·undefined负的2的30次方（超出当时整型取值范围的一个数）·null空指针null的存储单元最后三位（即标志位）和object-一样，所以被误判为Object引用类型1.Object2.Date3.Array4.RegExp"},{"title":"原型","path":"/2024/08/28/原型和原型链/","content":"任何函数都可以作为构造函数，当该函数通过new关键字调用时，就可以称这个函数为构造函数。 prototype是函数特有的属性一句话概括prototype的作用：让某一个构造函数实例化的所有对象可以找到公共的方法和属性 1234567891011var Parent = function()&#123;&#125;Parent.prototype.name = &quot;所有Parent的实例都可以读取到我&quot;;let p1 = new Parent();let p2 = new Parent();p1.name // &quot;所有Parent的实例都可以读取到我&quot;p2.name // &quot;所有Parent的实例都可以读取到我&quot; __proto__属性是对象特有的属性。 它表示当前对象的原型对象是谁对象的__proto__就是构造函数的prototype 1p1.__proto__ === Parent.prototype; //true 原型链的基本概念 每个对象都有一个原型（prototype）,并从原型上继承属性和方法。原型本身也是一个对象，它也有自己的原型，形成一个链式结构。这种链式结构就被称为原型链。 实例是类的具象化产品对象是一个具有多种属性的内容结构实例都是对象，对象不一定是实例（如Dbject.prototype是对象但不是实例），构造函数也是对象prototype,是构造函数的属性proto是对象的属性 Object也是Function的实例，那Function是谁的实例呢？ 12Function._proto_===Function.prototype;//true Function构造函数的prototype和proto属性都指向同一个原型，是否可以说Function对象是由Function构造函数创建的一个实例？Yes and No.Yes的部分：按照JS中“实例”的定义，a是b的实例即a instanceof b为true,默认判断条件就是b.prototype在a的原型链上。而Function instanceof Function为true,本质上即Object..getPrototypeOf(Function)&#x3D;&#x3D;Function.prototype,正符合此定义。No的部分：Function是built-in的对象，也就是并不存在“Function对象由Function构造函数创建”这样显然会造成鸡生蛋蛋生鸡的问题。实际上，当直接写一个函数时（如function f0或x&#x3D;&gt;x),也不存在调用Function构造器，只有在你显式调用Function构造器时（如new Function(x’,’return x’))才有。注意，本质上，a instanceof b只是一个运算，即满足某种条件就返回true&#x2F;false,当我们说a是b的实例时，也只是表示他们符合某种关系。JS是一门强大的动态语言，你甚至可以在运行时改变这种关系，比如修改对象的原型从而改变instanceof运算的结果。此外，ES6+已允许通过Symbol.hasInstance来自定义instanceof运算。 1Function.prototype//&quot;function&quot; 后来意见：先有的Object.prototype,Object.prototype构造出Function.prototype,然后Function.prototype构造出Object和Function。Object.prototype.是鸡，Object和Function都是蛋。prototype有一个默认的constructor属性，用于记录实例由哪个构造函数创建.proto每一个对象都具有的一个属性，叫proto,这个属性指向该对象的原型.，原型有两个属性，constructor和proto既然实例对象和构造函数都可以指向原型，那么原型是否有属性可以指向构造函数或实例吗？proto.与其说是一个属性，不如说是个getter&#x2F;setter,,当使用obj.proto时，可以理解为返回了Object.getPrototypeOf(obj),constructor每一个原型都有一个constructor属性指向关联的构造函数. 12345678910function Person()&#123;&#125;var person new Person();console.log(person.__proto_==Person.prototype)//trueconsole.log(Person.prototype.constructor=Person)//true原型对象的constructor指向构造函数本身//顺便学习一个ES5的方法，可以获得对象的原型console.log(Object.getPrototypeof(person)===Person.prototype)//trueconsole.log(Object.getPrototypeof(person))person._proto_Person.prototype //constructor 实例&amp;原型当读取实例属性时若找不到，就会查找与对象关联原型中的属性，若还查不到，就去找原型的原型，一直找到最顶层为止原型的原型实例的proto:指向构造函数的prototype原型链 1console.log(Object.prototype._proto_===null)//true 意思就是Object.prototype没得原型，图中由相互关联的原型组成的练状结构就是原型链（蓝色这条线）创建一个原型链只有name属性的对象 123let obj=Object.create(null)/为obj的prototype属性赋值为nullobj.name &#x27;merry&#x27;console.log(obj) 参考文档https://zh.javascript..info/prototype-methodsproto和prototypeprototype是原型对象一proto一将对象和该对象的原型相连特殊的Function对象，Function的proto指向的是自身的prototype。构造函数prototype的proto也是指向构造函数的构造函数的prototype构造函数是一个函数对象，通过Function构造器产生的。原型对象本身是一个普通对象，而普通对象的构造函数是Object。.除了Object的原型对象(Object.prototype)的proto指向null,其他内置函数对象的原型对象（例如：Array.prototype)和自定义构造函数的proto都指向Object.prototype,因为原型对象本身是普通对象 123Object.prototype._proto_=null;Array.prototype._proto_=object.prototype;Foo.prototype.proto object.prototype; 一切对象都是继承自Object对象，Object对象直接继承根源对象null·一切的函数对象（包括Object对象），都是继承自Function对象·Object对象直接继承自Function对象·Function对象的proto会指向自己的原型对象，最终还是继承自Object对象原型&amp;原型链需要new关键字，成为”构造器constructor或构造函数”。通过prototype定义的属性，再被多个实例化后，引用地址是同一个。继承链从祖父—到爷爷—到爸爸—到自己 constructor指向构造函数，每个对象的proto指向创建它的构造函数的prototype,而构造函数的prototype也有proto:指向他的父辈或者是Object,当查找一个对象中不存在的属性时，会去它的proto、proto中的proto中进行寻找，直到找到或者是nul为止 instanceof判断对象的proto和构造函数的prototype是不是同一个地址 Object.setPrototypeOfr改变对象的proto原型(prototype):一个对象，实现对象的属性继承，简单理解为对象的爹。prototype可以通过Object.getPrototypeOf()和Object..setPrototypeOf()访问器访问。当继承的函数被调用时，ts指向的是当前继承的对象，而不是继承的函数所在的原型对象。不是所有对象都有原型。"},{"title":"判断对象是否具有属性","path":"/2024/08/28/判断对象是否具有属性/","content":"1、in如果属性来自对象的原型，仍然返回true 12345let obj = &#123; name:aa&#x27;&#125;;&#x27;name&#x27; in obj;//true&#x27;toString&#x27;in obj;//true 2、Reflect.has()检查属性是否在对象中，和一样作为函数工作 12345const obj = &#123; name:111&#125;;Reflect.has(obj,&#x27;name&#x27;);//trueReflect.has(obj,&#x27;toString&#x27;);//true 3、hasOwnProperty()返回布尔值，指对象是否具有指定属性作为它自己的属性（不是继承）可正确区分对象本身属性和其原型的属性 12345const obj = &#123; a:1&#125;;obj.hasownProperty(&#x27;a&#x27;);//trueobj.hasownProperty(&#x27;toString&#x27;);//false 缺点：如果对象是用Object.create(null)创建的，不能使用这个方法 123const obj object.create(null);obj.name =&#x27;merry&#x27;;obj.hasownProperty(&#x27;name&#x27;);//Uncaught TypeError:obj.hasownProperty is not a function 4.Object.prototype.hasOwnProperty()可解决3的问题，本方法直接调用内置有效函数，跳过原型链 1234const obj=object.create(null);obj.name=&#x27;merry&#x27;Object.prototype.hasOwnProperty.call(obj,&#x27;name&#x27;)//trueObject.prototype.hasOwnProperty.call(obj,&#x27;toString&#x27;);//false 5、Object.hasOwn()若对象具有指定属性作为自己的属性，则Object.hasOwn(O静态方法返回true,若属性被继承或不存在，返回false 1234const obj=object.create(null);obj.name =&#x27;merry&#x27;object.hasown(obj,&#x27;name&#x27;);//trueObject.hasOwn(obj,&#x27;toString&#x27;);//false","tags":["前端软件开发"]},{"title":"遍历对象的方法","path":"/2024/08/28/遍历对象的方法/","content":"for in以任意顺序迭代一个对象的除Symbol以外的可枚举属性，包括继承的可枚举属性。 1234567891011121314151617181920212223//Object原型链上扩展的方法也会被遍历出来Object.prototype.fun ()=&gt;&#123;&#125;var obj = &#123; a:1, b:2, c:3&#125;for (const item in obj)&#123; console.log(&quot;属性名：&quot;+item+&quot;/属性值：&quot;+obj[item]);&#125;//属性名：a/属性值：1//属性名：b/属性值：2//属性名：C/属性值：3//属性名：fun/属性值：()=&gt;&#123;&#125;//而如果我们不希望搜索到原型上的，我们就可以使用hasOwnPropertyfor (const item in obj)&#123; if (obj.hasOwnProperty(item))&#123; console.log(&quot;属性名：&quot;+item+&quot;/属性值：&quot;+obj[item]); &#125;&#125;//属性名：a/属性值：1//属性名：b/属性值：2//属性名：c/属性值：3 如果我们不希望搜索到原型上的，我们就可以使用hasOwnProperty Object.key返回一个给定对象的自身可枚举属性名组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致。 123456789//注意：当属性名为数字的时候会排序，key/values/entries都有这个特性~const anobj=&#123;100:&#x27;a&#x27;,2:&#x27;b&#x27;,7:&#x27;c&#x27;&#125;;console.log(Object.keys(anobj));//console:[&#x27;2&#x27;,7,&#x27;100&#x27;]const str = &#x27;hello&#x27;;console.log(Object.keys(str));//[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]const arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];console.log(Object.keys(arr));//[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;]var obj = &#123;a:1,b:2,c:3&#125;;console.log(Object.keys(obj));//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] Object.values12345678910//注意：当属性名为数字的时候会排序，key/values/entries都有这个特性~//注意：当属性名为数字的时候会排序，key/values/entries都有这个特性~const obj1=&#123;100:1,d:2,a:9,1:3,5:99,b:8&#125;;console.log(Object.values(obj1));//[3,99,1,2,9,8]const str=&#x27;hello&#x27;;console.log(Object.values(str));//[&quot;h&quot;,&quot;e&quot;,&quot;&quot;&quot;&quot;&quot;o&quot;]const arr=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];console.log(Object.values(arr));//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]var obj2=&#123;a:1,b:2,c:3&#125;;console.log(Object.values(obj2));//[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]v Object.entries返回一个给定对象自身可枚举属性的键值对数组，其排列与使用for.循环遍历该对象时返回的顺序一致 1234567891011121314//注意：当属性名为数字的时候会排序，key/values/entries都有这个特性~const obj1=&#123;100:1,d:2,a:9,1:3,5:99,b:8&#125;;console.log(Object.entries(obj1));//[[&quot;1&quot;,3],[&quot;5&quot;,99],[&quot;100&quot;,1],[&quot;d&quot;,2],[&quot;a&quot;,9],[&quot;b&quot;,8]]const str=&#x27;hello&#x27;;console.log(Object.entries(str));//[[&quot;0&quot;,&quot;h&quot;],[&quot;1&quot;,&quot;e&quot;],[&quot;2&quot;,&quot;&quot;],[&quot;3&quot;,&quot;&quot;],[&quot;4&quot;,&quot;o&quot;]]const obj2=&#123;a:1,b:2,c:3&#125;;console.log(Object.entries(obj2));//[[&quot;a&quot;,1],[&quot;b&quot;,2],[&quot;c&quot;,3]]const obj3=&#123;a:1,b:2,c:3&#125;;for (const [key,value] of Object.entries(obj3))&#123; console.log(`$&#123;key&#125;:$&#123;value&#125;`);&#125;//a:1//b:2//c:3 object.getownPropertyNames返回一个由指定对象的所有自身属性的属性名组成的数组。（包括不可枚举属性但不包括Symbol值作为名称的属性) 123456789101112131415//注意：当属性名为数字的时候会排序，key/values/entries都有这个特性const arobj=&#123;100:1,d:2,a:9,1:3,5:99,b:8&#125;;console.log(Object.getOwnPropertyNames(arobj));//[&quot;1&quot;,&quot;5&quot;,&quot;100&quot;,&quot;d&quot;,&quot;a&quot;,&quot;b&quot;]const str=&#x27;hello&#x27;;console.log(Object.getOwnPropertyNames(str));//[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;length&quot;]const arr=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];console.log(Object.getOwnPropertyNames(arr));//s[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;length&quot;]const obj=&#123;a:1,b:2,c:3&#125;;console.log(Object.getOwnPropertyNames(obj));//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]const syobj =&#123;a:1,b:2 &#125;const symbol1=Symbol(&#x27;symbol1&#x27;)const symbol2=Symbol(&#x27;symbol2&#x27;)syobj[symbol1]=&#x27;hello&#x27;syobj[symbol2]=&#x27;world&#x27;console.log(Object.getOwnPropertyNames(syobj));//[&quot;a&quot;,&quot;b&quot;] Object.getownPropertySymbols()方法返回一个给定对象自身的所有Symbol属性的数组 123456const obj=&#123;a:1,b:2,c:3&#125;;const symbol1=Symbol(&#x27;symbol1&#x27;)const symbol2=Symbol(&#x27;symbo12&#x27;)obj[symbol1]=&#x27;hello&#x27;obj[symbol2]=&#x27;world&#x27;console.log(Object.getOwnPropertySymbols(obj));//[Symbol(symbol1),Symbol(symbol2)] 报错：TypeError: Cannot convert a Symbol value to a string Reflect.ownKeys()静态方法Reflect..ownKeys(()返回一个由目标对象自身的属性名组成的数组 123456const obj=&#123;a:1,b:2,c:3&#125;;const symbol1=Symbol(&#x27;symbol1&#x27;)const symbol2=Symbol(&#x27;symbol2&#x27;)obj[symbol1]=&#x27;hello&#x27;obj[symbol2]=&#x27;world&#x27;console.log(Reflect.ownKeys(obj));//[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,Symbol(symbol1),Symbol(symbol2) 报错：TypeError: Cannot convert a Symbol value to a string 注意 在ES6之前Object的键值对是无序的； 在ES6之后Object的键值对按照自然数、非自然数和Symbol进行排序，自然数是按照大小升序进行排序，其他两种都是按照插入的时间顺序进行排序。","tags":["前端软件开发"]},{"title":"遍历对象属性","path":"/2024/08/28/遍历对象属性/","content":"使用hasOwnProperty判断对象自身属性中是否具有指定的属性访问属性点表示和加[]语法的主要优点是可以通过变量访问属性。如果属性包含空格，就不能通过.访问它。属性名可以包含非字母非数字，使用[]访问它。除非必须使用变量访问属性，否则我们使用点表示法。注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object) 1234567891011const keyA = &#123; a:1&#125;;const keyB = &#123; b:2&#125;;const myobject = &#123; [keyA]:&#x27;valueA&#x27;, [keyB]:&#x27;valueB&#x27;&#125;;console.log(myobject) //object &#123;[object object]:&quot;valueB&quot;&#125; for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）Object.keys(obj)返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）的键名Object.getOwnPropertyNames(obj)返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）的键名Object.getOwnPropertySymbols(obj)返回一个数组，包含对象自身的所有Symbol属性的键名Reflect.ownKeys(obj)返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是Symbol或字符串，也不管是否可枚举","tags":["前端软件开发"]},{"title":"String方法","path":"/2024/08/28/String方法/","content":"charAt(index):返回指定索引处的字符串，若没找着，返回空 charCodeAt(index):返回指定索引处的字符的Unicode值123//toLowerCase()转换成小写toUpperCase()转换成大写var x =&quot;a&quot;.toLowercase().charCodeAt(0)//x=97 concat(str1,str2,.):连接多个字符串，返回连接后字符串副本，纯函数（和数组一样的用法） fromCharCode():将Unicode值转换成实际字符串12String.fromCharCode(97)//返回&quot;a&quot; indexOf(str):返回str在父串中第一次出现的位置，若没有返回-1 lastIndexOf(str):返回str在父串中最后一次出现的位置，若没有返回-1 match(regex):搜索字符串，返回正则表达式的所有匹配 search(regex):基于正则表达式搜索字符串，返回第一个匹配的位置 slice(start,,end):返回字符索引在start和end(不含)之间的子串 split(sep,l1imit):将字符串分割为字符数组，limit为从头开始执行分割的最大数量 substr(start,length):从字符索引start的位置开始，返回长度为length的子串 substring(from,to):返回字符索引在from和to(不含)之间的子串，和slice几乎相同，但它允许from&gt;to,不支持负参数 toLowerCase0:将字符串转换为小写 toUpperCase():将字符串转换为大写 valueOf0:返回原始字符串值 toString)把Number对象转换为字符串，返回结果{}的valueOf结果为，toString的结果为”[object Object]”[]的valueOf结果为0，toString的结果为” str.codePointAt(pos)返回pos位置的字符编码123//不同的字母有不同的代码alert(&quot;z&quot;.codePointAt(0));//122alert(&quot;Z&quot;.codePointAt(0));//90 String.fromCodePoint(code)通过code创建字符1234567891011alert(String.fromCodePoint(90));//Z//八u后跟十六进制代码，通过代码添加Unicode字符//在十六进制系统中90为5aalert(&#x27;\\u005a&#x27;);//Z&#x27;a&#x27;&gt;&#x27;Z因为字符通过数字代码比较，ā(97)&gt;Z(90)//英文是否大写function upperCase(num)&#123; var reg =/[A-Z]+$/; return reg.test(num);&#125; replace不会修改原字符串！第二个参数传入要替换的目标字符串，replace只会匹配一次第二个参数也可传入一个函数，若原始字符串中有个我们查找的字符串，函数就会执行次，且函数返回一个字符串，来替换每次匹配到的字符串参数$&amp;$&amp;适用于没有子表达式的情况123var sStr=&#x27;讨论一下正则表达式中的replacel的用法&#x27;；sStr.replace(/正则表达式/，&#x27;《$&amp;》&#x27;)；//得到：&quot;讨论一下《正则表达式》中的replace的用法&quot; $匹配字符串左边的所有字符123var sStr=&#x27;讨论一下正则表达式中的replace的用法&#x27;；sStr.replace(/正则表达式/，&#x27;《$`》&#x27;)；//得到：&quot;讨论一下《讨论一下》中的replacel的用法&quot; $’匹配字符串右边的所有字符123var sStra=&#x27;讨论-下正则表达式中的replace的用法&#x27;；sStr.replace(/正则表达式/，&quot;《$&#x27;》&quot;)；/得到：&quot;讨论一下《中的replacel的用法》中的replacel的用法&quot; 123,4..n依次匹配子表达式123var sStr=&#x27;讨论一下正则表达式中的replace的用法&#x27;；sStr.replace(/(正则)(.+？)（式）/，&quot;《$1》$2&lt;$3&gt;&quot;)；//得到：&quot;讨论一下《正则》表达&lt;式&gt;中的replace的用法&quot; 函数12345var sStr=&#x27;讨论一下正则表达式中的replacel的用法&#x27;；sStr.replace(/(正则).+？（式）/，function()&#123;console.log(arguments);&#125;)；/[&quot;正则表达式&quot;，&quot;正则&quot;，&quot;式&quot;，4，&quot;讨论一下正则表达式中的replace的用法&quot;] 参数分别为。匹配到的字符串·若正则使用了分组匹配就是多个，否则无此参数·匹配字符串的索引位置·原始字符串arguments是当前函数的内置属性，指代当前匹配的参数伪数组。或者使用命名形参的方式：12345var sStr=&#x27;讨论一下正则表达式中的replace的正则表达式用法&#x27;；sStr.replace(/(正则).+？（式）/g,function($1)&#123;console.log($1);return $1 +&#x27;a&#x27;;&#125;)； 用法12345678910111213str=str.replace(八s*/g);//去除字符串内所有的空格\\s匹配任何空白字符。（空格，制表符，换行符）str=str.replace(/\\s*|\\s*$/g,&quot;&quot;);//去除字符串内首尾空格str=str.replace(/\\s*/,&quot;&quot;);//去除字符串左侧空格str=str.replace(/八s*&amp;/,&quot;&quot;);//去除字符串右侧空格name &quot;Doe,John&quot;;let a=name.replace(/(\\w+)\\s*,\\s*(\\w+)/,&quot;$2 $1&quot;);console.log(a)//John Doe/首字母大写let name =&#x27;aaa bbb ccc&#x27;;let uw=name.replace(/\\b\\w+\\b/g,function(word)&#123;return word.substring(0,1).toUppercase()+word.substring(1);&#125;) str.trim()r0删除字符串两端的空白字符并返回，不影响原来字符串本身，返回一个新的字符串*缺陷：只能去除字符串两端的空格，不能去除中间的空格截取字符串substring()substring0用于提取字符串中介于两个指定下标之间的字符substring(start,stop)·st妇t:一个非负整数，指要提取的子串的第一个字符在字符串中的位置，必需填写·soP:一个非负整数，比要提取的子串的最后一个字符在字符串上的位置多1，可写可不写，如果不写则返回的子串会一直到字符串的结尾该字符串的长度为stop-start如果参数start与stop相等，则该方法返回的就是一个空串，如果start比stoP大，那么该方法在提取子串之前会先交换这两个参数substr()substr(O在字符串中抽取从start下标开始的指定数目的字符substr(start,length)·st妇t:要截取的子串的起始下标，必须是数值。如果是负数，那么该参数从字符串的尾部开始算起的位置。也就是说，1指字符串中最后一个字符，2指倒数第二个字符，以此类推，必需要写·length:子串中的字符数，必须是数值。如果不填该参数，返回字符串的开始位置到结尾的字符。如果length为0或者负数，将返回一个空字符串split()split(0把一个字符串分割成字符串数组stringObject.split(separator,howmany)separator:字符串或正则表达式，从该参数指定的地方分割字符串。(必须要填写)howmany:指返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。(可选)","tags":["前端软件开发"]},{"title":"对原数组无影响","path":"/2024/08/28/对原数组无影响/","content":"concat()创建一个副本，返回新构建的数组 slice()创建一个包含原有数组中一个或多个元素的新数组 reduce()reduce()方法不会改变原有数组 filter将所有元素进行判断，将满足条件的元素作为一个新的数组返回 some将所有元素进行判断返回一个布尔值，如果存在元素都满足判断条件，则返回true,若所有元素都不满足判断条件，则返回false; every将所有元素进行判断返回一个布尔值，如果所有元素都满足判断条件，则返回ue,否则为false; 求最大值12vara=[1,2,3,4];Math.max.apply(null,a); join纯函数 flat(),flatMap()将数组扁平化处理，返回一个新数组，对原数据没有影响。flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。flatMap()方法对原数组的每个成员执行一个函数相当于执行Array.prototype.map(),然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。 123456789101112131415161718192021222324252627282930// 示例数组，包含嵌套数组const nestedArray = [1, [2, [3, [4]], 5]];// 使用 flat() 方法拉平一层const flatArrayOneLevel = nestedArray.flat();console.log(&#x27;flat() 一层拉平:&#x27;, flatArrayOneLevel);// 使用 flat() 方法拉平两层const flatArrayTwoLevels = nestedArray.flat(2);console.log(&#x27;flat() 两层拉平:&#x27;, flatArrayTwoLevels);// 使用 flat() 方法拉平所有层const flatArrayAllLevels = nestedArray.flat(Infinity);console.log(&#x27;flat() 所有层拉平:&#x27;, flatArrayAllLevels);// 使用 flatMap() 方法const flatMapArray = nestedArray.flatMap((item) =&gt; &#123; // 如果是数字，返回一个包含该数字的新数组 // 如果是数组，返回该数组本身 return Array.isArray(item) ? item : [item];&#125;);console.log(&#x27;flatMap():&#x27;, flatMapArray);// 使用 flatMap() 方法并绑定 thisconst context = &#123; multiplier: 10 &#125;;const flatMapArrayWithContext = nestedArray.flatMap(function(item) &#123; // 使用 this 乘以数组中的每个数字 return Array.isArray(item) ? item.map(num =&gt; this.multiplier * num) : [this.multiplier * item];&#125;, context);console.log(&#x27;flatMap() 绑定 this:&#x27;, flatMapArrayWithContext);"},{"title":"对原数组有影响","path":"/2024/08/28/对原数组有影响/","content":"push返回数组最新长度 unshift()返回新数组长度 splice()返回空数组，返回包含删除元素的数组 123[2,3,4].splice(0,1);//0位置删除-个，返回[2][2,3,4].sp1ice(0,1,5);//0位置删除1个，插入5，原数组是[5,3,4]，返回[2]arrayObject.splice(index,howmany,item1,.....,itemx) index:必需。添加&#x2F;删除项目位置，使用负数可从数组结尾处规定位置。howmany:必需。要删除项目数量。如果设置为0，则不会删除项目。item1,…..,itemx:可选。向数组添加新项目。 pop()shift()","tags":["前端软件开发"]},{"title":"创建数组","path":"/2024/08/28/创建数组/","content":"Array.from()浅拷贝1234const dp1=Array(5).fill(1);console.log(dp1)//1,1,1,1,1const dp2=Array.from(Array(5),()=&gt;Array(5).fill(1));console.log(dp2)//1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 从类数组对象或者可迭代对象中创建一个新的数组实例。Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 Array.of()根据一组参数来创建新的数组实例，支持任意的参数数量和类型，没有参数时返回[]，当参数只有一个的时候，实际上是指定数组的长度。 sort原理对数组进行排序，默认排序顺序规则是将元素转换为字符串，然后比较它们的UT℉-16代码单元值序列时构建的。 copyWithin()将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。 target(必需)：从该位置开始替换数据。如果为负值，表示倒数。 start(可选)：从该位置开始读取数据，默认为0。如果为负值，表示从末尾开始计算。 end(可选)：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。123[1,2,3,4,5].copyWithin(0,3);//将从3号位直到数组结束的成员（(4和5)，复制到从0号位开始的位置，结果覆盖了原来的1和2//[4,5,3,4,5] find()find)用于找出第一个符合条件的数组成员参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组 findIndex()findIndex.返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1find和findIndex这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置注意，如果填充的类型为对象，则是浅拷贝","tags":["前端软件开发"]},{"title":"响应式布局","path":"/2024/08/28/响应式布局/","content":"页面的设计和开发根据用户行为和设备环境进行调整和响应Content is like water 12&lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;&gt; 1.width&#x3D;device-width:自适应手机屏幕的尺寸宽度2.maximum-scale:缩放比例的最大值3.inital-scale:缩放的初始化4.user-scalable:用户可以缩放实现响应式布局的方式1.媒体查询2.百分比3.vw&#x2F;vh4.rem响应式设计实现通常会从以下几方面思考：1.弹性盒子和媒体查询等2.百分比布局创建流式布局的弹性UⅡ，同时使用媒体查询限制元素的尺寸和内容变更范围3.相对单位使得内容自适应调节缺点：1.仅适用布局、信息、框架并不复杂的部门类型网站2.兼容各种设备工作量大，效率低下3.代码累赘，出现隐藏无用的元素，加载时间加长4.一定程度上改变了网站原有的布局结构"},{"title":"div居中的几种方式","path":"/2024/08/28/div居中的几种方式/","content":"方式一 123456position:absolute;top:0;bottom:0;left:0;right:0;margin:auto; 方式二可以给父元素添加下面的属性，利用lex布局来实现 123display:flex;align-items:center;flex-direction:column 方式三通过定位和变形来实现给父元素添加position:relative;相对定位。给自身元素添加position:absolute,绝对定位。top:50%;使自身元素距离上方”父元素的50%高度”的高度。1eft:50%;使自身元素距离上方”父元素的50%宽度”的宽度。transform:translate(-50%,-50%):使自身元素再往左，往上平移自身元素的50%宽度和高度。 1234position:absolute;top:50%;left:50%;transform:translate(-50%,-50%); 方式四这个是实现内容文本居中的，坑死了，之前没留意在一个全局的文件加了，后面很多组件里面的内容都居中了，还一时没发现，虽然想到会不会是全局文件的问题，但一下子眼拙没看到，结果捣鼓半天 1body&#123;text-align:center&#125;"},{"title":"重排，重绘和合成","path":"/2024/08/28/重排，重绘和合成/","content":"回流一定触发重绘，重绘不一定触发回流。重绘开销小，回流代价高。回流reflow也叫重排layout渲染树中部分或全部元素的尺寸、结构或属性变化，浏览器会重新渲染部分或全部文档触发回流的操作：·初次渲染·窗口大小改变(resize事件)■元素属性、尺寸、位置、内容改变元素字体大小变化■添加或者删除可见dom元素■激活CSS伪类（如：hover)■查询某些属性或调用某些方法clientWidth、clientHeight、clientTop、clientLeftoffsetWidth、offsetHeight、offsetTop、offsetLeftscrollWidth、scrollHeight、scrollTop、scrollLeftgetComputedStyle()getBoundingClientRect()scrollTo()修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来。重绘repaint某些元素的样式如颜色改变，但不影响其在文档流中的位置，浏览器会对元素重新绘制不再执行布局阶段，直接进入绘制阶段合成利用transform、opacity和filter可实现合成效果，即GPU加速避开布局分块和绘制阶段优化·最小化重绘和重排：样式集中改变，使用添加新样式类名■使用absolute或fixed使元素脱离文档流（制作复杂动画时对性能有影响）■开启GPU加速。利用css属性transform opacity will-change等，比如改变元素位置，使用translate会比使用绝对定位改变其left或top更高效，因为它不会触发重排或重绘，transform使浏览器为元素创建一个GPU图层，这使得动画元素在一个独立的层中进行谊染，当元素内容没有改变就没必要进行渲染。·使用visibility替换display:none,因为前者只会引起重绘，后者会引发回流（改变了布局）。DOM离线后修改，如：先把DOM设为display:none(有一次Reflow),然后修改再显示，只会触发一次回流不要把DOM结点属性值放在一个循环当成循环里的变量不要使用table布局，可能很小的一个小改动会造成整个table重新布局动画实现速度的选择，动画速度越快，回流次数越多，也可以选择使用requestAnimationFrameCSS选择符从右往左匹配查找，避免节点层级过多。频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于vd©o标签，浏览器会自动将该节点变为图层·通过documentFragment创建一个DOM文档片段，在它上面批量操作DOM,完成后再添加到文档中，只触发一次回流documentFragment不是真实DOM的一部分，它的变化不会触发DOM树的重新渲染，不会导致性能问题效果不甚明显，因为现代浏览器会使用队列存储储存多次修改进行优化"},{"title":"水平居中","path":"/2024/08/28/水平居中/","content":"不定宽高1.定位+margin:auto2.定位+transform3.定位+margin:负值4.f1ex布局5.grid布局 内联元素水平居中l.行内元素可设置：text-align:center2.flex布局设置父元素：display:flex;justify-content:center垂直居中1.单行文本父元素确认高度：height&#x3D;&#x3D;line-height2.多行文本父元素确认高度：disaply:table-cell,vertical-align:middle 块级元素水平居中1.定宽：margin:0auto2.绝对定位+left:50%+margin:负自身一半垂直居中l.position:absolutei设置left、top、margin-left、margin-top(定高)2.display:table-cell3.transform:translate(x,y)4.flex(不定高，不定宽)5.grid(不定高，不定宽)，兼容性相对比较差","tags":["前端软件开发"]},{"title":"盒子模型","path":"/2024/08/28/盒子模型/","content":"盒模型宽度的计算普通盒模型默认盒子属性：box-sizing:content-box; width只包含内容宽度，不包含border和padding offsetWidth &#x3D;(width padding border),margin width和height属性只会应用到这个元素的内容区 box-sizing:content–box;&#x2F;&#x2F;定义引擎如何计算元素的总高度和总宽度 content-box默认值，元素的width&#x2F;height不包含padding,border,与标准盒子模型表现一致 border-box元素的width&#x2F;height包含padding,border,与怪异盒子模型表现一致 inherit指定box-sizing属性的值，应该从父元素继承 怪异盒模型设置语句：box-sizing:border-box; offsetWidth&#x3D;width(padding和border都挤压到内容里面) width和height包括内容区、padding和border,不算margin margin纵向重叠margin负值问题BFCfloat元素居中样式单位两栏布局左边宽度固定，右边宽度自适应。 利用flex布局，将左边元素设置为固定宽度200px,将右边的元素设置为flex:1 利用浮动。左边元素宽度设置为200px,且设置向左浮动。右边元素的margin-left设置为200px,宽度设置为auto(默认为auto,撑满整个父元素)。margin-left&#x2F;padding-left&#x2F;calc 利用浮动。左边元素宽度固定，设置向左浮动。右侧元素设置overflow:hidden;这样右边就触发了BFC,BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。float+overflow:hidden 左列左浮动，将自身高度塌陷，使得其它块级元素可以和它占据同一行位置 右列利用自身流特性占满整行 右列设置overflow,触发BFC特性，使自身和左列浮动元素隔开，不沾满整行 绝对定位父级相对定位左边absolute定位，宽度固定。设置右边margin-left为左边元素的宽度值。 绝对定位，父级元素相对定位。左边元素宽度固定，右边元素absolute定位，left为宽度大小，其余方向为0。（有歧义，谨慎使用) 使用calc计算123456789.leftdisplay:inline-block;width:240px;&#125;rightdisplay:inline-block;width:calc(100%-240px);&#125;//使用calc()函数计算&lt;div&gt;元素的宽度 grid","tags":["前端软件开发"]},{"title":"脱离文档流","path":"/2024/08/28/脱离文档流/","content":"定位流元素的属性position为absolute或fixed,它就是一个绝对定位元素。 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 它的定位相对于它的包含块，相关CSS属性：top、bottom、left、right; 对于position:absolute,元素定位将相对于上级元素中最近的一个relative、fixed、absolute,如果没有则相对于body; 对于position:fixed,正常来说是相对于浏览器窗口定位的，但是当元素祖先的transform属性非none时，会相对于该祖先进行定位。 浮动流在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能地向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 普通流普通流其实就是指BFC中的FC。FC(Formatting Context),直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。在普通流中，元素按照其在HTML中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行。块级元素则会被渲染为完整的一个新行。除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在HML文档中的位置决定。","tags":["前端软件开发"]},{"title":"px_em_rem_vh_vw的区别及使用场景","path":"/2024/08/28/px-em-rem-vh-vw的区别及使用场景/","content":"px也就是像素，是基于屏幕分辨率来说的，一旦设置了，就无法适应页面大小的变化。 emem：是相对单位，相对于当前对象内文本的字体大小（也就是它的父元素），如果当前对象内文本的字体没有设置大小，就会相对于浏览器默认字体大小也就是16px。所以在没有设置的情况下1em&#x3D;16px。 为了便于运算你可以在body选择器中声明Font-size-62.5%;这就使em值变为16px*62.5%&#x3D;10px,这样12px&#x3D;1.2em,10px&#x3D;1em,也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。 remrem的出现是为了解决em的问题的，em是相对于父元素来说的，这就要求我们进行任何元素设置的时候，都需要知道它的父元素字体的大小。而rem是相对于根元素，这样就意味着，我们只需要在根元素确定一个参考值，就可以了，同时还能做到只修改根元素就成比例地调整所有字体大小。 vh,vwvh、vw是根据窗口的宽度。会把窗口的大小分为100份，所以50w代表窗口大小的一半。并且这个值是相对的，当窗口大小发生改变也会跟着改变，同理，则为窗口的高度 区别px是固定的大小，em是相对于父元素字体的大小，rem是相对于根元素字体的大小，vh、w是相对可是窗口的大小 使用场景 一般我们在设置边框和边距的时候用px比较好 而在一些需要做响应式的页面用rem比较便捷 但是具体还是得看你的业务来定的"},{"title":"position属性","path":"/2024/08/27/position属性/","content":"relative:相对自身之前正常文档流中的位置发生偏移，未脱离文档流, 且原来的位置仍然被占据。发生偏移时，可能覆盖其他元素, 但不会影响其他元素的位置和大小。body默认是relative,子绝父相。 absolute:元素框不再占有文档位置，脱离文档流, 并且相对于包含块进行偏移（所谓包含块就是最近一级外层元素position不为static的元素)。 给元素设置position:absolute, 在没有定义宽度的情况下，宽度由元素里面的内容决定。 在父元素没有设置相对定位或绝对定位的情况下，元素相对于根元素定位（即html元素）（是父元素没有）。 父元素设置了相对定位或绝对定位，元素会相对于离自己最近的设置了相对或绝对定位的父元素进行定位（或者说离自己最近的不是static的父元素进行定位，因为元素默认是static）。 fixd:元素框不再占有文档流位置，并且相对于视窗进行定位。 static:默认值，取消继承。 sticky:css3新增属性值，粘性定位，相当于relative和fixed的混合。最初会被当作是relative,相对原来位置进行偏移；一旦超过一定的阈值，会被当成fixed定位，相对于视口定位。 inherit 绝对定位：absolute 和 fixed 统称为绝对定位相对定位：relative默认值：static 参考文章：css之position相对定位和绝对定位CSS position 相对定位和绝对定位","tags":["前端软件开发"]},{"title":"CSS选择器优先级总结","path":"/2024/08/26/CSS选择器优先级总结/","content":"CSS有多少种样式类型：1.行内样式：&lt;style&#x2F;style&gt;2.内联样式：&lt;div style-“color:red&gt;;3.外部样式：或@import引入 常见选择器及选择器权重 选择器 格式 优先级权重 id选择器 #id 100 类选择器 .classname 10 属性选择器 a[ref &#x3D; “eee”] 10 伪类选择器 li:last-child 10 标签选择器 div 1 伪元素选择器 li:after 1 相邻兄弟选择器 h1+p 0 子选择器 ul&gt;li 0 后代选择器 li a 0 通配符选择器 * 0 三、注意事项 !important声明的样式的优先级最高； 如果优先级相同，则最后出现的样式生效；覆盖原则。 继承得到的样式的优先级最低：和类继承差不多。 通用选择器(*)、子选择器(&gt;)和相邻同胞选择器(+)并不在这四个等级中，所以它们的权值都为0： 样式表的来源不同时，优先级顺序为：内联样式&gt;内部样式&gt;外部样式&gt;浏览器用户自定义样式&gt;浏览器默认样式。","tags":["前端软件开发"]},{"title":"display:none与visibility:hidden的区别","path":"/2024/08/26/display-none与visibility-hidden的区别/","content":"是否在渲染树中 display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间； visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。 是否是继承属性 display:none是非继承属性，子孙节点会随着父节点从渲染树消失，不是因为继承了display:none，相当于整个节点被移除了,通过修改子孙节点的属性也无法显示（都移除了如何获取子孙节点？设置属性感觉也没啥用）； visibility:hidden是继承属性，子孙节点消失是由于继承了hidden,通过设置visibility:Avisible可以让子孙节点显示； 修改常规文档流中元素的display通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘 如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取（读屏器会选择性读取，只会读取visibility:hidden的内容）。 这两者的关系类似于v-if和v-show之间的关系 v-if 和 v-show 都是Vue.js框架中用于条件性渲染元素的指令，但它们的工作机制和使用场景有所不同。 v-if 工作机制：v-if 是一个条件渲染指令，它是“真正”的条件渲染，因为它确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 性能开销：因为 v-if 的元素可能被销毁和重建，所以切换时会有更高的性能开销。 使用场景：当元素需要频繁切换时，使用 v-if 可能会导致性能问题，因为它会不断地创建和销毁元素。因此，v-if 更适合条件不经常改变的情况。 v-show 工作机制：v-show 只是简单地切换元素的 CSS 属性 display。元素始终被保留在DOM中，它只是简单地切换显示与隐藏。 性能开销：初始渲染时有更高的开销，因为无论条件是否为真，元素总是会被渲染并保留在DOM中，但是切换开销较小，因为只是改变了CSS。 使用场景：当元素需要非常频繁地切换显示状态时，使用 v-show 是更好的选择，因为它的性能开销较小。 之间的关系 共同点：都是用来根据条件展示或隐藏元素。 不同点： v-if 是“真正”的条件渲染，条件为假时不会渲染元素。 v-show 则始终渲染元素，只是简单地切换元素的CSS display 属性。 v-if 有更高的切换开销，v-show 有更高的初始渲染开销。 使用场景不同，v-if 适用于条件变化不频繁的情况，v-show 适用于条件变化非常频繁的情况。","tags":["前端软件开发"]},{"title":"Swin-Transformer论文分析","path":"/2024/08/26/Swin-Transformer论文总结/","content":"看起来是从图像角度进行计算，和vit原理差不多，都是将图像切成小块，每一个小块可以近似看为一个向量，注意力的计算也是基于这些向量进行的，二维的图像转为一维的向量进行训练学习。 全局自注意力机制，所有的token都可以相互联系起来，但这样计算量会特别特别大。Swin Transformer通过窗口（Window）来限制自注意力的范围，计算量就小很多, 简单来说，Swin Transformer把图像分成了很多个小窗口（Window），然后每个窗口里面的token只和窗口里的其他token互相作用。不过，如果窗口一直不动，每个窗口之间的token就不会交进行注意力的交互，这样会缺少全局信息（不够全局，在窗口内还是全局的）。所以, Swin Transformer就会每隔一层，移动一下窗口的位置（Shift Window），让这些窗口错开一部分。这样，原来在不同窗口里的token，就可以通过这次移动的窗口进行注意力的交互达到理论上的全局注意力机制。"},{"title":"行内元素和块级元素","path":"/2024/08/25/行内元素和块级元素/","content":"一. 元素种类 行内元素123456789&lt;a&gt; &lt;strong&gt; &lt;b&gt; &lt;em&gt; &lt;del&gt; &lt;span&gt; &lt;img&gt; &lt;input&gt; &lt;select&gt; 行内元素（inline elements）在HTML中指的是那些不会自动在其前后创建新行的元素，它们只占据必要的宽度，并且可以与其他行内元素并排显示。以下是一些关于行内元素的特点和示例，以帮助您更好地理解： 特点 不换行：行内元素通常不会独自占据一行，它们会与周围的文本或行内元素共享一行。 宽度：行内元素的宽度是由其内容决定的，而不是由外部容器或CSS样式定义的。 高度和行高：行内元素可以设置高度和行高，但这些样式可能不会影响元素的实际布局，因为行内元素通常只占据一行文本的高度。 垂直对齐：行内元素通常沿着它们的基线对齐，这意味着它们会与周围的文本基线对齐。 示例假设有以下HTML代码： 123&lt;p&gt; 这是一个段落，其中包含了一些&lt;em&gt;行内元素&lt;/em&gt;，比如&lt; strong &gt;加粗文本&lt;/ strong &gt;和&lt; a href=&quot;https://example.com&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt; 在这个例子中，&lt;em&gt;、&lt;strong&gt;和&lt;a&gt;都是行内元素。当这段代码在浏览器中渲染时，它们的表现如下： &lt;em&gt;会使其内容变为斜体。 &lt;strong&gt;会使其内容变为粗体。 &lt;a&gt;会创建一个链接。这些元素不会独自占据一行，而是与周围的文本共享同一行，就像这样：这是一个段落，其中包含了一些行内元素，比如加粗文本和链接。 块级元素12345678&lt;h1&gt;~&lt;h6&gt;&lt;p&gt;&lt;div&gt;&lt;ul&gt;&lt;ol&gt;&lt;li&gt;&lt;div&gt;&lt;dl&gt; 总是在新行上开始，默认占据一整行；高度，行高以及外边距和内边距都可控制；宽带始终是与浏览器宽度一样，与内容无关；它可以容纳内联元素和其他块元素。 空元素1&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 二、行内元素和块级元素的转换123456//定义元素为块级元素display: block//定义元素为行内元素display inline//定义元素为行display: inline-block 三、块级元素和行内元素的区别我们区分块级元素和行内元素，首先行内元素是在一行中能有多个的，块级元素是自己占一行的。接着可以从三个方面来查看 是否占据一行，还是能多个处于一行中，行内是可以的； 是否可以设置宽高，行内是不可以的。 行内元素只可以容纳文本和其他行内元素，块级元素啥都可以容纳 总结 行内元素和块级元素很好区分，顾名思义，行内就是能都在一行里的，一行可以有多个&lt;a&gt;标签，可以有多个&lt;input&gt;标签，而同类的还有&lt;span&gt;&#x2F;&lt;img &gt;&#x2F;&lt;strong&gt;等，这不就很容易记住了。而块级元素就是要自己占一行的，那不就有&lt;div&gt;，还有我们使用的列表&lt;ul&gt;&#x2F;&lt;ol&gt;，除此之外还有&lt;h1&gt;～&lt;h6&gt;&#x2F;&lt;p&gt;等等。 code example 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;行内元素转块级元素示例&lt;/title&gt; &lt;style&gt; /* 默认的 span 元素是行内元素 */ span &#123; background-color: yellow; padding: 10px; &#125; /* 将 span 元素转换为块级元素 */ .block-span &#123; display: block; width: 200px; text-align: center; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是普通的段落。&lt;/p&gt; &lt;span&gt;这是一个行内元素，默认不会独占一行，行内元素会和周围的文本紧密排列。&lt;/span&gt;aaa &lt;p&gt;行内元素的表现不会影响其他内容的布局。例如，&lt;span&gt;这是另一个行内元素&lt;/span&gt;，它仍然在当前行内。&lt;/p&gt; &lt;p&gt;下面展示一个被转换为块级元素的 &lt;code&gt;span&lt;/code&gt; 元素：&lt;/p&gt; &lt;span class=&quot;block-span&quot;&gt;这个 span 元素被转换为块级元素，会独占一行。&lt;/span&gt;aaa &lt;p&gt;由于被设置为块级元素，即使紧跟在其后的文本也会被移到下一行：&lt;/p&gt; &lt;span class=&quot;block-span&quot;&gt;块级元素通常具有宽度和高度，独占一行。&lt;/span&gt;aaa &lt;p&gt;这就是行内元素与块级元素的不同展示效果。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;","tags":["前端软件开发"]},{"title":"MMSegmentation基本概念-模型","path":"/2024/08/23/MMSegmentation基本概念-模型/","content":"ModelsWe usually define a neural network in a deep learning task as a model, and this model is the core of an algorithm. MMEngine abstracts a unified model BaseModel to standardize the interfaces for training, testing and other processes. All models implemented by MMSegmentation inherit from BaseModel, and in MMSegmentation we implemented forward and added some functions for the semantic segmentation algorithm. MMEngine抽象了一个统一的模型BaseModel, 目的是标准化训练，测试以及其它的流程。所有MMSegmentation实现的模型继承自BaseModel,在MMSegmentation中我们实现了前向传播和添加了一些语义分割算法的功能。 Common componentsSegmentorIn MMSegmentation, we abstract the network architecture as a Segmentor, it is a model that contains all components of a network. We have already implemented EncoderDecoder and CascadeEncoderDecoder, which typically consist of Data preprocessor, Backbone, Decode head and Auxiliary head. 在MMSegmentation中，我们将网络结构抽象为一个Segmentor, 这是一个包含网络所有组件的模型。我们已经实现了EncoderDecoder和CascadeEncoderDecoder，这两者典型地由Data preprocessor, Backbonem, Decode head和Auxiliary head构成。 Data preprocessorData preprocessor is the part that copies data to the target device and preprocesses the data into the model input format. 数据预处理器是将数据复制到目标设备并将数据预处理为模型输入格式的部分。 BackboneBackbone is the part that transforms an image to feature maps, such as a ResNet-50 without the last fully connected layer. 主干是将图像转换为特征图的部分，例如没有最后一个完全连接层的ResNet-50。 NeckNeck is the part that connects the backbone and heads. It performs some refinements or reconfigurations on the raw feature maps produced by the backbone. An example is Feature Pyramid Network (FPN). 颈部是连接骨干和头部的部分。它对骨干生成的原始特征图进行一些细化或重新配置。一个例子是特征金字塔网络（FPN）。 Decode headDecode head is the part that transforms the feature maps into a segmentation mask, such as PSPNet.解码头是将特征映射转换为分割掩码的部分，例如PSPNet。 Auxiliary headAuxiliary head is an optional component that transforms the feature maps into segmentation masks which only used for computing auxiliary losses.辅助头是一个可选组件，它将特征图转换为仅用于计算辅助损失的分割掩码。 Basic interfacesMMSegmentation wraps BaseModel and implements the BaseSegmentor class, which mainly provides the interfaces forward, train_step, val_step and test_step. The following will introduce these interfaces in detail. forwardThe forward method returns losses or predictions of training, validation, testing, and a simple inference process. forward。函数返回训练阶段的losses或predictions The method should accept three modes: “tensor”, “predict” and “loss”: “tensor”: Forward the whole network and return the tensor or tuple of tensor without any post-processing, same as a common nn.Module.“张量”：转发整个网络并返回张量的张量或元组，无需任何后处理，与普通的nn. Module相同。 “predict”: Forward and return the predictions, which are fully processed to a list of SegDataSample. 前向计算并返回预测，这些预测被完全处理到SegDataSample列表中。 “loss”: Forward and return a dict of losses according to the given inputs and data samples.根据给定的输入和数据样本转发和返回损失判断。 Note: SegDataSample is a data structure interface of MMSegmentation, it is used as an interface between different components. SegDataSample implements the abstract data element mmengine.structures.BaseDataElement, please refer to the [SegDataSample documentation](Note that this method doesn’t handle either backpropagation or optimizer updating, which are done in the method train_step.) and data element documentation in MMEngine for more information. Note that this method doesn’t handle either backpropagation or optimizer updating, which are done in the method train_step. Parameters: inputs (torch.Tensor) - The input tensor with shape (N, C, …) in general. data_sample (list[SegDataSample]) - The seg data samples. It usually includes information such as metainfo and gt_sem_seg. Default to None. mode (str) - Return what kind of value. Defaults to ‘tensor’. Returns: dict or list: If mode &#x3D;&#x3D; “loss”, return a dict of loss tensor used for backward and logging. If mode &#x3D;&#x3D; “predict”, return a list of SegDataSample, the inference results will be incrementally added to the data_sample parameter passed to the forward method, each SegDataSample contains the following keys: pred_sem_seg (PixelData): Prediction of semantic segmentation. seg_logits (PixelData): Predicted logits of semantic segmentation before normalization. If mode &#x3D;&#x3D; “tensor”, return a tensor or tuple of tensor or dict of tensor for custom use. prediction modes We briefly describe the fields of the model’s configuration in the config documentation, here we elaborate on the model.test_cfg field. model.test_cfg is used to control forward behavior, the forward method in “predict” mode can run in two modes: whole_inference: If cfg.model.test_cfg.mode &#x3D;&#x3D; ‘whole’, model will inference with full images. An whole_inference mode example config: 12345model = dict( type=&#x27;EncoderDecoder&#x27; ... test_cfg=dict(mode=&#x27;whole&#x27;)) slide_inference: If cfg.model.test_cfg.mode &#x3D;&#x3D; ‘slide’, model will inference by sliding-window. Note: if you select the slide mode, cfg.model.test_cfg.stride and cfg.model.test_cfg.crop_size should also be specified. An slide_inference mode example config: 12345model = dict( type=&#x27;EncoderDecoder&#x27; ... test_cfg=dict(mode=&#x27;slide&#x27;, crop_size=256, stride=170)) train_stepThe train_step method calls the forward interface of the loss mode to get the loss dict. The BaseModel class implements the default model training process including preprocessing, model forward propagation, loss calculation, optimization, and back-propagation. Parameters: data (dict or tuple or list) - Data sampled from the dataset. In MMSegmentation, the data dict contains inputs and data_samples two fields. optim_wrapper (OptimWrapper) - OptimWrapper instance used to update model parameters. Note: OptimWrapper provides a common interface for updating parameters, please refer to optimizer wrapper documentation in MMEngine for more information. Returns: Dict[str, torch.Tensor]: A dict of tensor for logging. val_stepThe val_step method calls the forward interface of the predict mode and returns the prediction result, which is further passed to the process interface of the evaluator and the after_val_iter interface of the Hook. Parameters: data (dict or tuple or list) - Data sampled from the dataset. In MMSegmentation, the data dict contains inputs and data_samples two fields. Returns: list - The predictions of given data. test_stepThe BaseModel implements test_step the same as val_step. Data PreprocessorThe SegDataPreProcessor implemented by MMSegmentation inherits from the BaseDataPreprocessor implemented by MMEngine and provides the functions of data preprocessing and copying data to the target device. The runner carries the model to the specified device during the construction stage, while the data is carried to the specified device by the SegDataPreProcessor in train_step, val_step, and test_step, and the processed data is further passed to the model. The parameters of the SegDataPreProcessor constructor: mean (Sequence[Number], optional) - The pixel mean of R, G, B channels. Defaults to None. std (Sequence[Number], optional) - The pixel standard deviation of R, G, B channels. Defaults to None. size (tuple, optional) - Fixed padding size. size_divisor (int, optional) - The divisor of padded size. pad_val (float, optional) - Padding value. Default: 0. seg_pad_val (float, optional) - Padding value of segmentation map. Default: 255. bgr_to_rgb (bool) - whether to convert image from BGR to RGB. Defaults to False. rgb_to_bgr (bool) - whether to convert image from RGB to BGR. Defaults to False. batch_augments (list[dict], optional) - Batch-level augmentations. Default to None. The data will be processed as follows: Collate and move data to the target device. Pad inputs to the input size with defined pad_val, and pad seg map with defined seg_pad_val. Stack inputs to batch_inputs. Convert inputs from bgr to rgb if the shape of input is (3, H, W). Normalize image with defined std and mean. Do batch augmentations like Mixup and Cutmix during training. The parameters of the forward method: data (dict) - data sampled from dataloader. training (bool) - Whether to enable training time augmentation. The returns of the forward method: Dict: Data in the same format as the model input.","tags":["MMSegmentation"]},{"title":"MMSegmentation从0.x迁移到1.x","path":"/2024/08/23/MMSegmentation从0-x迁移到1-x/","content":"New dependencies MMSegmentation 1.x 依赖于一些新的软件包，建议准备一个新的干净环境,然后根据安装教程重新安装。 手动安装以下软件包。 MMEngine：MMEngine 是 OpenMMLab 2.0 架构的核心，我们将许多与计算机视觉无关的内容从 MMCV 拆分到 MMEngine 中。 MMCV：OpenMMLab 的计算机视觉包。这不是一个新的依赖，但您需要将其升级到 2.0.0 或以上的版本。 MMClassification（可选）：OpenMMLab 的图像分类工具箱和基准。这不是一个新的依赖，但您需要将其升级到 1.0.0rc6 版本。 MMDetection(可选): OpenMMLab 的目标检测工具箱和基准。这不是一个新的依赖，但您需要将其升级到 3.0.0 或以上的版本。 Train launchThe main improvement of OpenMMLab 2.0 is releasing MMEngine which provides universal and powerful runner for unified interfaces to launch training jobs. Function Original New Conclusion Loading pre-trained checkpoint --load_from=$CHECKPOINT --cfg-options load_from=$CHECKPOINT 将load_from放到cfg-options下 Resuming Train from specific checkpoint --resume-from=$CHECKPOINT --resume=$CHECKPOINT resume-from简化为resume Resuming Train from the latest checkpoint --auto-resume --resume=&#39;auto&#39; –auto-resume默认为true修改为可以有多个resume的值的变量 Whether not to evaluate the checkpoint during training --no-validate --cfg-options val_cfg=None val_dataloader=None val_evaluator=None –no-validate默认为true修改为val_cfg, val_dataloader,val_evaluator这几个有多个值的变量 Training device assignment --gpu-id=$DEVICE_ID - 删掉了可以指定gpu-id的配置 Whether or not set different seeds for different ranks --diff-seed --cfg-options randomness.diff_rank_seed=True 将diff-seed放到cfg-options下 Whether to set deterministic options for CUDNN backend --deterministic --cfg-options randomness.deterministic=True 将deterministic放到cfg-options下 Test launchHere’s the provided information formatted into a Markdown table: Function 0.x 1.x Conclusion Evaluation metrics --eval mIoU --cfg-options test_evaluator.type=IoUMetric –eval 修改为–cfg-options mIou修改为有多个值的test_evaluator.type Whether to use test time augmentation --aug-test --tta aug-test修改为tta Whether save the output results without perform evaluation --format-only --cfg-options test_evaluator.format_only=True –format-only修改为–cfg-options，默认值为true修改为有多个值的test_evaluator.format_only Configuration fileModel settingsNo changes in model.backbone, model.neck, model.decode_head and model.losses fields.model.backbone, model.neck, model.decode_head and model.losses和MMSeg0.x相同 Add model.data_preprocessor field to configure the DataPreProcessor, including: 相对于MMSeg0.x添加了model.data_preprocessor 字段 mean (Sequence, optional): The pixel mean of R, G, B channels. Defaults to None. std (Sequence, optional): The pixel standard deviation of R, G, B channels. Defaults to None. size (Sequence, optional): Fixed padding size. size_divisor (int, optional): The divisor of padded size. seg_pad_val (float, optional): Padding value of segmentation map. Default: 255. padding_mode (str): Type of padding. Default: ‘constant’. constant: pads with a constant value, this value is specified with pad_val. bgr_to_rgb (bool): whether to convert image from BGR to RGB.Defaults to False. rgb_to_bgr (bool): whether to convert image from RGB to BGR. Defaults to False. Dataset settingsChanges in data: The original data field is split to train_dataloader, val_dataloader and test_dataloader. This allows us to configure them in fine-grained. For example, you can specify different sampler and batch size during training and test. The samples_per_gpu is renamed to batch_size. The workers_per_gpu is renamed to num_workers. data字段拆分为train_dataloader, val_dataloader, test_dataloader三个字段，可以在训练集，测试集分别指定不同的sampler和batch_size, samples_per_gpu重命名为batch_size， workers_per_gpu重命名为num_workers Original 1234567data = dict( samples_per_gpu=4, workers_per_gpu=4, train=dict(...), val=dict(...), test=dict(...),) New 123456789101112131415train_dataloader = dict( batch_size=4, num_workers=4, dataset=dict(...), sampler=dict(type=&#x27;DefaultSampler&#x27;, shuffle=True) # necessary)val_dataloader = dict( batch_size=4, num_workers=4, dataset=dict(...), sampler=dict(type=&#x27;DefaultSampler&#x27;, shuffle=False) # necessary)test_dataloader = val_dataloader Changes in pipeline: The original formatting transforms ToTensor、ImageToTensor、Collect are combined as PackSegInputs. 将ToTensor, ImageToTensor, Collect组合为一个字段PackSegInputs. We don’t recommend to do Normalize and Pad in the dataset pipeline. Please remove it from pipelines and set it in the data_preprocessor field. Normalize和Pad修改为在data_preprocessor中设置 The original Resize in MMSeg 1.x has been changed to RandomResize and the input arguments img_scale is renamed to scale, and the default value of keep_ratio is modified to False. Resize修改为RandomResize，不知道这两种Resize方式是否相同，img_scale重命名为scale,功能应该是相同的，keep_ration的默认值修改为False. The original test_pipeline combines single-scale test and multi-scale test together, in MMSeg 1.x we separate it into test_pipeline and tta_pipeline. train_pipeline: Original 123456789101112train_pipeline = [ dict(type=&#x27;LoadImageFromFile&#x27;), dict(type=&#x27;LoadAnnotations&#x27;, reduce_zero_label=True), dict(type=&#x27;Resize&#x27;, img_scale=(2560, 640), ratio_range=(0.5, 2.0)), dict(type=&#x27;RandomCrop&#x27;, crop_size=crop_size, cat_max_ratio=0.75), dict(type=&#x27;RandomFlip&#x27;, prob=0.5), dict(type=&#x27;PhotoMetricDistortion&#x27;), dict(type=&#x27;Normalize&#x27;, **img_norm_cfg), dict(type=&#x27;Pad&#x27;, size=crop_size, pad_val=0, seg_pad_val=255), dict(type=&#x27;DefaultFormatBundle&#x27;), dict(type=&#x27;Collect&#x27;, keys=[&#x27;img&#x27;, &#x27;gt_semantic_seg&#x27;]),] new: 12345678910111213train_pipeline = [ dict(type=&#x27;LoadImageFromFile&#x27;), dict(type=&#x27;LoadAnnotations&#x27;, reduce_zero_label=True), dict( type=&#x27;RandomResize&#x27;, scale=(2560, 640), ratio_range=(0.5, 2.0), keep_ratio=True), dict(type=&#x27;RandomCrop&#x27;, crop_size=crop_size, cat_max_ratio=0.75), dict(type=&#x27;RandomFlip&#x27;, prob=0.5), dict(type=&#x27;PhotoMetricDistortion&#x27;), dict(type=&#x27;PackSegInputs&#x27;)] test_pipeline: Original: 123456789101112131415test_pipeline = [ dict(type=&#x27;LoadImageFromFile&#x27;), dict( type=&#x27;MultiScaleFlipAug&#x27;, img_scale=(2560, 640), # img_ratios=[0.5, 0.75, 1.0, 1.25, 1.5, 1.75], flip=False, transforms=[ dict(type=&#x27;Resize&#x27;, keep_ratio=True), dict(type=&#x27;RandomFlip&#x27;), dict(type=&#x27;Normalize&#x27;, **img_norm_cfg), dict(type=&#x27;ImageToTensor&#x27;, keys=[&#x27;img&#x27;]), dict(type=&#x27;Collect&#x27;, keys=[&#x27;img&#x27;]), ])] New 12345678910111213141516171819202122test_pipeline = [ dict(type=&#x27;LoadImageFromFile&#x27;), dict(type=&#x27;Resize&#x27;, scale=(2560, 640), keep_ratio=True), dict(type=&#x27;LoadAnnotations&#x27;, reduce_zero_label=True), dict(type=&#x27;PackSegInputs&#x27;)]img_ratios = [0.5, 0.75, 1.0, 1.25, 1.5, 1.75]tta_pipeline = [ dict(type=&#x27;LoadImageFromFile&#x27;, backend_args=None), dict( type=&#x27;TestTimeAug&#x27;, transforms=[ [ dict(type=&#x27;Resize&#x27;, scale_factor=r, keep_ratio=True) for r in img_ratios ], [ dict(type=&#x27;RandomFlip&#x27;, prob=0., direction=&#x27;horizontal&#x27;), dict(type=&#x27;RandomFlip&#x27;, prob=1., direction=&#x27;horizontal&#x27;) ], [dict(type=&#x27;LoadAnnotations&#x27;)], [dict(type=&#x27;PackSegInputs&#x27;)] ])] 将transfor从test_pipeline中拎出来放到tta_pipeline(Test Time Augmentation Pipeline，用于提高模型预测性能的模块。这个模块通过对输入图像进行一系列的变换和增强，然后将这些变换后的图像输入到模型中，最后将这些预测结果进行融合，以得到最终的预测结果。这样做可以有效地提高模型的鲁棒性和准确性。）中。 Changes in evaluation: The evaluation field is split to val_evaluator and test_evaluator. And it won’t support interval and save_best arguments. The interval is moved to train_cfg.val_interval, and the save_best is moved to default_hooks.checkpoint.save_best. pre_eval has been removed.单一的evaluation拆分为val_evaluator和test_evaluator同时删除了interval和save_best参数，interval放到了train_cfg.val_interval下，save_best放到了default_hooks.checkpoint.save_best下，删掉了pre_eval ‘mIoU’ has been changed to ‘IoUMetric’. Original： 1evaluation = dict(interval=2000, metric=&#x27;mIoU&#x27;, pre_eval=True) New: 12val_evaluator = dict(type=&#x27;IoUMetric&#x27;, iou_metrics=[&#x27;mIoU&#x27;])test_evaluator = val_evaluator Optimizer and Schedule settingsChanges in optimizer and optimizer_config: Now we use optim_wrapper field to specify all configuration about the optimization process. And the optimizer is a sub field of optim_wrapper now.将optimizer封装到optim_wrapper下。 paramwise_cfg is also a sub field of optim_wrapper, instead of optimizer.原本在optimizer下的optim_wrapper移动到了paramwise_cfg下。 optimizer_config is removed now, and all configurations of it are moved to optim_wrapper. 删除了optimizer_config。 grad_clip is renamed to clip_grad. grad_clip重命名为clip_grad。 Original 12optimizer = dict(type=&#x27;AdamW&#x27;, lr=0.0001, weight_decay=0.0005)optimizer_config = dict(grad_clip=dict(max_norm=1, norm_type=2)) New 1234optim_wrapper = dict( type=&#x27;OptimWrapper&#x27;, optimizer=dict(type=&#x27;AdamW&#x27;, lr=0.0001, weight_decay=0.0005), clip_grad=dict(max_norm=1, norm_type=2)) Changes in lr_config: The lr_config field is removed and we use new param_scheduler to replace it. 用param_scheduler替换掉了lr_config, 不知道内部是否做了修改 The warmup related arguments are removed, since we use schedulers combination to implement this functionality. 删除了warmup相关的参数，改用schedulers combination实现对应的功能。 The new schedulers combination mechanism is very flexible, and you can use it to design many kinds of learning rate &#x2F; momentum curves. See the tutorial for more details. 新的schedulers combination可以实现多种learning rate &#x2F; momentum curves。 Original： 12345678lr_config = dict( policy=&#x27;poly&#x27;, warmup=&#x27;linear&#x27;, warmup_iters=1500, warmup_ratio=1e-6, power=1.0, min_lr=0.0, by_epoch=False) New: 123456789101112param_scheduler = [ dict( type=&#x27;LinearLR&#x27;, start_factor=1e-6, by_epoch=False, begin=0, end=1500), dict( type=&#x27;PolyLR&#x27;, power=1.0, begin=1500, end=160000, eta_min=0.0, by_epoch=False, )] Changes in runner: Most configuration in the original runner field is moved to train_cfg, val_cfg and test_cfg, which configure the loop in training, validation and test.大部分原来的runner字段被移动到了train_cfg，val_cfg和test_cfg中 Original： 1runner = dict(type=&#x27;IterBasedRunner&#x27;, max_iters=20000) New: 1234# The `val_interval` is the original `evaluation.interval`.train_cfg = dict(type=&#x27;IterBasedTrainLoop&#x27;, max_iters=20000, val_interval=2000)val_cfg = dict(type=&#x27;ValLoop&#x27;) # Use the default validation loop.test_cfg = dict(type=&#x27;TestLoop&#x27;) # Use the default test loop. In fact, in OpenMMLab 2.0, we introduced Loop to control the behaviors in training, validation and test. The functionalities of Runner are also changed. You can find more details of runner tutorial in MMEngine. Runtime settingsChanges in checkpoint_config and log_config: The checkpoint_config are moved to default_hooks.checkpoint and the log_config are moved to default_hooks.logger. And we move many hooks settings from the script code to the default_hooks field in the runtime configuration. checkpoint_config被移动到了default_hooks.checkpoint， log_config 被移动到了 default_hooks.logger，从script code移动了很多hooks settings到runtime configuration中的default_hooks。 123456789101112131415161718default_hooks = dict( # record the time of every iterations. timer=dict(type=&#x27;IterTimerHook&#x27;), # print log every 50 iterations. logger=dict(type=&#x27;LoggerHook&#x27;, interval=50, log_metric_by_epoch=False), # enable the parameter scheduler. param_scheduler=dict(type=&#x27;ParamSchedulerHook&#x27;), # save checkpoint every 2000 iterations. checkpoint=dict(type=&#x27;CheckpointHook&#x27;, by_epoch=False, interval=2000), # set sampler seed in distributed environment. sampler_seed=dict(type=&#x27;DistSamplerSeedHook&#x27;), # validation results visualization. visualization=dict(type=&#x27;SegVisualizationHook&#x27;)) In addition, we split the original logger to logger and visualizer. The logger is used to record information and the visualizer is used to show the logger in different backends, like terminal and TensorBoard. 将original logger划分为logger和visualizer. logger用于记录信息， visualizer被用于以不同的后端显示logger（terminal和TensorBoard） Original： 123456log_config = dict( interval=100, hooks=[ dict(type=&#x27;TextLoggerHook&#x27;), dict(type=&#x27;TensorboardLoggerHook&#x27;), ]) New: 12345678default_hooks = dict( ... logger=dict(type=&#x27;LoggerHook&#x27;, interval=100),)vis_backends = [dict(type=&#x27;LocalVisBackend&#x27;), dict(type=&#x27;TensorboardVisBackend&#x27;)]visualizer = dict( type=&#x27;SegLocalVisualizer&#x27;, vis_backends=vis_backends, name=&#x27;visualizer&#x27;) Changes in load_from and resume_from: The resume_from is removed. And we use resume and load_from to replace it. 删除了resume_from，使用resume和load_from替代，不知道是否需要修改代码以适配。 If resume&#x3D;True and load_from is not None, resume training from the checkpoint in load_from. If resume&#x3D;True and load_from is None, try to resume from the latest checkpoint in the work directory. If resume&#x3D;False and load_from is not None, only load the checkpoint, not resume training. If resume&#x3D;False and load_from is None, do not load nor resume. Changes in dist_params: The dist_params field is a sub field of env_cfg now. And there are some new configurations in the env_cfg. Changes in dist_params: The dist_params field is a sub field of env_cfg now. And there are some new configurations in the env_cfg. dist_params作为一个子字段放到了env_cfg下。 12345678910env_cfg = dict( # whether to enable cudnn benchmark cudnn_benchmark=False, # set multi process parameters mp_cfg=dict(mp_start_method=&#x27;fork&#x27;, opencv_num_threads=0), # set distributed parameters dist_cfg=dict(backend=&#x27;nccl&#x27;),) Changes in workflow: workflow related functionalities are removed. workflow相关的功能被删除。 New field visualizer: The visualizer is a new design in OpenMMLab 2.0 architecture. We use a visualizer instance in the runner to handle results &amp; log visualization and save to different backends. See the visualization tutorial for more details. visualizer在OpenMMLab2.0中是一个新设计。 New field default_scope: The start point to search module for all registries. The default_scope in MMSegmentation is mmseg. See the registry tutorial for more details. default_scope是一个新加的字段 在MMSegmentation中default_scope是mmseg。","tags":["MMSegmentation"]},{"title":"JavaScript","path":"/2024/08/22/JavaScript/","content":"代码示例：学习和调试 JavaScript 数组方法123456789101112131415161718192021222324252627282930313233343536373839// Array.from() 和 fill() 示例// 创建一个包含 5 个 0 的数组let array1 = Array.from(&#123; length: 5 &#125;, () =&gt; 0);// 两个参数，一个字典（key为length），一个函数（返回每个元素）console.log(&#x27;Array.from() 填充 0:&#x27;, array1); // 输出: [0, 0, 0, 0, 0]// 用嵌套的 Array.from() 创建二维数组let n = 3;let dp = Array.from(Array(n + 1), () =&gt; Array(n + 1).fill(0));console.log(&#x27;二维数组 (dp):&#x27;, dp);// 输出: 一个 (n+1) 大小的二维数组，所有元素都填充为 0// Array.of() 示例let array2 = Array.of(1, 2, 3, 4, 5);// 和python array2 = [1, 2, 3, 4, 5]差不多console.log(&#x27;Array.of():&#x27;, array2); // 输出: [1, 2, 3, 4, 5]// sort() 示例（降序排序）let array3 = [3, 1, 4, 1, 5];array3.sort((a, b) =&gt; b - a);// 从小到大排序就是(a, b) =&gt; a - b, 从大到小排序就是(a, b) =&gt; b - aconsole.log(&#x27;排序后的数组:&#x27;, array3); // 输出: [5, 4, 3, 1, 1]// copyWithin() 示例let array4 = [1, 2, 3, 4, 5];array4.copyWithin(0, 3);console.log(&#x27;copyWithin(0, 3) 结果:&#x27;, array4);// 将2号位开始到数组末尾的元素搬到一号位开始的位置// 输出: [4, 5, 3, 4, 5] -&gt; 从索引 3 开始的元素被复制到起始位置// find() 示例let found = array4.find(element =&gt; element &gt; 4);console.log(&#x27;找到第一个大于 4 的元素:&#x27;, found); // 输出: 5// findIndex() 示例let index = array4.findIndex(element =&gt; element === 3);console.log(&#x27;第一个值为 3 的元素索引:&#x27;, index); // 输出: 2// fill() 示例let array5 = [1, 2, 3, 4, 5];array5.fill(9, 1, 3);console.log(&#x27;fill(9, 1, 3) 结果:&#x27;, array5);// 输出: [1, 9, 9, 4, 5] -&gt; 从索引 1 到 3 之间填充 9"},{"title":"积分图像编程实现","path":"/2024/08/21/积分图像编程实现/","content":"维基百科：积分图原图： 积分图： 积分图的每一点（x, y）的值是原图中对应位置的左上角区域的所有值得和 而且，积分图可以只遍历一次图像即可有效的计算出来，因为积分图每一点的（x, y）值是： 一旦积分图计算完毕，对任意矩形区域的和的计算就可以在常数时间内完成。如右图中，阴影矩形区域的值："},{"title":"vue前端开发框架概述","path":"/2024/08/21/vue前端开发框架概述/","content":"渐进式JavaScript框架渐进式（Progressive）：逐步集成：这意味着你可以从项目中的一部分开始使用Vue.js，而不需要全面重构。例如，你可以先在一个小部件中使用Vue.js，然后逐渐扩展到整个应用程序。易用性：Vue.js的设计注重易用性，使得开发者可以快速上手，即使他们之前没有使用过类似的框架。 JavaScript框架：基于JavaScript：Vue.js是一个基于JavaScript的库，它使用HTML、CSS和JavaScript来构建用户界面。框架特性：虽然Vue.js被宣传为一个框架，但它实际上是一个库，因为它不强制你遵循特定的项目结构或代码组织方式。但是，它提供了足够的工具和特性，如组件系统、状态管理、路由等，使其在功能上接近于一个框架。 完全响应式的渲染系统“完全响应式的渲染系统”是Vue.js的一个核心特性，它指的是Vue.js能够自动追踪依赖并在数据变化时更新DOM的能力。 响应式数据绑定Vue.js的响应式系统基于Object.defineProperty()（Vue 2.x）或Proxy（Vue 3.x）实现，它使得Vue实例中的数据对象变得“响应式”。这意味着当数据对象的属性被访问或修改时，Vue能够自动检测到这些变化，并且可以执行相应的操作。 响应式原理依赖收集：当组件渲染时，它会访问所需数据的属性，Vue会记录这些属性的访问，这个过程称为“依赖收集”。每个属性都关联一个或多个观察者（Watcher）。变更检测：当数据发生变化时，Vue会通知所有依赖于该数据的观察者。重新渲染：观察者接收到数据变更的通知后，会触发组件的重新渲染过程，Vue会高效地更新DOM以反映最新的数据状态。 完全响应式的特点自动更新：开发者不需要手动操作DOM来更新视图，Vue会自动完成这一过程。最小化DOM操作：Vue的渲染系统会智能地计算出需要变更的最小DOM集合，并只更新这部分，从而提高性能。声明式：Vue使用声明式渲染，开发者只需描述应用的状态，Vue会负责状态的变更到视图的映射。声明式编程是一种编程范式，它关注于“要做什么”，而不是“如何去做”。在声明式渲染中，你只需要描述应用的最终状态，而Vue.js会负责根据这些描述来更新实际的DOM。一个简单的Vue声明式渲染的例子： 123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=&quot;reverseMessage&quot;&gt;反转消息&lt;/button&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;); &#125; &#125;&#125;);&lt;/script&gt; 在这个例子中： 是一个插值表达式，它声明了标签的内容应该与Vue实例的message数据属性绑定。v-on:click&#x3D;”reverseMessage” 是一个事件监听器指令，它声明了当按钮被点击时，应该调用reverseMessage方法。当reverseMessage方法被调用，message的值会被反转，由于Vue的响应式系统，插值表达式会自动更新，显示反转后的消息，而不需要开发者手动操作DOM。 组件化：响应式系统在组件级别上工作，每个组件都有自己的响应式数据，组件的状态变化只会影响该组件的DOM，不会影响其他组件。 一个前端开发框架，封装了常用的前端开发wheels,提高了程序员前端开发的效率 组件化开发 声明式渲染 双向数据绑定 指令系统 过渡效果 路由管理 状态管理 工具链 社区和生态系统 文档和教程 跨平台开发","tags":["前端软件开发"]},{"title":"计算机学习之实践分析","path":"/2024/08/20/计算机学习之实践分析/","content":"有兴趣肯动手成为一种优势的前提是能够将这些实践经验用于学习对应的理论（这种理论在有实践经验下学习可以弥补和别人不动手直接学和自己肯动手这件事情本身所用的时间之差）"},{"title":"MMSegmentation如何集成tensorboard","path":"/2024/08/19/MMSegmentation如何配置tensorboard/","content":"VisualizationMMSegmentation 1.x provides convenient ways for monitoring training status or visualizing data and model predictions. Training status MonitorMMSegmentation 1.x uses TensorBoard to monitor training status. TensorBoard ConfigurationInstall TensorBoard following official instructions e.g. 12pip install tensorboardXpip install future tensorboard Add TensorboardVisBackend in vis_backend of visualizer in default_runtime.py config file:12345vis_backends = [dict(type=&#x27;LocalVisBackend&#x27;), dict(type=&#x27;TensorboardVisBackend&#x27;)] visualizer = dict( type=&#x27;SegLocalVisualizer&#x27;, vis_backends=vis_backends, name=&#x27;visualizer&#x27;) Modify the config file12345678910111213...vis_backends = [ dict(type=&#x27;LocalVisBackend&#x27;), dict(type=&#x27;TensorboardVisBackend&#x27;)]visualizer = dict( name=&#x27;visualizer&#x27;, type=&#x27;SegLocalVisualizer&#x27;, vis_backends=[ dict(type=&#x27;LocalVisBackend&#x27;), dict(type=&#x27;TensorboardVisBackend&#x27;) ])... Examining scalars in TensorBoardLaunch training experiment e.g. 12345python tools/train.py configs/pspnet/pspnet_r50-d8_4xb4-80k_ade20k-512x512.py --work-dir work_dir/test_visual``` Find the vis_data path of work_dir after starting training, for example, the vis_data path of this particular test is as follows: ```bashwork_dirs/test_visual/20220810_115248/vis_data The scalar file in vis_data path includes learning rate, losses and data_time etc, also record metrics results and you can refer logging tutorial in MMEngine to log custom data. The tensorboard visualization results are executed with the following command: 1tensorboard --logdir work_dirs/test_visual/20220810_115248/vis_data"},{"title":"从bilibili我是小土堆up主那里学习到的软件开发经验","path":"/2024/08/18/从bilibili我是小土堆up主那里学习到的软件开发经验/","content":"打造高效的软件开发工作流高效的软件开发工作流是软硬件协同，对瑞士军刀式的工具首先要正反两面地分析，不同工具组合带来的综合能力才是真正的“瑞士军刀”"},{"title":"工匠精神","path":"/2024/08/17/工匠精神/","content":"工匠精神在竞争激烈的社会中是保持竞争优势的重要素质工匠精神不是一味的增加工作时间，而是在看准方向后的认真工作，需要抵制诱惑，虽然在AI时代可能通过广泛的涉猎对使用AI有一定的好处，但从提升判断力的角度，只追求广度是不行的，光有广度不代表就有很强的判断力，且AI现在的体系还不能完全排除人工的介入，在确定方向后，对我自己的学习情况来说，一定程度上地发扬“工匠精神”是短期提升判断力的关键。"},{"title":"英语","path":"/2024/08/16/英语/","content":"多学会一门语言，就多掌握一种思维方式falter“Falter” means to hesitate or waver in one’s actions or intentions, often due to uncertainty or lack of confidence. It can also refer to a physical unsteadiness or a weakening in one’s performance or strength.Example sentence: The speaker faltered when she forgot her next point in the speech. His confidence in the business plan started to falter after the market analysis. Spur“Spur” can be both a noun and a verb.As a noun, a spur is a small pointed device attached to a rider’s boot, used to urge a horse to move faster. It can also refer to something that prompts or encourages a action or process.As a verb, to spur means to encourage or stimulate someone or something to do something more quickly or with more energy.Example sentences: Noun: The cowboy wore spurs to control his horse. Verb: The company’s new policy is designed to spur innovation among its employees. landscape“Landscape” refers to the physical features of a piece of land, including natural elements like mountains, rivers, and trees, as well as man-made structures like buildings and roads. It’s often used to describe the overall appearance of an area of land, whether in a natural, rural setting or an urban environment.Example sentence: “The photographer took a stunning picture of the mountain landscape at sunset.” fine-grained“Fine-grained” refers to something that is very detailed or intricate. It is often used to describe materials, data, or analysis that involves small, distinct parts or elements. For example, in the context of data analysis, “fine-grained data” would mean data that is very detailed and specific, allowing for a deep level of understanding or analysis.Example sentence: The researcher used fine-grained analysis to understand the intricate details of the data. unified“Unified” means to bring together separate elements into a single, cohesive whole. It often refers to the process of combining different things or groups to function as one. For example, “The company aims to unify its various departments to improve communication and efficiency.”In a sentence: “The new software successfully unified the data from different sources, making it easier to analyze.” delineating“Delineating” means outlining or defining something clearly. It’s often used to describe the act of drawing a clear boundary or explaining something in detail. For example, in a scientific report, you might delineate the different stages of a process.Example sentence: The architect delineated the plans for the new building, showing every detail of the structure. sliceThe word “slice” can be used both as a noun and a verb in English.As a noun: A thin, flat piece cut from something, such as a piece of cake, meat, or cheese. Example: She cut a slice of cake for everyone at the party. A share or portion of something. Example: He wants a bigger slice of the profits.As a verb: To cut something into thin, flat pieces. Example: She sliced the tomatoes for the salad. To hit a ball in a way that makes it spin sideways, causing it to curve in the air. Example: The golfer sliced his drive into the rough.In summary, “slice” refers to cutting something into thin pieces or a share of something, and can also describe a type of swing or hit in sports like golf. facilitating“Facilitating” means making something easier or more likely to happen. It involves helping a process or activity to run smoothly and effectively. For example, in a meeting, a facilitator helps guide the discussion and ensures everyone has a chance to speak.Example sentence: The new software is designed to facilitate communication between different departments in the company. dynamicDynamic is an adjective that describes something that is always changing or moving. It can also refer to a process or system that is active and capable of changing or being changed. For example, in a business context, a “dynamic market” is one that is constantly changing.Example sentence: The dynamic nature of technology means that new innovations are always emerging."},{"title":"从AI编程认知AI","path":"/2024/08/16/从AI编程认知AI/","content":"输入输出全是文本的场景，尝试用大模型去提效 软件开发领域市场调研需求分析PRD撰写图形元素绘制技术选型代码生成(文本输入+GPT4V)代码审查编写测试用例运维 最好最新的模型带来更好更新的能力编程能力是大模型各项能力的天花板 技术leader 训练数据质量高结果可衡量编程语言无二义性训练编程可提高大模型的推理能力 使用AI编程，除了解决编程问题以外，更重要是形成对AI的正确认知。 AI编程的适用场景1.技术我懂，不想自己写帮我完成重复性工作帮我完成也要费费脑子才能写出来代码2.技术不大懂，让AI先做，自己边用边学当心ta犯错当心给的不是最佳方案如果完全不懂技术，AI编程的帮助不大。 如果一个机器绝对不会犯错，它就不可能是智能的。-阿兰图灵AI的幻觉不可完全消除，只能尽可能压制.所以，使用者的判断力，决定了AI能力的上限.就像团队领导，是团队的上限一样。 AI能力定律：AI能力的上限，是使用者的判断力AI能力 &#x3D; min(AI能力，使用者判断力) AI提效定律：AI提升的效率，与使用者的判断力成正比，与生产力成反比效率提升幅度 &#x3D; 使用者判断力&#x2F;使用者生产力 解读 使用者的判断力，是最重要的 提升判断力，比提升实操能力更重要。所谓”眼高手低”者的福音 广阔的视野是判断力的养料"},{"title":"软件工程师沉淀","path":"/2024/08/15/软件工程师沉淀/","content":"到底是学的多好还是学的深入好?如果学的是是技术的经典理论的话，那么毫无疑问是学的多更好，前提是能够学懂学好。如果是学习技术应用的话，需要知道的是应用是基于底层技术的上层建筑，如果从底层技术的角度分析，那么大多数技术应用在技术底层是同质化严重的，如果沉迷于学的多，对于通过项目来引导理论学习的人来说，可能会无法触及的更深层次的技术理论，从而在对技术的理解上显得局限，虽然这个和性格也有一定关系，但我认为软件工程师认真地学精可能比粗略地学广泛更有意义。"},{"title":"翁恺Java语言程序设计学习心得","path":"/2024/08/12/翁恺Java语言程序设计学习心得/","content":"对我而言是一门编程启蒙课，更多的是偏认知的学习，比如: 对于程序员学习角度来说，不要害怕去在电脑上编程，大不了重启一下电脑，对电脑没啥影响，可以学习到东西才是相对重要的。 对于程序实现的信心：只要我想做某个程序，且这个程序比较有趣，有足够多的时间和精力去做时，我是能够做出一些可运行的版本甚至是让我自己觉得有成就感的程序的。 好的程序员从我观察来看都具备非常优秀的软件思维，但这究竟是不是我现阶段应该重点关注的重点，我现在的观点是不是，从github的优秀开源项目中可以看出，好的软件开发项目不是一蹴而就的，即便是厉害的程序员，都是采用一种迭代式开发的流程，如果一开始就想构思出一个非常完美的软件项目，很容易陷入一种空想主义中而脱离实际开发情况，从我的角度来看，在“做”中不断锤炼优秀的软件思维才是合理的程序员成长路径，一个有大量开发经验即便不主动学习优秀软件思维的程序员或多或少也能自己总结出很多软件思维的，我的悟性尚能满足我学习的需要，我所需要做的就是不断训练自己在编程中兼顾实现与编程思维两者的平衡，程序的价值最终可能不仅只是技术本身，还有产品相关的能力，这也是程序员必须思考的问题，持续进行版本迭代也很重要，这可以帮助程序员建立全局观念，不局限于低效的代码学习中，技术的本质是分析和解决问题的能力，对于程序员来说，同样是技术人员，只是工具是电脑，我的目标应该是成为一名优秀的软件工程师。"},{"title":"pytorch中相关概念","path":"/2024/08/10/pytorch中相关概念/","content":"tensor在PyTorch中，torch.Tensor是存储和变换数据的主要工具。 Tensor与Numpy的多维数组非常相似。 Tensor还提供了GPU计算和自动求梯度等更多功能，这些使Tensor更适合深度学习。 123456x = torch.empty(5,3)x = torch.rand(5,3)x = torch.randn(2,3)x = torch.zeros(5,3,dtype=long)x = torch.tensor([5.5,3])... torch.nn.Conv2d"},{"title":"如何读懂大型软件项目源代码?","path":"/2024/08/07/如何读懂大型软件项目源代码/","content":"用好Notion软件，利用此软件可以按层级关系将零散代码逻辑在脑海中形成一个整体框架，也可以结合xmind等软件更直接地展示代码结构。 运行软件项目，通过输入输出来给人脑提供关键代码链路的思绪。比如如果项目是用python语言构建的，通过添加print语句实现变量的跟踪。还可以利用代码调试功能，比如断点，逐步执行代码，实时查看变量变化和函数调用情况。 利用好visio这类软件表示更多的逻辑关系。还可以使用 UML 图（如类图、时序图）来表示系统的静态结构和动态行为，这可以帮助更好地理解面向对象设计。 分清楚影响理解框架代码的原因是啥，如果是各个小的模块理解错误，那就需要逐个击破来理解整体。在理解小模块时，可以结合单元测试。编写和运行单元测试不仅能验证模块功能，还能帮助理解模块的输入输出和依赖关系。 对大的目录进行归纳总结，最好是记录在Notion上，记录关键模块、类、函数的作用和关系，以便日后查阅，因为代码较多，后续如果再来看可能忘记了，忘记了就需要再看一遍，相当于思维不集中会影响效率，有些时候可能总结的内容（也就是压缩过的内容）就足以理解了 需要高度集中，最好进入心流状态，最好用一整段时间去理解，下次理解相当于需要再从代码和文档中找到当时的理解水平。 IDE的全局关键字检索功能很有用，比如vscode可以显示所有包含指定关键字的文件引用，可以帮助构建代码框架逻辑。除了 VSCode，还可以使用更专业的代码搜索工具，如 Sourcegraph 或 Opengrok，支持跨项目搜索和代码导航。 面向对象思维，通过对象，模块，组件来构建系统的认识。可以学习设计模式（Design Patterns），如《设计模式：可复用面向对象软件的基础》一书中提到的23种经典设计模式，帮助理解和应用面向对象思想。 明确改动哪些地方对系统运行有影响，哪些地方改动对系统没有影响及如何在系统上增加功能，如何在增加功能的同时不破坏原有系统的优良设计，如何重构原来系统中不合理的逻辑设计。在进行代码改动前，可以使用代码覆盖率工具（如 Coverage.py）和静态代码分析工具（如 SonarQube），评估改动的潜在影响和风险。 阅读官方文档，理解开发者的设计思路。还可以查阅社区文档、技术博客和开发者论坛，获取更多实战经验和最佳实践。 算法能力的学习，大型软件项目一般开发人员水平较高，用到了大量数据结构与算法的思想，如果算法能力不足再看到相关代码实现会觉得理解不足或觉得这些算法是框架本身的创新。建议系统学习算法与数据结构，可以参考《算法导论》（CLRS）这本书，并在 LeetCode、HackerRank 等平台上实践。 如果能问原开发者还是要先问，理解框架的目的就是应用框架，如何快速的掌握一个框架的能力是追求的目标，然后再谈框架的进阶理解，否则进阶学习也是低效的。在问原开发者时，可以提前准备好问题，并尝试提出一些自己的理解和解决方案，展示你的思考过程，往往能得到更有针对性的指导。"},{"title":"python面向对象总结","path":"/2024/08/03/python面向对象总结/","content":"何为面向对象？类：图纸父类：可以理解为基础类，这里需要正确理解父类这个名词所包含的等级高的信息，父类中的属性和方法是一个基础子类：从父类中衍生出来的类，具备父类中的基础，可以在父类上做扩展方法，也可以重写父类的方法和属性注意：父类不代表比子类更丰富，子类拓展父类，这里不能通过等级层次去理解，更合理的方法是从进化的角度分析这两个概念 对象：根据图纸造出来的车继承：python中子类会继承父类的方法和属性，包括私有属性和私有方法，但通常不建议使用它们 封装：主要利用私有属性和私有方法实现封装，好处就是修改这个类的内部方法而不影响使用这个类的代码（比如有更优的算法可以实现排序，那就可以直接替换封装好的类的排序方法而不用改动调用这个类的代码） 多态：多态允许使用一个单一类型的实体（如变量，函数，接口）来代表多种类型的对象，简单来说，多态就是“一个接口，多种实现”。 代码例子： 123456789101112131415161718192021222324252627282930313233class Animal: def speak(self): passclass Dog(Animal): def speak(self): return &quot;Woof!&quot;class Cat(Animal): def speak(self): return &quot;Meow!&quot;class Duck(Animal): def speak(self): return &quot;Quack!&quot;def animal_sound(animal): print(animal.speak())# 创建不同的动物对象dog = Dog()cat = Cat()duck = Duck()# 使用相同的函数调用不同对象的方法animal_sound(dog) # 输出: Woof!animal_sound(cat) # 输出: Meow!animal_sound(duck) # 输出: Quack!# 多态性在集合中的应用animals = [Dog(), Cat(), Duck()]for animal in animals: animal_sound(animal) 可以看到多态的几个关键特点: 方法重写: 每个子类(Dog, Cat, Duck)都重写了父类Animal的speak()方法。这允许每个子类提供自己的实现。统一接口: 所有的动物类都有一个speak()方法,这提供了一个统一的接口。运行时多态: animal_sound()函数接受一个Animal类型的参数,但它可以处理任何Animal的子类。在运行时,Python会调用对象实际类型的speak()方法。灵活性: 我们可以轻松地添加新的动物类(如Cow),只要它实现了speak()方法,就可以无缝地与现有代码工作。 如何理解多态？通过编写处理父类对象的代码，这些代码可以用于所有的子类对象，即通过父类就可以实现（批量&#x2F;统一）管理不同的子类对象，这些子类对象继承父类有多种实现，差不多等于多态的子类对象。 如何理解对象和类class的关系？图纸和图纸造出来的东西的关系，在看项目源代码时，看到class很容易就想是不是这个类里面的代码完成了对应的功能，从最终执行来说，确实是这样，但准确来说这不是面向对象编程(oop)的思想，按照oop来说是这个class构造的对象实现了相关的功能，oop中一切皆是对象，这里我还没有从传统的顺序执行的代码编程中跳出来。 设计类class的原则单一职责原则（SRP）：一个类应该只有一个引起变化的原因。这意味着一个类应该只负责一项功能或一组紧密相关的功能。开放&#x2F;关闭原则（OCP）：类应该对扩展开放，对修改关闭。这意味着你应当能够扩展一个类的行为，而不需要修改其源代码。里氏替换原则（LSP）：派生类必须能够替换其基类。这意味着基类和派生类应该能够互相替换，而不影响程序的正确性。接口隔离原则（ISP）：不应该强迫客户依赖于它们不使用的接口。这意味着一个类不应该实现它不需要的方法。依赖倒置原则（DIP）：高层模块不应该依赖于低层模块，它们都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。封装：隐藏内部实现细节，只暴露必要的接口。这有助于减少系统各部分之间的依赖关系。重用：尽可能重用代码。这可以通过创建可重用的类和模块来实现。灵活性：设计时要考虑未来可能的变化，使类和模块易于修改和扩展。简洁性：避免不必要的复杂性。类应该简单、直接，易于理解。可测试性：类应该易于测试。这通常意味着它们应该具有清晰的职责，并且应该尽量减少依赖关系。 包装类（Wrapper Class）子类和包装类的区别和联系a. 继承关系子类：继承自一个父类，子类拥有父类的属性和方法，并可以对其进行扩展或重写。包装类：包装类通常是final类，不能被继承。这意味着你不能创建一个继承自包装类的子类。例如，Integer类是final的，不能被继承。b. 扩展能力子类：子类可以通过继承父类的属性和方法，并添加新的功能。通过多态，子类对象可以被看作父类对象使用。包装类：包装类不能被继承，因此不能扩展。但是它们提供了基本类型的对象化功能和一些额外的实用方法。c. 多态性子类：子类对象可以被赋值给父类引用，体现了多态性。例如，Animal类的子类Dog可以被赋值给Animal类型的变量。包装类：包装类不是基本类型的子类，所以不能将基本类型赋值给包装类变量，反之亦然。需要通过装箱和拆箱来转换。 总结联系：包装类是基本类型的对象化表示，通过装箱和拆箱机制，使得基本类型可以作为对象使用。它们和基本类型密切相关，但并不继承自基本类型。区别：包装类通常是final类，不能继承，不能扩展。而子类可以继承和扩展父类的功能，支持多态性。包装类主要用于在需要对象的地方表示基本类型，同时提供了额外的实用功能。 自定义类的包装类自定义包装类可以为原始类提供额外的功能、接口或封装逻辑，同时保持对原始类的控制。比如，你可以为一个类提供额外的验证逻辑、线程安全功能，或者通过包装类实现某些设计模式。 示例：自定义类及其包装类我们先定义一个简单的类，然后为它编写一个包装类。 原始类：Person 123456789101112131415161718192021222324252627282930public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;name=&#x27;&quot; + name + &quot;&#x27;, age=&quot; + age + &quot;&#125;&quot;; &#125;&#125; 包装类：PersonWrapper我们可以创建一个包装类 PersonWrapper，它包含一个 Person 对象，并提供额外的功能。 123456789101112131415161718192021222324252627282930313233343536373839public class PersonWrapper &#123; private Person person; public PersonWrapper(Person person) &#123; this.person = person; &#125; public String getName() &#123; return person.getName(); &#125; public int getAge() &#123; return person.getAge(); &#125; // 提供额外的功能 public void printGreeting() &#123; System.out.println(&quot;Hello, &quot; + person.getName() + &quot;! You are &quot; + person.getAge() + &quot; years old.&quot;); &#125; // 你还可以通过包装类对原始类的行为进行控制或修改 public void setName(String name) &#123; System.out.println(&quot;Setting name to: &quot; + name); person.setName(name); &#125; public void setAge(int age) &#123; if (age &gt; 0) &#123; person.setAge(age); &#125; else &#123; System.out.println(&quot;Invalid age!&quot;); &#125; &#125; @Override public String toString() &#123; return &quot;PersonWrapper&#123;person=&quot; + person + &quot;&#125;&quot;; &#125;&#125; 使用包装类 123456789101112131415161718public class Main &#123; public static void main(String[] args) &#123; Person person = new Person(&quot;Alice&quot;, 30); PersonWrapper personWrapper = new PersonWrapper(person); // 使用包装类调用原始类的方法 System.out.println(&quot;Name: &quot; + personWrapper.getName()); System.out.println(&quot;Age: &quot; + personWrapper.getAge()); // 使用包装类提供的额外功能 personWrapper.printGreeting(); // 通过包装类修改原始类的属性 personWrapper.setName(&quot;Bob&quot;); personWrapper.setAge(25); System.out.println(personWrapper); &#125;&#125; 包装类的应用场景自定义包装类的用例很多，包括但不限于： 增强功能：为已有的类增加新的方法或属性，而不需要修改原始类。代理模式：包装类可以在某些情况下代理对原始类的访问，常用于控制访问或延迟初始化。装饰模式：通过包装类为原始类添加新功能，而不改变其结构。适配器模式：包装类可以作为适配器，将一个类的接口转换为另一个类的接口。总结虽然在语言内置的包装类中，通常是为基本类型设计的，但你完全可以为自定义类创建包装类。这种设计可以帮助你扩展类的功能，增强代码的灵活性和可维护性。"},{"title":"使用MMSegmentation进行语义分割","path":"/2024/07/21/使用MMSegmentation进行语义分割/","content":"文章来源：https://zhuanlan.zhihu.com/p/393070556 一、前言本实例将通过使用语义分割，将道路在实际场景中分割出来，从而为无人驾驶小车提供道路信息和前进方向信息。 语义分割作为计算机视觉中一项基础任务，同时在自动驾驶&#x2F;视频编辑等领域中有重要的应用，因此一直受到学术界和工业界的广泛关注。在近几年的会议中，语义分割的论文层出不穷，但是市面上一直缺乏一款能够相对公平比较各种方法的框架。为了方便研究员和工程师们，MMLab开源了一套基于 PyTorch 实现的标准统一的语义分割框架：MMSegmentation。 https://github.com/open-mmlab/mmsegmentation 在 MMSeg 下，其复现和比较了很多语义分割的算法，并对训练测试的超参进行了优化和统一，在精度，速度，稳定性等方面都超过目前开源的其他代码库。 MMSegmentationMMSegmentation 保持了 MM 系列一贯的风格，拥有灵活的模块化设计和全面的高性能model zoo。目前支持18种算法，大部分算法都提供了多种 setting 以及在 Cityscapes，ADE20K，Pascal VOC 2012上的训练结果（目前应该是语义分割中最大的 模型库）。 https://github.com/open-mmlab/mmsegmentation/blob/master/docs/dataset_prepare.md#nighttime-driving) MMSeg 作为全新的语义分割框架，和其他的框架相比，它提供了更强更快的主流算法，统一超参的公平比较，附带丰富的配置文件和五花八门的 tricks，而且非常灵活易于拓展。 二、制作数据集使用Labelme来标注自己的数据集： https://github.com/wkentaro/labelme https://blog.csdn.net/u014061630/article/details/88756644 1. Labelme介绍Labelme 是一个图形界面的图像标注软件。用 Python 语言编写的，图形界面使用的是 Qt（PyQt）。 labelme作用： 对图像进行多边形，矩形，圆形，多段线，线段，点形式的标注（可用于目标检测，图像分割，等任务）。 对图像进行进行 flag 形式的标注（可用于图像分类 和 清理 任务）。 视频标注 生成 VOC 格式的数据集（for semantic &#x2F; instance segmentation） 生成 COCO 格式的数据集（for instance segmentation） 2.Labelme安装首先安装Anaconda： https://www.cnblogs.com/dream-it-possible/p/14301540.html 然后运行以下命令： 1234567891011121314151617181920#################### for Python 2 ####################conda create --name=labelme python=2.7source activate labelme# conda install -c conda-forge pyside2conda install pyqtpip install labelme# 如果想安装最新版本，请使用下列命令安装：# pip install git+https://github.com/wkentaro/labelme.git#################### for Python 3 ####################conda create --name=labelme python=3.6source activate labelme# conda install -c conda-forge pyside2# conda install pyqtpip install pyqt5 # pyqt5 can be installed via pip on python3pip install labelme 使用labelme命令打开标注界面 点击Open_Dir打开需要标注的数据集，这里分两类数据集，可行驶区域(darea)，背景(background)，标注如下图所示。 点击左侧create polygons，依次标定点，使其形成闭合区域，写明所标类别，这里背景可以选择不标注。 标定后保存，会自动生成一个.json的文件，这个.json文件和你的图片放在一起就好。 使用命令 1git clone https://github.com/wkentaro/labelme.git 下载labelme支持文件。 但是需要注意的是，mmsegmentation同mmdetection一样，有一些固定的数据集格式。在目标检测中，最为常见的当属COCO和VOC两种格式了。 对于语义分割来说，我们这里按照VOC数据对标注好的数据进行转化。转化方式非常简单，只使用labelme即可。 读者可以在&#x2F;labelme&#x2F;examples&#x2F;semantic_segmentation&#x2F;下：制作一份labels.txt文件：__ignore__和_background_是要写在最前面的。然后后面依次写上你的类名即可。 运行指令： 1python ./labelme2voc.py data_annotated data_dataset_voc --labels labels.txt 其中： data_annotated: 是用Labelme标注好的数据文件夹(图片与.json一一对应)。 data_dataset_voc：是生成的VOC格式的数据集。 得到数据集如下： 其中，JPEGImages是原始图片，SegmentationClass存储的是.npy格式的标注数据。SegmentationClassPNG是标注图片。SegmentationClassVisualization是原图与标注区域的mask格式。 就此数据集准备完毕。 三、环境搭建1.环境搭建这里建议使用anaconda安装对应环境 先使用conda创建一个独立的测试环境 12conda create --name=mmsegmentation python=3.7.0conda activate open-mmlab 接下来安装pytorch首先使用命令查看当前环境的cuda版本： 在C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA目录下查看cuda版本 或cmd执行 1nvcc -V 可以看到这里cuda版本为11.1，对照自己的cuda和pytorch版本，具体可参考：https://pytorch.org/get-started/locally/ 这里我们安装pytorch1.8.1，使用如下命令： 1pip install torch==1.8.0+cu111 torchvision==0.9.1+cu111 -f https://download.pytorch.org/whl/torch_stable.html 注意这里的cu111指cuda版本为11.1，读者需要替换为自己所需的版本 下面安装mmcv库，一定要注意对照自己的cuda和pytorch版本，具体可参考：https://mmcv.readthedocs.io/en/latest/get_started/installation.html 1pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/cu111/torch1.8.0/index.html 接下来下载mmsegmentation支持文件 1pip install git+https://github.com/open-mmlab/mmsegmentation.git # install the master branch 通过以上命令安装mmsegmentation运行必要环境，此外，还需在mmsegmentation根目录下运行以下命令进行补充。 1pip install -r requirements.txt 待安装完毕环境即搭建完成。 2.验证环境为了验证 MMSegmentation 和它所需要的环境是否正确安装，我们可以使用样例 python 代码来初始化一个 segmentor 并推理一张 demo 图像。 1234567891011121314151617181920212223from mmseg.apis import inference_segmentor, init_segmentorimport mmcvconfig_file = &#x27;configs/pspnet/pspnet_r50-d8_512x1024_40k_cityscapes.py&#x27;checkpoint_file = &#x27;checkpoints/pspnet_r50-d8_512x1024_40k_cityscapes_20200605_003338-2966598c.pth&#x27;# 从一个 config 配置文件和 checkpoint 文件里创建分割模型model = init_segmentor(config_file, checkpoint_file, device=&#x27;cuda:0&#x27;)# 测试一张样例图片并得到结果img = &#x27;test.jpg&#x27; # 或者 img = mmcv.imread(img), 这将只加载图像一次．result = inference_segmentor(model, img)# 在新的窗口里可视化结果model.show_result(img, result, show=True)# 或者保存图片文件的可视化结果# 您可以改变 segmentation map 的不透明度(opacity)，在(0, 1]之间。model.show_result(img, result, out_file=&#x27;result.jpg&#x27;, opacity=0.5)# 测试一个视频并得到分割结果video = mmcv.VideoReader(&#x27;video.mp4&#x27;)for frame in video: result = inference_segmentor(model, frame) model.show_result(frame, result, wait_time=1) 当您完成 MMSegmentation 的安装时，上述代码应该可以成功运行。 此外还可以使用demo脚本可视化单张图片， 1python demo/image_demo.py $&#123;IMAGE_FILE&#125; $&#123;CONFIG_FILE&#125; $&#123;CHECKPOINT_FILE&#125; [--device $&#123;DEVICE_NAME&#125;] [--palette-thr $&#123;PALETTE&#125;] 样例： 12python demo/image_demo.py demo/demo.jpg configs/pspnet/pspnet_r50-d8_512x1024_40k_cityscapes.py \\ checkpoints/pspnet_r50-d8_512x1024_40k_cityscapes_20200605_003338-2966598c.pth --device cuda:0 --palette cityscapes 推理的 demo 文档可在此查询：demo&#x2F;inference_demo.ipynb 。 四、配置文件编写与必要的设置对于mmsegmentation来说，如果读者想快速使用的话。config文件几乎是你唯一需要改动的东西。mmseg的模型使用，训练配置，数据地址都是靠config指明的。 在mmseg的官网中，有关config的资料很清晰，但是细节并不到位。 config是有继承关系的，根文件就是_base_中的一个个文件。虽如此，但仍然不建议初次使用的读者使用官网提供的简略写法。 在mmsegmentation的configs下，存放了各式各样的模型的配置文件，这些配置文件大多数都是针对的大型开源数据集。我们需要改的不是网络结构，主要是你的数据集地址，你定义的类别数，以及必要的训练设置。 这里可以通过运行一遍train来让系统自动生成一个config文件，然后复制出来进行自己的更改，将tools中的train.py复制到mmsegmentation根目录下，并运行以下代码： 1python train.py configs/deeplabv3/deeplabv3_r50-d8_512x512_20k_voc12aug.py 运行后报错正常，此时根目录下会生成work_dirs文件夹，并在其中生成我们所需的config文件： 将其拷贝出来，就可以基于此修改我们的配置文件了。 对于config文件，我们只需要关注&#x3D;&#x3D;数据集、类别、训练配置&#x3D;&#x3D;。 整个config文件大致可分为三个部分，即model , data 以及一些训练的配置。 1.数据集地址我们首先修改训练数据的地址 在config文件的第43行，是我们的数据集要遵照的格式，因为在准备数据集阶段我们已经修改为VOC格式，因此这里不用修改。 第44行是我们数据集的文件目录，这里我将其放入根目录data文件下。 再往下，进入data字典下，我们改动第87行的数据地址。第88行的img_dir是指语义分割数据集的原始图片，我们存到了JPEGImages下；ann_dir存放的是标注文件，我们存放的地址是SegmentationCLassPNG。注意，原始VOC还进行了数据增强，读者把带有Aug对应的地方删掉即可。第90行的split对应的是指定哪些图片存放train.txt 同理还需要test.txt 和val.txt，下面我们将制作这三个txt文本。 首先执行以下代码将全部数据图片的名称提取并保存在一个txt文件中 1234567891011import ospath = &quot;F:\\Dataset\\data_dataset_voc\\JPEGImages&quot;filenames=os.listdir(os.getcwd())for name in filenames: filenames[filenames.index(name)]=name[:-4]out=open(&#x27;names.txt&#x27;,&#x27;w&#x27;) #输出的txt文件名称for name in filenames: out.write(name+&#x27; &#x27;)out.close() 然后将txt中图片名称随机分为3类，即训练集、测试集和验证集： 12345678910111213141516171819202122232425import randomnum_line = 0def write_to_txt(file, start, end): with open(file, &#x27;w&#x27;) as name: for i in data[start:end]: name.write(&#x27;&#x27;.join(i) + &quot; &quot;) name.close()if __name__ == &#x27;__main__&#x27;: data = [] with open(&#x27;names.txt&#x27;, &#x27;r&#x27;) as f: for line in f: data.append(list(line.strip(&#x27; &#x27;).split(&#x27;,&#x27;))) num_line = num_line + 1 f.close() print(num_line) #数据集总数 random.shuffle(data) write_to_txt(&quot;train.txt&quot;,0,400) #这里需要自己根据自己数据集数量进行分配 write_to_txt(&quot;test.txt&quot;,400,450) write_to_txt(&quot;val.txt&quot;,450,len(data) + 1) 最后修改好的数据集部分代码如下 train部分 val部分 test部分 2.类别配置下面开始修改类别，先在配置文件中修改读者需要的类别数，标出的类别改成读者自己的，类别数等于n+1，也就是类别数量+背景。 我们只需要 行驶区域(darea)，背景(background)这两类，所以我们的num_classes&#x3D;2 这里需要修改两处，分别是第23行和第36行。 修改后，还需要修改一些底层配置。 首先是在mmsegmentation/mmseg/datasets下，找到voc.py（因为我们的格式是VOC），做如下修改。 其中PALETTE你可以简单理解为颜色，background对应[0, 0, 0]就是黑色，依次类推。 然后在mmsegmentation/mmseg/core/evaluation下，找到class_names.py，做类似修改： 到这里类别部分就修改好了 3.修改必要的训练配置这里要修改的地方不多，一般只简单改改训练迭代总数。下面的167行，读者的数据集不大的话，不需要迭代这么多次。 至此，我们的配置文件修改好了。然后我们给修改好的配置文件改个名字。 五、运行我们再次运行之前的指令: 1python tools/train.py segdemo.py 开始训练！！！ 训练结束后，模型保存在work_dirs/deeplabv3_r50-d8_512x512_20k_voc12aug/下， 接下来就可以测试我们的模型效果了，在根目录下新建一个python文件，并输入以下代码： 1234567891011from mmseg.apis import inference_segmentor , init_segmentorimport mmcvconfig_file = &#x27;segdemo.py&#x27;checkpoints_file = &#x27;work_dirs/deeplabv3_r50-d8_512x512_20k_voc12aug/latest.pth&#x27;model = init_segmentor(config_file, checkpoints_file, device = &#x27;cuda:0&#x27;)img = &#x27;mytest.jpg&#x27;result = inference_segmentor(model, img)model.show_result(img,result,out_file=&#x27;none_opacity_result.jpg&#x27;,opacity=0.5) 保存为testdemo.py，在根目录下打开终端，输入命令： 1python testdemo.py 运行后，将自动将结果保存在根目录下，文件名称为none_opacity_result.jpg，这里通过修改11行的out_file和opacity可以修改输出文件名称和输出效果透明度。 当opacity&#x3D;0.1时，得到结果： 当opacity&#x3D;0.5时，得到结果： 当opacity&#x3D;1时，得到结果： 在获取到道路信息后，我们可以开始尝试为无人驾驶汽车指明前进的方向。在实际的工程中，我们采用了强化学习方法来获取无人驾驶汽车前进方向以避免道路两旁行人或障碍物的影响。在本次实例中，我们暂时使用图像处理的方式来初步获取方向信息。对于强化学习方法，感兴趣的读者可以自己尝试实现。 通过以下python程序来对图像进行简单的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import matplotlib.image as mpimgfrom pylab import *img_plt = mpimg.imread(&#x27;none_opacity_result.jpg&#x27;)point_x = [0]*320point_y = [0]*320left_flag=0right_flag=0left_val=0right_val=0i=0for line in range(180): for row in range(320): #print(line,row,img_plt[line,row,0],left_flag,right_flag) if img_plt[line,row,0] &gt;= 100 and left_flag == 0: left_flag = 1 left_val = row if (img_plt[line,row,0] &lt;=50 and left_flag == 1) or(row==319 and img_plt[line,row,0]&gt;=128 and left_flag == 1): left_flag = 0 right_val = row right_flag = 1 if right_flag == 1 : middle = (left_val+right_val)//2 #img_plt[line,middle,1] = 200 point_x[i]=middle point_y[i]=line i=i+1 right_flag=0 left_flag = 0i=i-1imshow(img_plt)x = [0,0]y = [0,0]x[0] = point_x[0]x[1]=point_x[i]y[0]=point_y[0]y[1]=point_y[i]plot(x, y, &#x27;r*&#x27;)plot(x[:2], y[:2])show() 最后输出得到小车前进路径：","tags":["语义分割"]},{"title":"self attention机制","path":"/2024/07/13/self-attention机制/","content":"self attention模块输入输出都可以看作是向量每个向量都要和其他向量在self attention模块中进行交互以下是两种两个向量之间交互的方法 一个向量和sequence中其他向量交互（两个向量之间交互的拓展），输出即为相关度 计算与输入位置对应的输出向量（考虑了其他所有向量的信息，在这里哪个向量的alpha更大，即相关性强，计算输出向量的求和那里对相关性强的输入向量对应的V矩阵系数乘的也越多） 这个self attention模块充分利用了GPU的并行能力，所有的操作都可以整合到矩阵计算中并行计算。"},{"title":"编程学习观点","path":"/2024/07/12/编程学习观点/","content":"培养对酷的编程项目如何构建的热情，尝试阅读理解消化源码，不要只停留在应用层。 QBX理论Q:需求量大B:基础X:稀缺性"},{"title":"浏览器跨域","path":"/2024/07/10/浏览器跨域/","content":"一个域下的JS脚本在未经允许的情况下，不能访问另一个域的内容，同源指的是协议域名和端口均相等的情况为同一个域。 跨域由于同源策略的限制，请求发送到后端，后端返回数据时被浏览器的跨域报错拦截。问：跨域的请求在服务端会不会真正执行？服务端就算是想拦截，也没法判断请求是否跨域，HTTP Request的所有Header都是可以被篡改的，它用什么去判断请求是否跨域呢？很明显服务端心有余而力不足啊！options:预检请求有一个很重要的作用就是询问服务端是不是允许这次请求，如果当前请求是个跨域的请求，你可以理解为：询问服务端是不是允许请求在当前域下跨域发送。当然，它还有其他的作用，比如询问服务端支持哪些HTTP方法。预检请求虽然不会真正在服务端执行逻辑，但也是一个请求啊，考虑到服务端的开销，不是所有请求都会发送预检的。一旦浏览器把请求判定为简单请求，浏览器就不会发送预检了。所以，如果你发送的是一个简单请求，这个请求不管是不是会受到跨域的限制，只要发出去了，一定会在服务端被执行，浏览器只是隐藏了返回值而已。对于前端开发而言，大部分的跨域问题，都是通过代理解决的。代理使用的场景是：生产环境不发生跨域，但开发环境发生跨域。所以，只需要在开发环境使用代理解决跨域即可一开发代理。 服务器与服务器通信不受跨域的影响，解决跨域也就可以从这个角度入手。浏览器不允许跨域的原因？防止黑客入侵 为啥html标签可以跨域？html标签只能调用get方法 在有服务器权限的情况下 服务器配置CROS实现跨域跨域资源共享Cross Origin Resourse-Sharing一般后端开启。是基于HTTP1.1的一种跨域解决方案。服务端设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。一个请求可以附带很多信息，会对服务器造成不同程度的影响，有的请求只是获取一些新闻，有的请求会改动服务器的数据。针对不同的请求，CORS规定了3种不同的交互模式 简单请求 需要预检的请求 附带身份凭证的请求 简单请求当请求同时满足以下条件时，浏览器会认为它是一个简单请求：1.请求方法属于下面的一种：getposthead2.请求头仅包含安全的字段，常见的安全字段如下：AcceptAccept-LanguageContent-LanguageContent-TypeDPRDownlinkSave-DataViewport-WidthWidth3.请求头如果包含Content-Type,仅限下面的值之一：text&#x2F;plainmultipart&#x2F;form-dataapplication&#x2F;x-www-form-urlencoded4.请求中的任意XMLHttpRequest对象均没有注册任何事件监听器；MLHttpRequest对象可以使用MLHttpRequest.upload属性访问。5.请求中没有使用ReadableStream对象。如果以上条件同时满足，浏览器判定为简单请求。当浏览器判定某个ajax跨域请求是简单请求时，会发生以下的事情1.请求头中会自动添加Origin字段比如，在页面http://my.com/index.html中有以下代码造成了跨域&#x2F;&#x2F;简单请求fetch(‘http://crossdomain.com/api/news‘);请求发出后，请求头会是下面的格式：GET &#x2F;api&#x2F;news&#x2F;HTTP&#x2F;1.1Host:crossdomain.comConnection:keep-alive12Referer:http://my.com/index.htmlOrigin:http://my.com 最后一行，Origin字段会告诉服务器，是哪个源地址在跨域请求2.服务器响应头中应包含Access-Control-Allow-Origin当服务器收到请求后，如果允许该请求跨域访问，需要在响应头中添加Access-.Control-Allow-Origin字段该字段的值可以是： *：表示我很开放，什么人我都允许访问 具体的源：比如http://my.com,表示我就允许你访问 实际上，这两个值对于客户端http://y.com而言，都一样，因为客户端才不会管其他源服务器允不允许，就关心自己是否被允许 假设服务器做出了以下的响应：HTTP&#x2F;1.1 200OK 1Access-Control-Allow-0rigin:http://my.com 消息体中的数据当浏览器看到服务器允许自己访问后，高兴的像一个两百斤的孩子，于是，它就把响应顺利的交给js,以完成后续的操作需要预检请求但是，如果浏览器不认为这是一种简单请求，就会按照下面的流程进行1.浏览器发送预检请求，询问服务器是否允许2.服务器允许3.浏览器发送真实请求4.服务器完成真实的响应 比如，在页面http://my.com/index.html中有以下代码造成了跨域 1234567891011121314//需要预检的请求fetch(&#x27;http://crossdomain.com/api/user&#x27;,method:&#x27;P0ST&#x27;,//post请求headers://设置请求头a:1,b:2,&#x27;content-type&#x27;:&#x27;application/json&#x27;,&#125;,body:JSON.stringify(&#123;name:&#x27;袁小进&#x27;，age:18&#125;),//设置请求体&#125;) 浏览器发现它不是一个简单请求，则会按照下面的流程与服务器交互1.浏览器发送预检请求，询问服务器是否允许OPTIONS &#x2F;api&#x2F;user HTTP&#x2F;1.1Host:crossdomain.com 123origin:http://my.comAccess-Control-Request-Method:POSTAccess-Control-Request-Headers:a,b,content-type 可以看出，这并非我们想要发出的真实请求，请求中不包含我们的请求头，也没有消息体。这是一个预检请求，它的目的是询问服务器，是否允许后续的真实请求。预检请求没有请求体，它包含了后续真实请求要做的事情预检请求有以下特征： 请求方法为OPTIONS 没有请求体 请求头中包含 Origin:请求的源，和简单请求的含义一致 Access-Control–Request-Method:后续的真实请求将使用的请求方法 Access–Control-Request-Headers:后续的真实请求会改动的请求头 2.服务器允许服务器收到预检请求后，可以检查预检请求中包含的信息，如果允许这样的请求，需要响应下面的消息格式HTTP&#x2F;1.1 200OKDate:Tue,21 Apr 2020 08:03:35 GMT 1234Access-Control-Allow-origin:http://my.comAccess-Control-ALlow-Methods:POSTAccess-Control-Allow-Headers:a,b,content-typeAccess-Control-Max-Age:86400 对于预检请求，不需要响应任何的消息体，只需要在响应头中添加： Access–Control-Allow-Origin:和简单请求一样，表示允许的源 Access-Control-Allow-Methods:表示允许的后续真实的请求方法 Access-Control-Allow-Headers:表示允许改动的请求头 Access-Control-Max-Age:告诉浏览器，多少秒内，对于同样的请求源、方法、头，都不需要再发送预检请求了3.浏览器发送真实请求预检被服务器允许后，浏览器就会发送真实请求了，上面的代码会发生下面的请求数据POST &#x2F;api&#x2F;user HTTP&#x2F;1.1Host:crossdomain.comConnection:keep-alive123Referer:http://my.com/index.htmlOrigin:http://my.com&#123;&quot;name&quot;:&quot;xiaoming&quot;,&quot;age&quot;:18&#125; 4服务器响应真实请求HTTP&#x2F;1.1 200OKDate:Tue,21 Apr 2020 08:03:35 GMT1Access-Control-Allow-origin:http://my.com 添加用户成功可以看出，当完成预检之后，后续的处理与简单请求相同附带身份凭证请求默认情况下，ajax的跨域请求并不会附带cookie,这样一来，某些需要权限的操作就无法进行不过可以通过简单的配置就可以实现附带cookie1234567//xhrvar xhr new XMLHttpRequest();xhr.withCredentials true;//fetch apifetch(url,credentials:include&#x27;,&#125;): 当一个请求需要附带cookie时，无论它是简单请求，还是预检请求，都会在请求头中添加cookie字段而服务器响应时，需要明确告知客户端：服务器允许这样的凭据告知的方式也非常的简单，只需要在响应头中添加：Access-Control-Allow-Credentials:true即可对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。另外要特别注意的是：对于附带身份凭证的请求，服务器不得设置Access-Contro-Allow-Origin的值为*。这就是不推荐使用的原因 额外补充 在跨域访问时，JS只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content–Type、Expires、Last-Modified、Pragma,如果要访问其他头，则需要服务器设置本响应头。Access-Control-Expose-Headers:头让服务器把允许浏览器访问的头放入白名单，例如：Access-Control-Expose-Headers:authorization,a,b这样JS就能够访问指定的响应头了。代理适用场景：生产环境不发生跨域，但开发环境发生跨域。开发代理：只需要在开发环境使用代理解决跨域。 12345module.exports =devServer:&#123;//配置开发服务器proxy:&#123;//配置代理&quot;/api&quot;:&#123;//若请求路径以/api开头target:&quot;http://dev.taobao.com&quot;,//将其转发到http://dev.taobao.com nginx代理反向代理功能是nginx的三大主要功能之一（静态wb服务器、反向代理、负载均衡）。反向代理：帮服务器拿到数据，然后选择合适的服务器。和CORS原理同，需要配置请求响应头Access-Control-Alow-Origin等字段。怎么做反向代理与负载均衡Ngx作为反向代理服务器，就是把http请求转发到另一个或者一些服务器上。通过把本地一个url前缀映射到要跨域访问的web服务器上，就可以实现跨域访问。对于浏览器来说，访问的就是同源服务器上的一个ul。而Nginxi通过检测url前缀，把http请求转发到后面真实的物理服务器。并通过rewrite命令把前缀再去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求是来自代理服务器的。 正向代理就是冒充客户端，反向代理就是冒充服务端。 WebSocket协议（与HTTP同级）因为WebSocketi请求头信息中有origin字段，表示请求源自哪个域，服务器可以根据这个字段判断是否允许本次通信。document.domain+iframe原理：相同主域名不同子域名下的页面，该方式只能用于二级域名相同的情况下，比如a.test.com和b.test.com适用于该方式。只需要给页面添加document..domain&#x3D;’test.com’表示二级域名都相同就可以实现跨域location.hash iframe通过C页面实现A和B通信window.name(共享变量)+iframe使用Apache做转发逆向代理，让跨域变成同域。2. JSONP（利用script标签和后端配合）前后端配合。只支持GET方法且不安全。利用src发送请求，传递一个回调。不受跨域问题限制：script,link,img,href,src,因为这些操作都不会通过响应结果进行可能出现安全问题的操作。通过标签指向一个需要访问的地址并提供一个回调函数来接收数据。 1234567891011//去创建一个script标签var script = document.createElement(&quot;script&quot;);//script的src属性设置接口地址并带一个callback回调函数名称script.src =&quot;http://127.0.0.1:8888/index.php?callback=jsonpCallback&quot;;//插入到页面document.head.appendchild(script);//通过定义函数名去接收后台返回数据function jsonpCallback(data)&#123;//注意jsonp返回的数据是json对象可以直接使用//ajax取得数据是json字符串需要转换成json对象才可以使用。&#125; 设置本地代理服务器 Nginx代理","tags":["前端软件开发"]},{"title":"mmsegmentation框架可视化训练指标","path":"/2024/07/01/mmsegmentation框架可视化训练指标/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import matplotlib import matplotlib.pyplot as pltmatplotlib.rc(&quot;font&quot;,family=&#x27;SimHei&#x27;) # 中文字体plt.plot([1,2,3], [100,500,300])plt.title(&#x27;matplotlib中文字体测试&#x27;, fontsize=25)plt.xlabel(&#x27;X轴&#x27;, fontsize=15)plt.ylabel(&#x27;Y轴&#x27;, fontsize=15)plt.show()import pandas as pd# 日志文件路径log_path = &#x27;./work_dirs/ZihaoDataset-PSPNet/20230818_210528/vis_data/scalars.json&#x27;with open(log_path, &quot;r&quot;) as f: json_list = f.readlines()len(json_list)eval(json_list[4])# pandas &gt;= 2.0使用pd.concat替换appendfor each in json_list[:-1]: new_row = pd.DataFrame([eval(each)]) # Convert the string to a DataFrame if &#x27;aAcc&#x27; in each: df_test = pd.concat([df_test, new_row], ignore_index=True) else: df_train = pd.concat([df_train, new_row], ignore_index=True)df_traindf_testdf_train.to_csv(&#x27;图表/训练日志-训练集.csv&#x27;, index=False)df_test.to_csv(&#x27;图表/训练日志-测试集.csv&#x27;, index=False)from matplotlib import colors as mcolorsimport randomrandom.seed(124)colors = [&#x27;b&#x27;, &#x27;g&#x27;, &#x27;r&#x27;, &#x27;c&#x27;, &#x27;m&#x27;, &#x27;y&#x27;, &#x27;k&#x27;, &#x27;tab:blue&#x27;, &#x27;tab:orange&#x27;, &#x27;tab:green&#x27;, &#x27;tab:red&#x27;, &#x27;tab:purple&#x27;, &#x27;tab:brown&#x27;, &#x27;tab:pink&#x27;, &#x27;tab:gray&#x27;, &#x27;tab:olive&#x27;, &#x27;tab:cyan&#x27;, &#x27;black&#x27;, &#x27;indianred&#x27;, &#x27;brown&#x27;, &#x27;firebrick&#x27;, &#x27;maroon&#x27;, &#x27;darkred&#x27;, &#x27;red&#x27;, &#x27;sienna&#x27;, &#x27;chocolate&#x27;, &#x27;yellow&#x27;, &#x27;olivedrab&#x27;, &#x27;yellowgreen&#x27;, &#x27;darkolivegreen&#x27;, &#x27;forestgreen&#x27;, &#x27;limegreen&#x27;, &#x27;darkgreen&#x27;, &#x27;green&#x27;, &#x27;lime&#x27;, &#x27;seagreen&#x27;, &#x27;mediumseagreen&#x27;, &#x27;darkslategray&#x27;, &#x27;darkslategrey&#x27;, &#x27;teal&#x27;, &#x27;darkcyan&#x27;, &#x27;dodgerblue&#x27;, &#x27;navy&#x27;, &#x27;darkblue&#x27;, &#x27;mediumblue&#x27;, &#x27;blue&#x27;, &#x27;slateblue&#x27;, &#x27;darkslateblue&#x27;, &#x27;mediumslateblue&#x27;, &#x27;mediumpurple&#x27;, &#x27;rebeccapurple&#x27;, &#x27;blueviolet&#x27;, &#x27;indigo&#x27;, &#x27;darkorchid&#x27;, &#x27;darkviolet&#x27;, &#x27;mediumorchid&#x27;, &#x27;purple&#x27;, &#x27;darkmagenta&#x27;, &#x27;fuchsia&#x27;, &#x27;magenta&#x27;, &#x27;orchid&#x27;, &#x27;mediumvioletred&#x27;, &#x27;deeppink&#x27;, &#x27;hotpink&#x27;]markers = [&quot;.&quot;,&quot;,&quot;,&quot;o&quot;,&quot;v&quot;,&quot;^&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;,&quot;s&quot;,&quot;p&quot;,&quot;P&quot;,&quot;*&quot;,&quot;h&quot;,&quot;H&quot;,&quot;+&quot;,&quot;x&quot;,&quot;X&quot;,&quot;D&quot;,&quot;d&quot;,&quot;|&quot;,&quot;_&quot;,0,1,2,3,4,5,6,7,8,9,10,11]linestyle = [&#x27;--&#x27;, &#x27;-.&#x27;, &#x27;-&#x27;]def get_line_arg(): &#x27;&#x27;&#x27; 随机产生一种绘图线型 &#x27;&#x27;&#x27; line_arg = &#123;&#125; line_arg[&#x27;color&#x27;] = random.choice(colors) # line_arg[&#x27;marker&#x27;] = random.choice(markers) line_arg[&#x27;linestyle&#x27;] = random.choice(linestyle) line_arg[&#x27;linewidth&#x27;] = random.randint(1, 4) # line_arg[&#x27;markersize&#x27;] = random.randint(3, 5) return line_argmetrics = [&#x27;loss&#x27;, &#x27;decode.loss_ce&#x27;, &#x27;aux.loss_ce&#x27;]plt.figure(figsize=(16, 8))x = df_train[&#x27;step&#x27;]for y in metrics: try: plt.plot(x, df_train[y], label=y, **get_line_arg()) except: passplt.tick_params(labelsize=20)plt.xlabel(&#x27;step&#x27;, fontsize=20)plt.ylabel(&#x27;Loss&#x27;, fontsize=20)plt.title(&#x27;训练集损失函数&#x27;, fontsize=25)plt.legend(fontsize=20)plt.savefig(&#x27;图表/训练集损失函数.pdf&#x27;, dpi=120, bbox_inches=&#x27;tight&#x27;)plt.show()metrics = [&#x27;decode.acc_seg&#x27;, &#x27;aux.acc_seg&#x27;]plt.figure(figsize=(16, 8))x = df_train[&#x27;step&#x27;]for y in metrics: try: plt.plot(x, df_train[y], label=y, **get_line_arg()) except: passplt.tick_params(labelsize=20)plt.xlabel(&#x27;step&#x27;, fontsize=20)plt.ylabel(&#x27;Metrics&#x27;, fontsize=20)plt.title(&#x27;训练集准确率&#x27;, fontsize=25)plt.legend(fontsize=20)plt.savefig(&#x27;图表/训练集准确率.pdf&#x27;, dpi=120, bbox_inches=&#x27;tight&#x27;)plt.show()df_test.columnsmetrics = [&#x27;aAcc&#x27;, &#x27;mIoU&#x27;, &#x27;mAcc&#x27;, &#x27;mDice&#x27;, &#x27;mFscore&#x27;, &#x27;mPrecision&#x27;, &#x27;mRecall&#x27;]plt.figure(figsize=(16, 8)x = df_test[&#x27;step&#x27;]for y in metrics: try: plt.plot(x, df_test[y], label=y, **get_line_arg()) except: passplt.tick_params(labelsize=20)plt.ylim([0, 100])plt.xlabel(&#x27;step&#x27;, fontsize=20)plt.ylabel(&#x27;Metrics&#x27;, fontsize=20)plt.title(&#x27;测试集评估指标&#x27;, fontsize=25)plt.legend(fontsize=20)plt.savefig(&#x27;图表/测试集分类评估指标.pdf&#x27;, dpi=120, bbox_inches=&#x27;tight&#x27;)plt.show() 参考MMSegmentation_Tutorials&#x2F;20230816&#x2F;【H1】可视化训练日志-训练过程总体评估指标.ipynb at main · TommyZihao&#x2F;MMSegmentation_Tutorials · GitHub","tags":["深度学习"]},{"title":"测试文章","path":"/2024/06/30/测试文章/","content":"这是一篇测试文章","tags":["原创"],"categories":["Java"]}]