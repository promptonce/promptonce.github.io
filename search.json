[{"title":"对Notion这款软件的理解","path":"/2025/09/07/对Notion这款软件的理解/","content":"Notion翻译为中文为概念，仅通过中文翻译来理解这款软件并不准确，更准确的定义应该是外挂知识库，其为人脑的补充，人脑可以存储各种知识和信息，这款软件的发展方向也是能够储存各种知识和信息。"},{"title":"对API的理解","path":"/2025/09/06/对API的理解/","content":"API是应用程序编程接口，按照技术经济学理论，API是不断动态进化的，API进化的敌人就是任何试图将技术封闭且不能促进经济发展的的人或团体。"},{"title":"前端技术品味观","path":"/2025/08/24/前端技术品味观/","content":"为前端技术奠基的这帮人压根就不是前端开发人员做的，而且这些人在设计的时候看重的不是其逻辑的完备性，由于其只是一门服务性的技术，导致其演化的多种多样，类似于建筑楼房和装修的关系，装修的风格千变万化。对待前端技术框架，注意框架开发者的表述，如果是确定性表述，说明其确实具有某种能力，如果不是确定性表述，不要去擅自推理以免陷入逻辑怪圈。"},{"title":"从箭头函数分析技术演进的动力","path":"/2025/08/21/从箭头函数分析技术演进的动力/","content":"技术发展是多点同时进行的，其繁荣程度和地球上的植被差不多，植被演进的核心动力是光合作用，而技术演进的核心动力是满足人类的需求，就箭头函数来说，其为程序员更好的创造出满足人类需求的工具带来了便利，站在创造者的角度去看待这种由懒而产生的需求，这种懒不是纯粹的缺乏动力。"},{"title":"JavaScript程序员和Python程序员技术对比","path":"/2025/08/21/JavaScript程序员和Python程序员技术对比/","content":"npm —&gt; pip package.json —&gt; requirements.txt"},{"title":"数学在科研和工程中的作用","path":"/2025/08/18/数学在科研和工程中的作用/","content":"数学提供了一个理想的空间可以提升思维工具的能力，其中取得的成果会为未来的工程和研究提供有力的辅助、甚至是关键。"},{"title":"AI辅助编程下项目学习的原则","path":"/2025/08/16/AI辅助编程下项目学习的原则/","content":"不要让AI成为开发团队的Leader, 在项目产品预期不明的情况下始终保证技术判断力的提升反而会让AI和程序员的协作效率更高。"},{"title":"从工科科学论对初级前端开发祛魅","path":"/2025/08/16/从工科科学论对初级前端开发祛魅/","content":"就实现客户需求而言，前端开发加速交付效率首先依赖于对框架、库的记忆其次才是推演，且此特征相对于初级后端开发更为明显。"},{"title":"计算机图形学中的矩阵乘法之美","path":"/2025/08/10/计算机图形学中的矩阵乘法之美/","content":"对二维平面中的图形应用多次仿射变换可以合并为一次矩阵乘法。"},{"title":"向量具有平移不变性","path":"/2025/08/10/向量具有平移不变性/","content":"向量是一个抽象的概念，向量最大的特点是方向性，平移不变性是一个严格的规定，保证了后续向量应用过程中相关逻辑严密。"},{"title":"CS50计算机入门总结","path":"/2025/08/10/CS50计算机入门总结/","content":"计算机只能处理0和1,这是它理解世界的方式，整个计算机知识体系是基于这一点构建起来的。 不管是二进制还是十进制，都是一种计算方式，两种进制都可以用来进行计算，人擅长用十进制计算，计算机擅长用二进制进行计算，之所以不同对象采用不同的进制和底层物理机制相关。人类创造出了计算机，人类不要盲目采用计算机的运作方式而幻想达到理想中的高效；推演，需要知晓物理机制的限制，非要模拟计算机运行也需要在人脑思考辅助工具都不可用才采用，这样才符合程序员入门经济学准则。 程序代码是解决问题的步骤说明，人可以通过自然语言写在纸上生成文件让其他人按照其执行，也可也通过编程再编译成二进制让计算机进行执行。 程序的核心结构是：输入（数据）-&gt; 计算（函数）-&gt; 输出"},{"title":"矩阵计算不满足交换律","path":"/2025/08/10/矩阵计算不满足交换律/","content":"从计算机图形学的仿射变换可以看出，同样两种变换操作采用不同的执行顺序得到的是两种结果。"},{"title":"编程开发中导入库和封装总结","path":"/2025/08/06/编程开发中导入库和封装总结/","content":"之所以能写出看起来优雅的代码是应为库代码在“负重前行”，但想要使用库的能力，需要通过导入的方式建立这种连接。但由于业务的多样性库函数不能端到端地解决问题，需要人类程序员介入来完成最后一公里的开发，这里仍然有一些难点，但更偏上层。"},{"title":"以具象离散和抽象连续思维来理解程序事件监听","path":"/2025/07/27/以具象离散和抽象连续思维来理解程序事件监听/","content":"计算机中的各种资源比如视频、图片、音频，给人的感觉是连续的，但也只是一种虚假的感觉，这是一种优秀的计算机设计抽象实践，这种离散设计与人的信号接收延迟原理相结合。程序的事件监听也是如此，可以知道一定是利用了循环，不断的去检查事件是否触发，这个检查时间可能非常短。"},{"title":"一个中等的工科生应有的能力","path":"/2025/07/16/一个中等的工科生应有的能力/","content":"记忆、推演、表达、感知、数理、操作、狂热、创造"},{"title":"从LLM角度看待代码语法层面的一些理论","path":"/2025/07/09/从LLM角度看待代码语法层面的一些理论/","content":"对于LLM来说，有一个理论是压缩信息需要的就是知识，在代码语法中，有函数，类这些理论的出现，正是为了压缩代码量，这正好说明函数，class这些就是知识。"},{"title":"定义变量和程序实现的关系","path":"/2025/06/18/定义变量和程序实现的关系/","content":"对于算法和应用结合的程序，变量定义说明算法逻辑关系捋清楚了，后面就是为算法服务的工具调用问题。"},{"title":"软件开发的深水区浅水区理论","path":"/2025/06/18/软件开发的深水区浅水区理论/","content":"在浅水区，科学家最早关注的区域，这里理论相对成熟，做开发会非常趁手，在这里应该更多关注虚心学习的态度。在深水区，努力也很重要，但天赋灵感的作用也会凸现。不要轻易将深水区的理论带到浅水区，分清楚自娱自乐和技术创造社会价值的区别。"},{"title":"程序员AI辅助编程中Prompt的成本核算","path":"/2025/06/17/程序员AI辅助编程中Prompt的成本核算/","content":"LLM在处理能力范围内的需求时代码键入速度远超人类，即便是地表最优秀的程序员，这好比计算机在计算速度上远超过任何一个数学家一样。在这个前提下将软件开发需求描述清楚是非常有性价比的，当少数文字对应大段业务代码时提效非常明显，当设计架构方面的代码编写上依赖于Agent的能力，在Agent能力范围以内遵循少数文字对应大段业务代码操作时提效非常明显。"},{"title":"cmd和powershell的区别","path":"/2025/06/15/cmd和powershell的区别/","content":"powershell在cmd上支持了更多的语法支持。"},{"title":"显示器亮度对比度护眼调节设置","path":"/2025/06/09/显示器亮度对比度护眼调节设置/","content":"调成眼睛舒服的效果。"},{"title":"软件开发需求实现过程中的成本核算问题","path":"/2025/06/04/软件开发需求实现过程中的成本核算问题/","content":"不是仅通过大脑中的仿真来核算，需要结合真实环境来核算，比如程序运行和调试必要的时间，这些时间和同步代码执行的时间可能差了几个数量级。"},{"title":"如何减少软件开发编程语言切换带来的不适感","path":"/2025/06/04/如何减少软件开发编程语言切换带来的不适感/","content":"不同编程语言本质上是不同编程语言作者对物理规律，更具体来说是计算机技术的设计方式不同，包含了原作者对技术转换能源的理解，但这些编程语言设计都有一些通用的理念，这个是在切换编程语言后可以利用这些通用的东西来减少语言切换的阻尼感。"},{"title":"软件开发中如何开发新需求","path":"/2025/06/04/软件开发中如何开发新需求/","content":"保证各个代码系统处于开发者模式启动中，对于前后端分离的系统，前端开发环境需要启动起来，后端服务器要远程登录上，因为随时可能添加测试代码测试需求实现过程中的问题。"},{"title":"JavaScript Promise产生原因","path":"/2025/06/03/JavaScript-Promise产生原因/","content":"JavaScript的并发是基于单线程的，单线程实现并发并不一定是不好的，单线程中资源共享较好，从源头上避免了多线程之间的一些问题。"},{"title":"异步编程的适用场景","path":"/2025/06/03/异步编程的适用场景/","content":"同步编程是一种不考虑特殊情况的开发模式，其假设是所有任务执行的速度非常快，但实际中I&#x2F;O密集型任务和网络请求任务耗时较长，异步编程就像一个补丁用于解决这个问题，为什么不能统一呢？这和想统一宇宙中的几大力一样，经典力学在量子维度失效，这样就要去否定经典力学的价值吗？经典力学同样能解决一些社会中的问题，这个世界上没有绝对的完美，只有相对的完美，如果你觉得有绝对的完美，那么想一想蒙蔽你的到底是啥。"},{"title":"并发、并行、异步、同步","path":"/2025/06/02/并发、并行、异步、同步/","content":"一个人在烧水、洗衣服、玩手机时可以选择做完一件事情后再做另一件事情，即便这样是低效的但也可以抽象为一种cpu的工作方式，站在更高效转换能源的角度，更合理的抽象方式是让CPU在等待一个任务执行完成的间隙切换到其他任务，对于I&#x2F;O密集型和网络请求这类任务来说，优化CPU的工作模式相比于提高这些任务的执行速度更有性价比，感觉计算机技术有点像在物理环境受限的情况下用智慧去走捷径的妥协艺术。 并发是指单核CPU轮流执行线程。并行指多核CPU不同核处理不同线程，做到真正的并行。同步是一种开发模式，后面的代码必须等前面的代码执行完成后才能执行。同步也是一种开发模式，后面的代码可以不用等前面的代码执行完成才开始执行，当数据返回时，通过回调函数的方式再执行前面的代码。"},{"title":"进程与线程","path":"/2025/06/02/进程与线程/","content":"程序代码存放在硬盘中，这和菜谱存放在柜子中道理相同，程序代码需要执行时，将代码读入到内存中，可以将一段代码读入多份到内存中，也就创建了多个进程，一个进程中为啥还要有“子进程”线程呢？比如文档编辑软件中，处理键盘回车换行的程序和页面渲染程序、保存文档到硬盘的程序都需要执行，这些程序共享同一个数据“文档”，这就时线程高效的原因。 一个进程的多个线程会轮流占用CPU时间。"},{"title":"Vuex的理解","path":"/2025/06/02/Vuex的理解/","content":"一个Vue应用中包含多个Vue组件，组件与组件之间可能通信关系复杂，这个时候需要Vuex作为中心进行管理，这和家里面的中心储物柜原理相同，1. 可以减小开发成本，避免多层嵌套组件链条中数据修改不好追踪的问题。 2. 通过维护唯一数据源，避免出现数据不一致的问题。3. 将数据处理逻辑集中在一个地方，避免数据处理方法分布在多个method中不好维护的问题。"},{"title":"redis相对于传统磁盘数据库","path":"/2025/05/27/redis相对于传统磁盘数据库/","content":"传统sql语句通过中磁盘中读取数据，时间单位为毫秒级，redis在内存中读取数据，时间单位为纳秒级，对于高频读写的数据，用内存数据库redis会极大提高系统处理速度。"},{"title":"AutoDL原理","path":"/2025/05/24/AutoDL原理/","content":""},{"title":"静态语言和动态语言","path":"/2025/05/23/静态语言和动态语言/","content":"对于变量定义而言，变量定义后，类型可以改变的语言就是动态语言，类型不能改变的就是静态语言，比如Java是静态语言，JavaScript是动态语言。"},{"title":"前后端协同开发","path":"/2025/05/22/前后端协同开发/","content":"通过引入API接口来简化前端的思考负担，将复杂的逻辑往后端迁移，数据库和后端交互最自然也最灵活， 后端不仅仅是具有访问数据库的能力，还具有实现复杂业务逻辑的能力，前端专注于解决可视化问题，包括前端编写组件收集数据传递到后端，从后端接收数据进行渲染，前端开发人员不用被复杂的业务逻辑干扰专注度。"},{"title":"JavaScript模块导出和导入","path":"/2025/05/22/JavaScript模块导出和导入/","content":"创建一个js文件，可以直接编写打印arguments变量的代码，这是因为用Node运行这个js文件时，node会对这个文件进行包装。在一个js文件中，如果需要导出数据，这里所说的数据包括函数，在javascript中，函数和数字，字符串等数据类型具有同等地位，可以通过module.exports &#x3D; {xxx}的方式导出，在其他文件中通过require(xxx.js)导入使用，这种方式为开发者实现代码整洁提供了方法。 es6中通过export和import实现，一个文件只能有一个export default，对于export default的数据，import时可以不使用{}, 非export default的数据，需要使用{}，这是LLM擅长的东西。"},{"title":"文本Prompt分段工具","path":"/2025/05/21/文本Prompt分段工具/","content":"​\t利用程序自动对文本进行切片，灵活修改切片段落字数，自动完成固定prompt模板连接，保持上下文的清洁。"},{"title":"python面向对象中的抽象方法","path":"/2025/05/20/python面向对象中的抽象方法/","content":"​\t让错误能够在编译器运行时就检查出来，不用等到结果报错再改，用规范减少思维负担。"},{"title":"序列化和反序列化","path":"/2025/05/14/序列化和反序列化/","content":"​ ​\t计算机软件技术是对现实世界的抽象，宇宙间有万物，万物如何交互可以通过软件设计来抽象，受限于物质组合的发展，软件抽象设计也是一个逐步迭代的过程。当前宇宙的发展阶段为计算机基于电磁波这种物质而进行软件设计，两台计算机之间如何传递对象呢，按照OOP的思想，对象虽然位于计算机中，但仍然是一个逻辑上的实体，如何定义对象传输成功了呢？保证具有对象的所有信息就行，即通过序列化后通过HTTP传输，接收方可以通过与发送方互相达成协议，保证接收方能够按照自己的方式正确将序列化的内容进行还原，这是当下物质发展阶段的可以通用的一套方案。"},{"title":"function call设计理念","path":"/2025/05/12/function-call设计理念/","content":"​\t程序运行无非就是输入输出，LLM的出现结合Function Call技术可以将程序输入这一步放宽松，用户输入的是自然语言也可以通过LLM转为程序能理解的输入，利用了LLM的自然语言处理能力和推理能力，有了标准化的输入后程序能够执行一些和工具交互的操作，如果调用的工具能否返回结果，那么还可以将调用结果返回给LLM，再利用LLM的NLP和推理能力优化输出。"},{"title":"JavaScript语言设计初衷","path":"/2025/05/11/JavaScript语言设计初衷/","content":"学习JavaScript语言需要有一些思想补丁，这门语言设计时为了追求开发速度所以不是特别严谨，比如定义var变量会做变量提升，在变量定义前打印也不会报错，这在其他语言里是不允许的。定义function A时又会自动创建A.prototype对象。只要通过new关键字调用，任何函数都可以作为构造函数。这些无形发生的过程按照其他设计严谨的语言逻辑去理解是不行的，需要加以防范。"},{"title":"显示屏护眼环境光照设置","path":"/2025/05/07/显示屏护眼环境光照设置/","content":"核心是防炫光，然后是降低明暗对比。"},{"title":"一种快速为论文查找参考文献的方法","path":"/2025/04/22/一种快速为论文查找参考文献的方法/","content":"利用perplex查找待搜寻引用的文献。 将文献导入类chatpdf工具中。 直接询问xxx内容是否可以引用本篇文章。","tags":["学术论文写作"]},{"title":"Embeddings和向量数据库","path":"/2025/04/14/Embeddings和向量数据库/","content":"二维向量通过余弦相似度来判断向量是否相关。停用词没有太多意义然后出现频率高。N-gram用多元方法拆分得到特征进行相似度计算做推荐系统。word2vec通过建模当前词和其两侧的值的关系或两侧的词和当前词的关系，利用神经网络的隐藏层来实现压缩特征。cherry studio的知识库功能用到的嵌入模式是用于找相似度的（根据用户的输入找到知识库中相似的文本），然后将这些找到的相似度的文本发送给AI作为上下文。"},{"title":"面向对象和面向过程有何不同?","path":"/2025/04/13/面向对象和面向过程有何不同/","content":"​\t面向对象将数据和方法作为一个整体来对待，面向过程则没有做数据+方法的隔离。虽然面向对象的实现中也有顺序执行，分支，循环等操作但整体上对象和对象之间的修改是互不影响的。举个形象的例子就是看电视通过遥控器控制电视换台等各种操作，而面向过程需要去电视机等电路板上实现对应的操作。"},{"title":"陆奇-我的大模型世界观有感-认知提高","path":"/2025/04/09/陆奇-我的大模型世界观有感-认知提高/","content":"​\t啥叫科技公司？用信息更有效地转化能源。传统编程是一种转换能源的方式，有啦大模型之后，仅传统编程相较于AI辅助编程转换效率变低。以前没有大模型的时候我们需要为每个任务构建单独的模型。大模型最先是将所有NLP的任务都统一一起做了，人类很多任务包括分析和推理其实都属于NLP的范畴，在OpenAI, DeepSeek这些公司付出固定边际成本后，下游不用AI就是在违背发展之道，但并不意味着我们需要任何时候都依赖AI而完全抛弃原来的工作方式，信息革命也没有淘汰掉所有的纸笔，一个好的模型组合应该是人脑的模型和AI的模型共同进化。​\t当下社会正在从服务经济向体验经济转型（比如星巴克，不仅是卖咖啡，也是卖的“第三空间”的氛围），除非一个人有独特的认知模型、独特的领域模型，这个人能做的AI都可以做，现在指的是一些重复性的工作，已经不能说简单了，因为编码以前被认为是一件很复杂的事情，但现在只要具备一定的代码领域模型都可以用AI进行编程，代码本质上一种语言，如果自然语言能够将需求描述清楚，那么AI也帮助不懂技术的人编程，但\t其实这些人还是懂技术的，因为他们有科学的培养，技术自大论完全就是培训班或者媒体为了某种利益而单独塑造的。真正高顶尖的技术人才往往生活最简朴的。OpenAI为啥能够打败谷歌和微软推出ChatGPT, 一个高效有判断力的小团队比一个总体高效却不灵活的组织创新能力更强，尤其是在一个范式变革的时期。transformer真的是一个很厉害的创新。​\tChatGPT内部封装了一个高材生，如何有效利用这个高材生的能力比和这个高材生比赛可能更有意义，本质上人类要做的是熵减-转换能源。人类仍然需要思考，但和传统的充当执行者的思考已经不同。这些模型需要不断的改进，这些工作需要人来参与，这里需要专家来做，普通人则通过用AI提供数据。模型是在进化的，从一代又一代的模型发布可以看出，这个进化过程显然是人在推动，就像早期猿类在过渡到人类的繁衍时，猿类依然需要扮演推动进化的作用-因为这个智能体还不能独立行动。现在的大模型更多的是在系统一和系统二上工作，所以现在科学研究依然是人来主导。如果说大语言模型和围绕其的生态是一个新物种，我觉得还不完全是，更像是超人的一种外延，本质上还是人类创造的一种工具，这是这个工具已经超越来人类理解的范畴。​\t当下为模型付出来很高的成本，比如程序员，现在用AI编程能够完成的工作在没有AI编程时雇主需要付出很高的成本，随着AI编程的发展，雇主对普通的编程领域模型支付的成本将会变低。"},{"title":"Webpack 和 Vite：为什么前端开发需要它们？","path":"/2025/03/28/Webpack-和-Vite：为什么前端开发需要它们？/","content":"我感觉就是浏览器的设计不能完全满足前端开发的需求，比如开发体验更好的SCSS，需要转译为CSS，ts转js，这一步需要构建工具来完成。浏览器需要和服务器建立连接，考虑到网络传输，构建工具将javascript进行压缩和合并到一个文件可以提高浏览器加载速度。有各种类型的浏览器，为了兼容这些浏览器，构建工具充当一个中间层可以适配多个不同的浏览器。"},{"title":"HTML5新特性","path":"/2025/03/11/HTML5新特性/","content":""},{"title":"HTML语义化标签总结","path":"/2025/03/11/HTML语义化标签总结/","content":""},{"title":"JavaScript基本类型","path":"/2025/03/09/JavaScript基本类型/","content":"Number, String, Null, Undefined, Boolean。"},{"title":"JavaScript ACM模式","path":"/2025/01/26/JavaScript-ACM模式/","content":"1234567891011121314151617const readline = require(&#x27;readline&#x27;);const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout&#125;);function processInput() &#123; rl.on(&#x27;line&#x27;, (input) =&gt; &#123; //const [a,b] = input.split(&#x27; &#x27;).map(Number); //const sum = a + b; //console.log(sum); &#125;)&#125;processInput();"},{"title":"sharedchat会话管理工具总结","path":"/2025/01/25/sharedchat会话管理工具总结/","content":"由技术变化产生的新需求，基于L站sharedchat的拓展，技术没有太高门槛，成熟的技术团队要么不愿意做要么没有看到技术变革产生的新用户群体。"},{"title":"vue组件通信","path":"/2025/01/24/vue组件通信/","content":"父组件向子组件传递值可以用props, 子组件向父组件传值可以用emit。vue2中可以用事件总线技术如eventbus，eventbus适合小型项目。如果是跨层级的组件可以通过provide和inject配合实现数据传递。Vuex和Pinia可以实现组件状态共享。$parent和$children也可以用于通信，但不建议这样做，会提高组件的耦合度。另外，利用作用域插槽也可以实现组件的通信。"},{"title":"vue中slot总结","path":"/2025/01/21/vue中slot总结/","content":""},{"title":"hexo博客中插入图片语法","path":"/2025/01/21/hexo博客中插入图片语法/","content":"123&#123;% asset_img xxx.png xxx %&#125;"},{"title":"vue中props传值总结","path":"/2025/01/21/vue中props传值总结/","content":""},{"title":"NDVI总结","path":"/2025/01/01/NDVI总结/","content":"NDVI是一种由不同光谱计算而来的指数，具体来说用NIR-RED 比上 NIR + RED, 这个比值可以让植区域尽可能值接近1, 非植被区域的值尽可能小，NDVI可以衡量植被的健康程度，比如寻找农作物的病虫害。生态学家可以用NDVI来检测森林覆盖率变化，遥感专家可以利用NDVI来提取城市绿地。"},{"title":"二叉树的深度与高度","path":"/2024/12/28/二叉树的深度与高度/","content":"二叉树的根节点位于最顶部，这和现实中的树是反的，当谈论二叉树的深度时，通常是以根节点为准，看这个节点到根节点有多少条边，当谈论节点的高度时，以叶子节点为基准，看这个节点到叶子节点有多少条边，注意是到最远叶子节点有多少条边，这和深度不一样，节点的深度明确是到根节点的边数量。"},{"title":"itopmap系统开发复盘","path":"/2024/11/24/itopmap系统开发复盘/","content":"ChatGPT发挥了多大作用? 页面UI的调整 软件思维必须要独立弄懂，不然看不懂别人的代码，不知道如何prompt。 如何理解代码框架（OpenlayerJS）？​\t为什么说调库简单？因为这是相较于实现库来说，实现库需要数学知识和算法思维，这往往是最考验智商的，专业且具有才华的程序员已经实现了这些功能将其封装为一个知识产品了，对于调库的程序员来说，只需要将精力放在看懂知识产品对应的说明书就行，这可能也需要花一些精力，但相对于实现哪些复杂的库来说难度要低很多，站在库构建者角度来说，肯定是希望用户不用花太多的学习成本就能用库方便的构建很多有价值的产品。作为公司，招聘程序员第一也应该是看应聘者将说明书看懂没有，然后才是看对底层实现细节理解的如何。现在的程序员能构建的软件相比于十年前已经复杂很多了，如果非要程序员从每个细节开始学习，那么就很难提高技术的转化率，技术是为社会服务的，脱离了这一前提的技术没有实际意义，只能称其为爱好，这也是专业程序员和以编程为爱好的极客的区别。 如何分析集成第三方开源系统遇到的问题？​\t闭源项目是给用户用的，开源项目是给开发者用的，开源项目好在不仅能够看到表象，还能研究表象的产生源头。首先对开源项目建立正确的认知，开源项目通常是优秀的同行已经建立一个标准化的产品，这个标准化的产品外观和闭源产品很像，如果不能以程序员视角看待，仅以用户视角看待，由于优秀开源项目通常时长期迭代的版本，封装和抽象层次较高，加上开源软件通常具有和闭源软件水准差不多的表象，容易在代码产生报错产生玄学思想，错误的低估来对产品的掌控力，这其实是还是抱着看待闭源软件那种思想，天下没有设计完美的软件，没有哪个软件的设计出来能够满足所有业务需求，但好在开源软件的代码是公开的，可以自主决定软件的行为。","tags":["软件开发项目复盘"]},{"title":"华为云Flexus L实例无法通过公网ip访问","path":"/2024/11/17/华为云Flexus-L实例无法通过公网ip访问/","content":"端口放行配置错了安全组然后服务器又绑定了另一个未未配置放行端口的安全组。","tags":["运维"]},{"title":"openai api调用格式","path":"/2024/11/16/openai-api调用格式/","content":"https://platform.openai.com/docs/quickstart?language-preference=python"},{"title":"leetcode 141. 环形链表","path":"/2024/11/11/leetcode-141-环形链表/","content":"1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */var hasCycle = function(head) &#123; // 0 let slow = head; let fast = head; let ret = false; // 1 while(fast &amp;&amp; fast.next !== null)&#123; fast = fast.next.next slow = slow.next; if(fast === slow)&#123; ret = true; break; &#125; &#125; // 2 return ret;&#125;; 循环中有fast &#x3D; fast.next.next需要判断fast.next不为空容易想到，还需要判断fast不为空，一个是从外部进入循环时的判断，一个是执行了fast &#x3D; fast.next.next后的判断，也可以将fast是否为空的判断写到fast &#x3D; fast.next.next这行之后（如果fast为空则用break跳出循环）","tags":["leetcode","算法"]},{"title":"vue,typescript项目打包报错","path":"/2024/11/10/vue-typescript项目打包报错/","content":"&#x2F;&#x2F; @ts-ignore：无法被执行的代码的错误","tags":["前端开发","Vue"]},{"title":"工作汇报总结","path":"/2024/11/08/工作汇报总结/","content":"计算制作PPT和开会的产出比","tags":["软件项目复盘"]},{"title":"快速更新失效域名证书方法","path":"/2024/11/03/快速更新失效域名证书方法/","content":"服务器端如果是windows直接登录CA官网进行域名证书的更新替换"},{"title":"node版本号排序","path":"/2024/11/01/node版本号排序/","content":"const versions &#x3D; [‘1.10.2’, ‘1.3’, ‘2.0.1’, ‘1.5.1’, ‘1.5’, ‘1.4.1’]; 进行排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 测试数据集（无歧义版本号，所有版本号格式统一）const testCases = [ &#123; input: [&#x27;10.0&#x27;, &#x27;2.0&#x27;, &#x27;1.9&#x27;, &#x27;1.10&#x27;, &#x27;1.8&#x27;], expected: [&#x27;1.8&#x27;, &#x27;1.9&#x27;, &#x27;1.10&#x27;, &#x27;2.0&#x27;, &#x27;10.0&#x27;], description: &quot;主要版本不一致的情况，测试两位版本号的比较&quot; &#125;, &#123; input: [&#x27;1.10&#x27;, &#x27;1.3&#x27;, &#x27;2.0&#x27;, &#x27;1.5&#x27;, &#x27;1.4&#x27;], expected: [&#x27;1.3&#x27;, &#x27;1.4&#x27;, &#x27;1.5&#x27;, &#x27;1.10&#x27;, &#x27;2.0&#x27;], description: &quot;包含主版本和次版本，避免歧义&quot; &#125;, &#123; input: [&#x27;1.0&#x27;, &#x27;1.1&#x27;, &#x27;1.0.1&#x27;, &#x27;1.2&#x27;, &#x27;1.0.0&#x27;], expected: [&#x27;1.0&#x27;, &#x27;1.0.0&#x27;, &#x27;1.0.1&#x27;, &#x27;1.1&#x27;, &#x27;1.2&#x27;], description: &quot;包含固定格式版本，补位0&quot; &#125;, &#123; input: [&#x27;2.1&#x27;, &#x27;2.0&#x27;, &#x27;1.9&#x27;, &#x27;1.10&#x27;, &#x27;1.10.1&#x27;], expected: [&#x27;1.9&#x27;, &#x27;1.10&#x27;, &#x27;1.10.1&#x27;, &#x27;2.0&#x27;, &#x27;2.1&#x27;], description: &quot;小版本和补丁更新及主版本升级&quot; &#125;, &#123; input: [&#x27;0.1&#x27;, &#x27;0.0.1&#x27;, &#x27;0.10&#x27;, &#x27;0.2&#x27;, &#x27;0.2.0&#x27;], expected: [&#x27;0.0.1&#x27;, &#x27;0.1&#x27;, &#x27;0.2&#x27;, &#x27;0.2.0&#x27;, &#x27;0.10&#x27;], description: &quot;补位和次版本，不存在单一数字的歧义&quot; &#125;];/** * 用户需要在这里完成 sortVersions 函数 */function sortVersions(arr) &#123; let newArr = arr.map(e =&gt; e.split(&#x27;.&#x27;).map(Number)); newArr.sort((a, b) =&gt; &#123; for(let i = 0; i &lt; 3; i++)&#123; if(a[i] != b[i])&#123; return a[i] - b[i] &#125; &#125; return 0 &#125;); return newArr.map(e =&gt; e.join(&#x27;.&#x27;));&#125;/** * 判题系统：检查用户的排序结果是否符合预期 */function judge() &#123; testCases.forEach((&#123; input, expected, description &#125;, index) =&gt; &#123; const userSortedVersions = sortVersions([...input]); // 不改变原数组 const result = userSortedVersions.join(&#x27;,&#x27;) === expected.join(&#x27;,&#x27;) ? &#x27;Accepted&#x27; : &#x27;Wrong Answer&#x27;; console.log(`Test Case $&#123;index + 1&#125;: $&#123;description&#125;`); console.log(&quot;Input Versions: &quot;, input); console.log(&quot;User Sorted Versions: &quot;, userSortedVersions); console.log(&quot;Expected Result: &quot;, expected); console.log(&quot;Judge Result: &quot;, result); console.log(&quot;-------------&quot;); &#125;);&#125;// 运行判题系统judge();"},{"title":"itopmap网站专题页面分析","path":"/2024/10/27/itopmap网站专题页面分析/","content":"卷帘添加节流处理，防止当用户拖动滑块地图组件触发较频繁"},{"title":"从二叉树遍历视角看递归思想","path":"/2024/10/25/从二叉树遍历视角看递归思想/","content":"比如中序遍历左中右（适用于一棵仅有三个节点的小二叉树和由无数小的二叉树构成的大二叉树，区别在与小二叉树的子树是一个节点（最小的树），大二叉树的是一棵较大的树，都是符合二叉树的定义） 二叉树是一个抽象的概念，不要被名字误导，二叉树存储的信息包括二叉树的节点值和节点与节点之间的关系，理解了这层逻辑，叫二叉啥都无所谓。 中序遍历就是对二叉树中存储的信息进行读取的一种方式。读取的原则是先读取左子树的信息，再读取根节点的信息，再读取右子树的信息，这个简称逻辑A（如果子树中还有更小的子树-左子树或右子树, 根节点就是自身，不存在多态现象，根节点起连接节点关系的作用，这个子树中也执行同样的逻辑A，那么就可以将整棵树的信息按照中序遍历这种信息提取方式进行读取），其他遍历顺序同理。 关于递归容易让人产生迷雾，需要认识到的是递归函数是一个会调用自身的函数，这点和普通函数有区别，其之所以写起来代码简洁也是来源于这个性质。 递归函数很适合遍历一颗二叉树，因为递归函数自身调用自身的性质和二叉树节点连接节点的性质是一致的。 递归相关的题型可以用和“数形结合”类似的“码形结合”来分析，在脑海中左边是代码，右边是二叉树图像，这两者是可以对应联系起来的。 JavaScript的函数套函数性质可以实现求解一些不是用递归能一下解决、但递归可以作为求解此问题的核心思想的题目，因为递归过程中的参数在外层函数的作用域中。"},{"title":"回溯算法总结","path":"/2024/10/24/回溯算法总结/","content":"有递归就有回溯，因为如果递归进去如果没有找到结果就需要回到之前的位置往另一个方向递归（比如遍历树的情况），有的递归不容易看出回溯可能是没有用完全体的递归。","tags":["算法"]},{"title":"WMTS（Web Map Tile Service）","path":"/2024/10/23/WMTS（Web-Map-Tile-Service）/","content":"本来一个服务器存放瓦片信息就可以了，但是人们发现和地图相关的style和切片方案和服务元数据都可以放在WMTS中"},{"title":"开源项目配置到服务器总结","path":"/2024/10/23/开源项目配置到服务器总结/","content":"在本地设备打包好所有依赖，通过服务器连接工具上传整个安装包，相当于执行离线安装。"},{"title":"tomcat和nginx总结","path":"/2024/10/20/nginx总结/","content":"nginx是一个高效的静态内容 Web 服务器，同时也是反向代理服务器，擅长处理静态资源、负载均衡和反向代理功能。 vue发布的网站非根域名刷新404的错误*解决方法：配置一个重定向规则，使得所有请求都指向Vue应用的入口文件 index.html。 1234567891011server &#123; listen 80; server_name your_domain.com; # 替换为你的域名或IP地址 location / &#123; root /path/to/your/vue/app; # Vue应用打包后的文件存放目录 try_files $uri $uri/ /index.html; # 如果找不到文件，则返回index.html &#125; index index.html;&#125;"},{"title":"flask总结","path":"/2024/10/17/flask总结/","content":"服务器运行flask绑定所有端口 1flask run --host 0.0.0.0"},{"title":"npm配置代理","path":"/2024/10/16/npm配置代理/","content":"12npm config delete proxynpm config set proxy http://proxy-server:port"},{"title":"new关键字绑定","path":"/2024/10/15/new关键字绑定/","content":"12345678function Student(name) &#123; console.log(this); // Student &#123;&#125; this.name = name; // Student &#123;name : &quot;codereasy&quot;&#125;&#125;// 通过new关键字创建一个新对象的步骤是什么、构造函数是如何创建新对象的？var xiaoming = new Student(&quot;codereasy&quot;)console.log(xiaoming); 在构造函数中添加return，如果return的是对象，则直接返回该对象，如果return的是基本类型，则return语句无效，仍然返回我们创建的新对象。"},{"title":"javascript_map对象总结","path":"/2024/10/13/javascript-map对象总结/","content":"12345678910let fruits = new Map();fruits.set(&quot;apple&quot;, &quot;red&quot;);fruits.set(&quot;banana&quot;, &quot;yellow&quot;);console.log(fruits.get(&quot;apple&quot;));console.log(fruits.has(&quot;lemon&quot;));// red// false"},{"title":"让自己开发的软件产品保持latest_version_release的意义","path":"/2024/10/12/让自己开发的软件产品保持latest-version-release的意义/","content":"有助于不断加深自己对技术的理解热启动站在高位思考","tags":["项目复盘"]},{"title":"深拷贝与浅拷贝的区别","path":"/2024/10/12/深拷贝与浅拷贝的区别/","content":"123456789101112131415161718192021let originalObject = &#123; name: &quot;John&quot;, age: 30, hobbies: [&quot;reading&quot;, &quot;coding&quot;],&#125;//浅拷贝对象const shallowCopyObj = Object.assign(&#123;&#125;, originalObject);// 修改拷贝对象的属性shallowCopyObj.name = &quot;Alice&quot;;shallowCopyObj.hobbies.push(&quot;painting&quot;);console.log(originalObject);console.log(shallowCopyObj);//&#123; name: &#x27;John&#x27;, age: 30, hobbies: [ &#x27;reading&#x27;, &#x27;coding&#x27;, &#x27;painting&#x27; ] &#125;//&#123;// name: &#x27;Alice&#x27;,// age: 30,// hobbies: [ &#x27;reading&#x27;, &#x27;coding&#x27;, &#x27;painting&#x27; ]//&#125; 如果对象的属性为引用类型或复杂类型，修改拷贝对象的属性，会影响到原对象，修改原对象的属性，也会影响到拷贝对象。","tags":["编程语言","JavaScript"]},{"title":"缓存总结","path":"/2024/10/07/缓存总结/","content":"强缓存就是在规定的时间内，浏览器直接从本地缓存中拿数据，不需要向服务器发送请求。这样，页面加载会更快。强缓存一般通过设置 Expires 或 Cache-Control 来控制缓存时间。 协商缓存则是浏览器会先向服务器询问，之前缓存的内容有没有更新。如果服务器确认没有更新，浏览器继续使用缓存数据。如果内容有变化，服务器会返回新的资源。协商缓存的机制常见于 Last-Modified 和 ETag 这两个头信息。"},{"title":"DIFF算法","path":"/2024/10/03/DIFF算法/","content":"Diff算法就是difference算法，用于高效找出dom树的差异，有以下注意点：当比较元素的类型不同时，直接重建这颗子树。当类型相同，只替换属性。Key可以用来避免不必要的重建销毁树操作。","tags":["算法"]},{"title":"hexo部署静态资源到github服务器","path":"/2024/09/25/hexo部署静态资源到github服务器/","content":"hexo d失败可以用git clone github仓库地址然后用hexo public目录替换后使用授权github仓库账号执行git push操作替代hexo d fatal: bad tree object 76efcae7c5c88277bd54626c763b790961115445fatal: the remote end hung up unexpectedlysend-pack: unexpected disconnect while reading sideband packetfatal: the remote end hung up unexpectedlyerror: failed to push some refs to ‘https://xxx.git‘FATAL Something’s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess. (D:\\promptonce-blog ode_modules\\hexo-deployer-git ode_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:519:28) at cp.emit (D:\\promptonce-blog ode_modules\\cross-spawn\\lib\\enoent.js:34:29) at ChildProcess._handle.onexit (node:internal&#x2F;child_process:294:12) 清空public目录下的文件克隆托管hexo博客的github仓库，将除.git的文件及目录复制到public目录中将原来根目录的.git目录删掉将克隆下来的目录的.git移动到根目录执行命令 123hexo cleanhexo ghexo d"},{"title":"MMSegmentation实验结果保存命名格式总结","path":"/2024/09/23/MMSegmentation实验结果保存命名格式总结/","content":"日期_模型名_骨干网络_其他重要参数_训练步骤_批次大小_目标尺寸"},{"title":"GPT时代的程序员生存之道","path":"/2024/09/22/GPT时代的程序员生存之道/","content":"GPT时代的程序员生存之道 警惕“Agent”模式带来的便捷，不断提升自己让Agent变成”Copilot”。"},{"title":"为何要将产品当成自己的孩子？","path":"/2024/09/20/为何要将产品当成自己的孩子？/","content":"只追求广度是不行的，光有广度不代表就有很强的判断力 如果学的是是技术的经典理论的话，那么毫无疑问是学的多更好，前提是能够学懂学好。如果是学习技术应用的话，需要知道的是应用是基于底层技术的上层建筑，如果从底层技术的角度分析，那么大多数技术应用在技术底层是同质化严重的，如果沉迷于学的多，对于通过项目来引导理论学习的人来说，可能会无法触及的更深层次的技术理论，从而在对技术的理解上显得局限，虽然这个和性格也有一定关系，但我认为软件工程师认真地学精可能比粗略地学广泛更有意义。 一个不能体现编程设计（能看出缺乏算法训练）的软件项目是很难让优秀的程序员去迭代的","tags":["项目复盘"]},{"title":"快速排序算法","path":"/2024/09/18/快速排序算法/","content":"利用递归，划分子区间","tags":["leetcode","算法"]},{"title":"Linux","path":"/2024/09/17/Linux/","content":"centos命令行操作，配合带远程文件管理器的终端（cursor&amp;vscode remotessh插件）即可完成大部分编程工作。没有GUI页面。"},{"title":"PPT制作总结","path":"/2024/09/15/PPT制作总结/","content":"高效美观地传递信息"},{"title":"Google Colab","path":"/2024/09/15/Google-Colab/","content":"谷歌硬盘保存代码及数据"},{"title":"编码隐匿在计算机软硬件背后的语言","path":"/2024/09/15/编码隐匿在计算机软硬件背后的语言/","content":"人们在相互沟通时使用了各种不同的编码，因为在不同的应用场合，其中的一些较其他的更为简便。例如，语言不能在纸上存储，所以使用了文字；语言、文字不适合用来在黑夜中安静地传递消息，故摩尔斯电码是一个方便的替代品。只要一种编码可以适用于其他编码所不能适用的场合，它就是一种有用的编码。 总结:为特定环境编码提高效率，满足需求","tags":["技术书籍阅读"]},{"title":"哈希表","path":"/2024/09/15/哈希表/","content":"哈希表将value和key关联起来，通过value计算出key实现快速判断一个元素是否出现集合里。 参考文章代码随想录"},{"title":"中缀表达式转后缀表达式","path":"/2024/09/14/中缀表达式转后缀表达式/","content":"从左到右依次扫描中缀表达式遇到元素为数字直接输出遇到算数运算符入栈遇到”(“入栈遇到”)”, 匹配左括号，所以栈顶元素依次出栈，直到”(“, 左括号也要出栈，然后直接扔掉，不放于结果后遇到符号，但栈顶符号优先大于当前元素，所以出栈〈栈中符号优先级如果都不小于当前元素则全部出栈）。当前元素入栈。最后如果栈中还有元素，则栈中符号依次出栈。 如果栈顶元素的优先级和当前遍历元素优先级一样呢？ 根据运算符的结合性来决定： 左结合运算符（如 + - \\* /） 先将栈顶元素出栈并输出 再将当前运算符入栈 右结合运算符（如 ^） 直接将当前运算符入栈，不弹出栈顶元素 这样保证了表达式转换为后缀表达式（逆波兰表达式）时，运算的先后顺序不会改变。 中缀表达式之所以需要转为后缀表达式是因为可以结合栈这个数据结构简化计算机对运算优先级的处理逻辑。 手动将中缀表达式转为后缀表达式的方法是对应人对中缀表达式计算过程中的优先级来添加括号，如果已经有括号则不添加，然后将符号移动到其对应括号的右边再去除括号，得到的式子即为后缀表达式。"},{"title":"前中后缀表达式","path":"/2024/09/14/前中后缀表达式/","content":"中缀表达式：运算符夹在操作数中间，比如 A + B。我们平时最常用的就是这种表达方式。 后缀表达式（也叫逆波兰表达式）：运算符放在操作数的后面，比如 A B +。这种方式没有括号，计算顺序完全取决于操作符的先后位置。","tags":["leetcode","算法"]},{"title":"完全二叉树","path":"/2024/09/14/完全二叉树/","content":"完全二叉树只允许最后一行不为满 最后一行必须从左往右排序 最后一行元素之间不可以有间隔","tags":["算法"]},{"title":"策略模式","path":"/2024/09/14/策略模式/","content":"策略模式允许用户在运行时选择算法或行为的具体实现。使用策略模式可以定义一系列的算法，并将每一个算法封装起来，使他们可以相互替换，这样算法的变化不会影响到使用算法的客户端"},{"title":"订单网站团队协作开发回顾","path":"/2024/09/10/订单网站团队协作开发回顾/","content":"进度把控能力任务拆解能力","tags":["软件项目复盘"]},{"title":"windows高效工具列表","path":"/2024/09/09/windows高效工具列表/","content":"notion sublime text vscode syncthing atom github noi microsoft powertoys bitwarden git microsoft whiteboard"},{"title":"OJ在线编程常见输入输出练习场总结","path":"/2024/09/09/OJ在线编程常见输入输出练习场总结/","content":"对于javascript语言, 掌握readline()函数和split()函数的使用编写代码速度要看内功，代码只是形式，编写代码过程中先在纸上完成题目的分析和方法的筛选，这一步先不要用代码作为分析语言，用纯逻辑分析，逻辑要严密，相当于在大脑中先运行排除掉一些后续翻译代码潜在的的bug，然后代入一个测试用例模拟运行分析是否可行，在纸上分析觉得可以的话就可以开始编码（题目简单基础的话可以只在大脑中完成），遇到bug就结合纸上的模拟运行的记录进行debug, 很多面试题都是考察经典的计算机编程理论。 做编程题（以培养编程思维为目的）的时候要适当克制用ide运行排错的意识，很多时候想用编译器进行边界条件的检查，但编程思维或编程信心也部分来自于脱离编译器独立得出正确的边界条件的过程。对于算法水平一般的人来说，考虑的主要是稳定性的边界条件。 学习编程题是为了更好的指导机器工作，不是让程序员去替代机器执行它所擅长的，不要试图理解每一个细节（可以适当不追求你的可读性，符合行业标准即可），除非必要。 编程是程序员为主，程序员是程序成长的主导者，不要有深度学习里的那种黑盒借口，这里的程序你是可控的。 如果一个API上网查的速度小于记忆回忆的速度就需要记住，这和现在有了AI翻译但那些会讲英语的人仍然优秀的原理是相同的。 平时刷题的时候不要过多花时间去从0想一个新算法，现在能够学习到的经典算法（其中部分已应用到生产中）的算法都是优秀的人花精力和天赋总结的，更多时候只需要理解别人的成果外加不断的练习巩固就可以提升自己的编程算法能力。 编程算法题笔试面试遇到不会的首先分析这个题的可能解题方向是啥（更多的是数据结构与算法的内容，不需要像搞科研那样的创新），如果是考察的经典的解题思路，由于一般这种题都会是在经典题型上进行变体（大公司很少考原题），需要将问题拆分为子问题逐个解决，这样有助于克服思绪混论的问题，然后，如果想不到解题方向，就将题进行简化为经典熟悉的简化题型（哪些题你确定你掌握了呢，根据打蛇打七寸的思想找，一定是有这种已掌握的题型的。）找是否可以排列组合成一个可能的解题思路。"},{"title":"passwordtry","path":"/2024/09/08/passwordtry/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107const rl = require(&quot;readline&quot;).createInterface(&#123; input: process.stdin &#125;);var iter = rl[Symbol.asyncIterator]();const readline = async () =&gt; (await iter.next()).value;void async function () &#123; // // Write your code here // while(line = await readline())&#123; // let tokens = line.split(&#x27; &#x27;); // let a = parseInt(tokens[0]); // let b = parseInt(tokens[1]); // console.log(a + b); // &#125; let n = parseInt(await readline()) let correct = await readline() let test = [] for(let i = 0; i &lt; n; i++)&#123; test.push(await readline()) &#125; // console.log(test) let qpl = [] let arr = [] let idxarr = new Array(test.length).fill(0) // console.log(idxarr) const permute = (test) =&gt; &#123; let result = []; // 用于存放最终的所有排列 let arr = []; // 当前的排列结果 let used = new Array(test.length).fill(false); // 标记哪些元素已经使用过 const backtracking = () =&gt; &#123; // 当排列长度等于输入数组长度时，表示找到一个完整的排列 if (arr.length === test.length) &#123; result.push(arr.slice()); // 将当前排列的拷贝加入结果 return; &#125; // 遍历数组中的每一个元素 for (let i = 0; i &lt; test.length; i++) &#123; // 如果当前元素已经使用过，跳过 if (used[i]) continue; // 将当前元素加入排列，并标记为已使用 arr.push(test[i]); used[i] = true; // 递归调用，继续生成下一个元素的排列 backtracking(); // 回溯：撤销当前的选择，恢复状态 arr.pop(); used[i] = false; &#125; &#125;; backtracking(); // 开始回溯 return result; // 返回所有生成的排列&#125;;// 示例调用let permutations = permute(test);// console.log(permutations);// 将permutations数组按字符串长度从小到大的顺序排序//想要排序的对象：是 permutations 数组的排列，而不是排列内的元素。排序标准：是根据每个排列的长度（permutations[i].length），而不是排列内元素的大小。for(let i = 0; i &lt; permutations.length; i++)&#123; for( let j = permutations[i].length - 1; j &gt; 0; j--)&#123; for( let k = 0; k &lt; j; k++)&#123; if(permutations[i][k] .length&gt; permutations[i][k+1].length)&#123; let temp = permutations[i][k]; permutations[i][k] = permutations[i][k+1]; permutations[i][k+1] = temp; &#125; &#125; &#125;&#125;// console.log(permutations)let minTry = nlet maxTry = 1for(let i = 0; i &lt; permutations.length; i++)&#123; let currentTry = 0 let wrongAnswer = [] for( let j = 0; j &lt; permutations[i].length ; j++)&#123; let flag1 = false for(let k = 0; k &lt; wrongAnswer.length; k++)&#123; if(permutations[i][j] == wrongAnswer[k])&#123; flag1 = true; break &#125; &#125; if(flag1)&#123; continue; &#125; currentTry++; if(permutations[i][j] == correct)&#123; break; &#125; else &#123; wrongAnswer.push(permutations[i][j]) &#125; &#125; if(currentTry &lt; minTry)&#123; minTry = currentTry &#125; if(currentTry &gt; maxTry)&#123; maxTry = currentTry &#125;&#125;console.log(minTry,maxTry)&#125;() 通过绘制树形图来理解。涉及到数组的排列和组合可以通过结合树形图和回溯来理解，直接从数组角度不太好想。 你想要排序的对象：是 permutations 数组的排列，而不是排列内的元素。 排序标准：是根据每个排列的长度（permutations[i].length），而不是排列内元素的大小。"},{"title":"简单工厂模式","path":"/2024/09/08/简单工厂模式/","content":"简单工厂模式（Simple Factory Pattern) ：又称为静态工厂方法 (Static Factory Method) 模式》它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。"},{"title":"77.组合,216.组合总和III,17.电话号码的字母组合","path":"/2024/09/06/77-组合-216-组合总和III-17-电话号码的字母组合/","content":"77.组合 代码随想录 leetcode 可以用回溯，但不知道如何回溯 定义了两个数组，一个用于函数返回的结果，一个用于记录返回结果的单元即数组的元素，在分析出这个题用回溯算法可以解决后，第一步需要做的就是定义变量，代码就是根据多种定义的变量编写的逻辑。 arr.slice() 创建一个包含原有数组中一个或多个元素的新数组 216.组合总和III17.电话号码的字母组合","tags":["leetcode","算法"]},{"title":"235.二叉搜索树的最近公共祖先,701.二叉搜索树中的插入操作,450.删除二叉搜索树中的节点","path":"/2024/09/04/235-二叉搜索树的最近公共祖先-701-二叉搜索树中的插入操作-450-删除二叉搜索树中的节点/","content":"​235. 二叉搜索树的最近公共祖先 只能想到普通的二叉树搜索最近的公共祖先的方法，不知道如何利用二叉搜索树的性质。 二叉搜索树根节点的值大于左子树的所有值小于右子树的所有值，从上到下便利到第一个位于p，q区间内的说明p，q位于当前便利节点的两侧，根据二叉树的图形，当前节点一定是p，q最近的公共祖先节点，因为如果不是接下来向左或向右都会错过成为另一个节点的祖先的机会，所以返回这个节点即可。 单层递归逻辑中，当p，q的值都大于或都小于当前遍历节点的值时，依次递归右子树或左子树后接收返回值需要判断是否为null再返回，递归下一层时漏写参数。 4. 单层递归逻辑中，当p，q的值都大于或都小于当前遍历节点的值时，依次递归右子树或左子树后接收返回值需要判断是否为null再返回，递归下一层时再次注意不要漏写参数。用了一天的零散时间。 701.二叉搜索树中的插入操作 根据二叉搜索树的性质，无论插入的数值是啥，都可以通过遍历到一个左右节点为null的节点进行插入。 插入是在二叉搜索树的叶子节点进行插入操作。 迭代法中没有考虑二叉搜索树为空的情况以及当前遍历节点左右子树其中一个为空另一个不为空的情况；递归法终止条件是返回一个新创建的节点。 4. 迭代法中没有考虑二叉搜索树为空的情况以及当前遍历节点左右子树其中一个为空另一个不为空的情况；递归法终止条件是返回一个新创建的节点。用了一天的零散时间。 450.删除二叉搜索树中的节点 不知道咋做。 递归的返回值是删除节点后的根节点，删除二叉搜索树中的节点分几种情况，第一种是待删除的节点为叶子节点，这种直接将null返回到上层递归进行处理即可，如果删除节点不是叶子节点且左右子树中一个为空一个不为空，则返回不为空的那一个（作为删除待删除节点后到二叉搜索树的根节点）到上一层递归中进行处理。如果待删除节点左右子树不为空，则先定义一个临时指针，初始值为当前指针的右子树位置，依次往左子树左边遍历，直到临时指针的左指针为null时暂停，将之前遍历的指针（临时指针的初始位置）的左子树放置到临时指针的右子树位置，返回之前遍历的指针（临时指针的位置）。 3. 递归的返回值是删除节点后的根节点，删除二叉搜索树中的节点分几种情况，第一种是待删除的节点为叶子节点，这种直接将null返回到上层递归进行处理即可，如果删除节点不是叶子节点且左右子树中一个为空一个不为空，则返回不为空的那一个（作为删除待删除节点后到二叉搜索树的根节点）到上一层递归中进行处理。如果待删除节点左右子树不为空，则先定义一个临时指针，初始值为当前指针的右子树位置，依次往左子树左边遍历，直到临时指针的左指针为null时暂停，将之前遍历的指针（临时指针的初始位置）的左子树放置到临时指针的右子树位置，返回之前遍历的指针（临时指针的位置）；递归函数内部再次递归时漏写参数。 4. 递归的返回值是删除节点后的根节点，删除二叉搜索树中的节点分几种情况，第一种是待删除的节点为叶子节点，这种直接将null返回到上层递归进行处理即可，如果删除节点不是叶子节点且左右子树中一个为空一个不为空，则返回不为空的那一个（作为删除待删除节点后到二叉搜索树的根节点）到上一层递归中进行处理。如果待删除节点左右子树不为空，则先定义一个临时指针，初始值为当前指针的右子树位置，依次往左子树左边遍历，直到临时指针的左指针为null时暂停，将之前遍历的指针（临时指针的初始位置）的左子树放置到临时指针的右子树位置，返回之前遍历的指针（临时指针的位置）；递归函数内部再次递归时注意不要漏写参数。用了两天的零散时间。","tags":["leetcode","算法"]},{"title":"530.二叉搜索树的最小绝对差,501.二叉搜索树中的众数,236.二叉树的最近公共祖先","path":"/2024/09/04/530-二叉搜索树的最小绝对差-501-二叉搜索树中的众数-236-二叉树的最近公共祖先/","content":"​530.二叉搜索树的最小绝对差 第一遍没有看懂题, 用层序遍历将所有树节点保存到一个数组中，然后依次遍历数组中每一个元素（即节点），将节点值作为基准元素递归遍历以这个节点为根节点的二叉树，计算根节点和当前遍历节点的值差的绝对值，然后和全局最小值进行比较，如果比全局最小值更小则更新全局最小值，最后返回全局最小值。 此题中说了是找二叉搜索树的最小绝对差，这颗树是有顺序的，左子树的值小于根节点的值小于右子树的值，用中序遍历转为转为数组也可以比较简单计算出最小绝对差，更好的方法是用一个指针变量记录前一个遍历节点的值（这里利用了二叉搜索树是有序的这个性质，最小绝对差的两个元素一定是相邻的两个元素），通过不断地递归中序遍历整棵树，同时更新pre指针变量，依次计算差的绝对值，然后和全局最小绝对差进行比较，如果当前差的绝对值更小则更新全局最小绝对差，最后返回全局最小绝对差。 不知道如何用javascript表示一个最大的数，忘记了是将当前遍历节点值和前一个结点值做差再和全局最小值做比较，这里用了当前遍历结点值直接和全局最小值做了比较，不够细致。忘记了更新pre指针，有偷懒的想法，因为看卡哥视频讲解中将一些关键代码都记录下来了，没有严格要求自己。 javascript中Math.max()对应的是-Infinity，要细致地读题，充分利用题目中的条件；刷题时尽量不要偷懒背题不思考；用了一天的零散时间。 501.二叉搜索树中的众数 1. 通过中序遍历将二叉搜索树所有结点值转为一个数组，然后本题就变成了求一个数组最长的连续重复子数组对应的数值的问题，然后用快慢指针先找到最大重复次数，然后同样用快慢指针再循环一遍数组找到所有等于最大重复次数的数值将其保存到一个结果数组中返回。 用双指针的思路，定义一个指针记录前一个遍历的结点，再定义一个全局最大重复次数的最大值，再定义一个全局变量result收集结果集，中序遍历过程中，定义一个count记录当前重复了多少次，如果当前重复次数和全局最大重复次数相等，则收集结果集，如果当前重复次数大于全局最大重复次数，更新全局最大重复次数的同时还要清空结果集，因为之前的结果集已经不满足条件了，最后返回结果集。 在用1中的思路时，当得到二叉搜索树中序遍历结点值数组后，用快慢指针遍历时在边界条件那里想了很长时间。在用2中的思路时更新前一个pre指针写到了判断当前结点和前一个结点的判断逻辑中去了，中序遍历过程中用于记录当前重复次数的count大于全局最大重复次数的代码处理逻辑中，只更新了全局最大重复次数和清空了结果数组，没有将新的结点值添加到结果数组中。 4. 在用1中的思路中，当得到二叉搜索树中序遍历结点值数组后，用快慢指针遍历时在边界条件外层写一个条件后可以通过内层循环逻辑去适配这个边界条件，不用同时外层考虑两个边界条件，这样可能会思路会乱。在用2中的思路时更新前一个pre指针写到了判断当前结点和前一个结点的判断逻辑中去了，中序遍历过程中用于记录当前重复次数的count大于全局最大重复次数的代码处理逻辑中，如果中序遍历过程中当前重复次数大于全局最大重复次数了，说明此时找到了更满足题条件的解，应当清空数组但也需要将当前结点值保存下来，否则结果集就会漏解。用了两天的零散时间。 二叉树的最近公共祖先 读题后感觉需要题目说的是判断两个结点是否有共同的最近祖先，不知道咋做。 本题用了回溯的思想，首先需要明确是从下往上找，所以用后续遍历，在左右子树上如果找到了这两个子节点中的其中一个都可以返回到上一级递归中，上一级递归中判断左右子树是否分别有这两个结点，如果有，那说明这一级递归中的结点就是最近的公共祖先，如果只有左子树有其中一个给定子节点，右子树没有给定的另一个子节点，说明当前递归层中的结点不是公共祖先，那么则返回右的这个子节点，交由上一级递归中的结点去判断，反之如果右子树有左子树没有也是同样的逻辑，如果左右子树都没有，那么就返回null。递归的终止条件是如果当前遍历结点为null或者为两个给定子节点中的其中一个则返回当前结点。 分别递归左右子树的时候递归函数中少写了参数，又有背卡哥视频的代码，对原理理解的还不是很透彻。 尽量理解原理做题而不是靠记忆。用了两天的零散时间","tags":["leetcode","算法"]},{"title":"654.最大二叉树,617.合并二叉树,700.二叉搜索树中的搜索,98.验证二叉搜索树","path":"/2024/09/04/654-最大二叉树-617-合并二叉树-700-二叉搜索树中的搜索-98-验证二叉搜索树/","content":"​654.最大二叉树 不知道咋做。 找到数组最大值，将数组划分为左右数组，然后递归构造二叉树，当数组长度为1时，构造二叉树节点然后返回。 在递归生成左右子树时需要判断划分的数组长度是否不为1,生成的节点递归创建左右子树有意义。 用了一天的零散时间。 617.合并二叉树 不知道咋做。 同时操作两棵树t1,t2, 可以直接用t1或t2根节点返回，递归的终止条件是如果t1为null,则返回t2, 如果t2为null则返回t1, 比如同时遍历t1和t2时，两颗树都有值直接进行相加操作，其中一个为null则返回另一个节点，依次递归处理左子树和右子树。 3. 同时操作两棵树t1,t2, 可以直接用t1或t2根节点返回，递归的终止条件是如果t1为null,则返回t2, 如果t2为null则返回t1, 比如同时遍历t1和t2时，两颗树都有值直接进行相加操作，其中一个为null则返回另一个节点，依次递归处理左子树和右子树。 4. 用了两天的零散时间。 二叉搜索树中的搜索 不知道咋做。 二叉搜索树根节点的值大于左子树的值，小于右子树的值，根据数值的大小自动选择递归调用选择返回左子树 &#x2F; 右子树节点。迭代法通过循环和节点值选择方向。 3. 二叉搜索树根节点的值大于左子树的值，小于右子树的值，根据数值的大小自动选择递归调用选择返回左子树 &#x2F; 右子树节点。迭代法通过循环和节点值选择方向。 4. 用了两天的零散时间。 98.验证二叉搜索树 不知道咋做。 通过生成一个中序遍历的数组，检查数组是否单调递增即可判断是否是二叉搜索树；通过设置一个变量记录前一个变量节点的数值，然后在每次遍历时通过比较前序遍历的中节点的值和记录的变量的大小关系，如果当前节点的值大于变量记录的值，则可能是二叉搜索树，否则不是二叉搜索书。 用生成数组判断递增中用到了双指针，后一个指针当&gt;&#x3D; length - 1时就需要跳出循环，while循环最下面判断后指针位于数组最后一个元素位置则跳出循环;JavaScript中定义最小值-Math.min() 4.用了两天的零散时间。","tags":["leetcode","算法"]},{"title":"513.找树左下角的值,112. 路径总和,106.从中序与后序遍历序列构造二叉树","path":"/2024/09/04/513-找树左下角的值-112-路径总和-106-从中序与后序遍历序列构造二叉树/","content":"​513.找树左下角的值 层序遍历可以做，不知道用递归咋做。 2.认真读题，首先是必须同时满足深度最大和左边两个条件，通过一个全局变量maxDepth保存最大深度，result保存最大深度对应的节点值，这个值必须是左节点，本题没有对中节点的处理逻辑，前中后序遍历都可以，只需满足左节点比右节点先遍历，递归结束后，返回result。 javascript不能直接在函数外层用let定义变量（maxDepth, result）,递归过程中这些值不能更新，可以通过用一个函数f在内部嵌套递归函数，函数f中定义的变量递归函数可以访问到和更新。 用了两天的零散时间。 路径总和 需要在递归计算过程中去判断是否节点值和为sum, 不知道单层递归逻辑是啥。 2.递归遍历节点过程中对sum进行可以减去节点值，当遍历到叶子节点判断sum是否为0则知道这个遍历路径是否满足条件，如果不满足条件，则会进行回溯，继续寻找其他路径。当为sum为0且当前节点为叶子节点则找到一条路径，返回true。 3.第一次递归就需要进行一个sum - root.val操作传递给递归函数，在对左右子树分别进行递归处理后需要返回false, 因为左右子树都没有找到满足条件的路径，则说明树没有符合节点和相加为sum的路径，则返回false。 用了两天的零散时间。 106.从中序与后序遍历序列构造二叉树 不知道咋做，觉得很麻烦。 从中序和后续遍历序列构造二叉树也是一个递归过程，先从后续遍历的最后一个位置确定根节点，这个值用来创建根节点n，二叉树在创建过程中也可以看成是无数个根节点创建而成的，然后根据这个根节点的值将中序遍历序列划分为左中序序列和有中序遍历序列，根据左中序序列的数组长度和右中序序列的数组长度将后续遍历序列也划分为左后续序列和右后续序列，然后递归处理左中序序列，左后序序列赋值给n的左孩子，递归处理右中序序列，右后序序列赋值给n的右孩子，最后返回节点n。 从中序和后续遍历序列构造二叉树也是一个递归过程，先从后续遍历的最后一个位置确定根节点，这个值用来创建根节点n，二叉树在创建过程中也可以看成是无数个根节点创建而成的，然后根据这个根节点的值将中序遍历序列划分为左中序序列和有中序遍历序列，根据左中序序列的数组长度和右中序序列的数组长度将后续遍历序列也划分为左后续序列和右后续序列，然后递归处理左中序序列，左后序序列赋值给n的左孩子，递归处理右中序序列，右后序序列赋值给n的右孩子，最后返回节点n。划分中序右序列那里需要从根节点位置的下一位作为开始节点位置。 用了两天的零散时间。","tags":["leetcode","算法"]},{"title":"110.平衡二叉树,257.二叉树的所有路径,404.左叶子之和,222.完全二叉树的节点个数","path":"/2024/09/04/110-平衡二叉树-257-二叉树的所有路径-404-左叶子之和-222-完全二叉树的节点个数/","content":"​110.平衡二叉树 （优先掌握递归） 不知道咋做。 在求二叉树的高度的代码上改，二叉树的高度肯定是大于等于0的，这里利用高度不可能是-1但可以表示当前子树不是平衡二叉树，子树不是平衡二叉树递归回来也不是平衡二叉树。 3. 在求二叉树的高度的代码上改，二叉树的高度肯定是大于等于0的，这里利用高度不可能是-1但可以表示当前子树不是平衡二叉树，子树不是平衡二叉树递归回来也不是平衡二叉树。 4。用了零散时间看，大概用了两天。 二叉树的所有路径 （优先掌握递归） 不知道咋做，但知道和遍历顺序有关。 递归进入下一层后要能够回到之前的状态，这样才能够遍历到以某个节点的另一条路径，回藏在递归中。 javascript本身就是赋值引用，所以不用单独针对递归进行处理。 用了零散时间，大概用了两天。 404.左叶子之和 （优先掌握递归） 这个是不是在递归过程中要用if判断。 首先是叶子节点，然后是左叶子节点，所以无法从当前节点进行判断是否是左叶子节点，只能从节点的父节点进行判断，如果当前节点的左孩子不为空，且左孩子的左孩子、右孩子为空，则找到了一个左叶子，右子树可能也有左叶子节点，也要递归，最后将左右的叶子节点相加返回。 3.首先是叶子节点，然后是左叶子节点，所以无法从当前节点进行判断是否是左叶子节点，只能从节点的父节点进行判断，如果当前节点的左孩子不为空，且左孩子的左孩子、右孩子为空，则找到了一个左叶子，右子树可能也有左叶子节点，也要递归，最后将左右的叶子节点相加返回。 4.用了零散时间，大概用了两天。 222.完全二叉树的节点个数（优先掌握递归） 不知道咋做。 没有完全理解，这个博客拖了太久了，这个题二刷再研究吧，因为可以用后续遍历，这里直接用的普通的后续遍历，遍历到空节点返回0,然后分别递归左右子树计算节点数和再加1得到以当前节点为根节点的数的节点数和然后返回。 3. 没有完全理解，这个博客拖了太久了，这个题二刷再研究吧，因为可以用后续遍历，这里直接用的普通的后续遍历，遍历到空节点返回0,然后分别递归左右子树计算节点数和再加1得到以当前节点为根节点的数的节点数和然后返回。 &#x2F;","tags":["leetcode","算法"]},{"title":"226.翻转二叉树,101.对称二叉树,104.二叉树的最大深度,111.二叉树的最小深度","path":"/2024/09/04/226-翻转二叉树-101-对称二叉树-104-二叉树的最大深度-111-二叉树的最小深度/","content":"​226.翻转二叉树 根节点可以交换左右指针，其他层逻辑不清楚，觉得应该不是简单的交换指针。 从下到上，依次交换节点的左右指针即可，关键在于选择遍历顺序，可以选择前序遍历和后序遍历，后续遍历（左右中，右左中）是先处理下层节点再处理当前层节点，处理每个节点都是执行一个交换指针操作。 交换指针的逻辑，javascript交换指针函数需要传递root,不能改变root.left和root.right的值达到交换指针的效果。 4.用了一个小时左右。 对称二叉树 根节点可以比较左右指针，其他层如何比较不知道。 2. 以根节点的子节点leftnode,rightnode这一层为例，首先判断leftnode,rightnode是否为空，leftnode和rightnode都为空，满足对称返回true, leftnode，rightnode其中一个为空则返回false,如果leftnode,rightnode都不为空则判断leftnode,rightnode两个节点的值是否相等，不相等则返回false,相等则继续递归比较leftnode.left和rightnode.right是否想等，leftnode.right和rightnode.left是否相等。如果这两次判断都为true,则结果为true,否则结果为false。递归结束条件为当前遍历节点为空。 3. 以根节点的子节点leftnode,rightnode这一层为例，首先判断leftnode,rightnode是否为空，leftnode和rightnode都为空，满足对称返回true, leftnode，rightnode其中一个为空则返回false,如果leftnode,rightnode都不为空则判断leftnode,rightnode两个节点的值是否相等，不相等则返回false,相等则继续递归比较leftnode.left和rightnode.right是否想等，leftnode.right和rightnode.left是否相等。如果这两次判断都为true,则结果为true,否则结果为false。递归结束条件为当前遍历节点为空。 用了一个小时左右。 104.二叉树的最大深度 只想到了层序遍历可以计算深度。 根节点的最大高度就是二叉树的最大深度，二叉树要求高度，通过后序遍历（即左右中）往上计算，叶子节点的高度为1，对于左右中的遍历顺序来说，中节点的最大深度高度为左右子节点高度中的最大值+1，递归结束条件为遍历节点为空，此时高度为0。 3. 根节点的最大高度就是二叉树的最大深度，二叉树要求高度，通过后序遍历（即左右中）往上计算，叶子节点的高度为1，对于左右中的遍历顺序来说，中节点的最大深度高度为左右子节点高度中的最大值+1，递归结束条件为遍历节点为空，此时高度为0。 用了一个小时左右。 111.二叉树的最小深度 只想到了层序遍历可以计算深度。 同样可以转换为计算二叉树的最小高度，采用左右中的遍历顺序，注意二叉树最小深度的定义，是从根节点到叶子节点的长度，不是空节点，所以需要添加判断条件 — 当左子树为空有子树为空时返回右子树的高度+1；当左子树不为空右子树为空时，返回左子树的高度+1；当左右子树都为空时，说明此时为叶子节点，高度为1；当左右子树都不为空时，分别计算左右子树的高度，取最小值再+1即为中节点对应高度；递归结束条件为当前节点为空。 3. 当左子树为空有子树为空时返回右子树的高度+1；当左子树不为空右子树为空时，返回左子树的高度+1。 用了一个小时左右。","tags":["leetcode","算法"]},{"title":"N叉树遍历相关(144,94,102,102,107,199,429,515,16,117,104,111)","path":"/2024/09/04/N叉树遍历相关(144,94,102,102,107,199,429,515,16,117,104,111)/","content":"​144. 二叉树的前序遍历 1.用递归。 2.递归结束条件是root为null。 3.&#x2F; 4.用了半个小时。 二叉树的后序遍历1.用递归。 2.递归结束条件是root为null。 3.递归那里忘记传入数组。 4.用了半个小时。 二叉树的中序遍历1.用递归。 2.递归结束条件是root为null。 3.&#x2F; 4.用了一分钟。 二叉树的层序遍历 1.首先想用循环，但又感觉做不出来。 利用队列的先进先出特性，同时记录一下树每一层的节点个数size，在开始读树的新一层时更新size, 循环size次将同一层的节点值保存进一个数组vector，size次后将vector作为一个元素保存进结果数组，当队列长度为0时代码执行结束。 3.最外层循环的边界条件没想清楚，左右节点入队时要判断是否为空。 用了一个小时左右。 二叉树的层序遍历 II 二叉树层序遍历为基础改的题。 没有看。 3.javascript array的unshift是从前面添加数组元素。 用了十分钟左右。 二叉树的右视图 二叉树层序遍历为基础改的题。 没有看。 3.javascript中获取数组最后一个元素不能通过arr[-1]来获取。 用了十分钟左右。 429 ． N 叉树的层序遍历 二叉树层序遍历为基础改的题。 没有看。 3.多子节点是存放在一个数组中。 用了半个小时左右。 515 ．在每个树行中找最大值 二叉树层序遍历为基础改的题。 没有看。 3.多子节点是存放在一个数组中。 用了半个小时左右。 16 ．填充每个节点的下一个右侧节点指针 二叉树层序遍历为基础改的题。 没有看。 3.javascript中可以通过Math.max.apply(null, arr)获取arr的最大值。 用了半个小时左右。 117 ．填充每个节点的下一个右侧节点指针 二叉树层序遍历为基础改的题。 没有看。 3.在如何连接指针那里想了一下，将二叉树层序遍历存放节点值修改为存放节点对象，就可以通过遍历二维数组中的每个层节点数组进行指针指向操作，不知道是否还有更好的方法。 将二叉树层序遍历存放节点值修改为存放节点对象，就可以通过遍历二维数组中的每个层节点数组进行指针指向操作；用了一个小时左右。 104 ·二叉树的最大深度 二叉树层序遍历为基础改的题。 没有看。 3.在如何获得二叉树最大深度那里想了一下，遍历每一层节点值将其保存进一个数组作为二维数组的元素，有多少个这样的元素二叉树的深度就是多少，不知道是否还有更好的方法。 遍历每一层节点值将其保存进一个数组作为二维数组的元素，有多少个这样的元素二叉树的深度就是多少；用了半个小时左右。 111 ．二叉树的最小深度 二叉树层序遍历为基础改的题。 没有看。 3.在如何获得二叉树最小深度那里想了一下，遍历每一层时将节点保存进一个数组中，然后将层节点数组作为二维数组的一个元素，循环遍历这个二维数组中的每一个元素，如果该元素的左右子节点均为空，则这个元素所在的最外层索引下标+1即为二叉树的最小深度，不知道还有没有更好的方法。 遍历每一层时将节点保存进一个数组中，然后将层节点数组作为二维数组的一个元素，循环遍历这个二维数组中的每一个元素，如果该元素的左右子节点均为空，则这个元素所在的最外层索引下标+1即为二叉树的最小深度；用了一个小时左右。","tags":["leetcode","算法"]},{"title":"150.逆波兰表达式求值","path":"/2024/09/04/150-逆波兰表达式求值/","content":"​150. 逆波兰表达式求值 知道会用到栈，要用到入栈和弹出操作。 遇到数就入栈，遇到操作符就弹出两个操作数，用操作符进行计算，然后将结果入栈，直到遍历完后缀表达式，栈中最后一个元素就是逆波兰表达式计算结果。 注意两个数在和操作符的相对位置，弹出的第一个数应该在操作符的右边，弹出的第二个数应该在操作符的左边，循环遍历逆波兰表达式判断是否位操作符时tokens[i]没有写[i]导致程序用例不能完全通过。 用了一个小时左右。","tags":["leetcode","算法"]},{"title":"232.用栈实现队列,225.用队列实现栈,20.有效的括号,1047.删除字符串中的所有相邻重复项","path":"/2024/09/04/232-用栈实现队列-225-用队列实现栈-20-有效的括号-1047-删除字符串中的所有相邻重复项/","content":"​232.用栈实现队列 知道要用两个栈实现，具体咋做忘了。队列的特性是先进先出，栈是先进后出，入队操作直接入栈就行，实现出队操作，入栈的第一个元素在栈最下面出来需要借助另一个栈b，先将所有元素入栈b，这样出栈的时候就是入队的第一个元素了，javascript中的栈竟然是直接用数组代替的，直接就可以进行pop操作和push操作。实现了pop函数在实现peek操作的时候可以直接调用pop来简化代码这个编程习惯真好。不知道栈如何实现。用了一个小时左右。225. 用队列实现栈 模模糊糊知道要用两个队列来实现，具体咋做忘了。用一个队列也可以实现栈，比如栈是先进后出，在一个队列里这个元素要出来必须等前面的元素出来才可以，可以让这个元素之前的元素出队再入队，这样就可以达到出栈元素的目的。javascript中队列竟然也是用数组实现的，出队元素是通过执行数组的shift方法达到获取移除第一个元素的作用。用了一个小时左右。 20. 有效的括号 有栈的代码了这个题感觉ok。&#x2F;需要建立左符号和右符号的关系，遇到右符号不是比较出栈元素和这个元素是否相等，而是判断这两个符号是否配对；遍历完字符串后，栈是否为空都有返回值。用了半个小时左右。 1047. 删除字符串中的所有相邻重复项 先想到用双指针，没做出来。原来用栈这么简单，结果就藏在栈里面的内容中，遍历一个新元素就检查栈顶是否和这个新元素相同，相同就出栈，不相同就入栈，将栈中的结果反转一下就是满足题意的结果。这个题用之前写过的类定义的栈会超时间，感觉可能和最后反转拼接操作有关，不知道具体啥原因，最后用了一个数组来实现存放元素，移除元素的逻辑，最后时间复杂度降低了。用了一个小时左右。","tags":["leetcode","算法"]},{"title":"151.翻转字符串里的单词,卡码网:55.右旋转字符串","path":"/2024/09/04/151-翻转字符串里的单词-卡码网-55-右旋转字符串/","content":"​151.翻转字符串里的单词 感觉需要用到反转字符串操作，但空格不知道如何处理。 先反转整个字符串，然后对单词进行反转，需要注意空格的处理。 3.坚持循环不变量原则，while循环中尽量将循环变量自增操作放置在最后，这样可以让循环变量自增后有一次判断，带入测试用例推导花了一些时间。主要是涉及到对末尾空格的处理，可能有多个空格或一个空格，这个空格需要删除。 4.用了一个小时左右。 卡码网：55.右旋转字符串 想用双指针，发现用不了。 2.先反转整个字符串，然后分段进行反转拼接即可。 3.javascript如何处理输入操作，输入处理的代码是网上找的，还没有掌握, 在concat那里少写了一个reverse函数导致结果顺序不对。 reverse函数是原地操作 123let a = [1,2,3]let b = a.reverse()console.log(a, b)//[ 3, 2, 1 ] [ 3, 2, 1 ] 4.用了半个小时左右。","tags":["leetcode","算法"]},{"title":"344.反转字符串,541.反转字符串II","path":"/2024/09/04/344-反转字符串-541-反转字符串II/","content":"​344. 反转字符串 感觉需要用到指针，但不知道咋做。 倒序就是一个交换left,right指针对应指针值的过程。 纠结在javascript中能不能用字符串索引（就是当数组用），javascript中不能像数组那样索引元素。 再一次见识到了双指针的力量。用了半个小时左右。 反转字符串 II 读不懂题。 卡哥真牛啊，纸上推一下吧，用小人脑虚拟出来的小计算机测试一下不好想的地方（谁和计算机比计算能力哟）。 （如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）前半段字符串反转，这句话是遍历到后面才会遇到的，题目中放在了前面，（如果剩余字符少于 k 个，则将剩余字符全部反转），这两句话前面遍历遇到，题目中放在了后面，这个算法其实还是在考reverse函数的实现，（如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）这本质上就是在计算机试结果。写边界条件确定整个题的循环不变量是啥，严格按照循环变量来写边界条件，出错率低。 4. （如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）前半段字符串反转，这句话是遍历到后面才会遇到的，题目中放在了前面，（如果剩余字符少于 k 个，则将剩余字符全部反转），这两句话前面遍历遇到，题目中放在了后面，这个算法其实还是在考reverse函数的实现，（如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样）这本质上就是在计算机试结果。写边界条件确定整个题的循环不变量是啥，严格按照循环变量来写边界条件，出错率低。","tags":["leetcode","算法"]},{"title":"454.四数相加II,383.赎金信,15.三数之和,18.四数之和","path":"/2024/09/04/454-四数相加II-383-赎金信-15-三数之和-18-四数之和/","content":"​454.四数相加II 暴力算法。 先两个循环将和放到map中，再两个循环求和查询map，计算总数求和，将一个4层循环复杂度降低了。要查找一个元素是否出现用map, map也是一个hash结构。 3.没啥问题。 用了半个小时左右。 赎金信 没读懂。 和有效字母异位词方法差不多。 没啥问题。 4.用了半个小时左右。 三数之和 1.暴力算法。 2.用hash法去重麻烦，双指针好理解。 3.快速排序代码不熟悉，最外层循环的边界条件，当left&#x3D;&#x3D;right后left和right要移动(left左移,right右移)，不然会一直循环下去。 4.用了一个小时左右，快速排序代码不熟悉，最外层循环的边界条件，当left&#x3D;&#x3D;right后left和right要移动(left左移,right右移)，不然会一直循环下去。 四数之和 题目说了是用一个数组，用map也不好处理去重。 在双指针上增加一层循环，然后修改对应边界条件，添加去重逻辑，剪枝逻辑。 外层循环和内层循环的边界条件，剪枝操作那里为啥是break? 4.用了两个小时左右。","tags":["leetcode","算法"]},{"title":"242.有效的字母异位词,349. 两个数组的交集,202.快乐数,1. 两数之和","path":"/2024/09/04/242-有效的字母异位词-349-两个数组的交集-202-快乐数-1-两数之和/","content":"​ 242.有效的字母异位词 对每一个字符串用一个字典统计每个字母出现的次数，最后比较两个字典是否key和value都相同。都相同则是有效字母异位词, javascript中如何实现字典的key和value的比较? 这个编程问题可以分解为多个查询问题，涉及到查询，用hash法肯定是最快和简单的，只需要用长度为26，值全为0的数组模拟一个hash表,遍历第一个字符串时查询hash表对应字母然后执行加1操作，然后遍历第二个字符串时查询hash表对应字母执行减1操作，遍历完两个字符串后，循环一次hash表检查是否都为0, 都为0则是有效的字母异位词，同样这种策略也可以用于判断多个字符串是否是有效的字母异位词。 在JavaScript中，不能直接用inputStr[i] - ‘a’映射到对应下标，要用inputStr[i].charCodeAt(0) - ‘a’.charCodeAt(0)，charCodeAt(0)是用来获取ascii码的函数。 感受到了用hash法的简洁，用了一个小时左右，调试花了一些时间，在JavaScript中，不能直接用inputStr[i] - ‘a’映射到对应下标，要用inputStr[i].charCodeAt(0) - ‘a’.charCodeAt(0)，charCodeAt(0)是用来获取ascii码的函数。 两个数组的交集 遍历第一个数组，对于每一个元素都去第二个数组中查找，如果找到了，就将这个元素保存到结果数组中，同时在第二个数组中将所有对应这个元素值的元素都删除，遍历完第一个数组后返回结果数组。 也利用了hash法在查找元素方面的优点，这里由于元素长度不固定，用数组就不太适合，利用set这个数据结构(底层实现是红黑树，可以用于这种查找元素范围不固定的情况)，将第一个数组转为set1，这样就自动完成了去重操作，然后遍历第二个数组，对每一个元素，在set1中执行查询操作，找到了就添加到结果set2中，利用set2完成去重操作，最后将set2转为数组返回。 不知道如何用javascript创建set类型，没有理解这个题用set的原因，利用了hash法在查找元素方面的优点，这里由于元素长度不固定，用数组就不太适合，利用set这个数据结构(底层实现是红黑树，可以用于这种查找元素范围不固定的情况)，将第一个数组转为set1，这样就自动完成了去重操作，然后遍历第二个数组，对每一个元素，在set1中执行查询操作，找到了就添加到结果set2中，利用set2完成去重操作，最后将set2转为数组返回。 4，用了一个小时左右，利用set完成去重操作和提高查找效率。 快乐数 觉得这个题是一个数学问题，不知道咋做，大致知道要用循环提取数字每一位。 循环计算各位的数字平方和的过程中，如果当前计算过的数和之前计算过的数字重复了，那么再进行操作就会陷入无限循环中，确认当前计算过的数是否在之前出现了，这又是一个查找元素的问题，那么又要回归到用哈希法上来，用set保存每次计算得到的各位平方和，然后每次计算出新的各位平方和判断是否在set中出现过，如果出现过，则跳出循环返回false, 如果没有出现过则将当前的各位平方和保存到set中，直到和为1返回true, 这有点像计算机的算力解决一个数学问题，如果和不为1且没有出现重复值时，继续循环，不可能不一直循环下去同时值也不为1。 3.计算各位和的函数没有抽离处理，也没有意识到这是一个可以抽离的公共函数，导致代码比较混乱，定义set的代码写到循环里去了，然后每次都会清空set，没有达到代码的效果。 4, 需要养成好的代码习惯，这个题用了一个小时左右。 两数之和 两重循环，第二重循环不能用第一层循环的值，判断第一层循环和第二层循环的两个数是否和为target, 如果和为target，则返回下标数组。 还是利用hash法查询元素快的优点，先将第一个数组转为一个map，因为查的是数组元素的值, 所以key就是数组元素的值, 而key对应的value就存放数组元素的下标，然后遍历第二个数组，每次就查询target - nums2[index]的元素是否在set中，如果在，将target - nums2[index]这个值对应的value，和第二次循环的index一起作为一组下标结果返回。 3.不知道javascript中map如何实现、如何获取map元素和设置map元素。利用hash法查询元素快的优点，先将第一个数组转为一个map，因为查的是数组元素的值, 所以key就是数组元素的值, 而key对应的value就存放数组元素的下标，然后遍历第二个数组，每次就查询target - nums2[index]的元素是否在set中，如果在，将target - nums2[index]这个值对应的value，和第二次循环的index一起作为一组下标结果返回。 4.let map &#x3D; {};map[key]&#x3D;value;var a &#x3D; map[key];解题用了一个小时左右。 ​","tags":["leetcode","算法"]},{"title":"24. 两两交换链表中的节点,19.删除链表的倒数第N个节点,面试题 02.07. 链表相交,142.环形链表II","path":"/2024/09/04/24-两两交换链表中的节点-19-删除链表的倒数第N个节点-面试题-02-07-链表相交-142-环形链表II/","content":"​ 24.两两交换链表中的节点 第一想法是不知道这个题如何做，知道有改变指针这个操作。 双指针也太好用了，用双指针整个过程就是一个双指针移动加修改指针的过程，就像织毛衣一样的感觉。这里竟然要保存两个临时指针变量。 要保存两个临时指针变量，结合示意图分析实现起来还可以，主要是指针赋值那里想清楚，输入用例一遍过。 分析能否用双指针的意识，这个编程题用了半个小时左右。 19.删除链表的倒数第N个节点 第一想法先计算得到链表的总长度，根据倒数多少个节点计算正向应该遍历多少个节点count，然后正向遍历到了待删除结点的前一个结点执行删除操作。 用双指针正好表示了倒数多少个这个概念，先让快指针移动n+1个位置（不是移动n位是因为用了虚拟头节点，然后需要在待删除结点的前一个节点才能执行操作），然后一起移动快慢指针，当快指针到达链表末尾的位置，慢指针在的位置正好是待删除的元素的前一个节点位置，执行删除操作即可。 快慢指针开始时指向虚拟头节点，然后可以通过一个示意图来推导一下执行n+1才是对应待删除节点的前一个位置，一起移动快慢指针循环的边界条件时fast指针是否为空，而不是fast.next,可以想一想fast指针应该是在最后一个节点的位置,此时fast指针的下一个节点为null,不能进入循环执行移动操作，正好满足fast指针在最后一个节点位置。 一起移动快慢指针循环的边界条件时fast指针是否为空，而不是fast.next,可以想一想fast指针应该是在最后一个节点的位置,此时fast指针的下一个节点为null,不能进入循环执行移动操作，正好满足fast指针在最后一个节点位置。这个题目用了接近一个小时的时间。 面试题 02.07. 链表相交1.看不懂题 2.再回去读题，大致懂了是需要先找出最短的链表，最极端的就是短的链表头节点就是相交的位置，这种链表相交可以节省计算机的存储空间，找到这两个链表长度的差值dista后，将长链表的cur指针向后移动这个差值（正数）个位置，然后从这里依次遍历长短链表，对应位置指针相同则返回，遍历完都没有找到指针相同的位置则返回null. 3.根据链表长度不同执行了两端差不多的代码，后一段代码拷贝过来时没有将循环的条件改过来，导致用例报错。用了一个小时左右，主要时题干没有读懂。 142.环形链表II1.不知道咋做 2.真聪明，又是双指针，数学证明有点多。 3.不熟悉这类需要数学推导证明的编程题，完全没有想到用数学方法。 4.数学推导证明完了，用结论写代码实现起来比较简单，这个题先背方法，一刷就先记得这个结论吧，先不追求掌握的很深入，二刷深入研究一下。","tags":["leetcode","算法"]},{"title":"203.移除链表元素,707.设计链表,206.反转链表","path":"/2024/09/04/203-移除链表元素-707-设计链表-206-反转链表/","content":"​203.移除链表元素 1.这个移除链表的原理已经懂了。 2.和我的方法差不多，但卡哥的代码没有用到temp变量，节省了内存。 3.当遇到要删除的元素时，prev指向待删除元素的下一个节点后，这个时候prev是否需要移动要看cur移动后对应的节点是否还是待删除的元素，如果是prev就不需要移动，因为还是待删除节点的前一个节点，如果不是prev就需要移动一位。 4.整体还行，半个小时左右，主要是prev是否移动那里没有想清楚。 707.设计链表 1.觉得这个题太复杂了，涉及到链表操作太多，对javascript class语法不太熟悉。删除节点那里比较容易实现，又有index这个参数，感觉代码量较大。 2.首先没有意识去定义size变量，计算机的存储空间那么大，总是觉得引入变量会让题变得复杂，其实要看你引入的变量有没有意义。dummyhead的设置感觉会让代码简洁的多。 3.javascript定义链表那里有点不熟练，null写成了None, 这是python代码写多了吗？然后就是读题，这个题是设计链表，题目已经明确规定了链表的定义，只需要严格按照这个题目的要求进行实现，比如哪些index是合法的，在index合法和index不超过size那里需要注意，不超过size是可以取到size的。边界条件比如while循环判断cur是否为空还是cur.next是否为空，一个是代入极端情况检验，一个是看之后的代码用了哪些，比如用了cur.next.val,那么cur.next就不能为空。 4.这个题用了一个小时左右，速度慢一是排斥做这种题干复杂的题，其实实现了一个函数就将一个函数折叠起来看起来就要好的多，然后是javascript定义ListNode和class语法还不熟悉，关于链表操作原理多理解其实已经不难了，多注意一下就行。 206.反转链表 1.不知道咋做，又一个反向指多感觉，但感觉实现起来比较复杂。 2.双指针正好可以反向指还可以移动，这个反转链表的操作可以拆解为多次反向指的操作，但要合理地连接起来。 3.双指针法实现起来比较简单，一遍过。 4.用了二十分钟左右，分析问题的能力和计算机模拟的思维能力是我觉得这道题比较难的地方。","tags":["leetcode","算法"]},{"title":"977. 有序数组的平方、59.螺旋矩阵II\"","path":"/2024/09/04/977-有序数组的平方、59-螺旋矩阵II/","content":"​977.有序数组的平方 1.最先是对题目有点看不懂，为啥会强调非递减，元素平方后负数会变为正数，原有的非递减顺序会改变。最直接想到的是直接数组每个元素求平方然后对数组排序。 2.非递减这个条件利用的好，较大的数位于数组两端，这就为用双指针解法创造了条件，这个题目没有要求数组原地操作，所以定义left,right指针指向原数组，k指针指向函数返回的新数组，依次比较left,right指向元素平方和的大小，较大的值赋值给k指针指向的位置，较大的指对应的指针移动（向右或向左），k指针后移，知道left&gt;right结束。 3.第一次用暴力解法做，在排序哪里用了冒泡排序，但内层循环本来是遍历的j, 结果用了外层循环的i，导致用例报错。用双指针法在循环结束条件处应该是当left&lt;&#x3D;right继续循环，因为当left&#x3D;right时left或right指向的元素一直没有放到新数组中去，但最后一次需要放进去。 4.学会了要充分利用题中的条件，比如非递减用双指针就比较好。然后就是边界条件用一个特殊情况去分析是否取等号，这个题学习了近一个小时。 59.螺旋矩阵II 1.第一次看到这个题目，不知道这个题如何做，只知道可能要利用下标关系，没有发现这个过程有何规律。 2.首先是这个规律看得很准，就是将这个过程分解为几圈和中间位置的处理，只有n为奇数时才会有中间位置，中间位置也就是模拟过程的最后一步，转多少圈可以通过n&#x2F;2取整来计算，最关键的还是要定义好循环不变量，比如用左闭右开的原则就要坚持每条边都用左闭右开的原则。每次转完一圈后就更新转圈的起始位置，横纵坐标加1就可以完成，然后在转每一个圈中，左闭右开这个边界通过引入一个offset变量控制，初始值为1, 转完一圈后offset加1。如果是奇数，最后一步还需要将中心位置赋值。 3.首先没有搞清楚循环的条件是啥，应该是转多少圈，用n&#x2F;2取整获得转的圈数。然后是数组索引的部分，没有想清楚哪里用startX,startY,i,j这些变量，用startX,startY初始化i,j后需要用i,j来定位，i,j是记录着当前位置的信息，startX,startY本身只在转完一圈后再执行+1的操作。 4.体会到了用好循环不变量的重要性，整个思维过程比较严谨且可控，学习了一个小时左右，第一次真正实现了这种精确的计算机模拟算法。","tags":["leetcode","算法"]},{"title":"704. 二分查找、27. 移除元素。","path":"/2024/09/04/704-二分查找、27-移除元素/","content":"​704.二分查找 第一想到的算法就是遍历数组判断是否等于要查找的元素，学习到一些编程技巧后知道用二分查找效率更高。 对区间的明确定义可以让逻辑更加清晰，闭区间就是可以取到的，开区间就是不能取到的，开区间不能取到所以用左闭右开时right要设置为nums.length,也就是要多一位，左闭右闭就不用多一位。同样的逻辑也可以用在计算完middle更新left或right那里, 用左闭右开时更新right时就不用减去1,因为取不到，用左闭右闭就需要减去1。 3. 开区间不能取到所以用左闭右开时right要设置为nums.length,也就是要多一位。同样的逻辑也可以用在计算完middle更新left或right那里, 用左闭右开时更新right时就不用减去1,因为取不到。 4.明确了区间定义后实现起来就容易多了，降低了想的难度，学习了一个小时。 27.移除元素 第一想到的算法就是形象地想从数组中直接将这个元素清除，有点和打麻将拿出一张牌有点像，需要移动后面的元素。 首先是暴力解法，就是遍历到要删除的元素然后将后续的元素依次向前移动覆盖。然后是双指针解法，理解双指针在这个题中的定义非常重要，快指针是遍历旧数组的指针，慢指针是新数组的指针，只需要快指针循环一次，就可以完成暴力解法两层的循环，开始时快慢指针在同一个位置，如果fast指针所指元素是要删除的元素，fast指针继续移动，slow指针不懂，移动后如果fast指针所指元素不是要删除的元素，则对slow指针所指的位置赋值为fast指针所指的值，slow指针移动, fast指针继续移动，直到遍历到末尾结束，slow指针对应新数组长度。 暴力实现最开始用的是for循环，测试用例报错，原因在于用for循环遍历到要删除的位置，然后内层循环后续的元素向前依次移动，这个时候外层循环指向的位置可能仍然是需要删除的元素，但外层for循环已经去到了下一个位置，看了卡哥代码，是将外层循环的指针回退了一位，我用的while循环感觉逻辑更清晰。用双指针方法最开始没有理解双指针在这个题中的定义，导致写出了两层循环，代码反而更复杂，然后如果fast指针所指元素不是要删除的元素，则对slow指针所指的位置赋值为fast指针所指的值，slow指针移动, fast指针继续移动，这个逻辑也能处理nums数组第一个元素不是要删除元素的情况，虽然有点冗余计算，但代码逻辑比较简单。 ​","tags":["leetcode","算法"]},{"title":"域名解析的好处","path":"/2024/09/03/域名解析的好处/","content":"tomcat配置多网站时，Nginx可以根据不同域名解析到不同的网站端口，其他操作比如回调都是基于域名的，不会因为tomcat配置多网站选择的端口问题而影响其他服务。当更换服务器后，只需要修改域名解析，不需要改动其他相关联的服务代码，因为都是基于域名的。","tags":["前端软件开发"]},{"title":"高分辨率小屏设备远程控制低分辨率大屏设备方案","path":"/2024/09/03/高分辨率小屏设备远程控制低分辨率大屏设备方案/","content":"启动parsec-vdd添加一块屏幕在window显示设置中调整显示方式为仅在这块新增的屏幕上显示调整屏幕分辨率为适合小屏设备（能占据全屏幕）的分辨率"},{"title":"Vue的生命周期","path":"/2024/08/28/Vue的生命周期/","content":"Vue渲染主要包含四大阶段，创建，渲染，更新，销毁，每个阶段前后各对应一个周期，beforeCreated, created, beforeMounted, Mounted, beforeUpdated, Updated, beforeDestroyed, Destroyed。beforeCreated中组件实例刚刚创建，Created中数据已经准备好，但dom尚未生成，这里可以进行一些异步操作请求网络数据，这里执行异步网络请求更加高效。beforeMounted阶段虚拟dom已经创建好，真实dom还未挂载。mounted后dom已经挂载成功。beforeUpdated是在数据更新前的阶段，updated是数据更新后的阶段，beforeDestroyed是组件销毁前的阶段，destroyed是组件销毁后的阶段，destroyed阶段可以进行定时器和事件监听的清除。","tags":["前端开发","Vue"]},{"title":"其他文件优化","path":"/2024/08/28/其他文件优化/","content":"1.服务端开启文件压缩功能2.执行JS代码过长会卡住渲染，对于需要很多时间计算的代码可以使用WebworkerwebWorker是运行在后台的JS,另开一个子线程，不会影响性能","tags":["前端开发，性能优化"]},{"title":"Cookie","path":"/2024/08/28/Cookie/","content":"​\t站在程序员视角，先摒弃掉用户那种觉得一切都是理所应当的思想，和人互相认识一样，当一个人A给另一个人B打招呼后，B会在大脑中记住A的特征，下次A来找B的时候，B可以根据A的特征来回忆是否认识这个人，打招呼这个过程就是登录，B在脑中记录A的特征就是将用户信息存储在数据库，下次A来找B时所携带的特征就是Cookie，两个人认识可能时间长来也会忘记特征，这就和cookie有效期有点像。"},{"title":"输入URL回车后","path":"/2024/08/28/输入URL回车后/","content":"浏览器读取到用户输入到URL链接开始解析，解析出域名和协议，如果是get请求还要解析出请求参数，这个时候开始构建http请求，如果本地系统中有缓存的资源，则直接加载。如果没有缓存则开始查找是否有域名对应的服务器IP地址，首先从浏览器缓存中找，浏览器缓存中没有找到则到操作系统本地缓存中查找，还没有找到就到host文件中查找，host文件中没有的话再到路由器的缓存中查找，这一步如果没有找到则到互联网提供商（如中国移动）中查找，再找不到就转发到根域名服务器，根域名服务器再返回顶级域名服务器，顶级域名服务器再返回权威域名服务器，有权威域名服务器返回ip地址，然后沿着原来的路径返回这个ip地址，并依次进行缓存。有了服务器ip地址后则浏览器与目标服务器建立连接，通过TCP三次握手建立连接，如果是https还有加解密的过程，然后客户端发送网络请求到服务端，包括请求头，请求体和请求行。服务端返回响应，浏览器端检查响应数据，如果数据格式时html, 则开始解析html, 遇到资源链接则继续发起网络请求下载资源，解析HTML生成dom树，解析css生成样式，将dom树和CSS合并成一个渲染树，浏览器来计算每个元素在屏幕上的显示位置进行绘制。","tags":["前端开发"]},{"title":"addEventListener和onClick()","path":"/2024/08/28/addEventListener和onClick/","content":"addEventListener是为元素绑定事件的方法，接收三个参数： 第一个参数：绑定的事件名 第二个参数：执行的函数 第三个参数： false:默认，代表冒泡时绑定 true:代表捕获时绑定onclick和addEventListener事件区别是：onclick事件会被覆盖，而addEventListener可以先后运行不会被覆盖，addEventListener可以监听多个事件"},{"title":"闭包","path":"/2024/08/28/闭包/","content":"​\t在一个javascript函数a中可以定义另一个函数b，这个函数a通常通过return的方法将这个内部函数b返回，函数b能够记住函数a中的变量，即便函数a已经执行完毕。看起来像内部函数关闭了外部函数的作用域。","tags":["编程语言","JavaScript"]},{"title":"异步解决方案","path":"/2024/08/28/异步解决方案/","content":"在前后端分离开发的场景下，前端发起一个请求，如果只有一个线程且在一个线程中等待将非常影响用户体验。比如站在用户角度，在网页提交了一个文生图的请求，在后端完成图片的生成过程中，用户不能滚动鼠标浏览其他内容，用户浏览其他内容这个功能的实现要依托于线程监听鼠标事件实现，如果线程卡在等待后端返回数据，那么使用体验将相当不好。"},{"title":"事件流","path":"/2024/08/28/事件流/","content":"事件流包含三个阶段，捕获阶段、目标阶段、冒泡阶段。事件流实现流对页面元素事件的处理，当用户点击时，先进入捕获阶段，然后到达目标阶段，最后执行冒泡阶段。其中有一种高效的事件处理机制-事件委托。事件委托是基于冒泡构建的，可以让事件的处理更加优雅同时提高前端性能。","tags":["前端开发"]},{"title":"箭头函数和普通函数的区别","path":"/2024/08/28/箭头函数和普通函数的区别/","content":"箭头函数不能作为构造函数，普通函数可以作为构造函数。普通函数有自己的this, 箭头函数没有自己的this, 箭头函数继承外部的this。箭头函数没有自己的augments对象，普通函数有自己的augments对象。箭头函数可以简化代码，比如对数组元素进行操作可以通过.map方法和箭头函数配合实现。箭头函数应为没有自己的this, 所以其继承this的属性也可以在嵌套函数中比普通函数更方便。 箭头函数的this为定义时所在的this,不绑定this(因为箭头函数没有Constructor),会捕获其所在上下文的this作为自己的this 若包裹在函数中，就是函数调用时所在的对象，放在全局就是window,箭头函数的this就是外层代码块的this,固定不变。 没有自己的this 继承来的this不会变 没有arguments,实际获得的arguments是外层函数的arguments call apply和bind无法改变this指向 不可用于构造函数，没有new关键字 无prototype 不能用于generator函数，没有yield关键字 定义对象的大括号不是一个单独的执行环境，它依旧处于全局环境中","tags":["前端软件开发"]},{"title":"JavaScript判断数据类型","path":"/2024/08/28/JavaScript判断数据类型/","content":"首先可以通过typeof判断，typeof判断基本数据类型没有问题，判断引用类型比如Array结果是Object, 不够准确，此时需要用instanceof来判断，instanceof可以判断对象的类型（比如对象是哪个类的实例），Array.isArray()也是一种判断是否是数组类型的方法。还有一种更为底层的方法，Object.prototype.toString.call()方法，这个方法判断基本数据类型和引用数据类型都可以。","tags":["前端开发","编程语言","JavaScript"]},{"title":"原型和原型链","path":"/2024/08/28/原型和原型链/","content":"JavaScript中任何一个函数都可以作为构造函数，只要通过new关键字调用，任何一个函数创建后，JavaScript框架会为这个函数创建一个prototype属性，在这个prototype上定义的属性和方法在所有通过prototype所在的函数创建的对象之间共享，构造函数A实例化出的对象a又会被JavaScript框架创建一个__proto__属性，a._proto_ &#x3D;&#x3D; A.prototype, 方便确定对象是哪个函数实例化出来的。在调用某个对象的属性或函数时，现在对象所对应的构造函数C自身的定义上查找，如果找到就执行，如果没有找到，就去这个对象的__proto__属性上查找，也就是C的prototype上查找, 如果找到了就执行，如果没有找到，因为C.prototype本身也是一个对象，这个对象是由Object创建的，C.prototype._proto_ &#x3D;&#x3D; Object.prototype, 所以在Object.prototype上查找，如果找到了就执行，如果还是没有找到同样由于Object.prototype也是一个对象，它也有__proto__属性，其值为null , 所以不可能在查找到值了，直接返回null。","tags":["编程语言","JavaScript"]},{"title":"盒子模型","path":"/2024/08/28/盒子模型/","content":"盒子模型是css布局的基础，描述了以盒子为单位来布局页面的方式。每个盒子有四个属性：内容，内边距，边框，外边距。内容是最核心的东西，起传达信息的作用，可以理解为最有价值的部分。内边距是内容与边框之间的空白。边框不用说了。外边距当前盒子和旁边盒子的间距。默认情况下盒子的宽度指的是内容的宽度+左右内边距宽度+边框宽度*2，盒子的高度等于内容的高度+上下内边距+上下边框高度。box-sizing取content-box时宽度高度只包含内容。","tags":["前端开发","UI","CSS"]},{"title":"CSS选择器优先级总结","path":"/2024/08/26/CSS选择器优先级总结/","content":"内联样式的优先级最高，权重为1000，id的选择器优先级比class的高，id选择器的权重为100，class的选择器优先级比标签选择器高。类选择器和属性选择器的权重为10，元素选择器权重为1。当选择器表达式权重相同时，后定义的规则会覆盖前面的规则。","tags":["前端开发","CSS"]},{"title":"Swin-Transformer论文分析","path":"/2024/08/26/Swin-Transformer论文总结/","content":"看起来是从图像角度进行计算，和vit原理差不多，都是将图像切成小块，每一个小块可以近似看为一个向量，注意力的计算也是基于这些向量进行的，二维的图像转为一维的向量进行训练学习。 全局自注意力机制，所有的token都可以相互联系起来，但这样计算量会特别特别大。Swin Transformer通过窗口（Window）来限制自注意力的范围，计算量就小很多, 简单来说，Swin Transformer把图像分成了很多个小窗口（Window），然后每个窗口里面的token只和窗口里的其他token互相作用。不过，如果窗口一直不动，每个窗口之间的token就不会交进行注意力的交互，这样会缺少全局信息（不够全局，在窗口内还是全局的）。所以, Swin Transformer就会每隔一层，移动一下窗口的位置（Shift Window），让这些窗口错开一部分。这样，原来在不同窗口里的token，就可以通过这次移动的窗口进行注意力的交互达到理论上的全局注意力机制。","tags":["算法"]},{"title":"行内元素和块级元素","path":"/2024/08/25/行内元素和块级元素/","content":"行内元素水平排列，块级元素垂直排列。可以通过display属性将行内元素转换为块级元素（display: block）。同时，块级元素也可以转为行内元素，分为两种，一种是利用display: inline将块级元素转为普通行内元素（不可以设置宽高），还有一种是display: inline-block, 将块级元素转为可以设置宽高的行内元素。","tags":["前端软件开发"]},{"title":"积分图像编程实现","path":"/2024/08/21/积分图像编程实现/","content":"维基百科：积分图原图： 积分图： 积分图的每一点（x, y）的值是原图中对应位置的左上角区域的所有值得和 而且，积分图可以只遍历一次图像即可有效的计算出来，因为积分图每一点的（x, y）值是： 一旦积分图计算完毕，对任意矩形区域的和的计算就可以在常数时间内完成。如右图中，阴影矩形区域的值：","tags":["算法"]},{"title":"计算机学习之实践分析","path":"/2024/08/20/计算机学习之实践分析/","content":"有兴趣肯动手成为一种优势的前提是能够将这些实践经验用于学习对应的理论（这种理论在有实践经验下学习可以弥补和别人不动手直接学和自己肯动手这件事情本身所用的时间之差）"},{"title":"从bilibili我是小土堆up主那里学习到的软件开发经验","path":"/2024/08/18/从bilibili我是小土堆up主那里学习到的软件开发经验/","content":"打造高效的软件开发工作流高效的软件开发工作流是软硬件协同，对瑞士军刀式的工具首先要正反两面地分析，不同工具组合带来的综合能力才是真正的“瑞士军刀”","tags":["开发效率"]},{"title":"工匠精神","path":"/2024/08/17/工匠精神/","content":"工匠精神在竞争激烈的社会中是保持竞争优势的重要素质工匠精神不是一味的增加工作时间，而是在看准方向后的认真工作，需要抵制诱惑，虽然在AI时代可能通过广泛的涉猎对使用AI有一定的好处，但从提升判断力的角度，只追求广度是不行的，光有广度不代表就有很强的判断力，且AI现在的体系还不能完全排除人工的介入，在确定方向后，对我自己的学习情况来说，一定程度上地发扬“工匠精神”是短期提升判断力的关键。"},{"title":"从AI编程认知AI","path":"/2024/08/16/从AI编程认知AI/","content":"输入输出全是文本的场景，尝试用大模型去提效 软件开发领域市场调研需求分析PRD撰写图形元素绘制技术选型代码生成(文本输入+GPT4V)代码审查编写测试用例运维 最好最新的模型带来更好更新的能力编程能力是大模型各项能力的天花板 技术leader 训练数据质量高结果可衡量编程语言无二义性训练编程可提高大模型的推理能力 使用AI编程，除了解决编程问题以外，更重要是形成对AI的正确认知。 AI编程的适用场景1.技术我懂，不想自己写。 帮我完成重复性工作 帮我完成也要费费脑子才能写出来代码2.技术不大懂，让AI先做，自己边用边学。 当心ta犯错 当心给的不是最佳方案 如果完全不懂技术，AI编程的帮助不大 如果一个机器绝对不会犯错，它就不可能是智能的。-阿兰图灵AI的幻觉不可完全消除，只能尽可能压制。所以，使用者的判断力，决定了AI能力的上限.就像团队领导，是团队的上限一样。 AI能力定律：AI能力的上限，是使用者的判断力 。AI能力 &#x3D; min(AI能力，使用者判断力)。 AI提效定律：AI提升的效率，与使用者的判断力成正比，与生产力成反比 。效率提升幅度 &#x3D; 使用者判断力&#x2F;使用者生产力。 解读 使用者的判断力，是最重要的。 提升判断力，比提升实操能力更重要。所谓”眼高手低”者的福音。（认知水平高也需要持续地努力，不要认为懒就是眼高） 广阔的视野是判断力的养料。 任何东西都有两面性，GPT也不例外，需要抑制使用它的缺点，发扬使用它的优点，可以不那么严谨地类比搜索引擎对使用它的人影响。","tags":["prompt"]},{"title":"软件工程师沉淀","path":"/2024/08/15/软件工程师沉淀/","content":"到底是学的多好还是学的深入好?如果学的是是技术的经典理论的话，那么毫无疑问是学的多更好，前提是能够学懂学好。如果是学习技术应用的话，需要知道的是应用是基于底层技术的上层建筑，如果从底层技术的角度分析，那么大多数技术应用在技术底层是同质化严重的，如果沉迷于学的多，对于通过项目来引导理论学习的人来说，可能会无法触及的更深层次的技术理论，从而在对技术的理解上显得局限，虽然这个和性格也有一定关系，但我认为软件工程师认真地学精可能比粗略地学广泛更有意义。 技术不是逃避现实问题的手段，剑需要有人能够挥动才能发挥作用。 打通所有API就像打通任督二脉一样。 抛开实现想通逻辑，抛开实现想通转换，最后语义空间实现，三层验证，螺旋上升，形成技术能力。"},{"title":"翁恺Java语言程序设计学习心得","path":"/2024/08/12/翁恺Java语言程序设计学习心得/","content":"对我而言是一门编程启蒙课，更多的是偏认知的学习，比如: 对于程序员学习角度来说，不要害怕去在电脑上编程，大不了重启一下电脑，对电脑没啥影响，可以学习到东西才是相对重要的。 对于程序实现的信心：只要我想做某个程序，且这个程序比较有趣，有足够多的时间和精力去做时，我是能够做出一些可运行的版本甚至是让我自己觉得有成就感的程序的。 好的程序员从我观察来看都具备非常优秀的软件思维，但这究竟是不是我现阶段应该重点关注的重点，我现在的观点是不是，从github的优秀开源项目中可以看出，好的软件开发项目不是一蹴而就的，即便是厉害的程序员，都是采用一种迭代式开发的流程，如果一开始就想构思出一个非常完美的软件项目，很容易陷入一种空想主义中而脱离实际开发情况，从我的角度来看，在“做”中不断锤炼优秀的软件思维才是合理的程序员成长路径，一个有大量开发经验即便不主动学习优秀软件思维的程序员或多或少也能自己总结出很多软件思维的，我的悟性尚能满足我学习的需要，我所需要做的就是不断训练自己在编程中兼顾实现与编程思维两者的平衡，程序的价值最终可能不仅只是技术本身，还有产品相关的能力，这也是程序员必须思考的问题，持续进行版本迭代也很重要，这可以帮助程序员建立全局观念，不局限于低效的代码学习中，技术的本质是分析和解决问题的能力，对于程序员来说，同样是技术人员，只是工具是电脑，我的目标应该是成为一名优秀的软件工程师。"},{"title":"如何读懂大型软件项目源代码?","path":"/2024/08/07/如何读懂大型软件项目源代码/","content":"用好Notion软件，利用此软件可以按层级关系将零散代码逻辑在脑海中形成一个整体框架，也可以结合xmind等软件更直接地展示代码结构。 运行软件项目，通过输入输出来给人脑提供关键代码链路的思绪。比如如果项目是用python语言构建的，通过添加print语句实现变量的跟踪。还可以利用代码调试功能，比如断点，逐步执行代码，实时查看变量变化和函数调用情况。 利用好visio这类软件表示更多的逻辑关系。还可以使用 UML 图（如类图、时序图）来表示系统的静态结构和动态行为，这可以帮助更好地理解面向对象设计。 分清楚影响理解框架代码的原因是啥，如果是各个小的模块理解错误，那就需要逐个击破来理解整体。在理解小模块时，可以结合单元测试。编写和运行单元测试不仅能验证模块功能，还能帮助理解模块的输入输出和依赖关系。 对大的目录进行归纳总结，最好是记录在Notion上，记录关键模块、类、函数的作用和关系，以便日后查阅，因为代码较多，后续如果再来看可能忘记了，忘记了就需要再看一遍，相当于思维不集中会影响效率，有些时候可能总结的内容（也就是压缩过的内容）就足以理解了 需要高度集中，最好进入心流状态，最好用一整段时间去理解，下次理解相当于需要再从代码和文档中找到当时的理解水平。 IDE的全局关键字检索功能很有用，比如vscode可以显示所有包含指定关键字的文件引用，可以帮助构建代码框架逻辑。VSCode甚至系统都要将其视为软件的一部分，任何能够辅助代码理解的设计都可以用上，软件项目开发者设计项目时参考了面向对象设计规范，同样分析别人写的代码也可以采用面向对象的方法对代码进行简化。越是优秀的代码越可以通过面向对象的方法进行简化。除了 VSCode，还可以使用更专业的代码搜索工具，如 Sourcegraph 或 Opengrok，支持跨项目搜索和代码导航。 面向对象思维，通过对象，模块，组件来构建系统的认识。可以学习设计模式（Design Patterns），如《设计模式：可复用面向对象软件的基础》一书中提到的23种经典设计模式，帮助理解和应用面向对象思想。 明确改动哪些地方对系统运行有影响，哪些地方改动对系统没有影响及如何在系统上增加功能，如何在增加功能的同时不破坏原有系统的优良设计，如何重构原来系统中不合理的逻辑设计。在进行代码改动前，可以使用代码覆盖率工具（如 Coverage.py）和静态代码分析工具（如 SonarQube），评估改动的潜在影响和风险。 阅读官方文档，理解开发者的设计思路。还可以查阅社区文档、技术博客和开发者论坛，获取更多实战经验和最佳实践。 算法能力的学习，大型软件项目一般开发人员水平较高，用到了大量数据结构与算法的思想，如果算法能力不足再看到相关代码实现会觉得理解不足或觉得这些算法是框架本身的创新。建议系统学习算法与数据结构，可以参考《算法导论》（CLRS）这本书，并在 LeetCode、HackerRank 等平台上实践。 如果能问原开发者还是要先问，理解框架的目的就是应用框架，如何快速的掌握一个框架的能力是追求的目标，然后再谈框架的进阶理解，否则进阶学习也是低效的。在问原开发者时，可以提前准备好问题，并尝试提出一些自己的理解和解决方案，展示你的思考过程，往往能得到更有针对性的指导。 不要排斥打开编辑器看项目源码，就和新手程序员不会看报错信息一样，因为其中包含着指引，这是大量项目经验才能养成这种习惯，如果想要快速迭代技术能力，需要学会去延伸。 程序员的理解能力很重要。对任何能够通过编译器器检查的代码先要有基本的尊重，如果想站在别人的代码基础上提高开发效率，必须要理解别人的代码，这期间可以反思哪些代码质量不高，可以如何改进，程序员是一种特殊的用户，适当抱着看看用户是如何想的思维进行代码理解工作。对于本来就优秀的代码，要能够像看报错信息那样有耐心的理解。 为啥会有软件框架？框架就是将框架所设定的业务相关的部分做成接口提供给用户，和业务不相关但必要的做成基础能力简化用户的劳动。","tags":["项目开发经验"]},{"title":"python面向对象总结","path":"/2024/08/03/python面向对象总结/","content":"何为面向对象？类：图纸父类：可以理解为基础类，这里需要正确理解父类这个名词所包含的等级高的信息，父类中的属性和方法是一个基础子类：从父类中衍生出来的类，具备父类中的基础，可以在父类上做扩展方法，也可以重写父类的方法和属性注意：父类不代表比子类更丰富，子类拓展父类，这里不能通过等级层次去理解，更合理的方法是从进化的角度分析这两个概念 对象：根据图纸造出来的车继承：python中子类会继承父类的方法和属性，包括私有属性和私有方法，但通常不建议使用它们 封装：主要利用私有属性和私有方法实现封装，好处就是修改这个类的内部方法而不影响使用这个类的代码（比如有更优的算法可以实现排序，那就可以直接替换封装好的类的排序方法而不用改动调用这个类的代码） 多态：多态允许使用一个单一类型的实体（如变量，函数，接口）来代表多种类型的对象，简单来说，多态就是“一个接口，多种实现”。 如何理解多态？通过编写处理父类对象的代码，这些代码可以用于所有的子类对象，即通过父类就可以实现（批量&#x2F;统一）管理不同的子类对象，这些子类对象继承父类有多种实现，差不多等于多态的子类对象。 如何理解对象和类class的关系？图纸和图纸造出来的东西的关系，在看项目源代码时，看到class很容易就想是不是这个类里面的代码完成了对应的功能，从最终执行来说，确实是这样，但准确来说这不是面向对象编程(oop)的思想，按照oop来说是这个class构造的对象实现了相关的功能，oop中一切皆是对象，这里我还没有从传统的顺序执行的代码编程中跳出来。 class定义了对象的数据和方法, 不同对象通过调用彼此的方法来完成交互， new一个class的对象后就可以对多个对象进行交互，这些待交互的对象又是通过其它的class创建的，可以一直追溯到计算机的底层原理。(可以结合gcc新版本是用旧版本的gcc编译的)"},{"title":"self attention机制","path":"/2024/07/13/self-attention机制/","content":"self attention模块输入输出都可以看作是向量每个向量都要和其他向量在self attention模块中进行交互以下是两种两个向量之间交互的方法 一个向量和sequence中其他向量交互（两个向量之间交互的拓展），输出即为相关度 计算与输入位置对应的输出向量（考虑了其他所有向量的信息，在这里哪个向量的alpha更大，即相关性强，计算输出向量的求和那里对相关性强的输入向量对应的V矩阵系数乘的也越多） 这个self attention模块充分利用了GPU的并行能力，所有的操作都可以整合到矩阵计算中并行计算。","tags":["算法"]},{"title":"编程学习观点","path":"/2024/07/12/编程学习观点/","content":"培养对酷的编程项目如何构建的热情，尝试阅读理解消化源码，不要只停留在应用层。 QBX理论Q:需求量大B:基础X:稀缺性","tags":["技术领悟"]},{"title":"mmsegmentation框架可视化训练指标","path":"/2024/07/01/mmsegmentation框架可视化训练指标/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import matplotlib import matplotlib.pyplot as pltmatplotlib.rc(&quot;font&quot;,family=&#x27;SimHei&#x27;) # 中文字体plt.plot([1,2,3], [100,500,300])plt.title(&#x27;matplotlib中文字体测试&#x27;, fontsize=25)plt.xlabel(&#x27;X轴&#x27;, fontsize=15)plt.ylabel(&#x27;Y轴&#x27;, fontsize=15)plt.show()import pandas as pd# 日志文件路径log_path = &#x27;./work_dirs/ZihaoDataset-PSPNet/20230818_210528/vis_data/scalars.json&#x27;with open(log_path, &quot;r&quot;) as f: json_list = f.readlines()len(json_list)eval(json_list[4])# pandas &gt;= 2.0使用pd.concat替换appendfor each in json_list[:-1]: new_row = pd.DataFrame([eval(each)]) # Convert the string to a DataFrame if &#x27;aAcc&#x27; in each: df_test = pd.concat([df_test, new_row], ignore_index=True) else: df_train = pd.concat([df_train, new_row], ignore_index=True)df_traindf_testdf_train.to_csv(&#x27;图表/训练日志-训练集.csv&#x27;, index=False)df_test.to_csv(&#x27;图表/训练日志-测试集.csv&#x27;, index=False)from matplotlib import colors as mcolorsimport randomrandom.seed(124)colors = [&#x27;b&#x27;, &#x27;g&#x27;, &#x27;r&#x27;, &#x27;c&#x27;, &#x27;m&#x27;, &#x27;y&#x27;, &#x27;k&#x27;, &#x27;tab:blue&#x27;, &#x27;tab:orange&#x27;, &#x27;tab:green&#x27;, &#x27;tab:red&#x27;, &#x27;tab:purple&#x27;, &#x27;tab:brown&#x27;, &#x27;tab:pink&#x27;, &#x27;tab:gray&#x27;, &#x27;tab:olive&#x27;, &#x27;tab:cyan&#x27;, &#x27;black&#x27;, &#x27;indianred&#x27;, &#x27;brown&#x27;, &#x27;firebrick&#x27;, &#x27;maroon&#x27;, &#x27;darkred&#x27;, &#x27;red&#x27;, &#x27;sienna&#x27;, &#x27;chocolate&#x27;, &#x27;yellow&#x27;, &#x27;olivedrab&#x27;, &#x27;yellowgreen&#x27;, &#x27;darkolivegreen&#x27;, &#x27;forestgreen&#x27;, &#x27;limegreen&#x27;, &#x27;darkgreen&#x27;, &#x27;green&#x27;, &#x27;lime&#x27;, &#x27;seagreen&#x27;, &#x27;mediumseagreen&#x27;, &#x27;darkslategray&#x27;, &#x27;darkslategrey&#x27;, &#x27;teal&#x27;, &#x27;darkcyan&#x27;, &#x27;dodgerblue&#x27;, &#x27;navy&#x27;, &#x27;darkblue&#x27;, &#x27;mediumblue&#x27;, &#x27;blue&#x27;, &#x27;slateblue&#x27;, &#x27;darkslateblue&#x27;, &#x27;mediumslateblue&#x27;, &#x27;mediumpurple&#x27;, &#x27;rebeccapurple&#x27;, &#x27;blueviolet&#x27;, &#x27;indigo&#x27;, &#x27;darkorchid&#x27;, &#x27;darkviolet&#x27;, &#x27;mediumorchid&#x27;, &#x27;purple&#x27;, &#x27;darkmagenta&#x27;, &#x27;fuchsia&#x27;, &#x27;magenta&#x27;, &#x27;orchid&#x27;, &#x27;mediumvioletred&#x27;, &#x27;deeppink&#x27;, &#x27;hotpink&#x27;]markers = [&quot;.&quot;,&quot;,&quot;,&quot;o&quot;,&quot;v&quot;,&quot;^&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;,&quot;s&quot;,&quot;p&quot;,&quot;P&quot;,&quot;*&quot;,&quot;h&quot;,&quot;H&quot;,&quot;+&quot;,&quot;x&quot;,&quot;X&quot;,&quot;D&quot;,&quot;d&quot;,&quot;|&quot;,&quot;_&quot;,0,1,2,3,4,5,6,7,8,9,10,11]linestyle = [&#x27;--&#x27;, &#x27;-.&#x27;, &#x27;-&#x27;]def get_line_arg(): &#x27;&#x27;&#x27; 随机产生一种绘图线型 &#x27;&#x27;&#x27; line_arg = &#123;&#125; line_arg[&#x27;color&#x27;] = random.choice(colors) # line_arg[&#x27;marker&#x27;] = random.choice(markers) line_arg[&#x27;linestyle&#x27;] = random.choice(linestyle) line_arg[&#x27;linewidth&#x27;] = random.randint(1, 4) # line_arg[&#x27;markersize&#x27;] = random.randint(3, 5) return line_argmetrics = [&#x27;loss&#x27;, &#x27;decode.loss_ce&#x27;, &#x27;aux.loss_ce&#x27;]plt.figure(figsize=(16, 8))x = df_train[&#x27;step&#x27;]for y in metrics: try: plt.plot(x, df_train[y], label=y, **get_line_arg()) except: passplt.tick_params(labelsize=20)plt.xlabel(&#x27;step&#x27;, fontsize=20)plt.ylabel(&#x27;Loss&#x27;, fontsize=20)plt.title(&#x27;训练集损失函数&#x27;, fontsize=25)plt.legend(fontsize=20)plt.savefig(&#x27;图表/训练集损失函数.pdf&#x27;, dpi=120, bbox_inches=&#x27;tight&#x27;)plt.show()metrics = [&#x27;decode.acc_seg&#x27;, &#x27;aux.acc_seg&#x27;]plt.figure(figsize=(16, 8))x = df_train[&#x27;step&#x27;]for y in metrics: try: plt.plot(x, df_train[y], label=y, **get_line_arg()) except: passplt.tick_params(labelsize=20)plt.xlabel(&#x27;step&#x27;, fontsize=20)plt.ylabel(&#x27;Metrics&#x27;, fontsize=20)plt.title(&#x27;训练集准确率&#x27;, fontsize=25)plt.legend(fontsize=20)plt.savefig(&#x27;图表/训练集准确率.pdf&#x27;, dpi=120, bbox_inches=&#x27;tight&#x27;)plt.show()df_test.columnsmetrics = [&#x27;aAcc&#x27;, &#x27;mIoU&#x27;, &#x27;mAcc&#x27;, &#x27;mDice&#x27;, &#x27;mFscore&#x27;, &#x27;mPrecision&#x27;, &#x27;mRecall&#x27;]plt.figure(figsize=(16, 8)x = df_test[&#x27;step&#x27;]for y in metrics: try: plt.plot(x, df_test[y], label=y, **get_line_arg()) except: passplt.tick_params(labelsize=20)plt.ylim([0, 100])plt.xlabel(&#x27;step&#x27;, fontsize=20)plt.ylabel(&#x27;Metrics&#x27;, fontsize=20)plt.title(&#x27;测试集评估指标&#x27;, fontsize=25)plt.legend(fontsize=20)plt.savefig(&#x27;图表/测试集分类评估指标.pdf&#x27;, dpi=120, bbox_inches=&#x27;tight&#x27;)plt.show() 参考MMSegmentation_Tutorials&#x2F;20230816&#x2F;【H1】可视化训练日志-训练过程总体评估指标.ipynb at main · TommyZihao&#x2F;MMSegmentation_Tutorials · GitHub","tags":["深度学习"]}]