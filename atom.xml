<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PromptOnce</title>
  
  
  <link href="https://promptonce.github.io/atom.xml" rel="self"/>
  
  <link href="https://promptonce.github.io/"/>
  <updated>2024-11-23T14:52:59.598Z</updated>
  <id>https://promptonce.github.io/</id>
  
  <author>
    <name>penggan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何平衡算法学习与Prompt工程能力的提升？</title>
    <link href="https://promptonce.github.io/2024/11/23/%E5%A6%82%E4%BD%95%E5%B9%B3%E8%A1%A1%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%8EPrompt%E5%B7%A5%E7%A8%8B%E8%83%BD%E5%8A%9B%E7%9A%84%E6%8F%90%E5%8D%87%EF%BC%9F/"/>
    <id>https://promptonce.github.io/2024/11/23/%E5%A6%82%E4%BD%95%E5%B9%B3%E8%A1%A1%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B8%8EPrompt%E5%B7%A5%E7%A8%8B%E8%83%BD%E5%8A%9B%E7%9A%84%E6%8F%90%E5%8D%87%EF%BC%9F/</id>
    <published>2024-11-23T14:51:41.000Z</published>
    <updated>2024-11-23T14:52:59.598Z</updated>
    
    <content type="html"><![CDATA[<p>在AI技术蓬勃发展的今天，程序员和开发者不仅需要扎实的算法基础，还需要掌握有效与AI模型交互的Prompt设计能力。以下是一些平衡这两种技能提升的策略和实践经验：</p><h4 id="1-打牢基础：算法与Prompt的核心知识"><a href="#1-打牢基础：算法与Prompt的核心知识" class="headerlink" title="1. 打牢基础：算法与Prompt的核心知识"></a>1. <strong>打牢基础：算法与Prompt的核心知识</strong></h4><ul><li><strong>算法</strong>：理解数据结构、经典算法（如排序、搜索、动态规划等），培养逻辑思维和问题解决能力。</li><li><strong>Prompt工程</strong>：熟悉AI模型的工作原理，掌握基本的Prompt设计技巧，例如如何精确描述任务、调整模型输出风格等。</li></ul><hr><h4 id="2-实践项目驱动学习"><a href="#2-实践项目驱动学习" class="headerlink" title="2. 实践项目驱动学习"></a>2. <strong>实践项目驱动学习</strong></h4><p>通过实际项目锻炼算法和Prompt能力：</p><ul><li><strong>结合型项目</strong>：选择既需要算法优化又涉及AI模型交互的项目，例如智能推荐系统、对话机器人等。</li><li><strong>实验与迭代</strong>：在项目中设置不同阶段，专注于优化算法性能或改进Prompt设计，逐步提升综合能力。</li></ul><hr><h4 id="3-定期复习与更新知识"><a href="#3-定期复习与更新知识" class="headerlink" title="3. 定期复习与更新知识"></a>3. <strong>定期复习与更新知识</strong></h4><ul><li><strong>算法</strong>：参与LeetCode、HackerRank等平台的编程挑战，保持技能熟练度。</li><li><strong>Prompt优化</strong>：关注AI和NLP领域的新进展，尝试不同模型如GPT、Claude等，探索新的Prompt技巧。</li></ul><hr><h4 id="4-团队合作与角色分配"><a href="#4-团队合作与角色分配" class="headerlink" title="4. 团队合作与角色分配"></a>4. <strong>团队合作与角色分配</strong></h4><p>在团队项目中：</p><ul><li><strong>算法专家</strong>：负责性能优化、数据处理等核心算法任务。</li><li><strong>Prompt设计师</strong>：负责与AI模型交互的任务，如对话设计、文本生成优化。</li><li><strong>跨角色培训</strong>：鼓励团队成员相互学习，增加协作理解。</li></ul><hr><h4 id="5-敏捷学习与小步迭代"><a href="#5-敏捷学习与小步迭代" class="headerlink" title="5. 敏捷学习与小步迭代"></a>5. <strong>敏捷学习与小步迭代</strong></h4><ul><li><strong>短期目标</strong>：设定可衡量的小目标，比如掌握一种算法或设计一个有效Prompt。</li><li><strong>反馈循环</strong>：在实践中收集反馈，优化学习策略，逐步提高技能水平。</li></ul><hr><h4 id="6-保持兴趣与动力"><a href="#6-保持兴趣与动力" class="headerlink" title="6. 保持兴趣与动力"></a>6. <strong>保持兴趣与动力</strong></h4><ul><li><strong>项目驱动</strong>：选择感兴趣的项目领域，通过解决实际问题保持学习动力。</li><li><strong>社区参与</strong>：加入技术社区、参与开源项目、参加Hackathon，获取激励和认可。</li></ul><hr><h4 id="7-应对信息过载"><a href="#7-应对信息过载" class="headerlink" title="7. 应对信息过载"></a>7. <strong>应对信息过载</strong></h4><ul><li><strong>专注主题</strong>：每次学习时聚焦于特定主题，避免分散注意力。</li><li><strong>休息与反思</strong>：合理安排学习与休息时间，定期复盘已学内容。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在AI技术蓬勃发展的今天，程序员和开发者不仅需要扎实的算法基础，还需要掌握有效与AI模型交互的Prompt设计能力。以下是一些平衡这两种技能提升的策略和实践经验：&lt;/p&gt;
&lt;h4 id=&quot;1-打牢基础：算法与Prompt的核心知识&quot;&gt;&lt;a href=&quot;#1-打牢基础：算法与</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>异或总结</title>
    <link href="https://promptonce.github.io/2024/11/23/%E5%BC%82%E6%88%96%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/11/23/%E5%BC%82%E6%88%96%E6%80%BB%E7%BB%93/</id>
    <published>2024-11-23T11:36:18.000Z</published>
    <updated>2024-11-23T15:23:08.605Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机科学中，<strong>异或运算（XOR）</strong>是一种非常常见的位运算，它有着独特的性质和广泛的应用，尤其是在数组问题和密码学中。本文将介绍如何利用异或运算高效地解决数组中的问题，并探讨其在密码学中的应用。</p><h2 id="一、异或运算的基本概念"><a href="#一、异或运算的基本概念" class="headerlink" title="一、异或运算的基本概念"></a>一、异或运算的基本概念</h2><p>异或运算（XOR）是一种对两个输入进行比较的逻辑运算，其规则如下：</p><ul><li>如果两个输入相同（即 0 ⊕ 0 或 1 ⊕ 1），则结果为 0。</li><li>如果两个输入不同（即 0 ⊕ 1 或 1 ⊕ 0），则结果为 1。</li></ul><h3 id="异或的真值表"><a href="#异或的真值表" class="headerlink" title="异或的真值表"></a>异或的真值表</h3><table><thead><tr><th>A</th><th>B</th><th>A ⊕ B</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><h3 id="异或的基本性质"><a href="#异或的基本性质" class="headerlink" title="异或的基本性质"></a>异或的基本性质</h3><ol><li><strong>交换律</strong>：A ⊕ B &#x3D; B ⊕ A</li><li><strong>结合律</strong>：A ⊕ (B ⊕ C) &#x3D; (A ⊕ B) ⊕ C</li><li><strong>自反性</strong>：A ⊕ A &#x3D; 0</li><li><strong>单位元</strong>：A ⊕ 0 &#x3D; A</li><li><strong>无进位加法</strong>：A ⊕ B 类似于对二进制数进行加法运算，但没有进位。</li></ol><p>这些性质使得异或运算在解决一些数组和加密问题时非常高效。</p><h2 id="二、利用异或解决数组中的唯一数问题"><a href="#二、利用异或解决数组中的唯一数问题" class="headerlink" title="二、利用异或解决数组中的唯一数问题"></a>二、利用异或解决数组中的唯一数问题</h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><p>给定一个整数数组，其中每个元素都出现了两次，只有一个元素出现了一次，要求找出这个唯一的元素。</p><h3 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2. 解决思路"></a>2. 解决思路</h3><p>利用异或的特性，所有出现两次的元素都会互相抵消，因为 <code>A ⊕ A = 0</code>。最终剩下的就是那个唯一的元素。</p><h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_single_number</span>(<span class="params">nums</span>):</span><br><span class="line">    result = <span class="number">0</span>  <span class="comment"># 初始化结果为 0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        result ^= num  <span class="comment"># 对数组中的每个数字进行异或</span></span><br><span class="line">    <span class="keyword">return</span> result  <span class="comment"># 返回最终的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(find_single_number(nums))  <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure><h3 id="4-解释"><a href="#4-解释" class="headerlink" title="4. 解释"></a>4. 解释</h3><ul><li>初始时，<code>result = 0</code>。</li><li>对数组中的每个元素进行异或运算：<br><code>0 ⊕ 2 = 2</code><br><code>2 ⊕ 3 = 1</code><br><code>1 ⊕ 2 = 3</code><br><code>3 ⊕ 4 = 7</code><br><code>7 ⊕ 4 = 3</code></li></ul><p>最终，<code>result</code> 的值是 <code>3</code>，即唯一出现一次的元素。</p><h3 id="5-时间与空间复杂度"><a href="#5-时间与空间复杂度" class="headerlink" title="5. 时间与空间复杂度"></a>5. 时间与空间复杂度</h3><ul><li><strong>时间复杂度</strong>：O(n)，需要遍历数组一次。</li><li><strong>空间复杂度</strong>：O(1)，只用了一个额外的变量 <code>result</code>。</li></ul><h3 id="6-应用场景"><a href="#6-应用场景" class="headerlink" title="6. 应用场景"></a>6. 应用场景</h3><p>该方法适用于需要找出唯一元素的问题，如数据流处理、传感器数据分析等。</p><h2 id="三、异或运算在密码学中的应用"><a href="#三、异或运算在密码学中的应用" class="headerlink" title="三、异或运算在密码学中的应用"></a>三、异或运算在密码学中的应用</h2><p>异或运算在密码学中有着重要的应用，尤其是在加密算法和数据保护中。其特性使得异或成为许多密码学算法的核心操作。</p><h3 id="1-对称加密（XOR-加密）"><a href="#1-对称加密（XOR-加密）" class="headerlink" title="1. 对称加密（XOR 加密）"></a>1. 对称加密（XOR 加密）</h3><p>在对称加密算法中，明文数据与密钥进行异或操作，从而生成密文。解密时，只需要将密文与相同的密钥再进行一次异或操作，就能恢复出原始的明文。</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul><li><strong>加密</strong>：明文 ⊕ 密钥 &#x3D; 密文</li><li><strong>解密</strong>：密文 ⊕ 密钥 &#x3D; 明文</li></ul><h4 id="示例：XOR-加密与解密"><a href="#示例：XOR-加密与解密" class="headerlink" title="示例：XOR 加密与解密"></a>示例：XOR 加密与解密</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xor_encrypt_decrypt</span>(<span class="params">data, key</span>):</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">chr</span>(<span class="built_in">ord</span>(c) ^ key) <span class="keyword">for</span> c <span class="keyword">in</span> data]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">plain_text = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">key = <span class="number">123</span>  <span class="comment"># 一个简单的密钥</span></span><br><span class="line">cipher_text = xor_encrypt_decrypt(plain_text, key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;加密后的文本:&quot;</span>, <span class="string">&#x27;&#x27;</span>.join(cipher_text))</span><br><span class="line"></span><br><span class="line">decrypted_text = xor_encrypt_decrypt(cipher_text, key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密后的文本:&quot;</span>, <span class="string">&#x27;&#x27;</span>.join(decrypted_text))</span><br></pre></td></tr></table></figure><h3 id="2-流加密（如-RC4）"><a href="#2-流加密（如-RC4）" class="headerlink" title="2. 流加密（如 RC4）"></a>2. 流加密（如 RC4）</h3><p>流加密算法，如 RC4，利用异或运算和伪随机密钥流对数据进行加密。在 RC4 中，密钥流与明文数据逐位进行异或，生成密文。解密时，使用相同的密钥流再进行一次异或操作即可恢复明文。</p><h3 id="3-哈希函数"><a href="#3-哈希函数" class="headerlink" title="3. 哈希函数"></a>3. 哈希函数</h3><p>许多哈希函数（如 SHA 系列）在内部使用异或运算。通过对数据的每一位进行异或操作，哈希函数能够将任意长度的输入映射到固定长度的输出，并尽可能避免哈希冲突。</p><h3 id="4-HMAC（哈希消息认证码）"><a href="#4-HMAC（哈希消息认证码）" class="headerlink" title="4. HMAC（哈希消息认证码）"></a>4. HMAC（哈希消息认证码）</h3><p>HMAC（Hash-based Message Authentication Code）是一种基于哈希函数和密钥的消息认证码。在 HMAC 中，异或运算用来混合密钥和消息，确保消息的完整性和认证。</p><h3 id="5-数字签名与消息认证"><a href="#5-数字签名与消息认证" class="headerlink" title="5. 数字签名与消息认证"></a>5. 数字签名与消息认证</h3><p>在消息认证和数字签名中，异或运算被用于确保消息的完整性。在基于密钥的消息认证码（HMAC）算法中，消息和密钥的组合通过异或运算生成唯一的认证码，验证消息是否被篡改。</p><h3 id="6-伪随机数生成"><a href="#6-伪随机数生成" class="headerlink" title="6. 伪随机数生成"></a>6. 伪随机数生成</h3><p>在一些加密算法中，异或运算用于生成伪随机数。通过对不同的种子值进行异或操作，可以生成不可预测的密钥流或掩码，增强加密的安全性。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>异或运算是一个非常强大的工具，不仅在解决数组问题时提供了高效的解决方案，还在密码学中发挥着至关重要的作用。通过其独特的性质，如自反性、交换律和结合律，异或能够在加密、哈希、消息认证和伪随机数生成等多个领域提供高效且安全的解决方案。</p><p>在数组问题中，异或的应用可以帮助我们快速找到唯一的元素，而在密码学中，它则成为许多加密算法的核心操作。随着对异或运算深入理解，我们能够在更多实际问题中发挥其强大的能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在计算机科学中，&lt;strong&gt;异或运算（XOR）&lt;/strong&gt;是一种非常常见的位运算，它有着独特的性质和广泛的应用，尤其是在数组问题和密码学中。本文将介绍如何利用异或运算高效地解决数组中的问题，并探讨其在密码学中的应用。&lt;/p&gt;
&lt;h2 id=&quot;一、异或运算的基本概念</summary>
      
    
    
    
    
    <category term="算法" scheme="https://promptonce.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>华为云Flexus L实例无法通过公网ip访问</title>
    <link href="https://promptonce.github.io/2024/11/17/%E5%8D%8E%E4%B8%BA%E4%BA%91Flexus-L%E5%AE%9E%E4%BE%8B%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%E5%85%AC%E7%BD%91ip%E8%AE%BF%E9%97%AE/"/>
    <id>https://promptonce.github.io/2024/11/17/%E5%8D%8E%E4%B8%BA%E4%BA%91Flexus-L%E5%AE%9E%E4%BE%8B%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%E5%85%AC%E7%BD%91ip%E8%AE%BF%E9%97%AE/</id>
    <published>2024-11-17T13:00:52.000Z</published>
    <updated>2024-11-17T15:04:48.270Z</updated>
    
    <content type="html"><![CDATA[<p>端口放行配置错了安全组然后服务器又绑定了另一个未未配置放行端口的安全组。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;端口放行配置错了安全组然后服务器又绑定了另一个未未配置放行端口的安全组。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>openai api调用格式</title>
    <link href="https://promptonce.github.io/2024/11/16/openai-api%E8%B0%83%E7%94%A8%E6%A0%BC%E5%BC%8F/"/>
    <id>https://promptonce.github.io/2024/11/16/openai-api%E8%B0%83%E7%94%A8%E6%A0%BC%E5%BC%8F/</id>
    <published>2024-11-16T10:16:55.000Z</published>
    <updated>2024-11-17T12:38:31.162Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://platform.openai.com/docs/quickstart?language-preference=python">https://platform.openai.com/docs/quickstart?language-preference=python</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://platform.openai.com/docs/quickstart?language-preference=python&quot;&gt;https://platform.openai.com/docs/quickstart?language-pre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cross attention总结</title>
    <link href="https://promptonce.github.io/2024/11/13/cross-attention%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/11/13/cross-attention%E6%80%BB%E7%BB%93/</id>
    <published>2024-11-13T13:42:38.000Z</published>
    <updated>2024-11-13T13:42:38.085Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>什么是 HTTP 请求中的 Origin 头？如何在特殊场景下处理它？</title>
    <link href="https://promptonce.github.io/2024/11/12/%E4%BB%80%E4%B9%88%E6%98%AF-HTTP-%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84-Origin-%E5%A4%B4%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8%E7%89%B9%E6%AE%8A%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%A4%84%E7%90%86%E5%AE%83%EF%BC%9F/"/>
    <id>https://promptonce.github.io/2024/11/12/%E4%BB%80%E4%B9%88%E6%98%AF-HTTP-%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84-Origin-%E5%A4%B4%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8%E7%89%B9%E6%AE%8A%E5%9C%BA%E6%99%AF%E4%B8%8B%E5%A4%84%E7%90%86%E5%AE%83%EF%BC%9F/</id>
    <published>2024-11-12T07:17:52.000Z</published>
    <updated>2024-11-12T07:18:34.989Z</updated>
    
    <content type="html"><![CDATA[<p>在 Web 开发中，跨域请求（Cross-Origin Requests）常常让开发者头疼，而 <code>Origin</code> 头是跨域资源共享（CORS）机制中必不可少的组成部分。本文将详细介绍 <code>Origin</code> 头的作用、为什么它与用户的 IP 不同，以及如何在特定场景下实现“不携带 <code>Origin</code> 头”的请求。</p><hr><h3 id="什么是-Origin-头？"><a href="#什么是-Origin-头？" class="headerlink" title="什么是 Origin 头？"></a>什么是 <code>Origin</code> 头？</h3><p><code>Origin</code> 头是浏览器在发起 HTTP 请求时自动添加的，用于标识请求的来源。这一头部信息由协议（如 <code>https</code>）、域名（如 <code>example.com</code>）和端口组成。它的主要作用是帮助服务器判断请求的来源是否被允许访问资源，是浏览器实现<strong>同源策略</strong>和<strong>CORS</strong>的关键部分。</p><p>例如，当你在浏览器中打开 <code>https://example.com</code> 并访问 <code>https://api.example.com</code> 时，请求的 <code>Origin</code> 头可能会显示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: https://example.com</span><br></pre></td></tr></table></figure><p>通过这个头部，服务器可以知道该请求来源于 <code>https://example.com</code>，并决定是否允许该跨域请求访问资源。</p><hr><h3 id="Origin-头-vs-用户-IP"><a href="#Origin-头-vs-用户-IP" class="headerlink" title="Origin 头 vs. 用户 IP"></a><code>Origin</code> 头 vs. 用户 IP</h3><p>很多人容易混淆 <code>Origin</code> 头和用户的 IP 地址。虽然请求确实是从用户的电脑发出的，但 <code>Origin</code> 头和用户 IP 是两个完全不同的概念：</p><ol><li><p><strong><code>Origin</code> 头表示网页来源</strong>：<code>Origin</code> 头标识的是网页的来源域（例如 <code>https://example.com</code>），而不是用户设备的地址。它主要用于同源策略的安全判断，帮助服务器控制跨域请求。</p></li><li><p><strong>用户 IP 表示设备的网络位置</strong>：用户的 IP 地址则是用户设备在网络中的地址，与物理位置和网络连接有关，用于路由传输。IP 不包含网页来源的信息，因此服务器无法依赖 IP 来判断请求是从哪个网页发起的。</p></li></ol><h3 id="为什么需要-Origin-头？"><a href="#为什么需要-Origin-头？" class="headerlink" title="为什么需要 Origin 头？"></a>为什么需要 <code>Origin</code> 头？</h3><p>浏览器的同源策略（Same-Origin Policy）规定，网页脚本只能访问与其来源相同的资源，<code>Origin</code> 头正是这一机制的组成部分。通过 <code>Origin</code> 头，服务器能够明确请求来源，并决定是否允许跨域访问。这在防止跨站请求伪造（CSRF）等安全攻击上非常有效。</p><hr><h3 id="如何实现不携带-Origin-头的请求？"><a href="#如何实现不携带-Origin-头的请求？" class="headerlink" title="如何实现不携带 Origin 头的请求？"></a>如何实现不携带 <code>Origin</code> 头的请求？</h3><p>在一些特殊场景中，可能需要发送不带 <code>Origin</code> 头的 HTTP 请求，跳过浏览器的同源策略检查。以下几种方法可以实现这一效果，但需谨慎使用，以免引入安全风险。</p><h4 id="1-使用非浏览器客户端发送请求"><a href="#1-使用非浏览器客户端发送请求" class="headerlink" title="1. 使用非浏览器客户端发送请求"></a>1. 使用非浏览器客户端发送请求</h4><p>浏览器会自动添加 <code>Origin</code> 头，但在使用非浏览器的 HTTP 客户端（如 Python 的 <code>requests</code> 库、Node.js 的 <code>http</code> 模块、cURL）时，可以手动控制请求头部，不携带 <code>Origin</code> 头。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://example.com/api&#x27;</span>, headers=&#123;&#125;)  <span class="comment"># 不携带 Origin 头</span></span><br></pre></td></tr></table></figure><p>这种方法适用于后端环境或自定义客户端应用，但不适合浏览器环境。</p><h4 id="2-使用代理服务器"><a href="#2-使用代理服务器" class="headerlink" title="2. 使用代理服务器"></a>2. 使用代理服务器</h4><p>如果需要从浏览器中发起不带 <code>Origin</code> 头的请求，可以设置一个代理服务器。通过代理转发请求，浏览器只会与代理通信，而代理则在将请求发送到目标服务器时省略 <code>Origin</code> 头。</p><p><strong>示例：NGINX 配置</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /proxy/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> https://example.com/api;</span><br><span class="line">    <span class="attribute">proxy_hide_header</span> Origin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法允许浏览器请求先发送到代理服务器，由代理移除 <code>Origin</code> 后转发到目标服务器。</p><h4 id="3-利用-JSONP（仅限-GET-请求）"><a href="#3-利用-JSONP（仅限-GET-请求）" class="headerlink" title="3. 利用 JSONP（仅限 GET 请求）"></a>3. 利用 JSONP（仅限 GET 请求）</h4><p>在一些跨域 GET 请求中，可以通过 JSONP（JSON with Padding）技术绕过同源策略。JSONP 利用 <code>&lt;script&gt;</code> 标签加载目标资源，不需要 <code>Origin</code> 头，但只能用于 GET 请求，且要求目标服务器支持 JSONP。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/api?callback=myCallbackFunction&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">myCallbackFunction</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-服务器端控制-CORS-配置"><a href="#4-服务器端控制-CORS-配置" class="headerlink" title="4. 服务器端控制 CORS 配置"></a>4. 服务器端控制 CORS 配置</h4><p>如果你拥有服务器的控制权限，并希望允许不带 <code>Origin</code> 头的请求，可以调整服务器的 CORS 配置。不过，这种方法依赖服务器端控制，并不是绕过 <code>Origin</code> 的方式。</p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>Origin</code> 头是 HTTP 和浏览器安全机制的重要组成部分，用于识别请求来源，确保跨域请求的安全性。在特定场景下，可以通过使用非浏览器客户端、代理服务器、JSONP 等方法实现不携带 <code>Origin</code> 头的请求。不过，需要谨慎使用这些方法，避免绕过浏览器的安全策略带来的潜在风险。</p><p>跨域和安全控制始终是 Web 开发中的重点，理解 <code>Origin</code> 头的作用、区别它和用户 IP，将有助于更好地配置和管理跨域资源共享（CORS）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Web 开发中，跨域请求（Cross-Origin Requests）常常让开发者头疼，而 &lt;code&gt;Origin&lt;/code&gt; 头是跨域资源共享（CORS）机制中必不可少的组成部分。本文将详细介绍 &lt;code&gt;Origin&lt;/code&gt; 头的作用、为什么它与用户的 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue 项目中的代码注释规范：提升可读性与可维护性</title>
    <link href="https://promptonce.github.io/2024/11/11/Vue-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%EF%BC%9A%E6%8F%90%E5%8D%87%E5%8F%AF%E8%AF%BB%E6%80%A7%E4%B8%8E%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7/"/>
    <id>https://promptonce.github.io/2024/11/11/Vue-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83%EF%BC%9A%E6%8F%90%E5%8D%87%E5%8F%AF%E8%AF%BB%E6%80%A7%E4%B8%8E%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7/</id>
    <published>2024-11-11T06:27:28.000Z</published>
    <updated>2024-11-11T06:28:29.693Z</updated>
    
    <content type="html"><![CDATA[<p>在现代 JavaScript 开发中，<strong>Vue.js</strong> 因其灵活的组件化结构和易学易用的特性广受欢迎。随着项目的日益复杂，良好的代码注释规范变得尤为重要。在 Vue 项目中，注释不仅仅帮助开发人员理解代码逻辑，还能提升团队协作效率，减少沟通成本。本文将结合 Vue 项目，讨论如何编写清晰、简洁且有效的代码注释。</p><hr><h3 id="为什么注释很重要？"><a href="#为什么注释很重要？" class="headerlink" title="为什么注释很重要？"></a>为什么注释很重要？</h3><p>代码注释的核心目标是提升代码的可读性、可维护性，并帮助开发人员理解代码的<strong>意图</strong>而非仅仅是<strong>实现</strong>。尤其是在 Vue 项目中，常常涉及复杂的组件交互、状态管理、路由控制等，良好的注释能让团队成员和未来的开发人员更容易理解代码背后的设计思想和业务逻辑。</p><p>良好的注释规范能帮助你：</p><ul><li><strong>解释“为什么”做某事，而不是“怎么做”</strong>：代码本身能说明“怎么做”，注释则应解释<strong>为何</strong>要这样做。</li><li><strong>避免重复</strong>：注释不应重复代码，应该补充代码中无法直接表达的内容。</li><li><strong>促进团队协作</strong>：多人协作的项目中，注释是沟通的桥梁。</li></ul><hr><h3 id="注释的类型和使用场景"><a href="#注释的类型和使用场景" class="headerlink" title="注释的类型和使用场景"></a>注释的类型和使用场景</h3><p>在 Vue 项目中，常用的注释类型包括单行注释、多行注释和文档注释。不同类型的注释适用于不同的场景：</p><h4 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1. 单行注释"></a>1. <strong>单行注释</strong></h4><p>单行注释适合对单行代码或某些简单逻辑进行简短说明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="number">0</span>  <span class="comment">// 用于存储计数器的初始值</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2. 多行注释"></a>2. <strong>多行注释</strong></h4><p>当某段逻辑较为复杂或需要详细解释时，可以使用多行注释。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 该方法处理用户登录逻辑：</span></span><br><span class="line"><span class="comment"> * 1. 检查用户名和密码的合法性</span></span><br><span class="line"><span class="comment"> * 2. 通过 API 请求进行登录</span></span><br><span class="line"><span class="comment"> * 3. 根据返回结果设置登录状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">login</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 登录逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-文档注释"><a href="#3-文档注释" class="headerlink" title="3. 文档注释"></a>3. <strong>文档注释</strong></h4><p>文档注释（如 JSDoc）用于描述函数、组件或模块的功能、参数及返回值。在 Vue 项目中，文档注释尤其对组件及其方法非常重要。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户登录组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@component</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 用于用户输入用户名和密码并进行登录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 登录函数，执行用户名和密码验证，并调用 API 进行登录</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">username</span> - 用户名</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">password</span> - 密码</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@returns</span> &#123;<span class="type">Promise</span>&#125; 登录结果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="title function_">login</span>(<span class="params">username, password</span>) &#123;</span><br><span class="line">            <span class="comment">// 登录逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="Vue-项目中的注释规范"><a href="#Vue-项目中的注释规范" class="headerlink" title="Vue 项目中的注释规范"></a>Vue 项目中的注释规范</h3><p>在 Vue 项目中，代码注释的规范化非常关键，特别是在 Vue 的各个部分（如 <code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code>、<code>props</code> 等）中。下面将介绍如何在这些常见的 Vue 代码部分中编写有效的注释。</p><h4 id="1-data-和-props-注释"><a href="#1-data-和-props-注释" class="headerlink" title="1. data 和 props 注释"></a>1. <strong>data 和 props 注释</strong></h4><p>在 Vue 中，<code>data</code> 和 <code>props</code> 通常需要注释，尤其是当项目中多个组件共享某些数据或属性时。注释可以帮助开发人员快速了解数据的来源和目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">username</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">        <span class="attr">required</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录成功后的回调函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@type</span> &#123;<span class="type">Function</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="attr">onLoginSuccess</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Function</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存储当前输入的密码</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@type</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-methods-注释"><a href="#2-methods-注释" class="headerlink" title="2. methods 注释"></a>2. <strong>methods 注释</strong></h4><p>在 Vue 组件的 <code>methods</code> 中，注释帮助描述每个方法的功能、参数和返回值。这对于理解业务逻辑尤为重要。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户注册</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">username</span> - 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">password</span> - 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">Promise</span>&#125; 注册结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">register</span>(<span class="params">username, password</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$axios</span>.<span class="title function_">post</span>(<span class="string">&#x27;/api/register&#x27;</span>, &#123; username, password &#125;)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-computed-和-watch-注释"><a href="#3-computed-和-watch-注释" class="headerlink" title="3. computed 和 watch 注释"></a>3. <strong>computed 和 watch 注释</strong></h4><p>对于计算属性 (<code>computed</code>) 和侦听器 (<code>watch</code>)，注释不仅能帮助描述计算逻辑，还能帮助理解为何监听某个状态的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户的欢迎信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125; 用户欢迎信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">welcomeMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`欢迎，<span class="subst">$&#123;<span class="variable language_">this</span>.username&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听密码变化，验证密码长度是否合规</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">password</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal.<span class="property">length</span> &lt; <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">passwordError</span> = <span class="string">&#x27;密码必须至少6个字符&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">passwordError</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="常见注释实践"><a href="#常见注释实践" class="headerlink" title="常见注释实践"></a>常见注释实践</h3><p>在开发过程中，除了普通的注释，以下几个注释标签也非常常见，能帮助团队更好地管理任务和提醒问题。</p><ul><li><p><strong>TODO</strong>：标记待办事项，提醒自己或团队成员某些功能尚未完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 完成注册流程的UI设计</span></span><br></pre></td></tr></table></figure></li><li><p><strong>FIXME</strong>：标记需要修复的错误或问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">FIXME:</span> 登录表单缺少验证码功能</span></span><br></pre></td></tr></table></figure></li><li><p><strong>NOTE</strong>：用于提供特别的提醒或说明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 使用异步组件加载时，确保相关模块已经编译完成</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="注释更新的重要性"><a href="#注释更新的重要性" class="headerlink" title="注释更新的重要性"></a>注释更新的重要性</h3><p>随着项目的推进，代码和功能会不断变化。为了避免代码与注释不一致，开发人员应养成<strong>同步更新注释</strong>的习惯。如果你修改了某个方法或组件的逻辑，记得更新相应的注释。过时的注释不仅无用，甚至可能误导团队成员。</p><hr><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在 Vue 项目中，良好的注释习惯是确保代码可读性和可维护性的关键。通过清晰的注释，团队成员能够更快速地理解业务逻辑和组件间的关系，减少沟通成本和维护难度。注释不仅能提升代码质量，还能促进团队协作和代码复用。</p><p>记住：注释是帮助他人理解代码的工具，而非为了取代代码的可读性。保持注释的简洁、清晰与准确，才能发挥其最大的价值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在现代 JavaScript 开发中，&lt;strong&gt;Vue.js&lt;/strong&gt; 因其灵活的组件化结构和易学易用的特性广受欢迎。随着项目的日益复杂，良好的代码注释规范变得尤为重要。在 Vue 项目中，注释不仅仅帮助开发人员理解代码逻辑，还能提升团队协作效率，减少沟通成本</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>leetcode 141. 环形链表</title>
    <link href="https://promptonce.github.io/2024/11/11/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <id>https://promptonce.github.io/2024/11/11/leetcode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
    <published>2024-11-11T05:05:08.000Z</published>
    <updated>2024-11-23T15:27:27.707Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hasCycle = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">let</span> slow = head;</span><br><span class="line">    <span class="keyword">let</span> fast = head;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast.<span class="property">next</span> !== <span class="literal">null</span>)&#123;</span><br><span class="line">        fast = fast.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">        slow = slow.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">if</span>(fast === slow)&#123;</span><br><span class="line">            ret = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>循环中有fast &#x3D; fast.next.next需要判断fast.next不为空容易想到，还需要判断fast不为空，一个是从外部进入循环时的判断，一个是执行了fast &#x3D; fast.next.next后的判断，也可以将fast是否为空的判断写到fast &#x3D; fast.next.next这行之后（如果fast为空则用break跳出循环）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
    <category term="leetcode,算法" scheme="https://promptonce.github.io/tags/leetcode-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>vue,typescript项目打包报错</title>
    <link href="https://promptonce.github.io/2024/11/10/vue-typescript%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99/"/>
    <id>https://promptonce.github.io/2024/11/10/vue-typescript%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E6%8A%A5%E9%94%99/</id>
    <published>2024-11-10T09:58:03.000Z</published>
    <updated>2024-11-10T09:59:21.126Z</updated>
    
    <content type="html"><![CDATA[<p>&#x2F;&#x2F; @ts-ignore：无法被执行的代码的错误</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;#x2F;&amp;#x2F; @ts-ignore：无法被执行的代码的错误&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>工作汇报总结</title>
    <link href="https://promptonce.github.io/2024/11/08/%E5%B7%A5%E4%BD%9C%E6%B1%87%E6%8A%A5%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/11/08/%E5%B7%A5%E4%BD%9C%E6%B1%87%E6%8A%A5%E6%80%BB%E7%BB%93/</id>
    <published>2024-11-08T07:44:58.000Z</published>
    <updated>2024-11-08T07:46:56.991Z</updated>
    
    <content type="html"><![CDATA[<p>计算制作PPT和开会的产出比</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算制作PPT和开会的产出比&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>html,css,js和Vue，Vuetify的关系</title>
    <link href="https://promptonce.github.io/2024/11/05/html-css-js%E5%92%8CVue%EF%BC%8CVuetify%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <id>https://promptonce.github.io/2024/11/05/html-css-js%E5%92%8CVue%EF%BC%8CVuetify%E7%9A%84%E5%85%B3%E7%B3%BB/</id>
    <published>2024-11-04T16:06:59.000Z</published>
    <updated>2024-11-04T16:13:49.608Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发领域，<strong>Vue</strong>和<strong>Vuetify</strong>常常被组合使用，尤其是在希望快速构建出高质量的、具备一致性视觉效果的应用时。这两者之间的关系却并非那么直观。Vue 是一个框架，而 Vuetify 是一个 UI 组件库——二者的定位和功能有着明显的差异，但也存在紧密的协作关系。本文将带你深入了解 Vue 和 Vuetify 的相互关系，并解释为什么它们的结合能提升开发效率。</p><hr><h2 id="1-Vue-是框架，Vuetify-是-UI-组件库"><a href="#1-Vue-是框架，Vuetify-是-UI-组件库" class="headerlink" title="1. Vue 是框架，Vuetify 是 UI 组件库"></a>1. Vue 是框架，Vuetify 是 UI 组件库</h2><p>首先，我们来看看 Vue 和 Vuetify 各自的定位。</p><ul><li><p><strong>Vue</strong>：Vue.js 是一个渐进式的 JavaScript 框架，主要用来构建用户界面，核心功能是通过数据驱动的方式来渲染视图。Vue 提供了响应式数据绑定、组件化管理、路由控制、状态管理等功能，它的设计理念是简洁灵活，让开发者专注于应用的业务逻辑和数据流管理。</p></li><li><p><strong>Vuetify</strong>：Vuetify 是一个基于 Material Design 的 Vue UI 组件库。它主要提供符合视觉设计规范的预定义组件，比如按钮、表单、导航栏、卡片等。这些组件是高度可自定义的，帮助开发者在 Vue 应用中快速实现一致性 UI，而不必自己设计和开发样式。</p></li></ul><p>因此，<strong>Vue 更专注于应用逻辑和架构，而 Vuetify 专注于视觉和交互设计</strong>。Vue 的关注点在于实现应用的核心逻辑，而 Vuetify 则让我们专注于页面的美观与用户体验。</p><h2 id="2-Vue-提供框架结构，Vuetify-提供视觉和交互设计"><a href="#2-Vue-提供框架结构，Vuetify-提供视觉和交互设计" class="headerlink" title="2. Vue 提供框架结构，Vuetify 提供视觉和交互设计"></a>2. Vue 提供框架结构，Vuetify 提供视觉和交互设计</h2><p>Vue 和 Vuetify 可以被理解为“逻辑与视觉”的关系：</p><ul><li>Vue 负责应用逻辑，提供数据的双向绑定、生命周期管理等，让页面可以随数据动态更新。</li><li>Vuetify 提供了大量预定义的 UI 组件，开发者无需关心复杂的样式调整，只需在 Vue 的架构中引入这些 Vuetify 组件，即可快速实现高质量的界面。</li></ul><p>Vue 搭建应用的逻辑框架，而 Vuetify 完成 UI 细节的展现。这种明确的分工大大提升了开发效率——我们可以专注于业务逻辑，而 Vuetify 则为我们完成了 UI 部分的视觉实现。</p><h2 id="3-Vue-和-Vuetify-之间是解耦的关系"><a href="#3-Vue-和-Vuetify-之间是解耦的关系" class="headerlink" title="3. Vue 和 Vuetify 之间是解耦的关系"></a>3. Vue 和 Vuetify 之间是解耦的关系</h2><p>Vue 和 Vuetify 之间没有强依赖关系。Vue 是一个独立的框架，可以结合其他 UI 库（如 Element、Ant Design Vue 等）来实现界面，也可以自己编写 CSS 和 HTML 模板；Vuetify 是 Vue 生态系统中的一个插件，因此使用它并非必需。</p><p>Vuetify 是一种可选的、灵活的 UI 解决方案。它只是 Vue 生态系统的一个补充部分，旨在提供高度自定义的、符合 Material Design 规范的组件库，帮助开发者快速搭建界面。如果项目需求有特殊的 UI 设计要求，开发者可以选择不使用 Vuetify，而是自行设计和实现。</p><p>这种解耦性赋予了开发者灵活性，让他们可以根据需求选择是否使用 Vuetify 作为 Vue 应用的 UI 库。</p><h2 id="4-Vue-作为底层逻辑，Vuetify-作为视觉呈现"><a href="#4-Vue-作为底层逻辑，Vuetify-作为视觉呈现" class="headerlink" title="4. Vue 作为底层逻辑，Vuetify 作为视觉呈现"></a>4. Vue 作为底层逻辑，Vuetify 作为视觉呈现</h2><p>Vue 和 Vuetify 的关系可以用“底层逻辑”与“视觉呈现”来描述：</p><ul><li><strong>Vue</strong> 作为底层逻辑层，控制应用的状态、数据流、组件生命周期等核心机制，是应用的“内核”。</li><li><strong>Vuetify</strong> 则利用 Vue 的组件机制构建了大量可复用的 UI 组件，使其成为上层的 UI 展现工具。Vuetify 的每一个组件实际上都是一个 Vue 组件，它依赖 Vue 的响应式系统和双向绑定功能来实现动态更新和数据渲染。</li></ul><p>Vuetify 正是基于 Vue 的灵活机制构建出来的，可以通过 Vue 实现数据的动态绑定，同时让用户界面符合 Material Design 规范。Vue 处理的是逻辑和数据，Vuetify 负责将这些逻辑和数据以符合视觉规范的方式呈现给用户。</p><hr><h2 id="总结：Vue-与-Vuetify-的优势互补"><a href="#总结：Vue-与-Vuetify-的优势互补" class="headerlink" title="总结：Vue 与 Vuetify 的优势互补"></a>总结：Vue 与 Vuetify 的优势互补</h2><p>Vue 和 Vuetify 的关系可以理解为一个负责逻辑、一个负责视觉：</p><ul><li><strong>Vue 是应用的逻辑骨架</strong>：它让我们可以用更少的代码实现复杂的应用逻辑，提供响应式、组件化的开发体验。</li><li><strong>Vuetify 是 UI 层的组件库</strong>：它封装了丰富的 UI 组件，帮助我们快速构建视觉一致、功能完善的界面。</li></ul><p>在 Vue 搭建的应用结构中引入 Vuetify，可以大大提升开发效率，让我们专注于业务逻辑，而不必担心 UI 的美观性和一致性。对于希望快速构建出美观、现代应用的开发者来说，Vue 和 Vuetify 的组合是一个很好的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前端开发领域，&lt;strong&gt;Vue&lt;/strong&gt;和&lt;strong&gt;Vuetify&lt;/strong&gt;常常被组合使用，尤其是在希望快速构建出高质量的、具备一致性视觉效果的应用时。这两者之间的关系却并非那么直观。Vue 是一个框架，而 Vuetify 是一个 UI 组件库</summary>
      
    
    
    
    
    <category term="Vue" scheme="https://promptonce.github.io/tags/Vue/"/>
    
    <category term="Vuetify" scheme="https://promptonce.github.io/tags/Vuetify/"/>
    
    <category term="前端框架" scheme="https://promptonce.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    <category term="UI组件库" scheme="https://promptonce.github.io/tags/UI%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MMSegmentation进阶指南-数据流</title>
    <link href="https://promptonce.github.io/2024/11/03/MMSegmentation%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>https://promptonce.github.io/2024/11/03/MMSegmentation%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E6%95%B0%E6%8D%AE%E6%B5%81/</id>
    <published>2024-11-03T12:13:47.000Z</published>
    <updated>2024-11-03T12:21:27.508Z</updated>
    
    <content type="html"><![CDATA[<img src="/2024/11/03/MMSegmentation%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E6%95%B0%E6%8D%AE%E6%B5%81/199228350-5f80699e-7fd2-4b4c-ac32-0b16b1922c2e.png" class="" title="199228350-5f80699e-7fd2-4b4c-ac32-0b16b1922c2e.png"><p>Runner 相当于 MMEngine 中的“集成器”。它覆盖了框架的所有方面，并肩负着组织和调度几乎所有模块的责任，这意味着各模块之间的数据流也由 Runner 控制。<br>Runner中实现上述不同颜色的传递（TrainLoop、ValLoop 和 TestLoop）<br>MMSegmentation的DataLoader和Pytorch的DataLoader保持一致。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2024/11/03/MMSegmentation%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97-%E6%95%B0%E6%8D%AE%E6%B5%81/199228350-5f80699e-7fd2-4b4c-ac32-0b16b</summary>
      
    
    
    
    
    <category term="MMSegmentation" scheme="https://promptonce.github.io/tags/MMSegmentation/"/>
    
  </entry>
  
  <entry>
    <title>从计算机线程中学习到的6个工作道理</title>
    <link href="https://promptonce.github.io/2024/11/03/%E4%BB%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%88%B0%E7%9A%846%E4%B8%AA%E5%B7%A5%E4%BD%9C%E9%81%93%E7%90%86/"/>
    <id>https://promptonce.github.io/2024/11/03/%E4%BB%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%88%B0%E7%9A%846%E4%B8%AA%E5%B7%A5%E4%BD%9C%E9%81%93%E7%90%86/</id>
    <published>2024-11-03T02:33:17.000Z</published>
    <updated>2024-11-03T03:23:10.637Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从计算机线程中学习到的6个工作道理"><a href="#从计算机线程中学习到的6个工作道理" class="headerlink" title="从计算机线程中学习到的6个工作道理"></a>从计算机线程中学习到的6个工作道理</h3><p>在软件开发中，线程是让计算机执行多任务的基本机制。线程如何管理、分配和执行任务的原理，能启发我们如何有效地组织和管理日常工作。这篇博客将从计算机线程的工作方式中总结出6个可应用于工作的道理，帮助我们提升效率、优化流程。</p><hr><h4 id="1-任务分解与并行执行"><a href="#1-任务分解与并行执行" class="headerlink" title="1. 任务分解与并行执行"></a>1. 任务分解与并行执行</h4><p><strong>线程原理</strong>：线程通过将复杂任务分解成多个可以并行处理的小任务，提高了执行效率。<br><strong>工作启示</strong>：在项目管理中，尝试将复杂的大任务拆分成可独立执行的小任务，并让团队成员并行处理。这不仅缩短了总任务完成时间，还让每个人更专注于具体任务。</p><p><em>示例</em>：例如在开发一个产品时，可以让一个小组负责前端，另一个小组负责后端，再分配一组专门进行测试，这样不同小组可以同时展开工作，最终加快项目整体进度。</p><hr><h4 id="2-资源共享与竞争管理"><a href="#2-资源共享与竞争管理" class="headerlink" title="2. 资源共享与竞争管理"></a>2. 资源共享与竞争管理</h4><p><strong>线程原理</strong>：多线程环境下，线程之间共享计算机资源，必须避免资源竞争或死锁。<br><strong>工作启示</strong>：团队成员在共享资源时，必须避免冲突。明确各自资源的分配，合理安排资源使用，设定优先级和规则，能够帮助团队避免资源争夺，实现更高效的协作。</p><p><em>示例</em>：在跨部门合作时，常会涉及共享数据或技术资源。可以制定共享资源的访问机制，例如规定各部门的数据提取时间和频率，确保资源得到合理利用。</p><hr><h4 id="3-同步与协调"><a href="#3-同步与协调" class="headerlink" title="3. 同步与协调"></a>3. 同步与协调</h4><p><strong>线程原理</strong>：多线程工作中，通过同步来确保数据一致性。<br><strong>工作启示</strong>：工作中，团队成员需要定期沟通和同步进展，以保持任务的一致性。我们可以通过每日站会、每周例会等方式，确保大家在同一个步调上，有效地避免信息不对称。</p><p><em>示例</em>：例如，项目管理中可以采用敏捷开发的每日站会形式，让每个成员汇报进展和遇到的问题，方便团队成员保持对项目的统一认识。</p><hr><h4 id="4-负载均衡与优化"><a href="#4-负载均衡与优化" class="headerlink" title="4. 负载均衡与优化"></a>4. 负载均衡与优化</h4><p><strong>线程原理</strong>：在多线程编程中，合理分配任务到各个线程避免超载，以优化整体性能。<br><strong>工作启示</strong>：在团队中，合理分配任务以避免某些成员过度负担，确保大家工作量适中。既能保证每个人的高效工作，也能防止人力资源浪费。</p><p><em>示例</em>：在资源紧张的项目中，可以根据团队成员的专长和工作量，合理分配任务。避免让某个人承担过多工作，导致项目进度延误。</p><hr><h4 id="5-容错与恢复机制"><a href="#5-容错与恢复机制" class="headerlink" title="5. 容错与恢复机制"></a>5. 容错与恢复机制</h4><p><strong>线程原理</strong>：在多线程中，一个线程出错不会导致整个系统崩溃，它可以被独立恢复或重启。<br><strong>工作启示</strong>：在工作中，当某个环节出问题时，应该设立容错机制，快速修复而不影响整体进度。这样可以防止小问题演变成阻碍项目的瓶颈。</p><p><em>示例</em>：在项目开发中，可以定期备份代码，或者采用版本控制系统（如Git）来管理代码，确保在某个功能模块出错时，能够快速恢复到上一个稳定版本。</p><hr><h4 id="6-优先级与抢占式调度"><a href="#6-优先级与抢占式调度" class="headerlink" title="6. 优先级与抢占式调度"></a>6. 优先级与抢占式调度</h4><p><strong>线程原理</strong>：多线程系统中，优先级高的任务会优先获得资源。<br><strong>工作启示</strong>：在工作中，我们需要对任务设定优先级，优先处理紧急或重要的任务，以确保关键任务得到及时处理。</p><p><em>示例</em>：在接到多个任务时，可以采用优先级评估法（如“重要-紧急”矩阵），先处理重要且紧急的任务，确保不因次要任务延误核心工作。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>计算机线程的工作原理，不仅能帮助我们理解程序的运行机制，也能为日常工作管理提供启发。<strong>将任务分解、管理资源、同步协调、负载优化、容错恢复和优先调度</strong>这些线程中的管理方式应用到工作中，有助于我们更高效地组织项目，提升团队协作效率。希望这些从线程中获得的道理，能够成为你工作中的小助手！</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;从计算机线程中学习到的6个工作道理&quot;&gt;&lt;a href=&quot;#从计算机线程中学习到的6个工作道理&quot; class=&quot;headerlink&quot; title=&quot;从计算机线程中学习到的6个工作道理&quot;&gt;&lt;/a&gt;从计算机线程中学习到的6个工作道理&lt;/h3&gt;&lt;p&gt;在软件开发中，线程是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>快速更新失效域名证书方法</title>
    <link href="https://promptonce.github.io/2024/11/03/%E5%BF%AB%E9%80%9F%E6%9B%B4%E6%96%B0%E5%A4%B1%E6%95%88%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6%E6%96%B9%E6%B3%95/"/>
    <id>https://promptonce.github.io/2024/11/03/%E5%BF%AB%E9%80%9F%E6%9B%B4%E6%96%B0%E5%A4%B1%E6%95%88%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6%E6%96%B9%E6%B3%95/</id>
    <published>2024-11-03T02:05:47.000Z</published>
    <updated>2024-11-03T02:07:08.952Z</updated>
    
    <content type="html"><![CDATA[<p>服务器端如果是windows直接登录CA官网进行域名证书的更新替换</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;服务器端如果是windows直接登录CA官网进行域名证书的更新替换&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>node版本号排序</title>
    <link href="https://promptonce.github.io/2024/11/01/node%E7%89%88%E6%9C%AC%E5%8F%B7%E6%8E%92%E5%BA%8F/"/>
    <id>https://promptonce.github.io/2024/11/01/node%E7%89%88%E6%9C%AC%E5%8F%B7%E6%8E%92%E5%BA%8F/</id>
    <published>2024-11-01T09:31:16.000Z</published>
    <updated>2024-11-01T09:39:26.480Z</updated>
    
    <content type="html"><![CDATA[<p>const versions &#x3D; [‘1.10.2’, ‘1.3’, ‘2.0.1’, ‘1.5.1’, ‘1.5’, ‘1.4.1’]; 进行排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试数据集（无歧义版本号，所有版本号格式统一）</span></span><br><span class="line"><span class="keyword">const</span> testCases = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">input</span>: [<span class="string">&#x27;10.0&#x27;</span>, <span class="string">&#x27;2.0&#x27;</span>, <span class="string">&#x27;1.9&#x27;</span>, <span class="string">&#x27;1.10&#x27;</span>, <span class="string">&#x27;1.8&#x27;</span>],</span><br><span class="line">        <span class="attr">expected</span>: [<span class="string">&#x27;1.8&#x27;</span>, <span class="string">&#x27;1.9&#x27;</span>, <span class="string">&#x27;1.10&#x27;</span>, <span class="string">&#x27;2.0&#x27;</span>, <span class="string">&#x27;10.0&#x27;</span>],</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&quot;主要版本不一致的情况，测试两位版本号的比较&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">input</span>: [<span class="string">&#x27;1.10&#x27;</span>, <span class="string">&#x27;1.3&#x27;</span>, <span class="string">&#x27;2.0&#x27;</span>, <span class="string">&#x27;1.5&#x27;</span>, <span class="string">&#x27;1.4&#x27;</span>],</span><br><span class="line">        <span class="attr">expected</span>: [<span class="string">&#x27;1.3&#x27;</span>, <span class="string">&#x27;1.4&#x27;</span>, <span class="string">&#x27;1.5&#x27;</span>, <span class="string">&#x27;1.10&#x27;</span>, <span class="string">&#x27;2.0&#x27;</span>],</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&quot;包含主版本和次版本，避免歧义&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">input</span>: [<span class="string">&#x27;1.0&#x27;</span>, <span class="string">&#x27;1.1&#x27;</span>, <span class="string">&#x27;1.0.1&#x27;</span>, <span class="string">&#x27;1.2&#x27;</span>, <span class="string">&#x27;1.0.0&#x27;</span>],</span><br><span class="line">        <span class="attr">expected</span>: [<span class="string">&#x27;1.0&#x27;</span>, <span class="string">&#x27;1.0.0&#x27;</span>, <span class="string">&#x27;1.0.1&#x27;</span>, <span class="string">&#x27;1.1&#x27;</span>, <span class="string">&#x27;1.2&#x27;</span>],</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&quot;包含固定格式版本，补位0&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">input</span>: [<span class="string">&#x27;2.1&#x27;</span>, <span class="string">&#x27;2.0&#x27;</span>, <span class="string">&#x27;1.9&#x27;</span>, <span class="string">&#x27;1.10&#x27;</span>, <span class="string">&#x27;1.10.1&#x27;</span>],</span><br><span class="line">        <span class="attr">expected</span>: [<span class="string">&#x27;1.9&#x27;</span>, <span class="string">&#x27;1.10&#x27;</span>, <span class="string">&#x27;1.10.1&#x27;</span>, <span class="string">&#x27;2.0&#x27;</span>, <span class="string">&#x27;2.1&#x27;</span>],</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&quot;小版本和补丁更新及主版本升级&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">input</span>: [<span class="string">&#x27;0.1&#x27;</span>, <span class="string">&#x27;0.0.1&#x27;</span>, <span class="string">&#x27;0.10&#x27;</span>, <span class="string">&#x27;0.2&#x27;</span>, <span class="string">&#x27;0.2.0&#x27;</span>],</span><br><span class="line">        <span class="attr">expected</span>: [<span class="string">&#x27;0.0.1&#x27;</span>, <span class="string">&#x27;0.1&#x27;</span>, <span class="string">&#x27;0.2&#x27;</span>, <span class="string">&#x27;0.2.0&#x27;</span>, <span class="string">&#x27;0.10&#x27;</span>],</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&quot;补位和次版本，不存在单一数字的歧义&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户需要在这里完成 sortVersions 函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortVersions</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newArr = arr.<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> e.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>));</span><br><span class="line">    newArr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != b[i])&#123;</span><br><span class="line">                <span class="keyword">return</span> a[i] - b[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> newArr.<span class="title function_">map</span>(<span class="function"><span class="params">e</span> =&gt;</span> e.<span class="title function_">join</span>(<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判题系统：检查用户的排序结果是否符合预期</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">judge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    testCases.<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; input, expected, description &#125;, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> userSortedVersions = <span class="title function_">sortVersions</span>([...input]); <span class="comment">// 不改变原数组</span></span><br><span class="line">        <span class="keyword">const</span> result = userSortedVersions.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) === expected.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>) ? <span class="string">&#x27;Accepted&#x27;</span> : <span class="string">&#x27;Wrong Answer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Test Case <span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>: <span class="subst">$&#123;description&#125;</span>`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Input Versions: &quot;</span>, input);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;User Sorted Versions: &quot;</span>, userSortedVersions);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Expected Result: &quot;</span>, expected);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Judge Result: &quot;</span>, result);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行判题系统</span></span><br><span class="line"><span class="title function_">judge</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;const versions &amp;#x3D; [‘1.10.2’, ‘1.3’, ‘2.0.1’, ‘1.5.1’, ‘1.5’, ‘1.4.1’]; 进行排序&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>react总结</title>
    <link href="https://promptonce.github.io/2024/10/30/react%E6%A6%82%E8%BF%B0/"/>
    <id>https://promptonce.github.io/2024/10/30/react%E6%A6%82%E8%BF%B0/</id>
    <published>2024-10-30T12:24:05.000Z</published>
    <updated>2024-10-30T12:26:36.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-组件（Components）"><a href="#1-组件（Components）" class="headerlink" title="1. 组件（Components）"></a>1. 组件（Components）</h3><ul><li><strong>功能组件</strong>：函数形式的组件，返回 JSX。</li><li><strong>类组件</strong>：通过类定义的组件，适用于较复杂的逻辑，但一般现在推荐使用功能组件。</li></ul><h3 id="2-JSX"><a href="#2-JSX" class="headerlink" title="2. JSX"></a>2. JSX</h3><ul><li>React 使用 JSX 语法，允许你在 JavaScript 中直接书写 HTML。</li><li>注意：JSX 需要用 <code>className</code> 代替 HTML 的 <code>class</code>。</li></ul><h3 id="3-状态（State）与属性（Props）"><a href="#3-状态（State）与属性（Props）" class="headerlink" title="3. 状态（State）与属性（Props）"></a>3. 状态（State）与属性（Props）</h3><ul><li><strong>Props</strong>：父组件传递给子组件的数据，组件通过 <code>props</code> 接收。</li><li><strong>State</strong>：组件内部的状态，用于控制组件的渲染。</li></ul><h3 id="4-生命周期方法"><a href="#4-生命周期方法" class="headerlink" title="4. 生命周期方法"></a>4. 生命周期方法</h3><ul><li>对于类组件，有一些内置的生命周期方法（如 <code>componentDidMount</code>、<code>componentDidUpdate</code> 等）。</li><li>在功能组件中，可以使用 <code>useEffect</code> Hook 来处理副作用。</li></ul><h3 id="5-Hooks"><a href="#5-Hooks" class="headerlink" title="5. Hooks"></a>5. Hooks</h3><ul><li><strong>useState</strong>：用于管理组件状态。</li><li><strong>useEffect</strong>：用于处理副作用，类似于生命周期方法。</li><li><strong>自定义 Hook</strong>：可以封装逻辑，以便在多个组件中复用。</li></ul><h3 id="6-事件处理"><a href="#6-事件处理" class="headerlink" title="6. 事件处理"></a>6. 事件处理</h3><ul><li>在 React 中，事件处理是通过 CamelCase 命名的，比如 <code>onClick</code>。</li><li>事件处理函数可以直接传递，但要注意 <code>this</code> 的绑定（在类组件中）。</li></ul><h3 id="7-条件渲染与列表渲染"><a href="#7-条件渲染与列表渲染" class="headerlink" title="7. 条件渲染与列表渲染"></a>7. 条件渲染与列表渲染</h3><ul><li>条件渲染可以通过 JavaScript 表达式实现，比如使用三元运算符。</li><li>列表渲染通常使用 <code>map</code> 方法，记得为每个元素提供唯一的 <code>key</code>。</li></ul><h3 id="8-表单处理"><a href="#8-表单处理" class="headerlink" title="8. 表单处理"></a>8. 表单处理</h3><ul><li>在 React 中，表单元素的值通常由组件的 state 控制（受控组件）。</li><li>使用 <code>onChange</code> 事件处理输入变化。</li></ul><h3 id="9-组件间通信"><a href="#9-组件间通信" class="headerlink" title="9. 组件间通信"></a>9. 组件间通信</h3><ul><li>使用 props 进行父子组件通信。</li><li>对于兄弟组件，可以通过提升状态到共同的父组件。</li></ul><h3 id="10-路由"><a href="#10-路由" class="headerlink" title="10. 路由"></a>10. 路由</h3><ul><li>使用 React Router 进行路由管理，常用组件有 <code>BrowserRouter</code>、<code>Route</code> 和 <code>Link</code>。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>你可以通过构建一个简单的 Todo 应用来实践这些概念。这样可以让你对 React 的结构和思维方式有更深入的理解。</p><p>面试时，除了掌握以上基础概念，还可以关注一些常见的面试问题，例如：</p><ul><li>React 的虚拟 DOM 是什么？</li><li>描述一下 React 的单向数据流。</li><li>在 React 中如何优化性能？</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-组件（Components）&quot;&gt;&lt;a href=&quot;#1-组件（Components）&quot; class=&quot;headerlink&quot; title=&quot;1. 组件（Components）&quot;&gt;&lt;/a&gt;1. 组件（Components）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nvm</title>
    <link href="https://promptonce.github.io/2024/10/30/nvm%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/10/30/nvm%E6%80%BB%E7%BB%93/</id>
    <published>2024-10-29T17:08:05.000Z</published>
    <updated>2024-10-29T17:08:27.550Z</updated>
    
    <content type="html"><![CDATA[<p><code>nvm</code> 是 “Node Version Manager” 的缩写，用于管理 Node.js 的版本。对于 Node.js 开发者来说，有时候在不同的项目中需要不同的 Node.js 版本，而手动切换和管理这些版本会比较麻烦。<code>nvm</code> 能帮助用户轻松地安装、管理和切换不同的 Node.js 版本。</p><h3 id="1-安装-nvm"><a href="#1-安装-nvm" class="headerlink" title="1. 安装 nvm"></a>1. 安装 <code>nvm</code></h3><h4 id="macOS-和-Linux"><a href="#macOS-和-Linux" class="headerlink" title="macOS 和 Linux"></a>macOS 和 Linux</h4><p>在 macOS 和 Linux 系统上可以使用以下命令安装 <code>nvm</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.4/install.sh | bash</span><br></pre></td></tr></table></figure><p>安装完成后，重启终端或运行以下命令，让 <code>nvm</code> 生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc   <span class="comment"># 或者 source ~/.zshrc，根据使用的终端而定</span></span><br></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>在 Windows 上可以使用 <a href="https://github.com/coreybutler/nvm-windows"><code>nvm-windows</code></a> 版本，它是专门为 Windows 系统开发的 Node 版本管理器，与 Linux&#x2F;macOS 的版本稍有不同，但功能类似。下载并按照安装向导进行安装。</p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><ul><li><p><strong>安装特定版本的 Node.js</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install &lt;版本号&gt;</span><br></pre></td></tr></table></figure><p>例如，安装 Node.js 14：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 14</span><br></pre></td></tr></table></figure></li><li><p><strong>列出已安装的 Node.js 版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm list</span><br></pre></td></tr></table></figure><p>或者可以用 <code>nvm ls</code> 查看本地已安装的版本列表。</p></li><li><p><strong>切换 Node.js 版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use &lt;版本号&gt;</span><br></pre></td></tr></table></figure><p>例如，切换到 Node.js 14：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use 14</span><br></pre></td></tr></table></figure></li><li><p><strong>查看可用的远程版本</strong></p><p>使用以下命令可以查看所有可安装的远程 Node.js 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br></pre></td></tr></table></figure></li><li><p><strong>卸载某个版本的 Node.js</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm uninstall &lt;版本号&gt;</span><br></pre></td></tr></table></figure><p>例如，卸载 Node.js 14：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm uninstall 14</span><br></pre></td></tr></table></figure></li><li><p><strong>设置默认版本</strong></p><p>如果希望在每次新打开终端时使用某个默认版本，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm <span class="built_in">alias</span> default &lt;版本号&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h3><p><code>nvm</code> 特别适用于以下场景：</p><ul><li><strong>不同项目的依赖</strong>：如果某个项目使用 Node.js 14 而另一个项目依赖 Node.js 16，可以使用 <code>nvm</code> 快速切换版本。</li><li><strong>测试兼容性</strong>：需要测试代码在多个 Node.js 版本上的表现，可以通过 <code>nvm</code> 安装多个版本并来回切换。</li><li><strong>方便升级或降级</strong>：<code>nvm</code> 让升级到最新版本、或临时降级到旧版本变得很容易。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>nvm</code> 只在当前用户的 shell 环境中生效，不会修改系统级的 Node.js 版本。</li><li>如果安装了 <code>nvm</code>，尽量不要再使用其他方式（如直接从官网安装）来安装 Node.js，以免发生冲突。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;nvm&lt;/code&gt; 是 “Node Version Manager” 的缩写，用于管理 Node.js 的版本。对于 Node.js 开发者来说，有时候在不同的项目中需要不同的 Node.js 版本，而手动切换和管理这些版本会比较麻烦。&lt;code&gt;nvm&lt;/c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>itopmap网站专题页面分析</title>
    <link href="https://promptonce.github.io/2024/10/27/itopmap%E7%BD%91%E7%AB%99%E4%B8%93%E9%A2%98%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90/"/>
    <id>https://promptonce.github.io/2024/10/27/itopmap%E7%BD%91%E7%AB%99%E4%B8%93%E9%A2%98%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90/</id>
    <published>2024-10-27T06:50:06.000Z</published>
    <updated>2024-10-27T07:29:53.232Z</updated>
    
    <content type="html"><![CDATA[<p>卷帘添加节流处理，防止当用户拖动滑块地图组件触发较频繁</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;卷帘添加节流处理，防止当用户拖动滑块地图组件触发较频繁&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>itopmap网站首页UI分析</title>
    <link href="https://promptonce.github.io/2024/10/26/itopmap%E7%BD%91%E7%AB%99%E9%A6%96%E9%A1%B5UI%E5%88%86%E6%9E%90/"/>
    <id>https://promptonce.github.io/2024/10/26/itopmap%E7%BD%91%E7%AB%99%E9%A6%96%E9%A1%B5UI%E5%88%86%E6%9E%90/</id>
    <published>2024-10-26T14:26:47.000Z</published>
    <updated>2024-10-26T14:41:32.675Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-地图的居中对齐和填充布局"><a href="#1-地图的居中对齐和填充布局" class="headerlink" title="1. 地图的居中对齐和填充布局"></a>1. <strong>地图的居中对齐和填充布局</strong></h3><ul><li>地图区域在整个页面中被居中显示，填充整个屏幕的可视区域。这通常是通过 <strong>flex布局</strong> 或 <strong>CSS grid布局</strong> 实现的，结合 <code>justify-content: center</code> 和 <code>align-items: center</code> 来水平和垂直居中。</li><li>地图本身会自动填满可用空间，保持响应性，可能使用了 <code>position: relative</code> 配合 <code>width: 100%</code> 和 <code>height: 100vh</code> 的设置，以确保地图在浏览器窗口大小变化时仍能适应。</li></ul><h3 id="2-浮动的工具栏和按钮"><a href="#2-浮动的工具栏和按钮" class="headerlink" title="2. 浮动的工具栏和按钮"></a>2. <strong>浮动的工具栏和按钮</strong></h3><ul><li>页面左侧和底部的几个按钮（放大镜、回退按钮、层级选择按钮等）是独立浮动的。它们的位置可能是通过 <strong>绝对定位</strong>（<code>position: absolute</code>）实现的，以便于将它们固定在地图上某个具体的坐标。</li><li><code>z-index</code> 可能用于这些工具栏按钮，以确保它们始终显示在地图之上，而不被地图或其他元素覆盖。</li></ul><h3 id="3-按钮组的相对布局和排列"><a href="#3-按钮组的相对布局和排列" class="headerlink" title="3. 按钮组的相对布局和排列"></a>3. <strong>按钮组的相对布局和排列</strong></h3><ul><li>底部的 Esri、BingMap、OSM 按钮看起来是成组显示的，应该是一个<strong>水平排列的 flexbox 容器</strong>。可能使用了 <code>display: flex</code> 和 <code>justify-content: space-around</code> 或 <code>justify-content: center</code> 来让按钮均匀分布，且保持在页面底部。</li><li>它们的位置可能通过 <code>position: absolute</code> 或 <code>position: fixed</code> 与底部对齐（例如 <code>bottom: 20px</code>），确保这些按钮在页面滚动时保持固定位置。</li></ul><h3 id="4-顶部菜单的相对和绝对布局"><a href="#4-顶部菜单的相对和绝对布局" class="headerlink" title="4. 顶部菜单的相对和绝对布局"></a>4. <strong>顶部菜单的相对和绝对布局</strong></h3><ul><li>顶部菜单（“提交订单”、“开启&#x2F;关闭Roi”）是悬浮在地图顶部的，通常是使用 <strong>绝对定位</strong> 或 <strong>固定定位</strong>（<code>position: fixed</code>），使其在页面滚动时也保持在视窗顶部不动。</li><li><code>top</code> 和 <code>left</code> 属性可以用来精确控制这些按钮的位置，而 <code>z-index</code> 则用于确保它们位于地图之上，始终可见。</li></ul><h3 id="5-图标和按钮的对齐"><a href="#5-图标和按钮的对齐" class="headerlink" title="5. 图标和按钮的对齐"></a>5. <strong>图标和按钮的对齐</strong></h3><ul><li>左侧一列工具栏图标的排列方式可以通过 <strong>垂直 flexbox</strong> 布局或 <strong>垂直对齐的 CSS 样式</strong> 实现，使所有按钮按顺序纵向排列。</li><li>这些按钮的位置可能是通过 <code>position: fixed</code> 或 <code>position: absolute</code> 实现的，与地图内容相对布局，不会在地图移动时发生变化。</li></ul><h3 id="6-z-index-的应用"><a href="#6-z-index-的应用" class="headerlink" title="6. z-index 的应用"></a>6. <strong>z-index 的应用</strong></h3><ul><li><code>z-index</code> 在此页面中起着重要作用，确保悬浮按钮（如工具栏按钮和底部地图切换按钮）总是显示在地图之上。通常 z-index 值较高的元素会覆盖值较低的元素，确保了用户交互性和可视性。</li></ul><h3 id="7-响应式设计"><a href="#7-响应式设计" class="headerlink" title="7. 响应式设计"></a>7. <strong>响应式设计</strong></h3><ul><li>地图本身具有响应性，在不同屏幕尺寸上会自动缩放。可能使用了媒体查询（<code>@media</code>）或者相对单位（如 <code>%</code> 或 <code>vh/vw</code>）来确保在不同设备和分辨率上都能自适应。</li></ul><h3 id="8-CSS-动画效果"><a href="#8-CSS-动画效果" class="headerlink" title="8. CSS 动画效果"></a>8. <strong>CSS 动画效果</strong></h3><ul><li>这些按钮在点击时可能有动画效果，比如放大、缩小或阴影变化，可以通过 <strong>CSS transitions</strong> 或 <strong>animations</strong> 实现。例如 <code>transform: scale(1.1)</code> 可以用来实现按钮点击后的轻微放大效果。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个页面布局运用了多种前端布局技术，包括 <code>flexbox</code>、<code>absolute positioning</code>、<code>z-index</code>、<code>relative positioning</code> 和响应式布局等，确保了地图和悬浮工具栏按钮的交互性和可视性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-地图的居中对齐和填充布局&quot;&gt;&lt;a href=&quot;#1-地图的居中对齐和填充布局&quot; class=&quot;headerlink&quot; title=&quot;1. 地图的居中对齐和填充布局&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;地图的居中对齐和填充布局&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从二叉树遍历视角看递归思想</title>
    <link href="https://promptonce.github.io/2024/10/25/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E8%A7%86%E8%A7%92%E7%9C%8B%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3/"/>
    <id>https://promptonce.github.io/2024/10/25/%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E8%A7%86%E8%A7%92%E7%9C%8B%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3/</id>
    <published>2024-10-24T17:13:24.000Z</published>
    <updated>2024-10-24T17:38:12.040Z</updated>
    
    <content type="html"><![CDATA[<p>比如中序遍历左中右（适用于一棵仅有三个节点的小二叉树和由无数小的二叉树构成的大二叉树，区别在与小二叉树的子树是一个节点（最小的树），大二叉树的是一棵较大的树，都是符合二叉树的定义）</p><p>二叉树是一个抽象的概念，不要被名字误导，二叉树存储的信息包括二叉树的节点值和节点与节点之间的关系，理解了这层逻辑，叫二叉啥都无所谓。</p><p>中序遍历就是对二叉树中存储的信息进行读取的一种方式。读取的原则是先读取左子树的信息，再读取根节点的信息，再读取右子树的信息，这个简称逻辑A（如果子树中还有更小的子树-左子树或右子树, 根节点就是自身，不存在多态现象，根节点起连接节点关系的作用，这个子树中也执行同样的逻辑A，那么就可以将整棵树的信息按照中序遍历这种信息提取方式进行读取），其他遍历顺序同理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;比如中序遍历左中右（适用于一棵仅有三个节点的小二叉树和由无数小的二叉树构成的大二叉树，区别在与小二叉树的子树是一个节点（最小的树），大二叉树的是一棵较大的树，都是符合二叉树的定义）&lt;/p&gt;
&lt;p&gt;二叉树是一个抽象的概念，不要被名字误导，二叉树存储的信息包括二叉树的节点值和节</summary>
      
    
    
    
    
  </entry>
  
</feed>
