<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PromptOnce</title>
  
  
  <link href="https://promptonce.github.io/atom.xml" rel="self"/>
  
  <link href="https://promptonce.github.io/"/>
  <updated>2024-10-06T15:32:06.455Z</updated>
  <id>https://promptonce.github.io/</id>
  
  <author>
    <name>penggan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进制总结</title>
    <link href="https://promptonce.github.io/2024/10/06/%E8%BF%9B%E5%88%B6%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/10/06/%E8%BF%9B%E5%88%B6%E6%80%BB%E7%BB%93/</id>
    <published>2024-10-06T15:30:20.000Z</published>
    <updated>2024-10-06T15:32:06.455Z</updated>
    
    <content type="html"><![CDATA[<p>进制（Number Base）是表示数值的方式之一，用不同的数字和符号来表示不同的数值。最常见的进制有二进制、十进制、八进制和十六进制等。接下来，详细介绍这些不同的进制及它们之间的转换。</p><h3 id="1-什么是进制？"><a href="#1-什么是进制？" class="headerlink" title="1. 什么是进制？"></a>1. 什么是进制？</h3><p>进制是指用多少个不同的符号来表示一个数值的系统。例如，<strong>十进制</strong>使用0到9共十个符号；而<strong>二进制</strong>使用0和1两个符号。因此，”进制”就是表示数值的基本符号种类的数量。</p><h3 id="2-常见进制及其特点"><a href="#2-常见进制及其特点" class="headerlink" title="2. 常见进制及其特点"></a>2. 常见进制及其特点</h3><ol><li><p><strong>二进制（Binary，基数为2）</strong></p><ul><li>符号：0, 1</li><li>二进制的每一位只表示0或1。</li><li>常用于计算机和数字电路，因为电子元件只有开（1）或关（0）的状态。</li><li>例如，二进制数 <code>101</code> 表示十进制中的数字 5（从右到左依次表示 ( 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 )）。</li></ul></li><li><p><strong>十进制（Decimal，基数为10）</strong></p><ul><li>符号：0, 1, 2, 3, 4, 5, 6, 7, 8, 9</li><li>是我们日常生活中最常用的进制。</li><li>例如，数字 <code>123</code> 表示 ( 1 \times 10^2 + 2 \times 10^1 + 3 \times 10^0 &#x3D; 123 )。</li></ul></li><li><p><strong>八进制（Octal，基数为8）</strong></p><ul><li>符号：0, 1, 2, 3, 4, 5, 6, 7</li><li>每一位表示8的幂，常用于计算机中早期的一些操作系统和硬件。</li><li>例如，八进制数 <code>17</code> 表示十进制中的数字 15（从右到左依次表示 ( 1 \times 8^1 + 7 \times 8^0 &#x3D; 15 )）。</li></ul></li><li><p><strong>十六进制（Hexadecimal，基数为16）</strong></p><ul><li>符号：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F</li><li>用数字0-9和字母A-F表示，其中A表示10，B表示11，依此类推到F表示15。</li><li>十六进制常用于计算机编程，因为它可以简洁地表示二进制数。1个十六进制位可以表示4个二进制位（如<code>F</code>表示<code>1111</code>）。</li><li>例如，十六进制数 <code>1A</code> 表示十进制中的数字 26（从右到左依次表示 ( 1 \times 16^1 + 10 \times 16^0 &#x3D; 26 )）。</li></ul></li></ol><h3 id="3-进制转换"><a href="#3-进制转换" class="headerlink" title="3. 进制转换"></a>3. 进制转换</h3><ul><li><p><strong>二进制到十进制</strong></p><ul><li>方法：按位展开成2的幂次方求和。</li><li>例如：二进制 <code>1101</code> 转换为十进制就是 ( 1 \times 2^3 + 1 \times 2^2 + 0 \times 2^1 + 1 \times 2^0 &#x3D; 13 )。</li></ul></li><li><p><strong>十进制到二进制</strong></p><ul><li>方法：不断除以2，记录余数，然后逆序排列余数。</li><li>例如：十进制 <code>13</code> 转换为二进制就是：<ul><li>( 13 \div 2 &#x3D; 6 ) 余 1</li><li>( 6 \div 2 &#x3D; 3 ) 余 0</li><li>( 3 \div 2 &#x3D; 1 ) 余 1</li><li>( 1 \div 2 &#x3D; 0 ) 余 1</li><li>结果逆序为 <code>1101</code>。</li></ul></li></ul></li><li><p><strong>十进制到八进制</strong></p><ul><li>方法：不断除以8，记录余数，然后逆序排列余数。</li><li>例如：十进制 <code>64</code> 转换为八进制就是：<ul><li>( 64 \div 8 &#x3D; 8 ) 余 0</li><li>( 8 \div 8 &#x3D; 1 ) 余 0</li><li>( 1 \div 8 &#x3D; 0 ) 余 1</li><li>结果逆序为 <code>100</code>。</li></ul></li></ul></li><li><p><strong>十进制到十六进制</strong></p><ul><li>方法：不断除以16，记录余数（如果余数大于9，就用对应的字母），然后逆序排列余数。</li><li>例如：十进制 <code>26</code> 转换为十六进制就是：<ul><li>( 26 \div 16 &#x3D; 1 ) 余 10（即 A）</li><li>( 1 \div 16 &#x3D; 0 ) 余 1</li><li>结果逆序为 <code>1A</code>。</li></ul></li></ul></li></ul><h3 id="4-进制之间的快速转换"><a href="#4-进制之间的快速转换" class="headerlink" title="4. 进制之间的快速转换"></a>4. 进制之间的快速转换</h3><ul><li><strong>二进制到八进制</strong> 和 <strong>二进制到十六进制</strong> 可以通过分组快速转换：<ul><li><strong>二进制到八进制</strong>：每三位二进制数对应一位八进制数。例如：二进制 <code>101110</code> 可以分成 <code>101</code> 和 <code>110</code>，分别对应八进制的 <code>5</code> 和 <code>6</code>，所以结果是 <code>56</code>。</li><li><strong>二进制到十六进制</strong>：每四位二进制数对应一位十六进制数。例如：二进制 <code>11101100</code> 可以分成 <code>1110</code> 和 <code>1100</code>，分别对应十六进制的 <code>E</code> 和 <code>C</code>，所以结果是 <code>EC</code>。</li></ul></li></ul><h3 id="5-进制的实际应用"><a href="#5-进制的实际应用" class="headerlink" title="5. 进制的实际应用"></a>5. 进制的实际应用</h3><ul><li><strong>二进制</strong>：计算机底层运算、逻辑电路等。</li><li><strong>八进制</strong>：早期计算机系统，现代使用较少。</li><li><strong>十进制</strong>：日常生活中最常用，如数学运算。</li><li><strong>十六进制</strong>：编程中表示颜色代码（如 <code>#FF00FF</code>）、内存地址等。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>进制是用来表示数值的一种符号系统。</li><li>不同的进制系统有不同的符号数量和表示规则。</li><li>各进制之间的转换需要掌握其表示方式和运算规则。</li><li>计算机领域中最常用的是二进制和十六进制。十进制是日常生活中最为熟悉和使用的系统。</li></ul><p>掌握进制及其转换对理解计算机的工作原理和程序设计非常有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;进制（Number Base）是表示数值的方式之一，用不同的数字和符号来表示不同的数值。最常见的进制有二进制、十进制、八进制和十六进制等。接下来，详细介绍这些不同的进制及它们之间的转换。&lt;/p&gt;
&lt;h3 id=&quot;1-什么是进制？&quot;&gt;&lt;a href=&quot;#1-什么是进制？&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DIFF算法</title>
    <link href="https://promptonce.github.io/2024/10/03/DIFF%E7%AE%97%E6%B3%95/"/>
    <id>https://promptonce.github.io/2024/10/03/DIFF%E7%AE%97%E6%B3%95/</id>
    <published>2024-10-03T10:15:33.000Z</published>
    <updated>2024-10-03T10:20:25.211Z</updated>
    
    <content type="html"><![CDATA[<p>DIFF 算法的作用：同层树节点比较的算法那么 DIFF 算法是如何工作的？<br>一、首先是先计算新老 DOM 的最小变化该算法会先遍历一遍老的 DOM. 然后在遍历新的DOM，最后会判断是改变&#x2F;新增&#x2F;删除来重新排序。这样无疑是非常耗费计算的，我们看一看出总共遍历了三回、如果有一千个节点．那么就湖发生了十亿次的计算。<br>二. diff 算法的优化diff 算法的优化也就是这个算法的核心部分了，简单来说就是针对具有相同父节点的同层新旧子节点进行比较，不相同的话就会新增或者删除，而不是使用逐层搜索递归遍历的方式。时间复杂度为 O(n)。</p><ol><li>只比较同一层级，不跨级比较</li><li>标签不同，直接删除，不继续比较</li><li>标签名相同， key相同，就认为是相同节点，不继续深度比较</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DIFF 算法的作用：同层树节点比较的算法那么 DIFF 算法是如何工作的？&lt;br&gt;一、首先是先计算新老 DOM 的最小变化该算法会先遍历一遍老的 DOM. 然后在遍历新的DOM，最后会判断是改变&amp;#x2F;新增&amp;#x2F;删除来重新排序。这样无疑是非常耗费计算的，我们看一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="https://promptonce.github.io/2024/10/03/Vuex/"/>
    <id>https://promptonce.github.io/2024/10/03/Vuex/</id>
    <published>2024-10-03T08:38:11.000Z</published>
    <updated>2024-10-03T08:42:00.743Z</updated>
    
    <content type="html"><![CDATA[<p>Vuex 通过集中存储和管理应用中的所有状态，避免了组件之间的状态不一致或数据混乱的问题。它的运作方式类似于 Flux 模式，能够帮助开发者更加有序地管理和维护应用的状态。 具体来说，Vuex 主要通过五个核心概念来工作：  </p><ol><li><p>state：集中存储应用的状态，相当于数据的存储中心。</p></li><li><p>getter：类似于计算属性，从 state 中派生出新的数据给组件使用。</p></li><li><p>mutation：唯一修改 state 的方式，必须是同步操作。</p></li><li><p>action：可以包含异步操作，然后通过调用 mutation 来更新 state。</p></li><li><p>modules：将 store 划分为多个模块，每个模块可以拥有自己的 state、mutation、action、getters。</p></li></ol><p>Vuex 的这种集中式的状态管理模式非常适合复杂的应用，尤其是当应用中的组件间状态需要共享时。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vuex 通过集中存储和管理应用中的所有状态，避免了组件之间的状态不一致或数据混乱的问题。它的运作方式类似于 Flux 模式，能够帮助开发者更加有序地管理和维护应用的状态。 具体来说，Vuex 主要通过五个核心概念来工作：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;state：集</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue中的keep-alive</title>
    <link href="https://promptonce.github.io/2024/10/02/Vue%E4%B8%AD%E7%9A%84keep-alive/"/>
    <id>https://promptonce.github.io/2024/10/02/Vue%E4%B8%AD%E7%9A%84keep-alive/</id>
    <published>2024-10-02T08:58:43.000Z</published>
    <updated>2024-10-02T09:01:14.348Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 中的 keep-alive用 keep-alive 包裏组件时．会缓存不活动的组件实例，而不是销毁．使得我们返回的时候能重新激活。 keep-alive主要用于保存组件状态或避免重复创建。避免重复渲染导致的性能间题。常见场景页面的缓存，如上面的保存浏览商品页的滚动条位置筛选信息等</p><blockquote><p>注意这个和这个 Keep-Alive 是不一样的．这个属性的作用是、往往我们三次握手后，传输完数据就会断开连接进行四次挥手、关闭 TCP 连接．但是当我们在头信息中加入了该属性&#96;那么 TCP 会在发送后仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求、保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vue 中的 keep-alive用 keep-alive 包裏组件时．会缓存不活动的组件实例，而不是销毁．使得我们返回的时候能重新激活。 keep-alive主要用于保存组件状态或避免重复创建。避免重复渲染导致的性能间题。常见场景页面的缓存，如上面的保存浏览商品页的滚动条</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue中Scoped原理</title>
    <link href="https://promptonce.github.io/2024/10/02/Vue%E4%B8%ADScoped%E5%8E%9F%E7%90%86/"/>
    <id>https://promptonce.github.io/2024/10/02/Vue%E4%B8%ADScoped%E5%8E%9F%E7%90%86/</id>
    <published>2024-10-02T08:39:36.000Z</published>
    <updated>2024-10-02T08:40:21.671Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 中的 scoped 样式的作用是为了让组件的样式只在该组件的范围内生效，避免影响全局或其他组件。它的实现通过给每个组件生成一个唯一的标识符（如 data-v-xxxxxx），并将这个标识符附加到组件内的 DOM 元素和样式上。这样一来，样式表中的选择器只会影响带有相应标识符的 DOM 元素，而不会污染其他组件的样式。 总结特点： 1. 局部样式作用域：组件内的样式只能作用于组件自身的标签，且不会影响外部或其他组件。 2. 自动添加标识：Vue 会自动为组件的 DOM 和样式添加特定的 data-v- 属性，确保样式的唯一性和作用范围。  这个机制有效地解决了样式冲突问题，尤其在大型应用中，它可以确保不同组件的样式独立。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vue 中的 scoped 样式的作用是为了让组件的样式只在该组件的范围内生效，避免影响全局或其他组件。它的实现通过给每个组件生成一个唯一的标识符（如 data-v-xxxxxx），并将这个标识符附加到组件内的 DOM 元素和样式上。这样一来，样式表中的选择器只会影响带有相</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue过滤器</title>
    <link href="https://promptonce.github.io/2024/09/30/Vue%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://promptonce.github.io/2024/09/30/Vue%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2024-09-30T10:48:44.000Z</published>
    <updated>2024-09-30T10:49:54.670Z</updated>
    
    <content type="html"><![CDATA[<p>Vue 过滤器的功能就是对数据进行格式化处理。它提供了两种常见的方式：一个是在双花括号插值中使用管道符号“|”来进行过滤，比如将消息首字母大写；另一个是在 <code>v-bind</code> 中使用过滤器来对绑定的值进行格式化，比如格式化 ID。</p><p>开发者可以通过定义过滤器来自定义常见的格式转换规则，例如把字符串的首字母大写。这个过滤器可以定义在组件内部，也可以定义为全局过滤器。</p><p>总结一下：Vue 过滤器相当于一种方便的工具，帮助开发者在显示数据之前对其进行简单的处理，使得代码更简洁。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Filter Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Vue 过滤器示例<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 输入框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入一些文字&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>原始消息: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>过滤后的消息: &#123;&#123; message | capitalize &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建 Vue 实例</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 数据对象</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 定义过滤器</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">filters</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">capitalize</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          value = value.<span class="title function_">toString</span>()</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vue 过滤器的功能就是对数据进行格式化处理。它提供了两种常见的方式：一个是在双花括号插值中使用管道符号“|”来进行过滤，比如将消息首字母大写；另一个是在 &lt;code&gt;v-bind&lt;/code&gt; 中使用过滤器来对绑定的值进行格式化，比如格式化 ID。&lt;/p&gt;
&lt;p&gt;开发者可</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Segformer技术分析</title>
    <link href="https://promptonce.github.io/2024/09/29/Segformer%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    <id>https://promptonce.github.io/2024/09/29/Segformer%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</id>
    <published>2024-09-29T09:24:15.000Z</published>
    <updated>2024-09-29T14:20:08.394Z</updated>
    
    <content type="html"><![CDATA[<p>SegFormer避免了使用显式位置编码，所以在处理不同分辨率的图像时，不需要进行复杂的插值操作，原因主要是它通过<strong>卷积操作</strong>和<strong>层次结构</strong>来隐式地捕捉位置信息，而不是依赖于固定的、与图像分辨率相关的位置编码。</p><p>在传统的Transformer模型（例如ViT）中，位置编码是为每个输入特征（如图像的每个patch）明确指定的位置信息。当分辨率改变时，patch的数量也会随之变化，模型无法直接理解新分辨率下的位置信息，因此需要对位置编码进行插值，让它适应新的patch数量和图像分辨率。这是一个复杂的过程，容易引入误差。</p><p>而<strong>SegFormer</strong>通过以下方式避免了这一问题：</p><ol><li><p><strong>卷积的局部感知特性</strong>：SegFormer在编码阶段使用了<strong>卷积</strong>来生成<strong>Overlap Patch Embeddings</strong>。卷积操作自带局部的空间感知能力，因此它能在不同分辨率下自动调整，依旧保持对邻近像素关系的理解，不需要显式位置编码来帮助模型识别位置。</p></li><li><p><strong>层次化的特征提取</strong>：SegFormer通过层次结构逐级缩减特征图，提取不同分辨率的特征，从而保留了多尺度的空间信息。这种方式让模型在不依赖固定位置编码的情况下，也能从全局和局部两个层面理解图像的空间结构。</p></li></ol><p>因此，当图像的分辨率改变时，SegFormer可以自适应地调整，而不用像ViT那样需要重新插值位置编码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SegFormer避免了使用显式位置编码，所以在处理不同分辨率的图像时，不需要进行复杂的插值操作，原因主要是它通过&lt;strong&gt;卷积操作&lt;/strong&gt;和&lt;strong&gt;层次结构&lt;/strong&gt;来隐式地捕捉位置信息，而不是依赖于固定的、与图像分辨率相关的位置编码。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cookie和session</title>
    <link href="https://promptonce.github.io/2024/09/29/cookie%E5%92%8Csession/"/>
    <id>https://promptonce.github.io/2024/09/29/cookie%E5%92%8Csession/</id>
    <published>2024-09-28T16:46:21.000Z</published>
    <updated>2024-09-28T16:55:39.607Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Cookie</strong> 和 <strong>Session</strong> 是两种在网络请求中用来存储用户数据的机制。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li>当你第一次访问某个网站时，服务器会把一些数据（叫做 Cookie）发到你的浏览器。</li><li>之后，每次你访问这个网站时，浏览器都会把这些 Cookie 发回给服务器。</li><li>Cookie 主要存储在本地电脑中，并且有大小限制，一般不能超过 4KB。</li><li>Cookie的保存形式分为会话Cookie和持久Cookie</li></ul><p><strong>会话 Cookie</strong> 和 <strong>持久 Cookie</strong> 的区别就在于它们的<strong>有效期</strong>和<strong>存储位置</strong>。</p><ol><li><p><strong>会话 Cookie</strong>（Session Cookie）：</p><ul><li>只在<strong>当前会话</strong>（即浏览器打开的这段时间）内有效。</li><li>当你关闭浏览器后，会话 Cookie 就会被自动删除。</li><li>会话 Cookie 主要用于临时信息存储，比如登录状态，关掉浏览器后就不再保存这些信息了。</li></ul></li><li><p><strong>持久 Cookie</strong>（Persistent Cookie）：</p><ul><li>它有明确的<strong>过期时间</strong>，可以在浏览器关闭后仍然保留，直到到达设定的过期时间或用户手动删除它。</li><li>持久 Cookie 常用于存储长期信息，比如网站的自动登录功能、用户偏好设置等。</li></ul></li></ol><p>总结就是：<strong>会话 Cookie</strong> 随浏览器关闭而消失，而 <strong>持久 Cookie</strong> 会保留到指定时间或被用户手动删除。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul><li>Session 是一种存储在服务器端的机制，它保存的是用户的会话信息。</li><li>当你登录某个网站后，服务器会生成一个 Session，保存你的登录状态等信息。之后每次你访问网站，服务器会根据你带上的 Cookie 来识别你，并找到对应的 Session 来确认你是谁。</li><li>Session 没有大小限制，但它会占用服务器的资源。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>Cookie 存在你的浏览器里，而 Session 存在服务器端。</li><li>Cookie 有大小和存储时间的限制，而 Session 通常没有这些限制。</li></ul><h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><ul><li><strong>Cookie</strong> 比较方便，因为它存储在本地。但不太安全，容易被恶意利用。</li><li><strong>Session</strong> 更安全，但需要服务器资源。</li></ul><h3 id="SSO（单点登录）"><a href="#SSO（单点登录）" class="headerlink" title="SSO（单点登录）"></a>SSO（单点登录）</h3><ul><li>SSO 就是让你只需要登录一次，就能访问多个系统。这对于使用多个系统的环境非常方便。</li></ul><p>SSO的优点<br>降低访问第三⽅⽹站风险（⽤户密码不存储或外部管理）；<br>从不同的⽤户名和密码的组合减少密码疲劳；<br>减少花费的时间重新输⼊密码相同的⾝份；<br>降低IT成本适当降低⼀些IT帮助台调⽤有关密码；<br>SSO集中的所有其他应⽤程序和系统，⽤于⾝份验证服务器的⾝份验证，并与技术相结合是为了确保⽤户不必主动输⼊凭据⼀次以上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Cookie&lt;/strong&gt; 和 &lt;strong&gt;Session&lt;/strong&gt; 是两种在网络请求中用来存储用户数据的机制。&lt;/p&gt;
&lt;h3 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>在浏览器中输入网址后发生了什么</title>
    <link href="https://promptonce.github.io/2024/09/29/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://promptonce.github.io/2024/09/29/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2024-09-28T16:22:39.000Z</published>
    <updated>2024-09-29T07:29:29.209Z</updated>
    
    <content type="html"><![CDATA[<p>当在浏览器中输入一个网址并按下回车键后，大致发生了以下几个步骤：</p><img src="/2024/09/29/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E2%BC%8A%E2%BD%B9%E5%9D%80%E5%90%8E%E5%8F%91%E2%BD%A3%E4%BA%86%E4%BB%80%E4%B9%88.png" class="" title="在浏览器中输入网址后发生了什么"><ol><li><strong>解析URL</strong>：浏览器会分析你输入的网址，把它分解成协议（如http或https）、域名（如example.com）等部分。</li><li><strong>生成HTTP请求</strong>：浏览器会根据解析好的网址，生成一个HTTP请求，准备向服务器获取网页内容。</li><li><strong>DNS查询</strong>：浏览器接着会向DNS服务器查询你输入的域名对应的IP地址，以便找到具体的服务器位置。</li><li><strong>与服务器建立连接</strong>：获取到IP地址后，浏览器会与目标服务器建立连接（如果是https，还会进行加密连接的建立）。</li><li><strong>发送HTTP请求</strong>：浏览器将之前生成的HTTP请求发给服务器，请求获取网页资源。</li><li><strong>服务器响应</strong>：服务器收到请求后，返回对应的网页数据（如HTML、CSS、图片等）。</li><li><strong>渲染网页</strong>：浏览器接收服务器的响应数据后，开始解析和渲染网页，将它显示在屏幕上。</li></ol><p>这些步骤迅速而连续地发生，最终会看到想要的网页。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当在浏览器中输入一个网址并按下回车键后，大致发生了以下几个步骤：&lt;/p&gt;
&lt;img src=&quot;/2024/09/29/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OSI七层模型</title>
    <link href="https://promptonce.github.io/2024/09/28/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>https://promptonce.github.io/2024/09/28/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-09-28T15:30:59.000Z</published>
    <updated>2024-09-28T15:42:41.755Z</updated>
    
    <content type="html"><![CDATA[<p>OSI七层模型是一种网络通讯的规则框架，它把数据传输分成了七个步骤，帮助不同的设备之间进行通信。这七个步骤（或层）分别是：</p><img src="/2024/09/28/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" class="" title="OSI七层模型"><ol><li><strong>物理层</strong>：就是各种硬件的物理连接，如网线、光纤等，它主要负责把0和1这些数字信号在设备之间传输。</li><li><strong>数据链路层</strong>：负责数据传输的准确性，确保数据不会出错，并规定如何进行数据的基本传输方式。</li><li><strong>网络层</strong>：决定数据通过网络的路径，让数据能从一个设备顺利到达另一个设备，常用的协议如IP就是在这一层。</li><li><strong>传输层</strong>：确保数据能完整无误地传到对方。常见的协议有TCP（可靠传输）和UDP（快速传输）。</li><li><strong>会话层</strong>：控制两台设备之间的通信会话，确保数据的连续性，比如什么时候开始传输，什么时候结束。</li><li><strong>表示层</strong>：对数据进行转换或加密，确保数据能被设备理解，比如文件的压缩和解压。</li><li><strong>应用层</strong>：直接跟用户打交道，比如我们上网时用的浏览器或者收发邮件的软件就是应用层的一部分。</li></ol><p>简单来说，OSI模型就是让不同设备可以按步骤有序地进行信息交流的一种规则。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;OSI七层模型是一种网络通讯的规则框架，它把数据传输分成了七个步骤，帮助不同的设备之间进行通信。这七个步骤（或层）分别是：&lt;/p&gt;
&lt;img src=&quot;/2024/09/28/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/OSI%E4%B8</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript字典序比较</title>
    <link href="https://promptonce.github.io/2024/09/28/JavaScript%E5%AD%97%E5%85%B8%E5%BA%8F%E6%AF%94%E8%BE%83/"/>
    <id>https://promptonce.github.io/2024/09/28/JavaScript%E5%AD%97%E5%85%B8%E5%BA%8F%E6%AF%94%E8%BE%83/</id>
    <published>2024-09-28T08:26:01.000Z</published>
    <updated>2024-09-28T08:28:37.999Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/HappyRocking/article/details/83619392">字典序算法详解</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strCode = <span class="keyword">function</span>(<span class="params">s</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> tokens = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(tokens.<span class="property">length</span> === <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="string">&#x27;z&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) - tokens[<span class="number">0</span>].<span class="title function_">charCodeAt</span>(<span class="number">0</span>)) * (<span class="number">10</span> ** <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = tokens.<span class="property">length</span> - <span class="number">1</span>, j = <span class="number">1</span>; i &gt; <span class="number">0</span> ; i--,j++)&#123;</span><br><span class="line">result += (<span class="string">&#x27;z&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) - tokens[i].<span class="title function_">charCodeAt</span>(<span class="number">0</span>)) * (<span class="number">10</span> ** j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compareStrings_</span>(<span class="params">s1, s2</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> tokens1 = s1.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> tokens2 = s2.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tokens1.<span class="property">length</span>; i++)&#123;</span><br><span class="line">tokens1[i] = tokens1[i].<span class="title function_">charCodeAt</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tokens2.<span class="property">length</span>; i++)&#123;</span><br><span class="line">tokens2[i] = tokens2[i].<span class="title function_">charCodeAt</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> minLen = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tokens1.<span class="property">length</span> &lt; tokens2.<span class="property">length</span>)&#123;</span><br><span class="line">minLen = tokens1.<span class="property">length</span>;</span><br><span class="line">result = -<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens1.<span class="property">length</span> &gt; tokens2.<span class="property">length</span>)&#123;</span><br><span class="line">minLen = tokens2.<span class="property">length</span>;</span><br><span class="line">result = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">minLen = tokens1.<span class="property">length</span>;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console.log(tokens1,tokens2,minLen,result)</span></span><br><span class="line"><span class="comment">//双指针比较</span></span><br><span class="line"><span class="keyword">let</span> pointer1 = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> pointer2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(tokens1[<span class="number">0</span>] &gt; tokens2[<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens1[<span class="number">0</span>] === tokens2[<span class="number">0</span>])&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(tokens1[pointer1] === tokens2[pointer2])&#123;</span><br><span class="line">pointer1++;</span><br><span class="line">pointer2++;</span><br><span class="line"><span class="keyword">if</span>(tokens1[pointer1] &gt; tokens2[pointer2])&#123;</span><br><span class="line">result = <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tokens1[pointer1] &lt; tokens2[pointer2])&#123;</span><br><span class="line">result = -<span class="number">1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pointer1 === minLen || pointer2 === minLen)&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compareStrings</span>(<span class="params">s1, s2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="title function_">localeCompare</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomString</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> chars = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result += chars[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * chars.<span class="property">length</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testCompareFunctions</span>(<span class="params">iterations = <span class="number">1000</span>, maxStrLen = <span class="number">10</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> progressBarLength = <span class="number">50</span>; <span class="comment">// 进度条长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> len1 = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * maxStrLen) + <span class="number">1</span>; <span class="comment">// 随机生成字符串长度</span></span><br><span class="line">        <span class="keyword">const</span> len2 = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * maxStrLen) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> s1 = <span class="title function_">randomString</span>(len1); <span class="comment">// 随机生成第一个字符串</span></span><br><span class="line">        <span class="keyword">const</span> s2 = <span class="title function_">randomString</span>(len2); <span class="comment">// 随机生成第二个字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> result1 = <span class="title function_">compareStrings_</span>(s1, s2); <span class="comment">// 用自定义的 compareStrings_ 函数</span></span><br><span class="line">        <span class="keyword">const</span> result2 = <span class="title function_">compareStrings</span>(s1, s2);  <span class="comment">// 用内置的 localeCompare 函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 localeCompare 的结果标准化为 -1, 0, 1 以进行比较</span></span><br><span class="line">        <span class="keyword">const</span> normalizedResult2 = result2 === <span class="number">0</span> ? <span class="number">0</span> : (result2 &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result1 !== normalizedResult2) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Test failed for inputs: &quot;<span class="subst">$&#123;s1&#125;</span>&quot; and &quot;<span class="subst">$&#123;s2&#125;</span>&quot;`</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`compareStrings_ result: <span class="subst">$&#123;result1&#125;</span>`</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`localeCompare result: <span class="subst">$&#123;normalizedResult2&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 一旦发现不一致，停止测试并打印错误信息</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进度条每隔一定的迭代次数更新</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="title class_">Math</span>.<span class="title function_">floor</span>(iterations / <span class="number">100</span>) === <span class="number">0</span> || i === iterations - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> progress = (i / iterations) * <span class="number">100</span>; <span class="comment">// 计算百分比</span></span><br><span class="line">            <span class="keyword">const</span> progressChars = <span class="title class_">Math</span>.<span class="title function_">floor</span>((progress / <span class="number">100</span>) * progressBarLength); <span class="comment">// 进度条符号的数量</span></span><br><span class="line">            <span class="keyword">const</span> progressBar = <span class="string">&#x27;=&#x27;</span>.<span class="title function_">repeat</span>(progressChars) + <span class="string">&#x27; &#x27;</span>.<span class="title function_">repeat</span>(progressBarLength - progressChars); <span class="comment">// 构建进度条</span></span><br><span class="line">            process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">`\r[<span class="subst">$&#123;progressBar&#125;</span>] <span class="subst">$&#123;progress.toFixed(<span class="number">2</span>)&#125;</span>%`</span>); <span class="comment">// \r 使光标回到行首，覆盖之前的输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\nAll tests passed!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testPerformance</span>(<span class="params">iterations = <span class="number">1000000</span>, maxStrLen = <span class="number">10</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> strings = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预生成随机字符串对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> len1 = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * maxStrLen) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> len2 = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * maxStrLen) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> s1 = <span class="title function_">randomString</span>(len1);</span><br><span class="line">        <span class="keyword">const</span> s2 = <span class="title function_">randomString</span>(len2);</span><br><span class="line">        strings.<span class="title function_">push</span>([s1, s2]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试自定义 compareStrings_ 的性能</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;Custom compareStrings_&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        <span class="title function_">compareStrings_</span>(strings[i][<span class="number">0</span>], strings[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;Custom compareStrings_&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试内置 localeCompare 的性能</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;Built-in localeCompare&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        strings[i][<span class="number">0</span>].<span class="title function_">localeCompare</span>(strings[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;Built-in localeCompare&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行测试</span></span><br><span class="line"><span class="title function_">testCompareFunctions</span>(<span class="number">1000</span>); <span class="comment">// 这里设置较小的迭代次数，方便观察进度</span></span><br><span class="line"><span class="comment">// 运行性能测试</span></span><br><span class="line"><span class="title function_">testPerformance</span>(<span class="number">1000</span>); <span class="comment">// 设置 1000 次测试</span></span><br><span class="line"><span class="comment">//[================================================= ] 99.90%</span></span><br><span class="line"><span class="comment">//All tests passed!</span></span><br><span class="line"><span class="comment">//Custom compareStrings_: 0.395ms</span></span><br><span class="line"><span class="comment">//Built-in localeCompare: 0.158ms</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/HappyRocking/article/details/83619392&quot;&gt;字典序算法详解&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手四次挥手</title>
    <link href="https://promptonce.github.io/2024/09/28/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://promptonce.github.io/2024/09/28/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2024-09-27T16:11:18.000Z</published>
    <updated>2024-09-28T16:39:33.851Z</updated>
    
    <content type="html"><![CDATA[<p>TCP的三次握手和四次挥手就是为确保数据可靠传输的一种机制。我们来简单讲一下：</p><h3 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h3><ol><li><strong>第一次握手</strong>：客户端发送一个SYN（同步序列编号）包，告诉服务器“我要开始连接，准备好了吗？”。</li><li><strong>第二次握手</strong>：服务器收到后，回复一个SYN（synchronize）+ACK（Acknowledgment）包，表示“我准备好了，咱们可以开始连接，但你要确认一下”。</li><li><strong>第三次握手</strong>：客户端收到后，回一个ACK包，表示“好的，我确认了，正式连接”。</li></ol><p>这样，三次握手后，双方建立了可靠连接，开始数据传输。</p><h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><ol><li><strong>第一次挥手</strong>：客户端发送FIN（finish）包，表示“我不再传数据了，你准备断开吧”。</li><li><strong>第二次挥手</strong>：服务器收到后，回复ACK包，表示“我知道了，但我还有数据要发”。</li><li><strong>第三次挥手</strong>：服务器发FIN包，表示“我数据发完了，可以断开了”。</li><li><strong>第四次挥手</strong>：客户端收到后，发ACK包，表示“好的，断开吧”。</li></ol><p>这四次挥手确保数据完全发送并成功断开连接，避免信息丢失。</p><p>简单来说，三次握手建立连接，四次挥手安全断开，都是为确保数据传输完整性和可靠性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TCP的三次握手和四次挥手就是为确保数据可靠传输的一种机制。我们来简单讲一下：&lt;/p&gt;
&lt;h3 id=&quot;三次握手：&quot;&gt;&lt;a href=&quot;#三次握手：&quot; class=&quot;headerlink&quot; title=&quot;三次握手：&quot;&gt;&lt;/a&gt;三次握手：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;stro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>理解JavaScript中this的行为:普通函数vs箭头函数</title>
    <link href="https://promptonce.github.io/2024/09/27/%E7%90%86%E8%A7%A3JavaScript%E4%B8%ADthis%E7%9A%84%E8%A1%8C%E4%B8%BA-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0vs%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://promptonce.github.io/2024/09/27/%E7%90%86%E8%A7%A3JavaScript%E4%B8%ADthis%E7%9A%84%E8%A1%8C%E4%B8%BA-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0vs%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</id>
    <published>2024-09-27T06:47:09.000Z</published>
    <updated>2024-09-27T06:48:08.983Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中，<code>this</code> 是一个非常重要但也容易引起混淆的概念。特别是在普通函数和箭头函数之间，<code>this</code> 的行为有着显著的区别。在这篇文章中，我们将通过一个代码示例，深入理解 <code>this</code> 在不同场景下的指向。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">fn1</span>: fn1,</span><br><span class="line">  <span class="attr">fn2</span>: fn2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn1</span>();       <span class="comment">// 输出: 1</span></span><br><span class="line"><span class="title function_">fn2</span>();       <span class="comment">// 输出: 1</span></span><br><span class="line">obj.<span class="title function_">fn1</span>();   <span class="comment">// 输出: 10</span></span><br><span class="line">obj.<span class="title function_">fn2</span>();   <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><p>让我们逐行解析这段代码，弄清楚为什么会得到这样的输出。</p><hr><h3 id="全局变量-a"><a href="#全局变量-a" class="headerlink" title="全局变量 a"></a>全局变量 <code>a</code></h3><p>首先，我们定义了一个全局变量 <code>a</code>，并赋值为 <code>1</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在浏览器环境中，使用 <code>var</code> 声明的全局变量会成为 <code>window</code> 对象的属性。所以此时，<code>window.a</code> 的值为 <code>1</code>。</p><hr><h3 id="普通函数-fn1"><a href="#普通函数-fn1" class="headerlink" title="普通函数 fn1"></a>普通函数 <code>fn1</code></h3><p>接下来定义了一个普通函数 <code>fn1</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JavaScript 中，普通函数的 <code>this</code> 指向取决于它被调用的上下文。也就是说，谁调用了这个函数，<code>this</code> 就会指向谁。</p><hr><h3 id="箭头函数-fn2"><a href="#箭头函数-fn2" class="headerlink" title="箭头函数 fn2"></a>箭头函数 <code>fn2</code></h3><p>然后，我们定义了一个箭头函数 <code>fn2</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与普通函数不同，箭头函数不会绑定自己的 <code>this</code>。它会继承定义时所在的上下文的 <code>this</code> 值。因此，<code>fn2</code> 的 <code>this</code> 始终是它在定义时的环境中的 <code>this</code>。</p><hr><h3 id="定义对象-obj"><a href="#定义对象-obj" class="headerlink" title="定义对象 obj"></a>定义对象 <code>obj</code></h3><p>我们定义了一个对象 <code>obj</code>，包含属性 <code>a</code> 和两个方法 <code>fn1</code>、<code>fn2</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">fn1</span>: fn1,</span><br><span class="line">  <span class="attr">fn2</span>: fn2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>a</code> 是对象 <code>obj</code> 的属性，而 <code>fn1</code> 和 <code>fn2</code> 分别引用前面定义的普通函数和箭头函数。</p><hr><h3 id="函数调用分析"><a href="#函数调用分析" class="headerlink" title="函数调用分析"></a>函数调用分析</h3><h4 id="1-调用-fn1"><a href="#1-调用-fn1" class="headerlink" title="1. 调用 fn1()"></a>1. 调用 <code>fn1()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn1</span>();  <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><p>这是直接调用 <code>fn1</code>。由于 <code>fn1</code> 是在全局作用域中调用的，因此它的 <code>this</code> 默认指向全局对象 <code>window</code>。于是 <code>this.a</code> 相当于 <code>window.a</code>，它的值为 <code>1</code>。</p><h4 id="2-调用-fn2"><a href="#2-调用-fn2" class="headerlink" title="2. 调用 fn2()"></a>2. 调用 <code>fn2()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn2</span>();  <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><p><code>fn2</code> 是一个箭头函数。箭头函数的 <code>this</code> 是在定义时决定的。在这里，<code>fn2</code> 是在全局作用域中定义的，因此它的 <code>this</code> 也是指向全局对象 <code>window</code>，所以输出的 <code>this.a</code> 也是 <code>1</code>。</p><h4 id="3-调用-obj-fn1"><a href="#3-调用-obj-fn1" class="headerlink" title="3. 调用 obj.fn1()"></a>3. 调用 <code>obj.fn1()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="title function_">fn1</span>();  <span class="comment">// 输出: 10</span></span><br></pre></td></tr></table></figure><p>这次调用 <code>fn1</code> 是通过对象 <code>obj</code> 来进行的。在这种情况下，<code>this</code> 指向调用函数的对象 <code>obj</code>，所以 <code>this.a</code> 实际上是 <code>obj.a</code>，即 <code>10</code>。</p><h4 id="4-调用-obj-fn2"><a href="#4-调用-obj-fn2" class="headerlink" title="4. 调用 obj.fn2()"></a>4. 调用 <code>obj.fn2()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="title function_">fn2</span>();  <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><p>虽然 <code>fn2</code> 是通过对象 <code>obj</code> 调用的，但由于 <code>fn2</code> 是箭头函数，它的 <code>this</code> 并不会被调用方式所影响。<code>fn2</code> 的 <code>this</code> 是在定义时就已经决定了的，它指向全局对象 <code>window</code>，因此 <code>this.a</code> 仍然是 <code>window.a</code>，值为 <code>1</code>。</p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过这个例子，我们可以清楚地看到 JavaScript 中 <code>this</code> 的不同表现：</p><ol><li><strong>普通函数</strong>：<code>this</code> 的指向取决于它的调用方式。谁调用了这个函数，<code>this</code> 就指向谁。</li><li><strong>箭头函数</strong>：<code>this</code> 不会绑定调用时的对象，而是继承自定义时的上下文 <code>this</code>。</li></ol><h4 id="执行结果总结："><a href="#执行结果总结：" class="headerlink" title="执行结果总结："></a>执行结果总结：</h4><ul><li><code>fn1()</code> 输出 <code>1</code>：普通函数，在全局作用域中调用，<code>this</code> 指向 <code>window</code>。</li><li><code>fn2()</code> 输出 <code>1</code>：箭头函数，继承全局 <code>this</code>，所以输出 <code>window.a</code>。</li><li><code>obj.fn1()</code> 输出 <code>10</code>：普通函数，通过对象调用，<code>this</code> 指向 <code>obj</code>。</li><li><code>obj.fn2()</code> 输出 <code>1</code>：箭头函数，依旧继承定义时的 <code>this</code>，输出 <code>window.a</code>。</li></ul><hr><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在 JavaScript 中，理解 <code>this</code> 的指向对于编写和调试代码非常重要。普通函数的 <code>this</code> 根据调用方式而变化，而箭头函数的 <code>this</code> 是固定的。掌握了这些规则，可以帮助我们更好地编写和调试代码，避免 <code>this</code> 指向错误带来的困扰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 JavaScript 中，&lt;code&gt;this&lt;/code&gt; 是一个非常重要但也容易引起混淆的概念。特别是在普通函数和箭头函数之间，&lt;code&gt;this&lt;/code&gt; 的行为有着显著的区别。在这篇文章中，我们将通过一个代码示例，深入理解 &lt;code&gt;this&lt;/code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PNG图片格式总结</title>
    <link href="https://promptonce.github.io/2024/09/26/PNG%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/09/26/PNG%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/</id>
    <published>2024-09-26T11:25:28.000Z</published>
    <updated>2024-09-27T16:12:44.072Z</updated>
    
    <content type="html"><![CDATA[<p>PNG有RGBA模式和RGB模式，灰度模式和调色板索引模式<br>PNG可以实现无损压缩</p><h3 id="1-灰度模式（Grayscale-Mode）"><a href="#1-灰度模式（Grayscale-Mode）" class="headerlink" title="1. 灰度模式（Grayscale Mode）"></a>1. <strong>灰度模式（Grayscale Mode）</strong></h3><p>灰度模式表示图像中的每个像素只有亮度信息，而没有颜色信息。简单来说，灰度图像只有黑白两种颜色的不同程度，从完全黑到完全白，中间有多个灰色渐变。</p><ul><li><p><strong>灰度模式的特点</strong>：</p><ul><li>每个像素只使用一个数值（通常是 8 位，范围从 0 到 255）来表示亮度。值为 0 表示完全黑，255 表示完全白。</li><li>与彩色图像相比，灰度图像占用的存储空间更少，因为它不需要存储红、绿、蓝三种颜色信息。</li></ul></li><li><p><strong>应用场景</strong>：灰度模式常用于黑白照片、扫描的文本图像，以及不需要颜色信息的其他图像。</p></li></ul><h3 id="2-调色板索引模式（Palette-Indexed-Mode）"><a href="#2-调色板索引模式（Palette-Indexed-Mode）" class="headerlink" title="2. 调色板索引模式（Palette-Indexed Mode）"></a>2. <strong>调色板索引模式（Palette-Indexed Mode）</strong></h3><p>调色板索引模式（有时也叫索引颜色模式）是一种节省存储空间的颜色表示方式，尤其适用于颜色数量有限的图像。在这种模式下，图像并不直接存储每个像素的颜色值，而是存储一个“索引”，这个索引指向调色板中的具体颜色。</p><ul><li><p><strong>调色板索引模式的特点</strong>：</p><ul><li>图像的颜色信息被限制在一个调色板中，调色板通常最多包含 256 种颜色（8 位索引），每个颜色索引对应具体的 RGB 颜色。</li><li>每个像素只保存颜色索引，而不是直接的颜色值。这种方式可以极大地减少图像文件的大小，尤其是在图像颜色数量较少的情况下。</li></ul></li><li><p><strong>应用场景</strong>：调色板索引模式常用于网页图像、简单的图标、GIF 动画等场景，特别是颜色变化不多的图像。例如，简单的卡通画、徽标或按钮图像。</p></li></ul><h3 id="灰度模式-vs-调色板索引模式："><a href="#灰度模式-vs-调色板索引模式：" class="headerlink" title="灰度模式 vs 调色板索引模式："></a><strong>灰度模式 vs 调色板索引模式</strong>：</h3><ul><li><strong>灰度模式</strong>：适合只有亮度变化的黑白图像，每个像素记录的是亮度信息。</li><li><strong>调色板索引模式</strong>：适合颜色有限的图像，通过索引值指向调色板中的颜色，节省存储空间。</li></ul><p>总的来说，这两种模式都是为了减少图像的存储需求而设计的，但应用场景有所不同。灰度模式用于单色图像，而调色板索引模式则用于有限颜色的彩色图像。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PNG有RGBA模式和RGB模式，灰度模式和调色板索引模式&lt;br&gt;PNG可以实现无损压缩&lt;/p&gt;
&lt;h3 id=&quot;1-灰度模式（Grayscale-Mode）&quot;&gt;&lt;a href=&quot;#1-灰度模式（Grayscale-Mode）&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo部署静态资源到github服务器</title>
    <link href="https://promptonce.github.io/2024/09/25/hexo%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%88%B0github%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://promptonce.github.io/2024/09/25/hexo%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%88%B0github%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2024-09-24T16:41:28.000Z</published>
    <updated>2024-09-29T15:38:20.727Z</updated>
    
    <content type="html"><![CDATA[<p>hexo d失败可以用git clone github仓库地址然后用hexo public目录替换后使用授权github仓库账号执行git push操作替代hexo d</p><blockquote><p>fatal: bad tree object 76efcae7c5c88277bd54626c763b790961115445<br>fatal: the remote end hung up unexpectedly<br>send-pack: unexpected disconnect while reading sideband packet<br>fatal: the remote end hung up unexpectedly<br>error: failed to push some refs to ‘<a href="https://xxx.git/">https://xxx.git</a>‘<br>FATAL Something’s wrong. Maybe you can find the solution here: <a href="https://hexo.io/docs/troubleshooting.html">https://hexo.io/docs/troubleshooting.html</a><br>Error: Spawn failed<br>    at ChildProcess.<anonymous> (D:\promptonce-blog\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:51:21)<br>    at ChildProcess.emit (node:events:519:28)<br>    at cp.emit (D:\promptonce-blog\node_modules\cross-spawn\lib\enoent.js:34:29)<br>    at ChildProcess._handle.onexit (node:internal&#x2F;child_process:294:12)</p></blockquote><p>清空public目录下的文件<br>克隆托管hexo博客的github仓库，将除.git的文件及目录复制到public目录中<br>将原来根目录的.git目录删掉<br>将克隆下来的目录的.git移动到根目录<br>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hexo d失败可以用git clone github仓库地址然后用hexo public目录替换后使用授权github仓库账号执行git push操作替代hexo d&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;fatal: bad tree object 76efcae7c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MMSegmentation实验结果保存命名格式总结</title>
    <link href="https://promptonce.github.io/2024/09/23/MMSegmentation%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E5%91%BD%E5%90%8D%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/09/23/MMSegmentation%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E5%91%BD%E5%90%8D%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/</id>
    <published>2024-09-23T11:39:27.000Z</published>
    <updated>2024-09-23T11:42:35.194Z</updated>
    
    <content type="html"><![CDATA[<p>日期_模型名_骨干网络_其他重要参数_训练步骤_批次大小_目标尺寸</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;日期_模型名_骨干网络_其他重要参数_训练步骤_批次大小_目标尺寸&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GPT时代的程序员生存之道</title>
    <link href="https://promptonce.github.io/2024/09/22/GPT%E6%97%B6%E4%BB%A3%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9F%E5%AD%98%E4%B9%8B%E9%81%93/"/>
    <id>https://promptonce.github.io/2024/09/22/GPT%E6%97%B6%E4%BB%A3%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9F%E5%AD%98%E4%B9%8B%E9%81%93/</id>
    <published>2024-09-22T11:07:41.000Z</published>
    <updated>2024-09-22T11:08:28.754Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.aliyun.com/article/1205402">GPT时代的程序员生存之道</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/article/1205402&quot;&gt;GPT时代的程序员生存之道&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>promise出现的原因和promise方法</title>
    <link href="https://promptonce.github.io/2024/09/22/promise%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8Cpromise%E6%96%B9%E6%B3%95/"/>
    <id>https://promptonce.github.io/2024/09/22/promise%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8Cpromise%E6%96%B9%E6%B3%95/</id>
    <published>2024-09-22T06:25:20.000Z</published>
    <updated>2024-09-27T06:31:32.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Promise出现的原因"><a href="#一、Promise出现的原因" class="headerlink" title="一、Promise出现的原因"></a>一、Promise出现的原因</h3><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在JavaScript中，异步编程是非常常见的需求，例如处理网络请求、文件读取、定时操作等。在早期，我们通常使用回调函数（callback）来处理异步操作，但随着代码复杂度的增加，回调函数的使用也带来了一些问题，例如：</p><ol><li><p><strong>回调地狱（Callback Hell）</strong>：<br>当多个异步操作需要按顺序执行时，回调函数会嵌套得非常深，导致代码难以阅读和维护。</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncOperation1</span>(<span class="keyword">function</span>(<span class="params">result1</span>) &#123;</span><br><span class="line">    <span class="title function_">asyncOperation2</span>(result1, <span class="keyword">function</span>(<span class="params">result2</span>) &#123;</span><br><span class="line">        <span class="title function_">asyncOperation3</span>(result2, <span class="keyword">function</span>(<span class="params">result3</span>) &#123;</span><br><span class="line">            <span class="comment">// 继续嵌套</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>错误处理复杂</strong>：<br>每个回调函数都需要单独处理错误，这使得代码更为冗长且不易统一管理。</p></li></ol><h3 id="Promise的引入"><a href="#Promise的引入" class="headerlink" title="Promise的引入"></a>Promise的引入</h3><p>为了解决这些问题，ECMAScript 6（ES6）引入了Promise。Promise是一种用于管理异步操作的对象，提供了一种更为清晰和强大的方式来处理异步代码。</p><h3 id="二、Promise的基本方法和用法"><a href="#二、Promise的基本方法和用法" class="headerlink" title="二、Promise的基本方法和用法"></a>二、Promise的基本方法和用法</h3><h3 id="1-创建一个Promise"><a href="#1-创建一个Promise" class="headerlink" title="1. 创建一个Promise"></a>1. 创建一个Promise</h3><p>你可以通过<code>new Promise</code>来创建一个Promise对象。它接受一个执行函数（executor），该函数有两个参数：<code>resolve</code>和<code>reject</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="keyword">let</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;操作成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-使用Promise"><a href="#2-使用Promise" class="headerlink" title="2. 使用Promise"></a>2. 使用Promise</h3><p>Promise对象有三个主要方法：<code>then</code>、<code>catch</code>和<code>finally</code>，用于处理异步操作的结果。</p><ul><li><p><strong>then</strong>：用于处理成功的结果。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 操作成功</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>catch</strong>：用于处理失败的结果。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error); <span class="comment">// 操作失败</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>finally</strong>：无论Promise成功还是失败，最终都会执行的代码。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">finally</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;操作完成&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-链式调用"><a href="#3-链式调用" class="headerlink" title="3. 链式调用"></a>3. 链式调用</h3><p>Promise可以通过链式调用的方式来简化异步操作的串联，避免回调地狱。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncOperation1</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result1</span> =&gt;</span> <span class="title function_">asyncOperation2</span>(result1))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result2</span> =&gt;</span> <span class="title function_">asyncOperation3</span>(result2))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result3</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理最终结果</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 统一处理错误</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-常见的Promise方法"><a href="#4-常见的Promise方法" class="headerlink" title="4. 常见的Promise方法"></a>4. 常见的Promise方法</h3><ul><li><p><strong>Promise.all</strong>：接收一个包含多个Promise的数组，只有当所有Promise都成功时，才会执行<code>then</code>，否则执行<code>catch</code>。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, promise3])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 所有Promise都成功</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 任意一个Promise失败</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>Promise.race</strong>：接收一个包含多个Promise的数组，只要有一个Promise成功或失败，就立即执行相应的<code>then</code>或<code>catch</code>。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1, promise2, promise3])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个成功的Promise</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个失败的Promise</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Promise提供了一种更为优雅和简洁的方式来处理JavaScript中的异步操作，解决了回调函数嵌套和错误处理复杂的问题。理解和掌握Promise对现代JavaScript编程至关重要。</p><p>Promise 的状态一旦确定（resolved 或 rejected），就无法更改。<br>同步代码先执行，Promise 回调是异步的，会在同步代码执行完毕后再执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">reject</span>();</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p> 输出<br> 1<br> 4<br> 3</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、Promise出现的原因&quot;&gt;&lt;a href=&quot;#一、Promise出现的原因&quot; class=&quot;headerlink&quot; title=&quot;一、Promise出现的原因&quot;&gt;&lt;/a&gt;一、Promise出现的原因&lt;/h3&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为何要将产品当成自己的孩子？</title>
    <link href="https://promptonce.github.io/2024/09/20/%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B0%86%E4%BA%A7%E5%93%81%E5%BD%93%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A9%E5%AD%90%EF%BC%9F/"/>
    <id>https://promptonce.github.io/2024/09/20/%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B0%86%E4%BA%A7%E5%93%81%E5%BD%93%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A9%E5%AD%90%EF%BC%9F/</id>
    <published>2024-09-20T05:39:23.000Z</published>
    <updated>2024-09-20T05:39:23.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>只追求广度是不行的，光有广度不代表就有很强的判断力</p></blockquote><blockquote><p>如果学的是是技术的经典理论的话，那么毫无疑问是学的多更好，前提是能够学懂学好。如果是学习技术应用的话，需要知道的是应用是基于底层技术的上层建筑，如果从底层技术的角度分析，那么大多数技术应用在技术底层是同质化严重的，如果沉迷于学的多，对于通过项目来引导理论学习的人来说，可能会无法触及的更深层次的技术理论，从而在对技术的理解上显得局限，虽然这个和性格也有一定关系，但我认为软件工程师认真地学精可能比粗略地学广泛更有意义。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;只追求广度是不行的，光有广度不代表就有很强的判断力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果学的是是技术的经典理论的话，那么毫无疑问是学的多更好，前提是能够学懂学好。如果是学习技术应用的话，需要知道的是应用是基于底层</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://promptonce.github.io/2024/09/20/webpack/"/>
    <id>https://promptonce.github.io/2024/09/20/webpack/</id>
    <published>2024-09-20T05:38:02.000Z</published>
    <updated>2024-09-20T05:38:02.325Z</updated>
    
    <content type="html"><![CDATA[<p>Webpack 是一个强大的 <strong>模块打包工具</strong>，广泛应用于前端项目中。它的主要作用是将各种资源（JavaScript、CSS、图片等）当作模块进行处理，最后生成优化后的静态文件，提升项目的加载性能和开发体验。</p><p>简单来说，Webpack 可以将多个文件合并为一个或者多个<strong>打包文件</strong>，减少请求次数，提高性能，同时还能进行代码拆分、按需加载等优化。</p><h3 id="Webpack-的核心概念："><a href="#Webpack-的核心概念：" class="headerlink" title="Webpack 的核心概念："></a>Webpack 的核心概念：</h3><ol><li><p><strong>Entry（入口）</strong>：Webpack 从哪个文件开始进行打包。通常是你应用的主文件（例如 <code>index.js</code>），Webpack 会根据依赖关系递归解析所有依赖的模块。</p></li><li><p><strong>Output（输出）</strong>：打包后的文件输出到哪里，通常是一个目录下的某个文件，比如 <code>dist/main.js</code>。</p></li><li><p><strong>Loaders（加载器）</strong>：Webpack 本身只理解 JavaScript 文件，但通过加载器，你可以让它处理其他类型的文件，比如 CSS、图片、甚至 Sass 或 TypeScript 文件。</p></li><li><p><strong>Plugins（插件）</strong>：插件用于扩展 Webpack 的功能，比如压缩打包后的文件、注入环境变量、分离 CSS 等。</p></li><li><p><strong>Mode（模式）</strong>：Webpack 有 <code>development</code>（开发模式） 和 <code>production</code>（生产模式） 两种模式，开发模式注重调试和快速编译，而生产模式则侧重于优化性能，比如压缩代码、移除无用代码等。</p></li></ol><h3 id="Webpack-的使用流程："><a href="#Webpack-的使用流程：" class="headerlink" title="Webpack 的使用流程："></a>Webpack 的使用流程：</h3><ol><li><p><strong>安装 Webpack</strong>：在项目中通过 <code>npm</code> 安装 Webpack 和它的 CLI 工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure></li><li><p>**创建 <code>webpack.config.js</code>**：这是 Webpack 的配置文件，用于定义入口、输出、加载器和插件等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,  <span class="comment">// 入口文件</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,  <span class="comment">// 打包后的文件名</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),  <span class="comment">// 输出路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  <span class="comment">// 匹配所有的 CSS 文件</span></span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],  <span class="comment">// 使用两个加载器来处理 CSS</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,  <span class="comment">// 开发模式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>运行打包命令</strong>：在终端中运行 <code>npx webpack</code>，Webpack 会根据配置文件进行打包，输出最终文件到指定目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure></li></ol><h3 id="Webpack-的主要功能："><a href="#Webpack-的主要功能：" class="headerlink" title="Webpack 的主要功能："></a>Webpack 的主要功能：</h3><ol><li><p><strong>代码拆分（Code Splitting）</strong>：Webpack 支持将代码拆分成多个包（chunks），只在需要时加载，提升应用的加载速度。</p></li><li><p><strong>按需加载（Lazy Loading）</strong>：通过动态 <code>import()</code>，可以让某些模块在用户实际需要时才加载，这对大型应用非常有用。</p></li><li><p><strong>模块热替换（Hot Module Replacement, HMR）</strong>：在开发过程中，当代码修改时，Webpack 能让你不刷新整个页面而只替换修改的模块，从而提升开发效率。</p></li><li><p><strong>Tree Shaking</strong>：Webpack 能在打包时移除没有用到的代码（通常是未使用的 ES6 模块），从而减少打包文件的大小。</p></li><li><p><strong>兼容各种模块化方案</strong>：Webpack 支持 AMD、CommonJS、ES6 模块等各种模块化标准，并能将这些模块统一打包为一个文件。</p></li></ol><h3 id="Webpack-例子："><a href="#Webpack-例子：" class="headerlink" title="Webpack 例子："></a>Webpack 例子：</h3><p>假如你有一个项目使用了 CSS 和图片，你可以这样配置 Webpack 来处理这些资源：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">   <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">   <span class="attr">output</span>: &#123;</span><br><span class="line">       <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">       <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">module</span>: &#123;</span><br><span class="line">       <span class="attr">rules</span>: [</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  <span class="comment">// 处理 CSS 文件</span></span><br><span class="line">               <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,  <span class="comment">// 处理图片文件</span></span><br><span class="line">               <span class="attr">use</span>: [</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                       <span class="attr">options</span>: &#123;</span><br><span class="line">                           <span class="attr">name</span>: <span class="string">&#x27;[name].[hash].[ext]&#x27;</span>,  <span class="comment">// 输出文件名格式</span></span><br><span class="line">                           <span class="attr">outputPath</span>: <span class="string">&#x27;images&#x27;</span>,  <span class="comment">// 输出路径</span></span><br><span class="line">                       &#125;,</span><br><span class="line">                   &#125;,</span><br><span class="line">               ],</span><br><span class="line">           &#125;,</span><br><span class="line">       ],</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,  <span class="comment">// 生产模式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Webpack-的优点："><a href="#Webpack-的优点：" class="headerlink" title="Webpack 的优点："></a>Webpack 的优点：</h3><ol><li><p><strong>强大的模块打包能力</strong>：Webpack 支持将所有资源视作模块，统一进行管理，极大简化了前端开发流程。</p></li><li><p><strong>灵活的配置</strong>：无论是简单的单页面应用，还是复杂的多页面应用，Webpack 都可以通过配置来满足不同的需求。</p></li><li><p><strong>丰富的插件生态</strong>：通过 Webpack 插件，你可以扩展它的功能，比如压缩文件、生成 HTML 文件、分析打包结果等。</p></li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Webpack 是现代前端开发中最常用的构建工具之一，它可以将项目中的各种资源（JS、CSS、图片等）进行打包、优化，提升项目的性能和开发体验。它的强大之处在于高度可配置性和丰富的插件生态，能够满足从小型项目到大型复杂项目的各种需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Webpack 是一个强大的 &lt;strong&gt;模块打包工具&lt;/strong&gt;，广泛应用于前端项目中。它的主要作用是将各种资源（JavaScript、CSS、图片等）当作模块进行处理，最后生成优化后的静态文件，提升项目的加载性能和开发体验。&lt;/p&gt;
&lt;p&gt;简单来说，Webpa</summary>
      
    
    
    
    
  </entry>
  
</feed>
