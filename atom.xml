<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PromptOnce</title>
  
  
  <link href="https://promptonce.github.io/atom.xml" rel="self"/>
  
  <link href="https://promptonce.github.io/"/>
  <updated>2024-09-29T14:20:08.394Z</updated>
  <id>https://promptonce.github.io/</id>
  
  <author>
    <name>penggan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Segformer技术分析</title>
    <link href="https://promptonce.github.io/2024/09/29/Segformer%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/"/>
    <id>https://promptonce.github.io/2024/09/29/Segformer%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</id>
    <published>2024-09-29T09:24:15.000Z</published>
    <updated>2024-09-29T14:20:08.394Z</updated>
    
    <content type="html"><![CDATA[<p>SegFormer避免了使用显式位置编码，所以在处理不同分辨率的图像时，不需要进行复杂的插值操作，原因主要是它通过<strong>卷积操作</strong>和<strong>层次结构</strong>来隐式地捕捉位置信息，而不是依赖于固定的、与图像分辨率相关的位置编码。</p><p>在传统的Transformer模型（例如ViT）中，位置编码是为每个输入特征（如图像的每个patch）明确指定的位置信息。当分辨率改变时，patch的数量也会随之变化，模型无法直接理解新分辨率下的位置信息，因此需要对位置编码进行插值，让它适应新的patch数量和图像分辨率。这是一个复杂的过程，容易引入误差。</p><p>而<strong>SegFormer</strong>通过以下方式避免了这一问题：</p><ol><li><p><strong>卷积的局部感知特性</strong>：SegFormer在编码阶段使用了<strong>卷积</strong>来生成<strong>Overlap Patch Embeddings</strong>。卷积操作自带局部的空间感知能力，因此它能在不同分辨率下自动调整，依旧保持对邻近像素关系的理解，不需要显式位置编码来帮助模型识别位置。</p></li><li><p><strong>层次化的特征提取</strong>：SegFormer通过层次结构逐级缩减特征图，提取不同分辨率的特征，从而保留了多尺度的空间信息。这种方式让模型在不依赖固定位置编码的情况下，也能从全局和局部两个层面理解图像的空间结构。</p></li></ol><p>因此，当图像的分辨率改变时，SegFormer可以自适应地调整，而不用像ViT那样需要重新插值位置编码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SegFormer避免了使用显式位置编码，所以在处理不同分辨率的图像时，不需要进行复杂的插值操作，原因主要是它通过&lt;strong&gt;卷积操作&lt;/strong&gt;和&lt;strong&gt;层次结构&lt;/strong&gt;来隐式地捕捉位置信息，而不是依赖于固定的、与图像分辨率相关的位置编码。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cookie和session</title>
    <link href="https://promptonce.github.io/2024/09/29/cookie%E5%92%8Csession/"/>
    <id>https://promptonce.github.io/2024/09/29/cookie%E5%92%8Csession/</id>
    <published>2024-09-28T16:46:21.000Z</published>
    <updated>2024-09-28T16:55:39.607Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Cookie</strong> 和 <strong>Session</strong> 是两种在网络请求中用来存储用户数据的机制。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li>当你第一次访问某个网站时，服务器会把一些数据（叫做 Cookie）发到你的浏览器。</li><li>之后，每次你访问这个网站时，浏览器都会把这些 Cookie 发回给服务器。</li><li>Cookie 主要存储在本地电脑中，并且有大小限制，一般不能超过 4KB。</li><li>Cookie的保存形式分为会话Cookie和持久Cookie</li></ul><p><strong>会话 Cookie</strong> 和 <strong>持久 Cookie</strong> 的区别就在于它们的<strong>有效期</strong>和<strong>存储位置</strong>。</p><ol><li><p><strong>会话 Cookie</strong>（Session Cookie）：</p><ul><li>只在<strong>当前会话</strong>（即浏览器打开的这段时间）内有效。</li><li>当你关闭浏览器后，会话 Cookie 就会被自动删除。</li><li>会话 Cookie 主要用于临时信息存储，比如登录状态，关掉浏览器后就不再保存这些信息了。</li></ul></li><li><p><strong>持久 Cookie</strong>（Persistent Cookie）：</p><ul><li>它有明确的<strong>过期时间</strong>，可以在浏览器关闭后仍然保留，直到到达设定的过期时间或用户手动删除它。</li><li>持久 Cookie 常用于存储长期信息，比如网站的自动登录功能、用户偏好设置等。</li></ul></li></ol><p>总结就是：<strong>会话 Cookie</strong> 随浏览器关闭而消失，而 <strong>持久 Cookie</strong> 会保留到指定时间或被用户手动删除。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul><li>Session 是一种存储在服务器端的机制，它保存的是用户的会话信息。</li><li>当你登录某个网站后，服务器会生成一个 Session，保存你的登录状态等信息。之后每次你访问网站，服务器会根据你带上的 Cookie 来识别你，并找到对应的 Session 来确认你是谁。</li><li>Session 没有大小限制，但它会占用服务器的资源。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>Cookie 存在你的浏览器里，而 Session 存在服务器端。</li><li>Cookie 有大小和存储时间的限制，而 Session 通常没有这些限制。</li></ul><h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><ul><li><strong>Cookie</strong> 比较方便，因为它存储在本地。但不太安全，容易被恶意利用。</li><li><strong>Session</strong> 更安全，但需要服务器资源。</li></ul><h3 id="SSO（单点登录）"><a href="#SSO（单点登录）" class="headerlink" title="SSO（单点登录）"></a>SSO（单点登录）</h3><ul><li>SSO 就是让你只需要登录一次，就能访问多个系统。这对于使用多个系统的环境非常方便。</li></ul><p>SSO的优点<br>降低访问第三⽅⽹站风险（⽤户密码不存储或外部管理）；<br>从不同的⽤户名和密码的组合减少密码疲劳；<br>减少花费的时间重新输⼊密码相同的⾝份；<br>降低IT成本适当降低⼀些IT帮助台调⽤有关密码；<br>SSO集中的所有其他应⽤程序和系统，⽤于⾝份验证服务器的⾝份验证，并与技术相结合是为了确保⽤户不必主动输⼊凭据⼀次以上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Cookie&lt;/strong&gt; 和 &lt;strong&gt;Session&lt;/strong&gt; 是两种在网络请求中用来存储用户数据的机制。&lt;/p&gt;
&lt;h3 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>在浏览器中输入网址后发生了什么</title>
    <link href="https://promptonce.github.io/2024/09/29/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://promptonce.github.io/2024/09/29/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2024-09-28T16:22:39.000Z</published>
    <updated>2024-09-29T07:29:29.209Z</updated>
    
    <content type="html"><![CDATA[<p>当在浏览器中输入一个网址并按下回车键后，大致发生了以下几个步骤：</p><img src="/2024/09/29/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E2%BC%8A%E2%BD%B9%E5%9D%80%E5%90%8E%E5%8F%91%E2%BD%A3%E4%BA%86%E4%BB%80%E4%B9%88.png" class="" title="在浏览器中输入网址后发生了什么"><ol><li><strong>解析URL</strong>：浏览器会分析你输入的网址，把它分解成协议（如http或https）、域名（如example.com）等部分。</li><li><strong>生成HTTP请求</strong>：浏览器会根据解析好的网址，生成一个HTTP请求，准备向服务器获取网页内容。</li><li><strong>DNS查询</strong>：浏览器接着会向DNS服务器查询你输入的域名对应的IP地址，以便找到具体的服务器位置。</li><li><strong>与服务器建立连接</strong>：获取到IP地址后，浏览器会与目标服务器建立连接（如果是https，还会进行加密连接的建立）。</li><li><strong>发送HTTP请求</strong>：浏览器将之前生成的HTTP请求发给服务器，请求获取网页资源。</li><li><strong>服务器响应</strong>：服务器收到请求后，返回对应的网页数据（如HTML、CSS、图片等）。</li><li><strong>渲染网页</strong>：浏览器接收服务器的响应数据后，开始解析和渲染网页，将它显示在屏幕上。</li></ol><p>这些步骤迅速而连续地发生，最终会看到想要的网页。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当在浏览器中输入一个网址并按下回车键后，大致发生了以下几个步骤：&lt;/p&gt;
&lt;img src=&quot;/2024/09/29/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OSI七层模型</title>
    <link href="https://promptonce.github.io/2024/09/28/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <id>https://promptonce.github.io/2024/09/28/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-09-28T15:30:59.000Z</published>
    <updated>2024-09-28T15:42:41.755Z</updated>
    
    <content type="html"><![CDATA[<p>OSI七层模型是一种网络通讯的规则框架，它把数据传输分成了七个步骤，帮助不同的设备之间进行通信。这七个步骤（或层）分别是：</p><img src="/2024/09/28/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" class="" title="OSI七层模型"><ol><li><strong>物理层</strong>：就是各种硬件的物理连接，如网线、光纤等，它主要负责把0和1这些数字信号在设备之间传输。</li><li><strong>数据链路层</strong>：负责数据传输的准确性，确保数据不会出错，并规定如何进行数据的基本传输方式。</li><li><strong>网络层</strong>：决定数据通过网络的路径，让数据能从一个设备顺利到达另一个设备，常用的协议如IP就是在这一层。</li><li><strong>传输层</strong>：确保数据能完整无误地传到对方。常见的协议有TCP（可靠传输）和UDP（快速传输）。</li><li><strong>会话层</strong>：控制两台设备之间的通信会话，确保数据的连续性，比如什么时候开始传输，什么时候结束。</li><li><strong>表示层</strong>：对数据进行转换或加密，确保数据能被设备理解，比如文件的压缩和解压。</li><li><strong>应用层</strong>：直接跟用户打交道，比如我们上网时用的浏览器或者收发邮件的软件就是应用层的一部分。</li></ol><p>简单来说，OSI模型就是让不同设备可以按步骤有序地进行信息交流的一种规则。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;OSI七层模型是一种网络通讯的规则框架，它把数据传输分成了七个步骤，帮助不同的设备之间进行通信。这七个步骤（或层）分别是：&lt;/p&gt;
&lt;img src=&quot;/2024/09/28/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/OSI%E4%B8</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript字典序比较</title>
    <link href="https://promptonce.github.io/2024/09/28/JavaScript%E5%AD%97%E5%85%B8%E5%BA%8F%E6%AF%94%E8%BE%83/"/>
    <id>https://promptonce.github.io/2024/09/28/JavaScript%E5%AD%97%E5%85%B8%E5%BA%8F%E6%AF%94%E8%BE%83/</id>
    <published>2024-09-28T08:26:01.000Z</published>
    <updated>2024-09-28T08:28:37.999Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/HappyRocking/article/details/83619392">字典序算法详解</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strCode = <span class="keyword">function</span>(<span class="params">s</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> tokens = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(tokens.<span class="property">length</span> === <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="string">&#x27;z&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) - tokens[<span class="number">0</span>].<span class="title function_">charCodeAt</span>(<span class="number">0</span>)) * (<span class="number">10</span> ** <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = tokens.<span class="property">length</span> - <span class="number">1</span>, j = <span class="number">1</span>; i &gt; <span class="number">0</span> ; i--,j++)&#123;</span><br><span class="line">result += (<span class="string">&#x27;z&#x27;</span>.<span class="title function_">charCodeAt</span>(<span class="number">0</span>) - tokens[i].<span class="title function_">charCodeAt</span>(<span class="number">0</span>)) * (<span class="number">10</span> ** j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compareStrings_</span>(<span class="params">s1, s2</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> tokens1 = s1.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> tokens2 = s2.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tokens1.<span class="property">length</span>; i++)&#123;</span><br><span class="line">tokens1[i] = tokens1[i].<span class="title function_">charCodeAt</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tokens2.<span class="property">length</span>; i++)&#123;</span><br><span class="line">tokens2[i] = tokens2[i].<span class="title function_">charCodeAt</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> minLen = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tokens1.<span class="property">length</span> &lt; tokens2.<span class="property">length</span>)&#123;</span><br><span class="line">minLen = tokens1.<span class="property">length</span>;</span><br><span class="line">result = -<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens1.<span class="property">length</span> &gt; tokens2.<span class="property">length</span>)&#123;</span><br><span class="line">minLen = tokens2.<span class="property">length</span>;</span><br><span class="line">result = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">minLen = tokens1.<span class="property">length</span>;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//console.log(tokens1,tokens2,minLen,result)</span></span><br><span class="line"><span class="comment">//双指针比较</span></span><br><span class="line"><span class="keyword">let</span> pointer1 = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> pointer2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(tokens1[<span class="number">0</span>] &gt; tokens2[<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(tokens1[<span class="number">0</span>] === tokens2[<span class="number">0</span>])&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(tokens1[pointer1] === tokens2[pointer2])&#123;</span><br><span class="line">pointer1++;</span><br><span class="line">pointer2++;</span><br><span class="line"><span class="keyword">if</span>(tokens1[pointer1] &gt; tokens2[pointer2])&#123;</span><br><span class="line">result = <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tokens1[pointer1] &lt; tokens2[pointer2])&#123;</span><br><span class="line">result = -<span class="number">1</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pointer1 === minLen || pointer2 === minLen)&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compareStrings</span>(<span class="params">s1, s2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="title function_">localeCompare</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">randomString</span>(<span class="params">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> chars = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        result += chars[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * chars.<span class="property">length</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testCompareFunctions</span>(<span class="params">iterations = <span class="number">1000</span>, maxStrLen = <span class="number">10</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> progressBarLength = <span class="number">50</span>; <span class="comment">// 进度条长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> len1 = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * maxStrLen) + <span class="number">1</span>; <span class="comment">// 随机生成字符串长度</span></span><br><span class="line">        <span class="keyword">const</span> len2 = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * maxStrLen) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> s1 = <span class="title function_">randomString</span>(len1); <span class="comment">// 随机生成第一个字符串</span></span><br><span class="line">        <span class="keyword">const</span> s2 = <span class="title function_">randomString</span>(len2); <span class="comment">// 随机生成第二个字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> result1 = <span class="title function_">compareStrings_</span>(s1, s2); <span class="comment">// 用自定义的 compareStrings_ 函数</span></span><br><span class="line">        <span class="keyword">const</span> result2 = <span class="title function_">compareStrings</span>(s1, s2);  <span class="comment">// 用内置的 localeCompare 函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 localeCompare 的结果标准化为 -1, 0, 1 以进行比较</span></span><br><span class="line">        <span class="keyword">const</span> normalizedResult2 = result2 === <span class="number">0</span> ? <span class="number">0</span> : (result2 &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result1 !== normalizedResult2) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Test failed for inputs: &quot;<span class="subst">$&#123;s1&#125;</span>&quot; and &quot;<span class="subst">$&#123;s2&#125;</span>&quot;`</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`compareStrings_ result: <span class="subst">$&#123;result1&#125;</span>`</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`localeCompare result: <span class="subst">$&#123;normalizedResult2&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 一旦发现不一致，停止测试并打印错误信息</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进度条每隔一定的迭代次数更新</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="title class_">Math</span>.<span class="title function_">floor</span>(iterations / <span class="number">100</span>) === <span class="number">0</span> || i === iterations - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> progress = (i / iterations) * <span class="number">100</span>; <span class="comment">// 计算百分比</span></span><br><span class="line">            <span class="keyword">const</span> progressChars = <span class="title class_">Math</span>.<span class="title function_">floor</span>((progress / <span class="number">100</span>) * progressBarLength); <span class="comment">// 进度条符号的数量</span></span><br><span class="line">            <span class="keyword">const</span> progressBar = <span class="string">&#x27;=&#x27;</span>.<span class="title function_">repeat</span>(progressChars) + <span class="string">&#x27; &#x27;</span>.<span class="title function_">repeat</span>(progressBarLength - progressChars); <span class="comment">// 构建进度条</span></span><br><span class="line">            process.<span class="property">stdout</span>.<span class="title function_">write</span>(<span class="string">`\r[<span class="subst">$&#123;progressBar&#125;</span>] <span class="subst">$&#123;progress.toFixed(<span class="number">2</span>)&#125;</span>%`</span>); <span class="comment">// \r 使光标回到行首，覆盖之前的输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\nAll tests passed!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testPerformance</span>(<span class="params">iterations = <span class="number">1000000</span>, maxStrLen = <span class="number">10</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> strings = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预生成随机字符串对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> len1 = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * maxStrLen) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> len2 = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * maxStrLen) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">const</span> s1 = <span class="title function_">randomString</span>(len1);</span><br><span class="line">        <span class="keyword">const</span> s2 = <span class="title function_">randomString</span>(len2);</span><br><span class="line">        strings.<span class="title function_">push</span>([s1, s2]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试自定义 compareStrings_ 的性能</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;Custom compareStrings_&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        <span class="title function_">compareStrings_</span>(strings[i][<span class="number">0</span>], strings[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;Custom compareStrings_&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试内置 localeCompare 的性能</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&#x27;Built-in localeCompare&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; iterations; i++) &#123;</span><br><span class="line">        strings[i][<span class="number">0</span>].<span class="title function_">localeCompare</span>(strings[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&#x27;Built-in localeCompare&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行测试</span></span><br><span class="line"><span class="title function_">testCompareFunctions</span>(<span class="number">1000</span>); <span class="comment">// 这里设置较小的迭代次数，方便观察进度</span></span><br><span class="line"><span class="comment">// 运行性能测试</span></span><br><span class="line"><span class="title function_">testPerformance</span>(<span class="number">1000</span>); <span class="comment">// 设置 1000 次测试</span></span><br><span class="line"><span class="comment">//[================================================= ] 99.90%</span></span><br><span class="line"><span class="comment">//All tests passed!</span></span><br><span class="line"><span class="comment">//Custom compareStrings_: 0.395ms</span></span><br><span class="line"><span class="comment">//Built-in localeCompare: 0.158ms</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/HappyRocking/article/details/83619392&quot;&gt;字典序算法详解&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手四次挥手</title>
    <link href="https://promptonce.github.io/2024/09/28/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://promptonce.github.io/2024/09/28/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2024-09-27T16:11:18.000Z</published>
    <updated>2024-09-28T16:39:33.851Z</updated>
    
    <content type="html"><![CDATA[<p>TCP的三次握手和四次挥手就是为确保数据可靠传输的一种机制。我们来简单讲一下：</p><h3 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h3><ol><li><strong>第一次握手</strong>：客户端发送一个SYN（同步序列编号）包，告诉服务器“我要开始连接，准备好了吗？”。</li><li><strong>第二次握手</strong>：服务器收到后，回复一个SYN（synchronize）+ACK（Acknowledgment）包，表示“我准备好了，咱们可以开始连接，但你要确认一下”。</li><li><strong>第三次握手</strong>：客户端收到后，回一个ACK包，表示“好的，我确认了，正式连接”。</li></ol><p>这样，三次握手后，双方建立了可靠连接，开始数据传输。</p><h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><ol><li><strong>第一次挥手</strong>：客户端发送FIN（finish）包，表示“我不再传数据了，你准备断开吧”。</li><li><strong>第二次挥手</strong>：服务器收到后，回复ACK包，表示“我知道了，但我还有数据要发”。</li><li><strong>第三次挥手</strong>：服务器发FIN包，表示“我数据发完了，可以断开了”。</li><li><strong>第四次挥手</strong>：客户端收到后，发ACK包，表示“好的，断开吧”。</li></ol><p>这四次挥手确保数据完全发送并成功断开连接，避免信息丢失。</p><p>简单来说，三次握手建立连接，四次挥手安全断开，都是为确保数据传输完整性和可靠性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TCP的三次握手和四次挥手就是为确保数据可靠传输的一种机制。我们来简单讲一下：&lt;/p&gt;
&lt;h3 id=&quot;三次握手：&quot;&gt;&lt;a href=&quot;#三次握手：&quot; class=&quot;headerlink&quot; title=&quot;三次握手：&quot;&gt;&lt;/a&gt;三次握手：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;stro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>理解JavaScript中this的行为:普通函数vs箭头函数</title>
    <link href="https://promptonce.github.io/2024/09/27/%E7%90%86%E8%A7%A3JavaScript%E4%B8%ADthis%E7%9A%84%E8%A1%8C%E4%B8%BA-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0vs%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://promptonce.github.io/2024/09/27/%E7%90%86%E8%A7%A3JavaScript%E4%B8%ADthis%E7%9A%84%E8%A1%8C%E4%B8%BA-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0vs%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</id>
    <published>2024-09-27T06:47:09.000Z</published>
    <updated>2024-09-27T06:48:08.983Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中，<code>this</code> 是一个非常重要但也容易引起混淆的概念。特别是在普通函数和箭头函数之间，<code>this</code> 的行为有着显著的区别。在这篇文章中，我们将通过一个代码示例，深入理解 <code>this</code> 在不同场景下的指向。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">fn1</span>: fn1,</span><br><span class="line">  <span class="attr">fn2</span>: fn2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn1</span>();       <span class="comment">// 输出: 1</span></span><br><span class="line"><span class="title function_">fn2</span>();       <span class="comment">// 输出: 1</span></span><br><span class="line">obj.<span class="title function_">fn1</span>();   <span class="comment">// 输出: 10</span></span><br><span class="line">obj.<span class="title function_">fn2</span>();   <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><p>让我们逐行解析这段代码，弄清楚为什么会得到这样的输出。</p><hr><h3 id="全局变量-a"><a href="#全局变量-a" class="headerlink" title="全局变量 a"></a>全局变量 <code>a</code></h3><p>首先，我们定义了一个全局变量 <code>a</code>，并赋值为 <code>1</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在浏览器环境中，使用 <code>var</code> 声明的全局变量会成为 <code>window</code> 对象的属性。所以此时，<code>window.a</code> 的值为 <code>1</code>。</p><hr><h3 id="普通函数-fn1"><a href="#普通函数-fn1" class="headerlink" title="普通函数 fn1"></a>普通函数 <code>fn1</code></h3><p>接下来定义了一个普通函数 <code>fn1</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 JavaScript 中，普通函数的 <code>this</code> 指向取决于它被调用的上下文。也就是说，谁调用了这个函数，<code>this</code> 就会指向谁。</p><hr><h3 id="箭头函数-fn2"><a href="#箭头函数-fn2" class="headerlink" title="箭头函数 fn2"></a>箭头函数 <code>fn2</code></h3><p>然后，我们定义了一个箭头函数 <code>fn2</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与普通函数不同，箭头函数不会绑定自己的 <code>this</code>。它会继承定义时所在的上下文的 <code>this</code> 值。因此，<code>fn2</code> 的 <code>this</code> 始终是它在定义时的环境中的 <code>this</code>。</p><hr><h3 id="定义对象-obj"><a href="#定义对象-obj" class="headerlink" title="定义对象 obj"></a>定义对象 <code>obj</code></h3><p>我们定义了一个对象 <code>obj</code>，包含属性 <code>a</code> 和两个方法 <code>fn1</code>、<code>fn2</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">fn1</span>: fn1,</span><br><span class="line">  <span class="attr">fn2</span>: fn2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>a</code> 是对象 <code>obj</code> 的属性，而 <code>fn1</code> 和 <code>fn2</code> 分别引用前面定义的普通函数和箭头函数。</p><hr><h3 id="函数调用分析"><a href="#函数调用分析" class="headerlink" title="函数调用分析"></a>函数调用分析</h3><h4 id="1-调用-fn1"><a href="#1-调用-fn1" class="headerlink" title="1. 调用 fn1()"></a>1. 调用 <code>fn1()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn1</span>();  <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><p>这是直接调用 <code>fn1</code>。由于 <code>fn1</code> 是在全局作用域中调用的，因此它的 <code>this</code> 默认指向全局对象 <code>window</code>。于是 <code>this.a</code> 相当于 <code>window.a</code>，它的值为 <code>1</code>。</p><h4 id="2-调用-fn2"><a href="#2-调用-fn2" class="headerlink" title="2. 调用 fn2()"></a>2. 调用 <code>fn2()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn2</span>();  <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><p><code>fn2</code> 是一个箭头函数。箭头函数的 <code>this</code> 是在定义时决定的。在这里，<code>fn2</code> 是在全局作用域中定义的，因此它的 <code>this</code> 也是指向全局对象 <code>window</code>，所以输出的 <code>this.a</code> 也是 <code>1</code>。</p><h4 id="3-调用-obj-fn1"><a href="#3-调用-obj-fn1" class="headerlink" title="3. 调用 obj.fn1()"></a>3. 调用 <code>obj.fn1()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="title function_">fn1</span>();  <span class="comment">// 输出: 10</span></span><br></pre></td></tr></table></figure><p>这次调用 <code>fn1</code> 是通过对象 <code>obj</code> 来进行的。在这种情况下，<code>this</code> 指向调用函数的对象 <code>obj</code>，所以 <code>this.a</code> 实际上是 <code>obj.a</code>，即 <code>10</code>。</p><h4 id="4-调用-obj-fn2"><a href="#4-调用-obj-fn2" class="headerlink" title="4. 调用 obj.fn2()"></a>4. 调用 <code>obj.fn2()</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="title function_">fn2</span>();  <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><p>虽然 <code>fn2</code> 是通过对象 <code>obj</code> 调用的，但由于 <code>fn2</code> 是箭头函数，它的 <code>this</code> 并不会被调用方式所影响。<code>fn2</code> 的 <code>this</code> 是在定义时就已经决定了的，它指向全局对象 <code>window</code>，因此 <code>this.a</code> 仍然是 <code>window.a</code>，值为 <code>1</code>。</p><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过这个例子，我们可以清楚地看到 JavaScript 中 <code>this</code> 的不同表现：</p><ol><li><strong>普通函数</strong>：<code>this</code> 的指向取决于它的调用方式。谁调用了这个函数，<code>this</code> 就指向谁。</li><li><strong>箭头函数</strong>：<code>this</code> 不会绑定调用时的对象，而是继承自定义时的上下文 <code>this</code>。</li></ol><h4 id="执行结果总结："><a href="#执行结果总结：" class="headerlink" title="执行结果总结："></a>执行结果总结：</h4><ul><li><code>fn1()</code> 输出 <code>1</code>：普通函数，在全局作用域中调用，<code>this</code> 指向 <code>window</code>。</li><li><code>fn2()</code> 输出 <code>1</code>：箭头函数，继承全局 <code>this</code>，所以输出 <code>window.a</code>。</li><li><code>obj.fn1()</code> 输出 <code>10</code>：普通函数，通过对象调用，<code>this</code> 指向 <code>obj</code>。</li><li><code>obj.fn2()</code> 输出 <code>1</code>：箭头函数，依旧继承定义时的 <code>this</code>，输出 <code>window.a</code>。</li></ul><hr><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在 JavaScript 中，理解 <code>this</code> 的指向对于编写和调试代码非常重要。普通函数的 <code>this</code> 根据调用方式而变化，而箭头函数的 <code>this</code> 是固定的。掌握了这些规则，可以帮助我们更好地编写和调试代码，避免 <code>this</code> 指向错误带来的困扰。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 JavaScript 中，&lt;code&gt;this&lt;/code&gt; 是一个非常重要但也容易引起混淆的概念。特别是在普通函数和箭头函数之间，&lt;code&gt;this&lt;/code&gt; 的行为有着显著的区别。在这篇文章中，我们将通过一个代码示例，深入理解 &lt;code&gt;this&lt;/code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PNG图片格式总结</title>
    <link href="https://promptonce.github.io/2024/09/26/PNG%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/09/26/PNG%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/</id>
    <published>2024-09-26T11:25:28.000Z</published>
    <updated>2024-09-27T16:12:44.072Z</updated>
    
    <content type="html"><![CDATA[<p>PNG有RGBA模式和RGB模式，灰度模式和调色板索引模式<br>PNG可以实现无损压缩</p><h3 id="1-灰度模式（Grayscale-Mode）"><a href="#1-灰度模式（Grayscale-Mode）" class="headerlink" title="1. 灰度模式（Grayscale Mode）"></a>1. <strong>灰度模式（Grayscale Mode）</strong></h3><p>灰度模式表示图像中的每个像素只有亮度信息，而没有颜色信息。简单来说，灰度图像只有黑白两种颜色的不同程度，从完全黑到完全白，中间有多个灰色渐变。</p><ul><li><p><strong>灰度模式的特点</strong>：</p><ul><li>每个像素只使用一个数值（通常是 8 位，范围从 0 到 255）来表示亮度。值为 0 表示完全黑，255 表示完全白。</li><li>与彩色图像相比，灰度图像占用的存储空间更少，因为它不需要存储红、绿、蓝三种颜色信息。</li></ul></li><li><p><strong>应用场景</strong>：灰度模式常用于黑白照片、扫描的文本图像，以及不需要颜色信息的其他图像。</p></li></ul><h3 id="2-调色板索引模式（Palette-Indexed-Mode）"><a href="#2-调色板索引模式（Palette-Indexed-Mode）" class="headerlink" title="2. 调色板索引模式（Palette-Indexed Mode）"></a>2. <strong>调色板索引模式（Palette-Indexed Mode）</strong></h3><p>调色板索引模式（有时也叫索引颜色模式）是一种节省存储空间的颜色表示方式，尤其适用于颜色数量有限的图像。在这种模式下，图像并不直接存储每个像素的颜色值，而是存储一个“索引”，这个索引指向调色板中的具体颜色。</p><ul><li><p><strong>调色板索引模式的特点</strong>：</p><ul><li>图像的颜色信息被限制在一个调色板中，调色板通常最多包含 256 种颜色（8 位索引），每个颜色索引对应具体的 RGB 颜色。</li><li>每个像素只保存颜色索引，而不是直接的颜色值。这种方式可以极大地减少图像文件的大小，尤其是在图像颜色数量较少的情况下。</li></ul></li><li><p><strong>应用场景</strong>：调色板索引模式常用于网页图像、简单的图标、GIF 动画等场景，特别是颜色变化不多的图像。例如，简单的卡通画、徽标或按钮图像。</p></li></ul><h3 id="灰度模式-vs-调色板索引模式："><a href="#灰度模式-vs-调色板索引模式：" class="headerlink" title="灰度模式 vs 调色板索引模式："></a><strong>灰度模式 vs 调色板索引模式</strong>：</h3><ul><li><strong>灰度模式</strong>：适合只有亮度变化的黑白图像，每个像素记录的是亮度信息。</li><li><strong>调色板索引模式</strong>：适合颜色有限的图像，通过索引值指向调色板中的颜色，节省存储空间。</li></ul><p>总的来说，这两种模式都是为了减少图像的存储需求而设计的，但应用场景有所不同。灰度模式用于单色图像，而调色板索引模式则用于有限颜色的彩色图像。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PNG有RGBA模式和RGB模式，灰度模式和调色板索引模式&lt;br&gt;PNG可以实现无损压缩&lt;/p&gt;
&lt;h3 id=&quot;1-灰度模式（Grayscale-Mode）&quot;&gt;&lt;a href=&quot;#1-灰度模式（Grayscale-Mode）&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo部署静态资源到github服务器</title>
    <link href="https://promptonce.github.io/2024/09/25/hexo%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%88%B0github%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://promptonce.github.io/2024/09/25/hexo%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%88%B0github%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2024-09-24T16:41:28.000Z</published>
    <updated>2024-09-29T15:38:20.727Z</updated>
    
    <content type="html"><![CDATA[<p>hexo d失败可以用git clone github仓库地址然后用hexo public目录替换后使用授权github仓库账号执行git push操作替代hexo d</p><blockquote><p>fatal: bad tree object 76efcae7c5c88277bd54626c763b790961115445<br>fatal: the remote end hung up unexpectedly<br>send-pack: unexpected disconnect while reading sideband packet<br>fatal: the remote end hung up unexpectedly<br>error: failed to push some refs to ‘<a href="https://xxx.git/">https://xxx.git</a>‘<br>FATAL Something’s wrong. Maybe you can find the solution here: <a href="https://hexo.io/docs/troubleshooting.html">https://hexo.io/docs/troubleshooting.html</a><br>Error: Spawn failed<br>    at ChildProcess.<anonymous> (D:\promptonce-blog\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:51:21)<br>    at ChildProcess.emit (node:events:519:28)<br>    at cp.emit (D:\promptonce-blog\node_modules\cross-spawn\lib\enoent.js:34:29)<br>    at ChildProcess._handle.onexit (node:internal&#x2F;child_process:294:12)</p></blockquote><p>清空public目录下的文件<br>克隆托管hexo博客的github仓库，将除.git的文件及目录复制到public目录中<br>将原来根目录的.git目录删掉<br>将克隆下来的目录的.git移动到根目录<br>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hexo d失败可以用git clone github仓库地址然后用hexo public目录替换后使用授权github仓库账号执行git push操作替代hexo d&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;fatal: bad tree object 76efcae7c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MMSegmentation实验结果保存命名格式总结</title>
    <link href="https://promptonce.github.io/2024/09/23/MMSegmentation%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E5%91%BD%E5%90%8D%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/09/23/MMSegmentation%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E4%BF%9D%E5%AD%98%E5%91%BD%E5%90%8D%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/</id>
    <published>2024-09-23T11:39:27.000Z</published>
    <updated>2024-09-23T11:42:35.194Z</updated>
    
    <content type="html"><![CDATA[<p>日期_模型名_骨干网络_其他重要参数_训练步骤_批次大小_目标尺寸</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;日期_模型名_骨干网络_其他重要参数_训练步骤_批次大小_目标尺寸&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GPT时代的程序员生存之道</title>
    <link href="https://promptonce.github.io/2024/09/22/GPT%E6%97%B6%E4%BB%A3%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9F%E5%AD%98%E4%B9%8B%E9%81%93/"/>
    <id>https://promptonce.github.io/2024/09/22/GPT%E6%97%B6%E4%BB%A3%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9F%E5%AD%98%E4%B9%8B%E9%81%93/</id>
    <published>2024-09-22T11:07:41.000Z</published>
    <updated>2024-09-22T11:08:28.754Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.aliyun.com/article/1205402">GPT时代的程序员生存之道</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/article/1205402&quot;&gt;GPT时代的程序员生存之道&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>promise出现的原因和promise方法</title>
    <link href="https://promptonce.github.io/2024/09/22/promise%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8Cpromise%E6%96%B9%E6%B3%95/"/>
    <id>https://promptonce.github.io/2024/09/22/promise%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8Cpromise%E6%96%B9%E6%B3%95/</id>
    <published>2024-09-22T06:25:20.000Z</published>
    <updated>2024-09-27T06:31:32.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Promise出现的原因"><a href="#一、Promise出现的原因" class="headerlink" title="一、Promise出现的原因"></a>一、Promise出现的原因</h3><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在JavaScript中，异步编程是非常常见的需求，例如处理网络请求、文件读取、定时操作等。在早期，我们通常使用回调函数（callback）来处理异步操作，但随着代码复杂度的增加，回调函数的使用也带来了一些问题，例如：</p><ol><li><p><strong>回调地狱（Callback Hell）</strong>：<br>当多个异步操作需要按顺序执行时，回调函数会嵌套得非常深，导致代码难以阅读和维护。</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncOperation1</span>(<span class="keyword">function</span>(<span class="params">result1</span>) &#123;</span><br><span class="line">    <span class="title function_">asyncOperation2</span>(result1, <span class="keyword">function</span>(<span class="params">result2</span>) &#123;</span><br><span class="line">        <span class="title function_">asyncOperation3</span>(result2, <span class="keyword">function</span>(<span class="params">result3</span>) &#123;</span><br><span class="line">            <span class="comment">// 继续嵌套</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>错误处理复杂</strong>：<br>每个回调函数都需要单独处理错误，这使得代码更为冗长且不易统一管理。</p></li></ol><h3 id="Promise的引入"><a href="#Promise的引入" class="headerlink" title="Promise的引入"></a>Promise的引入</h3><p>为了解决这些问题，ECMAScript 6（ES6）引入了Promise。Promise是一种用于管理异步操作的对象，提供了一种更为清晰和强大的方式来处理异步代码。</p><h3 id="二、Promise的基本方法和用法"><a href="#二、Promise的基本方法和用法" class="headerlink" title="二、Promise的基本方法和用法"></a>二、Promise的基本方法和用法</h3><h3 id="1-创建一个Promise"><a href="#1-创建一个Promise" class="headerlink" title="1. 创建一个Promise"></a>1. 创建一个Promise</h3><p>你可以通过<code>new Promise</code>来创建一个Promise对象。它接受一个执行函数（executor），该函数有两个参数：<code>resolve</code>和<code>reject</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 异步操作</span></span><br><span class="line">    <span class="keyword">let</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;操作成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;操作失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-使用Promise"><a href="#2-使用Promise" class="headerlink" title="2. 使用Promise"></a>2. 使用Promise</h3><p>Promise对象有三个主要方法：<code>then</code>、<code>catch</code>和<code>finally</code>，用于处理异步操作的结果。</p><ul><li><p><strong>then</strong>：用于处理成功的结果。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 操作成功</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>catch</strong>：用于处理失败的结果。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error); <span class="comment">// 操作失败</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>finally</strong>：无论Promise成功还是失败，最终都会执行的代码。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="title function_">finally</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;操作完成&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-链式调用"><a href="#3-链式调用" class="headerlink" title="3. 链式调用"></a>3. 链式调用</h3><p>Promise可以通过链式调用的方式来简化异步操作的串联，避免回调地狱。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncOperation1</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result1</span> =&gt;</span> <span class="title function_">asyncOperation2</span>(result1))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result2</span> =&gt;</span> <span class="title function_">asyncOperation3</span>(result2))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result3</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理最终结果</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 统一处理错误</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-常见的Promise方法"><a href="#4-常见的Promise方法" class="headerlink" title="4. 常见的Promise方法"></a>4. 常见的Promise方法</h3><ul><li><p><strong>Promise.all</strong>：接收一个包含多个Promise的数组，只有当所有Promise都成功时，才会执行<code>then</code>，否则执行<code>catch</code>。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, promise3])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 所有Promise都成功</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 任意一个Promise失败</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>Promise.race</strong>：接收一个包含多个Promise的数组，只要有一个Promise成功或失败，就立即执行相应的<code>then</code>或<code>catch</code>。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1, promise2, promise3])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个成功的Promise</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 第一个失败的Promise</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Promise提供了一种更为优雅和简洁的方式来处理JavaScript中的异步操作，解决了回调函数嵌套和错误处理复杂的问题。理解和掌握Promise对现代JavaScript编程至关重要。</p><p>Promise 的状态一旦确定（resolved 或 rejected），就无法更改。<br>同步代码先执行，Promise 回调是异步的，会在同步代码执行完毕后再执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">reject</span>();</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p> 输出<br> 1<br> 4<br> 3</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、Promise出现的原因&quot;&gt;&lt;a href=&quot;#一、Promise出现的原因&quot; class=&quot;headerlink&quot; title=&quot;一、Promise出现的原因&quot;&gt;&lt;/a&gt;一、Promise出现的原因&lt;/h3&gt;&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为何要将产品当成自己的孩子？</title>
    <link href="https://promptonce.github.io/2024/09/20/%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B0%86%E4%BA%A7%E5%93%81%E5%BD%93%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A9%E5%AD%90%EF%BC%9F/"/>
    <id>https://promptonce.github.io/2024/09/20/%E4%B8%BA%E4%BD%95%E8%A6%81%E5%B0%86%E4%BA%A7%E5%93%81%E5%BD%93%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A9%E5%AD%90%EF%BC%9F/</id>
    <published>2024-09-20T05:39:23.000Z</published>
    <updated>2024-09-20T05:39:23.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>只追求广度是不行的，光有广度不代表就有很强的判断力</p></blockquote><blockquote><p>如果学的是是技术的经典理论的话，那么毫无疑问是学的多更好，前提是能够学懂学好。如果是学习技术应用的话，需要知道的是应用是基于底层技术的上层建筑，如果从底层技术的角度分析，那么大多数技术应用在技术底层是同质化严重的，如果沉迷于学的多，对于通过项目来引导理论学习的人来说，可能会无法触及的更深层次的技术理论，从而在对技术的理解上显得局限，虽然这个和性格也有一定关系，但我认为软件工程师认真地学精可能比粗略地学广泛更有意义。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;只追求广度是不行的，光有广度不代表就有很强的判断力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果学的是是技术的经典理论的话，那么毫无疑问是学的多更好，前提是能够学懂学好。如果是学习技术应用的话，需要知道的是应用是基于底层</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://promptonce.github.io/2024/09/20/webpack/"/>
    <id>https://promptonce.github.io/2024/09/20/webpack/</id>
    <published>2024-09-20T05:38:02.000Z</published>
    <updated>2024-09-20T05:38:02.325Z</updated>
    
    <content type="html"><![CDATA[<p>Webpack 是一个强大的 <strong>模块打包工具</strong>，广泛应用于前端项目中。它的主要作用是将各种资源（JavaScript、CSS、图片等）当作模块进行处理，最后生成优化后的静态文件，提升项目的加载性能和开发体验。</p><p>简单来说，Webpack 可以将多个文件合并为一个或者多个<strong>打包文件</strong>，减少请求次数，提高性能，同时还能进行代码拆分、按需加载等优化。</p><h3 id="Webpack-的核心概念："><a href="#Webpack-的核心概念：" class="headerlink" title="Webpack 的核心概念："></a>Webpack 的核心概念：</h3><ol><li><p><strong>Entry（入口）</strong>：Webpack 从哪个文件开始进行打包。通常是你应用的主文件（例如 <code>index.js</code>），Webpack 会根据依赖关系递归解析所有依赖的模块。</p></li><li><p><strong>Output（输出）</strong>：打包后的文件输出到哪里，通常是一个目录下的某个文件，比如 <code>dist/main.js</code>。</p></li><li><p><strong>Loaders（加载器）</strong>：Webpack 本身只理解 JavaScript 文件，但通过加载器，你可以让它处理其他类型的文件，比如 CSS、图片、甚至 Sass 或 TypeScript 文件。</p></li><li><p><strong>Plugins（插件）</strong>：插件用于扩展 Webpack 的功能，比如压缩打包后的文件、注入环境变量、分离 CSS 等。</p></li><li><p><strong>Mode（模式）</strong>：Webpack 有 <code>development</code>（开发模式） 和 <code>production</code>（生产模式） 两种模式，开发模式注重调试和快速编译，而生产模式则侧重于优化性能，比如压缩代码、移除无用代码等。</p></li></ol><h3 id="Webpack-的使用流程："><a href="#Webpack-的使用流程：" class="headerlink" title="Webpack 的使用流程："></a>Webpack 的使用流程：</h3><ol><li><p><strong>安装 Webpack</strong>：在项目中通过 <code>npm</code> 安装 Webpack 和它的 CLI 工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack webpack-cli</span><br></pre></td></tr></table></figure></li><li><p>**创建 <code>webpack.config.js</code>**：这是 Webpack 的配置文件，用于定义入口、输出、加载器和插件等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,  <span class="comment">// 入口文件</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,  <span class="comment">// 打包后的文件名</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),  <span class="comment">// 输出路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  <span class="comment">// 匹配所有的 CSS 文件</span></span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],  <span class="comment">// 使用两个加载器来处理 CSS</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>,  <span class="comment">// 开发模式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>运行打包命令</strong>：在终端中运行 <code>npx webpack</code>，Webpack 会根据配置文件进行打包，输出最终文件到指定目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure></li></ol><h3 id="Webpack-的主要功能："><a href="#Webpack-的主要功能：" class="headerlink" title="Webpack 的主要功能："></a>Webpack 的主要功能：</h3><ol><li><p><strong>代码拆分（Code Splitting）</strong>：Webpack 支持将代码拆分成多个包（chunks），只在需要时加载，提升应用的加载速度。</p></li><li><p><strong>按需加载（Lazy Loading）</strong>：通过动态 <code>import()</code>，可以让某些模块在用户实际需要时才加载，这对大型应用非常有用。</p></li><li><p><strong>模块热替换（Hot Module Replacement, HMR）</strong>：在开发过程中，当代码修改时，Webpack 能让你不刷新整个页面而只替换修改的模块，从而提升开发效率。</p></li><li><p><strong>Tree Shaking</strong>：Webpack 能在打包时移除没有用到的代码（通常是未使用的 ES6 模块），从而减少打包文件的大小。</p></li><li><p><strong>兼容各种模块化方案</strong>：Webpack 支持 AMD、CommonJS、ES6 模块等各种模块化标准，并能将这些模块统一打包为一个文件。</p></li></ol><h3 id="Webpack-例子："><a href="#Webpack-例子：" class="headerlink" title="Webpack 例子："></a>Webpack 例子：</h3><p>假如你有一个项目使用了 CSS 和图片，你可以这样配置 Webpack 来处理这些资源：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">   <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">   <span class="attr">output</span>: &#123;</span><br><span class="line">       <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">       <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">module</span>: &#123;</span><br><span class="line">       <span class="attr">rules</span>: [</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  <span class="comment">// 处理 CSS 文件</span></span><br><span class="line">               <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,  <span class="comment">// 处理图片文件</span></span><br><span class="line">               <span class="attr">use</span>: [</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">                       <span class="attr">options</span>: &#123;</span><br><span class="line">                           <span class="attr">name</span>: <span class="string">&#x27;[name].[hash].[ext]&#x27;</span>,  <span class="comment">// 输出文件名格式</span></span><br><span class="line">                           <span class="attr">outputPath</span>: <span class="string">&#x27;images&#x27;</span>,  <span class="comment">// 输出路径</span></span><br><span class="line">                       &#125;,</span><br><span class="line">                   &#125;,</span><br><span class="line">               ],</span><br><span class="line">           &#125;,</span><br><span class="line">       ],</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>,  <span class="comment">// 生产模式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Webpack-的优点："><a href="#Webpack-的优点：" class="headerlink" title="Webpack 的优点："></a>Webpack 的优点：</h3><ol><li><p><strong>强大的模块打包能力</strong>：Webpack 支持将所有资源视作模块，统一进行管理，极大简化了前端开发流程。</p></li><li><p><strong>灵活的配置</strong>：无论是简单的单页面应用，还是复杂的多页面应用，Webpack 都可以通过配置来满足不同的需求。</p></li><li><p><strong>丰富的插件生态</strong>：通过 Webpack 插件，你可以扩展它的功能，比如压缩文件、生成 HTML 文件、分析打包结果等。</p></li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Webpack 是现代前端开发中最常用的构建工具之一，它可以将项目中的各种资源（JS、CSS、图片等）进行打包、优化，提升项目的性能和开发体验。它的强大之处在于高度可配置性和丰富的插件生态，能够满足从小型项目到大型复杂项目的各种需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Webpack 是一个强大的 &lt;strong&gt;模块打包工具&lt;/strong&gt;，广泛应用于前端项目中。它的主要作用是将各种资源（JavaScript、CSS、图片等）当作模块进行处理，最后生成优化后的静态文件，提升项目的加载性能和开发体验。&lt;/p&gt;
&lt;p&gt;简单来说，Webpa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue路由传参</title>
    <link href="https://promptonce.github.io/2024/09/20/Vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82/"/>
    <id>https://promptonce.github.io/2024/09/20/Vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82/</id>
    <published>2024-09-20T05:36:42.000Z</published>
    <updated>2024-09-20T05:36:42.681Z</updated>
    
    <content type="html"><![CDATA[<p>路由传参方式可划分为 params 传参和 query 传参，而 params 传参又可分为在 url 中显示参数和不显示参数两种方式<br>方式A ：这种需要在路由配置好可以传递参数 xxx 的，不是最方便的<br>路由配置<br>{<br>path ： ‘&#x2F;child&#x2F;:XXX’,<br>component ：（ child<br>}<br>父组件<br>&lt;router—link to&#x3D;”&#x2F;child&#x2F;XXX”&gt;:&lt;&#x2F;router—link&gt;<br>子组件读取<br>this.num &#x3D; this.$route.params.XXX<br>方式B ：这种同样需要在路山配置好可以传递参数 XXX 的，不过是用到 push方法的<br>路由配置<br>{<br>  path:’&#x2F;child&#x2F;:XXX’<br>  component ：Child<br>}<br>父组件<br>this.$router. push({、 &#x2F;chiId&#x2F;${XXXFpath ：<br>子组件读取<br>this.num &#x3D; this.Sroute.params.XXX上面两种方式都会在地址显示出传递的参数、类似 get 请求方式 c ．这种不需要在路山配置好根据路由的名称、需要保持一致路由配置不需要配置，但是子组件的 name 必须与父组件传递的路由一致父组件th iS ， $router.push({params ：{X)O(: ，1子组件读取this.num &#x3D; this 、 $route.params.XXX &#x2F;&#x2F;妈呀方式 D ，这种不需要在路由配置好根据路由的名称&#96;通过 que 缪来传递路由配置不需要配置，但是子组件的 name 必须与父组件传递的路由一致{父组件this.$router.push({path: ‘&#x2F;child’query: {子组件读取this.num &#x3D; this.$route.query.XXX总的来说使用方式 C 和 D 最为多，毕竟不需要对路由配置做修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;路由传参方式可划分为 params 传参和 query 传参，而 params 传参又可分为在 url 中显示参数和不显示参数两种方式&lt;br&gt;方式A ：这种需要在路由配置好可以传递参数 xxx 的，不是最方便的&lt;br&gt;路由配置&lt;br&gt;{&lt;br&gt;path ： ‘&amp;#x2F;c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>网站配置https</title>
    <link href="https://promptonce.github.io/2024/09/20/%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AEhttps/"/>
    <id>https://promptonce.github.io/2024/09/20/%E7%BD%91%E7%AB%99%E9%85%8D%E7%BD%AEhttps/</id>
    <published>2024-09-20T05:34:11.000Z</published>
    <updated>2024-09-20T08:47:22.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是-HTTPS？"><a href="#1-什么是-HTTPS？" class="headerlink" title="1. 什么是 HTTPS？"></a>1. 什么是 HTTPS？</h2><p>HTTPS（超文本传输安全协议）是 HTTP 的加密版本，通过 SSL&#x2F;TLS 协议来确保数据传输的安全性。也就是说，别人不能轻易地偷看你们之间的通信内容啦！</p><h2 id="2-HTTPS-配置流程"><a href="#2-HTTPS-配置流程" class="headerlink" title="2. HTTPS 配置流程"></a>2. HTTPS 配置流程</h2><h3 id="步骤-1-获取-SSL-证书"><a href="#步骤-1-获取-SSL-证书" class="headerlink" title="步骤 1: 获取 SSL 证书"></a>步骤 1: 获取 SSL 证书</h3><p>首先你需要一个 SSL 证书。这个证书就像是网站的“身份证”，能保证访问者正在访问的确实是你的网站哦！你有两个选择：</p><ul><li><strong>购买 SSL 证书</strong>：许多域名提供商（如 Namecheap、GoDaddy）都有提供。</li><li><strong>使用免费 SSL 证书</strong>：推荐使用 <a href="https://letsencrypt.org/">Let’s Encrypt</a>，这是一个免费的证书颁发机构（CA），超棒的！</li></ul><h3 id="步骤-2-安装-SSL-证书"><a href="#步骤-2-安装-SSL-证书" class="headerlink" title="步骤 2: 安装 SSL 证书"></a>步骤 2: 安装 SSL 证书</h3><p>获得证书后，要把它安装到你的服务器上。安装的具体方法取决于你的网站服务器种类，我们来看常见的两种情况。</p><h4 id="a-Nginx-服务器"><a href="#a-Nginx-服务器" class="headerlink" title="a. Nginx 服务器"></a><strong>a. Nginx 服务器</strong></h4><ol><li>将 SSL 证书和私钥上传到服务器。</li><li>修改 Nginx 配置文件（通常在 <code>/etc/nginx/sites-available/</code> 里面）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line">    <span class="built_in">return</span> 301 https://$host<span class="variable">$request_uri</span>;  <span class="comment"># 重定向到 https</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name example.com www.example.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /path/to/ssl/certificate.crt;</span><br><span class="line">    ssl_certificate_key /path/to/private/key.key;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启用 HTTPS 的一些推荐配置</span></span><br><span class="line">    ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment"># 网站的根目录</span></span><br><span class="line">        root /var/www/html;</span><br><span class="line">        index index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>保存配置，然后重启 Nginx：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><h4 id="b-Apache-服务器"><a href="#b-Apache-服务器" class="headerlink" title="b. Apache 服务器"></a><strong>b. Apache 服务器</strong></h4><ol><li>打开 Apache 配置文件（通常在 <code>/etc/apache2/sites-available/</code> 里面）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerName example.com</span><br><span class="line">    Redirect permanent / https://example.com/</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:443&gt;</span><br><span class="line">    ServerName example.com</span><br><span class="line"></span><br><span class="line">    SSLEngine on</span><br><span class="line">    SSLCertificateFile /path/to/ssl/certificate.crt</span><br><span class="line">    SSLCertificateKeyFile /path/to/private/key.key</span><br><span class="line">    SSLCertificateChainFile /path/to/ca_bundle.crt</span><br><span class="line"></span><br><span class="line">    DocumentRoot /var/www/html</span><br><span class="line">    &lt;Directory /var/www/html&gt;</span><br><span class="line">        Options Indexes FollowSymLinks</span><br><span class="line">        AllowOverride All</span><br><span class="line">        Require all granted</span><br><span class="line">    &lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>启用 SSL 模块并重启 Apache：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod ssl</span><br><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure><h3 id="步骤-3-强制-HTTPS"><a href="#步骤-3-强制-HTTPS" class="headerlink" title="步骤 3: 强制 HTTPS"></a>步骤 3: 强制 HTTPS</h3><p>虽然你已经配置好 HTTPS 了，但是还需要确保所有用户都通过 HTTPS 来访问你的站点呢~ 最简单的方法就是在 Nginx 或 Apache 里设置 301 重定向，前面我们已经有提到啦，就是那个把 HTTP 重定向到 HTTPS 的部分。</p><h3 id="步骤-4-测试你的-HTTPS"><a href="#步骤-4-测试你的-HTTPS" class="headerlink" title="步骤 4: 测试你的 HTTPS"></a>步骤 4: 测试你的 HTTPS</h3><p>哇，终于配置好了！接下来打开浏览器，访问你的网站 <code>https://your-domain.com</code>，看看是不是成功显示一个小锁头🔒啦？如果有小锁头，恭喜你，HTTPS 配置成功！</p><p>别忘了用在线工具 <a href="https://www.ssllabs.com/ssltest/">SSL Labs</a> 来测试你的 SSL 证书是否配置得完美哦~</p><h2 id="tomcat配置证书和Nginx配置https证书有何区别？"><a href="#tomcat配置证书和Nginx配置https证书有何区别？" class="headerlink" title="tomcat配置证书和Nginx配置https证书有何区别？"></a>tomcat配置证书和Nginx配置https证书有何区别？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是-HTTPS？&quot;&gt;&lt;a href=&quot;#1-什么是-HTTPS？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是 HTTPS？&quot;&gt;&lt;/a&gt;1. 什么是 HTTPS？&lt;/h2&gt;&lt;p&gt;HTTPS（超文本传输安全协议）是 HTTP 的加密版本</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深度学习中nchw_to_nlc函数总结</title>
    <link href="https://promptonce.github.io/2024/09/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%ADnchw-to-nlc%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/09/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%ADnchw-to-nlc%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</id>
    <published>2024-09-19T14:50:41.000Z</published>
    <updated>2024-09-19T15:23:44.389Z</updated>
    
    <content type="html"><![CDATA[<p>下面的例子展示了如何手动实现 <code>NCHW</code> 到 <code>NLC</code> 的转换，使用纯 Python 列表和基础的列表操作。</p><h3 id="NCHW-NLC-的手动实现"><a href="#NCHW-NLC-的手动实现" class="headerlink" title="NCHW -&gt; NLC 的手动实现"></a>NCHW -&gt; NLC 的手动实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 4D 张量 (NCHW)，Batch Size = 2, Channels = 3, Height = 4, Width = 4</span></span><br><span class="line">nchw_tensor = np.random.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>)  <span class="comment"># 使用numpy来初始化张量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;NCHW 格式的张量：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(nchw_tensor.shape)  <span class="comment"># 输出 (2, 3, 4, 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动转换 NCHW -&gt; NLC</span></span><br><span class="line">batch_size, channels, height, width = nchw_tensor.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个新的列表以存储转换后的数据</span></span><br><span class="line">nlc_tensor = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每个 batch</span></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(batch_size):</span><br><span class="line">    <span class="comment"># 存储每个 batch 的结果</span></span><br><span class="line">    batch_result = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对于每个 batch，我们需要将 (Height, Width) 展开为一个长度 (Length)，然后通道排到最后</span></span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            <span class="comment"># 对于每个 (h, w) 位置，取出所有的通道值，并将它们组合成一个长度为 channels 的列表</span></span><br><span class="line">            pixel_data = nchw_tensor[b, :, h, w]</span><br><span class="line">            batch_result.append(pixel_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 把这个 batch 的结果加到最终的输出列表中</span></span><br><span class="line">    nlc_tensor.append(batch_result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为 NumPy 数组，得到最终的形状</span></span><br><span class="line">nlc_tensor = np.array(nlc_tensor)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n转换为 NLC 格式的张量：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(nlc_tensor.shape)  <span class="comment"># 输出应为 (2, 16, 3)，其中 16 = 4 * 4（合并了 H 和 W）</span></span><br></pre></td></tr></table></figure><h3 id="代码解释："><a href="#代码解释：" class="headerlink" title="代码解释："></a>代码解释：</h3><ol><li><p><strong>创建初始张量</strong>：</p><ul><li><code>nchw_tensor</code> 是一个 4D 的 NumPy 数组，形状为 <code>(2, 3, 4, 4)</code>，即 <code>Batch Size = 2</code>，<code>Channels = 3</code>，<code>Height = 4</code>，<code>Width = 4</code>。</li></ul></li><li><p><strong>手动遍历维度</strong>：</p><ul><li>使用四重嵌套循环，其中：<ul><li>第一层循环遍历每个批次 (<code>b</code>)；</li><li>第二、三层循环遍历 <code>Height</code> 和 <code>Width</code> 的每一个位置 (<code>h, w</code>)；</li><li>对于每个 <code>(h, w)</code> 位置，提取所有的通道数据，并将它们作为一组。</li><li>将每组通道数据按顺序存入 <code>batch_result</code> 列表中。</li></ul></li></ul></li><li><p><strong>合并 Height 和 Width</strong>：</p><ul><li>对于每个 batch，将 <code>(Height, Width)</code> 的像素展开为一个长度，得到的张量形状为 <code>(Batch Size, Length, Channels)</code>。其中 <code>Length = Height * Width</code>。</li></ul></li><li><p><strong>最终结果</strong>：</p><ul><li>手动构造的 <code>nlc_tensor</code> 最终转换为 NumPy 数组，它的形状是 <code>(2, 16, 3)</code>，符合 <code>NLC</code> 格式。</li></ul></li></ol><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NCHW 格式的张量：</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">转换为 NLC 格式的张量：</span><br><span class="line">(<span class="number">2</span>, <span class="number">16</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="手动实现的缺点："><a href="#手动实现的缺点：" class="headerlink" title="手动实现的缺点："></a>手动实现的缺点：</h3><ul><li>虽然这个手动实现清楚地展示了张量的维度转换过程，但相对于使用库函数，它效率低，尤其是在数据规模较大时。</li><li>使用嵌套循环手动处理数据比用高效的库（如 PyTorch、NumPy 等）更慢，且代码冗长。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>虽然在实际工作中通常使用框架的内置函数（如 <code>permute</code>、<code>reshape</code> 等）进行张量操作，但理解手动转换的过程可以帮助你更好地掌握这些操作的本质。这个手动示例展示了如何通过基本的 Python 列表和循环，将 <code>NCHW</code> 格式的张量转换为 <code>NLC</code> 格式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下面的例子展示了如何手动实现 &lt;code&gt;NCHW&lt;/code&gt; 到 &lt;code&gt;NLC&lt;/code&gt; 的转换，使用纯 Python 列表和基础的列表操作。&lt;/p&gt;
&lt;h3 id=&quot;NCHW-NLC-的手动实现&quot;&gt;&lt;a href=&quot;#NCHW-NLC-的手动实现&quot; clas</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://promptonce.github.io/2024/09/19/hello-world/"/>
    <id>https://promptonce.github.io/2024/09/19/hello-world/</id>
    <published>2024-09-19T07:01:09.219Z</published>
    <updated>2024-06-30T15:29:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>快速排序算法</title>
    <link href="https://promptonce.github.io/2024/09/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://promptonce.github.io/2024/09/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2024-09-18T08:17:39.000Z</published>
    <updated>2024-09-18T14:52:19.307Z</updated>
    
    <content type="html"><![CDATA[<p>利用递归，划分子区间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;利用递归，划分子区间&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RESTful_API</title>
    <link href="https://promptonce.github.io/2024/09/18/RESTful-API/"/>
    <id>https://promptonce.github.io/2024/09/18/RESTful-API/</id>
    <published>2024-09-18T06:52:30.000Z</published>
    <updated>2024-09-18T06:53:53.814Z</updated>
    
    <content type="html"><![CDATA[<p>RESTful API（Representational State Transfer API）是一种设计风格，用于构建基于Web的应用程序和服务。它允许客户端（比如浏览器或移动应用）通过HTTP协议与服务器进行通信，通常涉及以下几个重要概念：</p><h3 id="1-资源（Resources）"><a href="#1-资源（Resources）" class="headerlink" title="1. 资源（Resources）"></a>1. <strong>资源（Resources）</strong></h3><ul><li><strong>资源</strong>是指你希望通过API管理的数据实体，比如用户、订单或产品。每个资源都有一个唯一的标识符（通常是一个URL）。</li><li>例如，如果你在构建一个电子商务网站，<code>/products</code> 可能是一个表示所有产品的资源，<code>/products/123</code> 可能表示一个特定的产品。</li></ul><h3 id="2-HTTP-方法"><a href="#2-HTTP-方法" class="headerlink" title="2. HTTP 方法"></a>2. <strong>HTTP 方法</strong></h3><p>RESTful API使用HTTP方法来执行不同的操作：</p><ul><li><strong>GET</strong>：获取资源的表示。比如，<code>GET /products</code> 获取所有产品，<code>GET /products/123</code> 获取ID为123的产品。</li><li><strong>POST</strong>：创建一个新的资源。比如，<code>POST /products</code> 发送一个新的产品数据，创建一个新产品。</li><li><strong>PUT</strong>：更新一个现有的资源。比如，<code>PUT /products/123</code> 更新ID为123的产品的详细信息。</li><li><strong>DELETE</strong>：删除一个资源。比如，<code>DELETE /products/123</code> 删除ID为123的产品。</li></ul><h3 id="3-无状态（Stateless）"><a href="#3-无状态（Stateless）" class="headerlink" title="3. 无状态（Stateless）"></a>3. <strong>无状态（Stateless）</strong></h3><p>每个请求都是独立的，服务器不会保存客户端的状态。每个请求必须包含所有信息以完成请求，例如，身份验证信息和请求数据。服务器不需要记住客户端的状态。</p><h3 id="4-可缓存（Cacheable）"><a href="#4-可缓存（Cacheable）" class="headerlink" title="4. 可缓存（Cacheable）"></a>4. <strong>可缓存（Cacheable）</strong></h3><p>响应应标记为可缓存或不可缓存，以提高性能。比如，如果获取的数据不经常变化，可以将其缓存，以减少对服务器的请求。</p><h3 id="5-统一接口（Uniform-Interface）"><a href="#5-统一接口（Uniform-Interface）" class="headerlink" title="5. 统一接口（Uniform Interface）"></a>5. <strong>统一接口（Uniform Interface）</strong></h3><p>RESTful API具有统一的接口，这意味着无论客户端如何与API交互，接口的行为是一致的。主要包括：</p><ul><li><strong>资源的标识</strong>：资源通过URI（统一资源标识符）标识。</li><li><strong>资源的表现</strong>：资源可以通过不同的格式（如JSON或XML）表示。</li><li><strong>自描述消息</strong>：消息中包含足够的信息，使接收方能够理解如何处理。</li><li><strong>超媒体作为应用程序状态的引擎（HATEOAS）</strong>：服务器提供的响应包括了进一步操作的链接，帮助客户端动态导航API。</li></ul><h3 id="6-层次结构（Layered-System）"><a href="#6-层次结构（Layered-System）" class="headerlink" title="6. 层次结构（Layered System）"></a>6. <strong>层次结构（Layered System）</strong></h3><p>API可以由多个层次组成，每一层可以处理请求和响应，客户端无法直接知道服务器的具体实现。这种层次化使得系统更加可扩展和维护。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>假设你有一个管理图书的API，以下是一些常见的RESTful API操作示例：</p><ul><li><strong>获取所有图书</strong><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /books</span><br></pre></td></tr></table></figure></li><li><strong>获取特定图书</strong><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /books/1</span><br></pre></td></tr></table></figure></li><li><strong>创建新图书</strong><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /books</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;New Book&quot;,</span><br><span class="line">  &quot;author&quot;: &quot;Author Name&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>更新特定图书</strong><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /books/1</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;Updated Book Title&quot;,</span><br><span class="line">  &quot;author&quot;: &quot;Updated Author Name&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>删除特定图书</strong><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /books/1</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;RESTful API（Representational State Transfer API）是一种设计风格，用于构建基于Web的应用程序和服务。它允许客户端（比如浏览器或移动应用）通过HTTP协议与服务器进行通信，通常涉及以下几个重要概念：&lt;/p&gt;
&lt;h3 id=&quot;1-</summary>
      
    
    
    
    
  </entry>
  
</feed>
