<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PromptOnce</title>
  
  
  <link href="https://promptonce.github.io/atom.xml" rel="self"/>
  
  <link href="https://promptonce.github.io/"/>
  <updated>2025-03-11T03:54:11.407Z</updated>
  <id>https://promptonce.github.io/</id>
  
  <author>
    <name>penggan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML5新特性</title>
    <link href="https://promptonce.github.io/2025/03/11/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://promptonce.github.io/2025/03/11/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2025-03-11T03:51:11.000Z</published>
    <updated>2025-03-11T03:54:11.407Z</updated>
    
    <content type="html"><![CDATA[<img src="/2025/03/11/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/HTML5%E6%96%B0%E7%89%B9%E6%80%A7.png" class="" title="HTML5新特性">]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2025/03/11/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/HTML5%E6%96%B0%E7%89%B9%E6%80%A7.png&quot; class=&quot;&quot; title=&quot;HTML5新特性&quot;&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTML语义化标签总结</title>
    <link href="https://promptonce.github.io/2025/03/11/HTML%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2025/03/11/HTML%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93/</id>
    <published>2025-03-11T03:36:47.000Z</published>
    <updated>2025-03-11T03:41:11.138Z</updated>
    
    <content type="html"><![CDATA[<img src="/2025/03/11/HTML%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93/HTML%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE.png" class="" title="HTML语义化标签">]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2025/03/11/HTML%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%E6%80%BB%E7%BB%93/HTML%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>从变量出发：编码世界的原子级构建法则</title>
    <link href="https://promptonce.github.io/2025/03/11/%E4%BB%8E%E5%8F%98%E9%87%8F%E5%87%BA%E5%8F%91%EF%BC%9A%E7%BC%96%E7%A0%81%E4%B8%96%E7%95%8C%E7%9A%84%E5%8E%9F%E5%AD%90%E7%BA%A7%E6%9E%84%E5%BB%BA%E6%B3%95%E5%88%99/"/>
    <id>https://promptonce.github.io/2025/03/11/%E4%BB%8E%E5%8F%98%E9%87%8F%E5%87%BA%E5%8F%91%EF%BC%9A%E7%BC%96%E7%A0%81%E4%B8%96%E7%95%8C%E7%9A%84%E5%8E%9F%E5%AD%90%E7%BA%A7%E6%9E%84%E5%BB%BA%E6%B3%95%E5%88%99/</id>
    <published>2025-03-10T16:33:23.000Z</published>
    <updated>2025-03-10T16:34:48.658Z</updated>
    
    <content type="html"><![CDATA[<p>计算机科学家翁恺提出的”当程序不知道如何写时，先将变量定义出来就知道如何写了”这一观点，深刻揭示了编程实践的核心方法论。我们可以从内涵与外延两个维度进行深入解析：</p><p>一、内涵解析（核心思想）</p><ol><li><p>变量驱动思维<br>通过变量定义强制开发者进行数据流建模，将抽象需求具象化为可操作的数据单元。这种思维转换如同建筑师的蓝图绘制，将混沌的需求转化为有序的数据结构。</p></li><li><p>分治策略实践<br>定义变量的过程实质上是实施分治法，将复杂系统解构为离散的数据实体。例如开发电商系统时，先定义User、Product、Order等核心实体变量，自然形成模块划分。</p></li><li><p>类型系统预演<br>现代编程中的变量定义包含类型声明（如TypeScript的类型注解），这本质上是建立程序的抽象代数系统。通过类型约束提前规避逻辑错误，如定义interface User {id: number}即构建了数据契约。</p></li></ol><p>二、外延扩展（应用场景）</p><ol><li><p>算法设计范式<br>在LeetCode解题时，先明确需要维护的指针变量（如快慢指针）、状态变量（如DP数组），往往能立即理清算法脉络。例如求解二叉树问题时，定义depth变量自然引导出递归结构。</p></li><li><p>系统架构预构<br>微服务设计中，定义OrderService、PaymentGateway等服务接口变量，实质是在进行领域驱动设计的限界上下文划分，这种变量定义已升华为架构元素的声明。</p></li><li><p>并发编程模型<br>在Go语言中，通过chan定义通信管道变量，立即明确了goroutine间的交互协议。这种变量定义构建了并发系统的拓扑结构，如定义resultChan :&#x3D; make(chan int, 10)即确定了并行计算框架。</p></li></ol><p>三、方法论升华</p><ol><li><p>笛卡尔坐标映射<br>将问题空间映射到由变量构成的笛卡尔坐标系，每个变量对应一个维度。例如在游戏开发中，定义playerPosition(x,y), velocity向量，就建立了物理运动的基础坐标系。</p></li><li><p>范畴论实践<br>变量类型定义构成程序范畴中的对象，函数定义构成态射。这种范畴论视角下，定义Maybe<T>这样的代数数据类型变量，实质是在构建程序的可组合单元。</p></li><li><p>形式验证基础<br>在安全关键系统中，变量定义需配合前置条件（如Ada的range约束），这种定义方式实质是在构建霍尔逻辑的三元组，为形式化验证奠定基础。</p></li></ol><p>结语：<br>翁恺的洞见揭示了编程本质是结构化思维的具象化过程。变量定义作为最细粒度的设计单元，既是最低阶的代码元素，又是最高阶的设计模式载体。这种二元统一性使其成为破解编程困境的有效突破口，体现了”见微知著”的工程智慧。当代开发者应将其升华为一种元编程思维，在量子计算、区块链等新兴领域继续发挥其方法论价值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机科学家翁恺提出的”当程序不知道如何写时，先将变量定义出来就知道如何写了”这一观点，深刻揭示了编程实践的核心方法论。我们可以从内涵与外延两个维度进行深入解析：&lt;/p&gt;
&lt;p&gt;一、内涵解析（核心思想）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;变量驱动思维&lt;br&gt;通过变量定义强制开</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript基本类型</title>
    <link href="https://promptonce.github.io/2025/03/09/JavaScript%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>https://promptonce.github.io/2025/03/09/JavaScript%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-03-09T09:11:16.000Z</published>
    <updated>2025-03-09T09:52:43.680Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中，数据类型可以分为两大类：<strong>原始数据类型（Primitive Types）</strong> 和 <strong>引用数据类型（Reference Types）</strong>。以下是具体分类：</p><hr><h3 id="1-原始数据类型（Primitive-Types）"><a href="#1-原始数据类型（Primitive-Types）" class="headerlink" title="1. 原始数据类型（Primitive Types）"></a><strong>1. 原始数据类型（Primitive Types）</strong></h3><p>原始数据类型是不可变的（immutable），直接存储值。包括以下 7 种：</p><ol><li><p><strong>Number</strong>  </p><ul><li>表示数字，包括整数和浮点数。  </li><li>例如：<code>42</code>, <code>3.14</code>, <code>NaN</code>（非数字）, <code>Infinity</code>（无穷大）。</li></ul></li><li><p><strong>String</strong>  </p><ul><li>表示文本数据。  </li><li>例如：<code>&quot;Hello&quot;</code>, <code>&#39;World&#39;</code>, <code>`Template Literal`</code>。</li></ul></li><li><p><strong>Boolean</strong>  </p><ul><li>表示逻辑值，只有两个值：<code>true</code> 和 <code>false</code>。</li></ul></li><li><p><strong>Undefined</strong>  </p><ul><li>表示变量已声明但未赋值。  </li><li>例如：<code>let x; console.log(x); // undefined</code>。</li></ul></li><li><p><strong>Null</strong>  </p><ul><li>表示空值或无值。  </li><li>例如：<code>let y = null;</code>。</li></ul></li><li><p><strong>Symbol</strong>（ES6 引入）  </p><ul><li>表示唯一的、不可变的值，通常用于对象属性的键。  </li><li>例如：<code>const sym = Symbol(&#39;description&#39;);</code>。</li></ul></li><li><p><strong>BigInt</strong>（ES2020 引入）  </p><ul><li>表示任意精度的整数，用于处理超出 <code>Number</code> 范围的整数。  </li><li>例如：<code>const bigNum = 1234567890123456789012345678901234567890n;</code>。</li></ul></li></ol><hr><h3 id="2-引用数据类型（Reference-Types）"><a href="#2-引用数据类型（Reference-Types）" class="headerlink" title="2. 引用数据类型（Reference Types）"></a><strong>2. 引用数据类型（Reference Types）</strong></h3><p>引用数据类型是可变的（mutable），存储的是值的引用（内存地址）。包括以下类型：</p><ol><li><p><strong>Object</strong>  </p><ul><li>表示复杂数据结构，可以是普通对象、数组、函数等。  </li><li>例如：<code>&#123; name: &quot;Alice&quot;, age: 25 &#125;</code>, <code>[1, 2, 3]</code>。</li></ul></li><li><p><strong>Array</strong>  </p><ul><li>表示有序的集合，本质上是特殊的对象。  </li><li>例如：<code>[1, 2, 3]</code>。</li></ul></li><li><p><strong>Function</strong>  </p><ul><li>表示可执行的代码块，本质上是对象。  </li><li>例如：<code>function add(a, b) &#123; return a + b; &#125;</code>。</li></ul></li><li><p><strong>Date</strong>  </p><ul><li>表示日期和时间。  </li><li>例如：<code>new Date()</code>。</li></ul></li><li><p><strong>RegExp</strong>  </p><ul><li>表示正则表达式。  </li><li>例如：<code>/abc/</code>。</li></ul></li><li><p><strong>Map</strong> 和 <strong>Set</strong>（ES6 引入）  </p><ul><li><code>Map</code> 是键值对的集合，键可以是任意类型。  </li><li><code>Set</code> 是唯一值的集合。  </li><li>例如：<code>new Map()</code>, <code>new Set()</code>。</li></ul></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>原始数据类型</strong>：<code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>Undefined</code>, <code>Null</code>, <code>Symbol</code>, <code>BigInt</code>。  </li><li><strong>引用数据类型</strong>：<code>Object</code>, <code>Array</code>, <code>Function</code>, <code>Date</code>, <code>RegExp</code>, <code>Map</code>, <code>Set</code> 等。</li></ul><p>JavaScript 是一种动态类型语言，变量的数据类型可以在运行时改变。</p><h3 id="JavaScript-原始数据类型的不可变性总结"><a href="#JavaScript-原始数据类型的不可变性总结" class="headerlink" title="JavaScript 原始数据类型的不可变性总结"></a><strong>JavaScript 原始数据类型的不可变性总结</strong></h3><h4 id="1-什么是不可变性？"><a href="#1-什么是不可变性？" class="headerlink" title="1. 什么是不可变性？"></a><strong>1. 什么是不可变性？</strong></h4><ul><li><strong>原始数据类型的值是不可变的</strong>：它们的值本身不能被修改。任何操作都会返回一个新的值，而不是修改原始值。</li><li><strong>变量可以重新赋值</strong>：变量是一个存储值的容器，它可以指向不同的值，但不会修改原始值。</li></ul><h4 id="2-例子说明"><a href="#2-例子说明" class="headerlink" title="2. 例子说明"></a><strong>2. 例子说明</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>; <span class="comment">// a 存储的是原始值 1</span></span><br><span class="line">a = <span class="number">2</span>;     <span class="comment">// a 被重新赋值为原始值 2</span></span><br></pre></td></tr></table></figure><ul><li><code>1</code> 和 <code>2</code> 是独立的原始值，<code>1</code> 没有被修改，只是 <code>a</code> 指向了新的值。</li></ul><h4 id="3-对比引用数据类型"><a href="#3-对比引用数据类型" class="headerlink" title="3. 对比引用数据类型"></a><strong>3. 对比引用数据类型</strong></h4><ul><li><strong>引用数据类型是可变的</strong>：它们的值可以被修改。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span> &#125;;</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;Bob&quot;</span>; <span class="comment">// 修改了对象的值</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-原始数据类型的不可变性示例"><a href="#4-原始数据类型的不可变性示例" class="headerlink" title="4. 原始数据类型的不可变性示例"></a><strong>4. 原始数据类型的不可变性示例</strong></h4><ul><li><strong>字符串的不可变性</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&quot;H&quot;</span>; <span class="comment">// 尝试修改字符串的第一个字符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// 输出 &quot;hello&quot;，字符串未被修改</span></span><br></pre></td></tr></table></figure></li><li><strong>数字的不可变性</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">num = num + <span class="number">1</span>; <span class="comment">// 返回一个新的值 2，而不是修改 1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-为什么原始数据类型是不可变的？"><a href="#5-为什么原始数据类型是不可变的？" class="headerlink" title="5. 为什么原始数据类型是不可变的？"></a><strong>5. 为什么原始数据类型是不可变的？</strong></h4><ul><li><strong>性能优化</strong>：原始数据类型的不可变性使得它们可以被高效地存储和比较。</li><li><strong>安全性</strong>：不可变性避免了意外的修改，使代码更加可预测。</li><li><strong>简化设计</strong>：不可变性简化了语言的设计和实现。</li></ul><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a><strong>6. 总结</strong></h4><ul><li><strong>原始数据类型的值是不可变的</strong>：它们的值本身不能被修改。</li><li><strong>变量可以重新赋值</strong>：变量可以指向不同的值，但不会修改原始值。</li><li><strong>引用数据类型是可变的</strong>：它们的值可以被修改。</li></ul><p>通过理解原始数据类型的不可变性，可以更好地掌握 JavaScript 的基本特性，并编写更高效、可预测的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 JavaScript 中，数据类型可以分为两大类：&lt;strong&gt;原始数据类型（Primitive Types）&lt;/strong&gt; 和 &lt;strong&gt;引用数据类型（Reference Types）&lt;/strong&gt;。以下是具体分类：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>伪类和伪元素</title>
    <link href="https://promptonce.github.io/2025/03/09/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    <id>https://promptonce.github.io/2025/03/09/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/</id>
    <published>2025-03-09T04:06:47.000Z</published>
    <updated>2025-03-09T04:12:21.588Z</updated>
    
    <content type="html"><![CDATA[<p>伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。</p><p>a:link,<br>a:visited {<br>  color: rebeccapurple;<br>  font-weight: bold;<br>}</p><p>a:hover {<br>  color: hotpink;<br>}</p><p>伪元素以类似方式表现。不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。</p><p>article p:first-child::first-line {<br>  font-size: 120%;<br>  font-weight: bold;<br>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。&lt;/p&gt;
&lt;p&gt;a:link,</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VSCode Copilot AI提效总结</title>
    <link href="https://promptonce.github.io/2025/03/08/VSCode-Copilot-AI%E6%8F%90%E6%95%88%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2025/03/08/VSCode-Copilot-AI%E6%8F%90%E6%95%88%E6%80%BB%E7%BB%93/</id>
    <published>2025-03-08T15:40:14.000Z</published>
    <updated>2025-03-08T15:40:14.429Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>在Windows Server上为Tomcat和Nginx配置HTTPS的完整指南</title>
    <link href="https://promptonce.github.io/2025/03/08/%E5%9C%A8Windows-Server%E4%B8%8A%E4%B8%BATomcat%E5%92%8CNginx%E9%85%8D%E7%BD%AEHTTPS%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/"/>
    <id>https://promptonce.github.io/2025/03/08/%E5%9C%A8Windows-Server%E4%B8%8A%E4%B8%BATomcat%E5%92%8CNginx%E9%85%8D%E7%BD%AEHTTPS%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</id>
    <published>2025-03-08T15:32:21.000Z</published>
    <updated>2025-03-08T15:33:19.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在今天的互联网环境中，启用HTTPS是保障网站安全性和用户信任的重要措施。本文将以<strong>Tomcat + Nginx</strong>组合为例，详细介绍在<strong>Windows Server</strong>系统下如何通过腾讯云SSL证书配置HTTPS，并实现HTTP到HTTPS的自动跳转。</p><hr><h2 id="一、获取SSL证书（腾讯云版）"><a href="#一、获取SSL证书（腾讯云版）" class="headerlink" title="一、获取SSL证书（腾讯云版）"></a>一、获取SSL证书（腾讯云版）</h2><h3 id="1-1-购买并申请证书"><a href="#1-1-购买并申请证书" class="headerlink" title="1.1 购买并申请证书"></a>1.1 购买并申请证书</h3><ol><li><p><strong>登录腾讯云控制台</strong><br>访问 <a href="https://console.cloud.tencent.com/ssl">腾讯云SSL证书控制台</a>，选择「证书管理」 &gt; 「我的证书」。</p></li><li><p><strong>申请免费证书（或购买付费证书）</strong>  </p><ul><li><strong>免费证书</strong>：点击「申请免费证书」，填写域名信息（例如 <code>example.com</code> 或 <code>*.example.com</code>）。  </li><li><strong>付费证书</strong>：选择OV或EV类型证书，按需购买后提交域名验证信息。</li></ul></li><li><p><strong>完成域名验证</strong>  </p><ul><li><strong>自动DNS验证</strong>（推荐）：若域名解析托管在腾讯云DNSPod，系统自动添加TXT记录。  </li><li><strong>手动验证</strong>：在其他DNS服务商处，按指引添加指定的TXT记录。</li></ul></li><li><p><strong>下载证书</strong><br>验证通过后，证书状态变为「已颁发」，点击「下载证书」，选择 <strong>Nginx</strong> 类型的证书文件（包含<code>.crt</code>和<code>.key</code>）。</p></li></ol><h3 id="1-2-证书文件说明"><a href="#1-2-证书文件说明" class="headerlink" title="1.2 证书文件说明"></a>1.2 证书文件说明</h3><p>下载的证书包解压后包含：</p><ul><li><strong>域名名称.crt</strong>：证书文件（包含证书链）</li><li><strong>域名名称.key</strong>：私钥文件</li><li>其他说明文件（如CSR文件）</li></ul><p><strong>保存路径示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\ssl\example.com.crt   # 证书文件</span><br><span class="line">C:\ssl\example.com.key   # 私钥文件</span><br></pre></td></tr></table></figure><hr><h2 id="二、配置Nginx作为HTTPS反向代理"><a href="#二、配置Nginx作为HTTPS反向代理" class="headerlink" title="二、配置Nginx作为HTTPS反向代理"></a>二、配置Nginx作为HTTPS反向代理</h2><h3 id="2-1-修改Nginx配置文件"><a href="#2-1-修改Nginx配置文件" class="headerlink" title="2.1 修改Nginx配置文件"></a>2.1 修改Nginx配置文件</h3><p>编辑 <code>nginx.conf</code>，添加以下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 腾讯云证书路径（注意使用正斜杠）</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      C:/ssl/example.com.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  C:/ssl/example.com.key;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启用强加密协议</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 反向代理到Tomcat的HTTP端口</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8080;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制HTTP跳转到HTTPS</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-重启Nginx服务"><a href="#2-2-重启Nginx服务" class="headerlink" title="2.2 重启Nginx服务"></a>2.2 重启Nginx服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><hr><h2 id="三、配置Tomcat支持代理（可选）"><a href="#三、配置Tomcat支持代理（可选）" class="headerlink" title="三、配置Tomcat支持代理（可选）"></a>三、配置Tomcat支持代理（可选）</h2><p>确保Tomcat能正确生成HTTPS链接（如重定向或URL构建）：<br>修改 <code>conf/server.xml</code>，找到HTTP连接器并添加<code>proxyName</code>和<code>proxyPort</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;443&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">proxyName</span>=<span class="string">&quot;example.com&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">proxyPort</span>=<span class="string">&quot;443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="四、验证HTTPS配置"><a href="#四、验证HTTPS配置" class="headerlink" title="四、验证HTTPS配置"></a>四、验证HTTPS配置</h2><ol><li><p><strong>访问测试</strong><br>浏览器打开 <code>https://example.com</code>，确认地址栏显示锁标志，并检查证书颁发者为腾讯云。</p></li><li><p><strong>SSL检测</strong><br>使用 <a href="https://www.ssllabs.com/ssltest/">SSL Labs测试工具</a> 检查配置安全性，确保评级为A或A+。</p></li></ol><hr><h2 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h2><ol><li><p><strong>证书有效期</strong><br>免费证书有效期为1年，付费证书为1-2年，需在到期前登录腾讯云控制台续费或重新申请。</p></li><li><p><strong>私钥安全</strong><br><code>.key</code> 文件为敏感信息，需设置严格的文件权限（仅允许管理员和Nginx进程访问）。</p></li><li><p><strong>多域名支持</strong><br>若需为多个域名配置HTTPS，可在Nginx中创建多个<code>server</code>块，并分别指定对应的证书路径。</p></li><li><p><strong>证书链完整性</strong><br>腾讯云提供的<code>.crt</code>文件已包含完整证书链，无需额外拼接中间证书。</p></li></ol><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过腾讯云SSL证书服务，您可以快速为Tomcat和Nginx架构启用HTTPS，显著提升网站的安全性和可信度。配合Nginx的高性能反向代理，既能保障数据传输安全，又能优化静态资源加载速度。建议定期检查证书有效期，并通过自动化脚本或腾讯云提醒功能及时续期，确保持续稳定的服务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在今天的互联网环境中，启用HTTPS是保障网站安全性和用户信任的重要措施。本文将以&lt;strong&gt;Tomcat + Nginx&lt;/stron</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>细节处理：软件工程师的隐形分水岭</title>
    <link href="https://promptonce.github.io/2025/03/05/%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86%EF%BC%9A%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E9%9A%90%E5%BD%A2%E5%88%86%E6%B0%B4%E5%B2%AD/"/>
    <id>https://promptonce.github.io/2025/03/05/%E7%BB%86%E8%8A%82%E5%A4%84%E7%90%86%EF%BC%9A%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E9%9A%90%E5%BD%A2%E5%88%86%E6%B0%B4%E5%B2%AD/</id>
    <published>2025-03-04T16:17:57.000Z</published>
    <updated>2025-03-04T16:19:10.050Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发的浩瀚宇宙中，代码的功能实现往往被视为工程师的“硬实力”，而细节处理则像是隐藏在幕后的“暗物质”——虽不易察觉，却决定了整个系统的稳定性和生命力。对于软件工程师而言，能否精准把控细节，往往是区分“完成任务”与“交付卓越”的关键分水岭。</p><h3 id="一、细节：代码质量的灵魂"><a href="#一、细节：代码质量的灵魂" class="headerlink" title="一、细节：代码质量的灵魂"></a>一、细节：代码质量的灵魂</h3><p>一段能运行的代码并不等同于高质量的代码。比如，一个忽略空指针检查的函数可能在测试中侥幸通过，但在生产环境中却可能引发灾难性崩溃。<strong>看似微小的疏漏，可能成为系统瘫痪的导火索</strong>。优秀的工程师会为每个变量赋初始值，为每个接口设计清晰的错误码，甚至在代码缩进和命名规范上追求极致。这些细节不仅提升了代码的可维护性，更在团队协作中减少了“破窗效应”带来的技术债务。</p><h3 id="二、系统稳定性的“蝴蝶效应”"><a href="#二、系统稳定性的“蝴蝶效应”" class="headerlink" title="二、系统稳定性的“蝴蝶效应”"></a>二、系统稳定性的“蝴蝶效应”</h3><p>2022年某知名云服务商的大规模宕机事件，根源竟是一个未正确处理的日期格式化异常。这类案例揭示了一个残酷真相：<strong>系统崩溃往往始于被轻视的“小问题”</strong>。工程师需要培养“防御性编程”思维：在写入文件时检查磁盘空间，在网络请求中设置超时熔断，对用户输入进行多层校验。这些细节如同安全气囊，在意外发生时为系统提供缓冲空间。</p><h3 id="三、用户体验的魔鬼在细节中"><a href="#三、用户体验的魔鬼在细节中" class="headerlink" title="三、用户体验的魔鬼在细节中"></a>三、用户体验的魔鬼在细节中</h3><p>当用户因为0.5秒的加载延迟而流失，或因为一个模糊的错误提示放弃操作时，功能完备性便失去了意义。<strong>用户体验的竞争本质上是细节颗粒度的竞争</strong>。工程师需要关注：日志系统是否能快速定位问题？API响应是否包含可读的错误信息？缓存机制是否考虑了冷启动场景？甚至一个按钮的加载状态动画，都可能成为留存率的关键变量。</p><h3 id="四、细节驱动的工程文化"><a href="#四、细节驱动的工程文化" class="headerlink" title="四、细节驱动的工程文化"></a>四、细节驱动的工程文化</h3><p>卓越的软件团队往往建立细节导向的工作机制：</p><ul><li><strong>代码审查清单</strong>：将常见陷阱（如内存泄漏、竞态条件）固化为审查标准</li><li><strong>自动化质量门禁</strong>：通过静态代码分析、单元测试覆盖率等指标卡点</li><li><strong>故障预演文化</strong>：定期开展混沌工程演练，主动暴露系统脆弱点</li><li><strong>可观测性设计</strong>：在系统设计阶段就埋入监控埋点，让细节问题无所遁形</li></ul><h3 id="五、修炼细节思维的三个阶梯"><a href="#五、修炼细节思维的三个阶梯" class="headerlink" title="五、修炼细节思维的三个阶梯"></a>五、修炼细节思维的三个阶梯</h3><ol><li><strong>工具化</strong>：利用IDE的Lint工具、SonarQube等自动化检测手段</li><li><strong>模式化</strong>：建立个人checklist（如发布前的10项验证）</li><li><strong>直觉化</strong>：通过代码嗅觉（Code Smell）训练，形成条件反射式的细节敏感度</li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>在人工智能逐渐接管重复性编码工作的今天，对细节的掌控能力正成为软件工程师不可替代的核心竞争力。那些愿意在边界条件上多思考一步、在错误处理上多写两行代码、在用户流程中多模拟一次的工程师，终将在技术变革的浪潮中构筑起自己的护城河。毕竟，软件工程的终极艺术，在于用无数精密咬合的细节，搭建起坚如磐石的数字世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在软件开发的浩瀚宇宙中，代码的功能实现往往被视为工程师的“硬实力”，而细节处理则像是隐藏在幕后的“暗物质”——虽不易察觉，却决定了整个系统的稳定性和生命力。对于软件工程师而言，能否精准把控细节，往往是区分“完成任务”与“交付卓越”的关键分水岭。&lt;/p&gt;
&lt;h3 id=&quot;一、</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>程序员学多门编程语言是“博学”还是“内耗”？一篇讲透真相</title>
    <link href="https://promptonce.github.io/2025/03/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AD%A6%E5%A4%9A%E9%97%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%98%AF%E2%80%9C%E5%8D%9A%E5%AD%A6%E2%80%9D%E8%BF%98%E6%98%AF%E2%80%9C%E5%86%85%E8%80%97%E2%80%9D%EF%BC%9F%E4%B8%80%E7%AF%87%E8%AE%B2%E9%80%8F%E7%9C%9F%E7%9B%B8/"/>
    <id>https://promptonce.github.io/2025/03/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AD%A6%E5%A4%9A%E9%97%A8%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%98%AF%E2%80%9C%E5%8D%9A%E5%AD%A6%E2%80%9D%E8%BF%98%E6%98%AF%E2%80%9C%E5%86%85%E8%80%97%E2%80%9D%EF%BC%9F%E4%B8%80%E7%AF%87%E8%AE%B2%E9%80%8F%E7%9C%9F%E7%9B%B8/</id>
    <published>2025-03-04T16:14:54.000Z</published>
    <updated>2025-03-04T16:16:55.738Z</updated>
    
    <content type="html"><![CDATA[<p>在程序员社群里，关于“该学多少门语言”的争论从未停止。<br>有人说：“语言只是工具，精通一门就够了！”<br>也有人反驳：“不懂多语言，永远成不了架构师！”<br><strong>事实究竟如何？</strong> 本文用 3000 字深度解析这个问题，帮你找到最适合自己的答案。</p><hr><h2 id="一、多语言学习的「隐藏收益」：远超你想象的认知升级"><a href="#一、多语言学习的「隐藏收益」：远超你想象的认知升级" class="headerlink" title="一、多语言学习的「隐藏收益」：远超你想象的认知升级"></a>一、多语言学习的「隐藏收益」：远超你想象的认知升级</h2><h3 id="1-破解“思维定式”的终极武器"><a href="#1-破解“思维定式”的终极武器" class="headerlink" title="1. 破解“思维定式”的终极武器"></a>1. 破解“思维定式”的终极武器</h3><ul><li><strong>案例对比</strong>：<br>只会 Java 的程序员在处理数据管道时，第一反应是写 <code>for 循环 + ArrayList</code>；<br>学过 Python 的开发者会直接使用 <code>生成器表达式</code> 节省内存，而接触过 Scala 的人可能选择 <code>惰性求值</code> 方案。  </li><li><strong>范式迁移实验</strong>：<br>尝试用 Haskell 实现一个简单的电商促销逻辑（无可变状态），你会被迫重新思考：<br><em>“如何不用变量累加，仅靠递归和模式匹配完成任务？”</em></li></ul><h3 id="2-技术选型的“降维打击”能力"><a href="#2-技术选型的“降维打击”能力" class="headerlink" title="2. 技术选型的“降维打击”能力"></a>2. 技术选型的“降维打击”能力</h3><p>当团队争论该用哪种技术方案时，多语言背景的程序员常能一锤定音：  </p><table><thead><tr><th><strong>场景</strong></th><th><strong>单一语言方案</strong></th><th><strong>多语言最优解</strong></th></tr></thead><tbody><tr><td>高并发消息队列</td><td>Java 线程池</td><td>Go 的 goroutine + channel</td></tr><tr><td>实时日志分析</td><td>Python 多进程</td><td>Rust 的零成本异步 + SIMD 优化</td></tr><tr><td>跨平台桌面应用</td><td>Electron 性能瓶颈</td><td>Flutter + Rust FFI 混合开发</td></tr></tbody></table><h3 id="3-职业护城河的构建密码"><a href="#3-职业护城河的构建密码" class="headerlink" title="3. 职业护城河的构建密码"></a>3. 职业护城河的构建密码</h3><p>2024 年 StackOverflow 调查显示：  </p><ul><li><strong>全栈工程师</strong> 平均薪资比单一领域开发者高 <strong>23%</strong>  </li><li>会 Rust 的程序员招聘需求年增长 <strong>189%</strong>  </li><li>同时掌握 <strong>Go + Python + SQL</strong> 成为云原生岗位标配</li></ul><hr><h2 id="二、暗礁密布：多语言学习中的「致命陷阱」"><a href="#二、暗礁密布：多语言学习中的「致命陷阱」" class="headerlink" title="二、暗礁密布：多语言学习中的「致命陷阱」"></a>二、暗礁密布：多语言学习中的「致命陷阱」</h2><h3 id="1-时间黑洞：一个真实开发者的学习账单"><a href="#1-时间黑洞：一个真实开发者的学习账单" class="headerlink" title="1. 时间黑洞：一个真实开发者的学习账单"></a>1. 时间黑洞：一个真实开发者的学习账单</h3><p>以每天投入 2 小时计算：  </p><table><thead><tr><th><strong>语言</strong></th><th>入门基础</th><th>项目实战</th><th>原理深挖</th><th>总耗时</th></tr></thead><tbody><tr><td>JavaScript</td><td>1个月</td><td>3个月</td><td>6个月</td><td>300h</td></tr><tr><td>Rust</td><td>2个月</td><td>6个月</td><td>1年+</td><td>500h</td></tr><tr><td>Haskell</td><td>3个月</td><td>1年</td><td>2年+</td><td>800h</td></tr></tbody></table><p><strong>残酷现实</strong>：如果同时学习 3 门语言，可能花费 1600 小时却无法胜任任何高级岗位。</p><h3 id="2-认知污染：那些年我们犯过的“跨语言错误”"><a href="#2-认知污染：那些年我们犯过的“跨语言错误”" class="headerlink" title="2. 认知污染：那些年我们犯过的“跨语言错误”"></a>2. 认知污染：那些年我们犯过的“跨语言错误”</h3><ul><li><strong>语法混搭灾难</strong>：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Python 中写 C 风格代码</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  <span class="comment"># 报错！</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>范式滥用惨案</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Java 中强行模仿函数式编程</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">list.stream().forEach(x -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(x);  <span class="comment">// 实际业务中常导致资源泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-深度幻觉：你以为的“精通”可能只是-API-调用师"><a href="#3-深度幻觉：你以为的“精通”可能只是-API-调用师" class="headerlink" title="3. 深度幻觉：你以为的“精通”可能只是 API 调用师"></a>3. 深度幻觉：你以为的“精通”可能只是 API 调用师</h3><ul><li><strong>表面技能</strong>：<br>“我能用 Python 的 TensorFlow 训练模型”  </li><li><strong>深层差距</strong>：  <ul><li>是否理解 CUDA 内核与 Python GIL 的交互？  </li><li>能否用 C++ 重写性能瓶颈模块？  </li><li>是否能在 JAX 中复现相同逻辑以利用 TPU 加速？</li></ul></li></ul><hr><h2 id="三、黄金法则：聪明人的多语言学习路线图"><a href="#三、黄金法则：聪明人的多语言学习路线图" class="headerlink" title="三、黄金法则：聪明人的多语言学习路线图"></a>三、黄金法则：聪明人的多语言学习路线图</h2><h3 id="1-三阶学习法：像打游戏升级一样规划路径"><a href="#1-三阶学习法：像打游戏升级一样规划路径" class="headerlink" title="1. 三阶学习法：像打游戏升级一样规划路径"></a>1. 三阶学习法：像打游戏升级一样规划路径</h3><table><thead><tr><th><strong>阶段</strong></th><th>目标</th><th>推荐语言组合</th><th>关键动作</th></tr></thead><tbody><tr><td>青铜阶段</td><td>建立编程思维</td><td>Python&#x2F;JavaScript</td><td>完成 3 个完整项目</td></tr><tr><td>白银阶段</td><td>理解系统原理</td><td>C + Java&#x2F;Go</td><td>阅读开源项目源码</td></tr><tr><td>王者阶段</td><td>掌握范式本质</td><td>Rust&#x2F;Haskell + 领域语言</td><td>参与编译器&#x2F;框架开发</td></tr></tbody></table><h3 id="2-领域聚焦策略：选对赛道事半功倍"><a href="#2-领域聚焦策略：选对赛道事半功倍" class="headerlink" title="2. 领域聚焦策略：选对赛道事半功倍"></a>2. 领域聚焦策略：选对赛道事半功倍</h3><ul><li><p><strong>Web 开发者</strong>：<br><strong>核心语言</strong>：TypeScript<br><strong>扩展语言</strong>：Go（后端优化）、Rust（WASM 性能突破）<br><strong>学习路径</strong>：React → Next.js → Actix-Web → WASM 混编  </p></li><li><p><strong>数据工程师</strong>：<br><strong>核心语言</strong>：Python<br><strong>扩展语言</strong>：Julia（高性能计算）、SQL（高级优化）<br><strong>学习路径</strong>：Pandas → PySpark → CUDA 编程 → 分布式查询优化</p></li></ul><h3 id="3-元技能训练：超越语言的学习心法"><a href="#3-元技能训练：超越语言的学习心法" class="headerlink" title="3. 元技能训练：超越语言的学习心法"></a>3. 元技能训练：超越语言的学习心法</h3><ul><li><strong>编译原理实战</strong>：<br>用 ANTLR 为自创的 DSL 语言写解析器，理解词法&#x2F;语法分析的通用逻辑。  </li><li><strong>跨语言调试</strong>：<br>在 VS Code 中同时调试 Java 微服务和 Python 数据管道，掌握多进程追踪技巧。  </li><li><strong>性能对比实验</strong>：<br>用 5 种语言实现同一个算法（如快速排序），用火焰图分析各语言运行时特征。</li></ul><hr><h2 id="四、灵魂拷问：你究竟需不需要学多门语言？"><a href="#四、灵魂拷问：你究竟需不需要学多门语言？" class="headerlink" title="四、灵魂拷问：你究竟需不需要学多门语言？"></a>四、灵魂拷问：你究竟需不需要学多门语言？</h2><h3 id="1-立即开始多语言学习的-3-个信号"><a href="#1-立即开始多语言学习的-3-个信号" class="headerlink" title="1. 立即开始多语言学习的 3 个信号"></a>1. 立即开始多语言学习的 3 个信号</h3><ul><li>✅ 发现现有语言无法优雅解决某些问题（如 Python 的 GIL 限制）  </li><li>✅ 工作需要频繁对接不同技术栈（如用 C++ 库优化 Java 服务）  </li><li>✅ 长期从事基础架构或工具链开发（需理解跨语言交互）</li></ul><h3 id="2-应该暂停学习的-3-个危险标志"><a href="#2-应该暂停学习的-3-个危险标志" class="headerlink" title="2. 应该暂停学习的 3 个危险标志"></a>2. 应该暂停学习的 3 个危险标志</h3><ul><li>❌ 无法用主语言实现红黑树等基础数据结构  </li><li>❌ 对当前语言的编译&#x2F;解释机制一无所知  </li><li>❌ 简历中超过 50% 的技能标签停留在“了解”阶段</li></ul><h3 id="3-终极决策公式"><a href="#3-终极决策公式" class="headerlink" title="3. 终极决策公式"></a>3. 终极决策公式</h3><p>[ \text{学习收益} &#x3D; \frac{\text{目标领域交叉需求} \times \text{已有语言深度}}{\text{时间成本} \times \text{认知负荷}} ]<br><strong>当该值 &gt;1 时</strong>：果断开始多语言学习<br><strong>当该值 &lt;0.5 时</strong>：优先深耕现有技术栈  </p><hr><h2 id="五、写给不同段位程序员的行动清单"><a href="#五、写给不同段位程序员的行动清单" class="headerlink" title="五、写给不同段位程序员的行动清单"></a>五、写给不同段位程序员的行动清单</h2><h3 id="1-初级开发者（0-2年）"><a href="#1-初级开发者（0-2年）" class="headerlink" title="1. 初级开发者（0-2年）"></a>1. 初级开发者（0-2年）</h3><ul><li><strong>必做</strong>：用主语言实现一个编译器&#x2F;解释器（如 TinyPython）  </li><li><strong>避坑</strong>：在 LeetCode 300 题前不要接触第二门语言  </li><li><strong>资源</strong>：《Crafting Interpreters》+ CPython 源码导读</li></ul><h3 id="2-中级工程师（2-5年）"><a href="#2-中级工程师（2-5年）" class="headerlink" title="2. 中级工程师（2-5年）"></a>2. 中级工程师（2-5年）</h3><ul><li><strong>必做</strong>：参与跨语言开源项目（如 Apache Arrow）  </li><li><strong>神器</strong>：  <ul><li><strong>WebAssembly</strong>：打通任意语言到浏览器的路径  </li><li><strong>GRPC</strong>：实践多语言微服务通信</li></ul></li><li><strong>书籍</strong>：《Seven Languages in Seven Weeks》</li></ul><h3 id="3-技术专家（5年-）"><a href="#3-技术专家（5年-）" class="headerlink" title="3. 技术专家（5年+）"></a>3. 技术专家（5年+）</h3><ul><li><strong>必做</strong>：设计一门领域特定语言（DSL）  </li><li><strong>挑战</strong>：  <ul><li>用 Rust 重写 Python 性能关键模块  </li><li>在 JVM 上运行 Erlang 风格的 Actor 模型</li></ul></li><li><strong>终极目标</strong>：成为《计算机程序的构造与解释》中的“元程序员”</li></ul><hr><h2 id="结语：超越语言之争"><a href="#结语：超越语言之争" class="headerlink" title="结语：超越语言之争"></a>结语：超越语言之争</h2><p>当你在多语言学习中感到困惑时，请记住 Linus Torvalds 的忠告：<br><strong>“烂程序员关心代码用什么语言写，伟大程序员关心代码解决了什么问题。”</strong>  </p><p>2024 年的技术生态正在发生剧变：  </p><ul><li><strong>Zig</strong> 挑战 C 语言的统治地位  </li><li><strong>Mojo</strong> 试图统一 Python 生态与硬件加速  </li><li><strong>WebAssembly</strong> 正在打破前后端边界</li></ul><p>在这样的时代，<strong>“学习能力”本身才是最核心的编程语言</strong>。你现在准备解锁哪种新技能？欢迎在评论区开启你的多语言之旅！</p><hr><p><strong>推荐扩展阅读</strong>：  </p><ul><li><a href="https://example.com/tech-radar">2024 开发者技能雷达</a>  </li><li><a href="https://example.com/llvm-guide">从 LLVM 看多语言编译原理</a>  </li><li><a href="https://example.com/google-case">我在谷歌用 5 种语言写同一个系统</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在程序员社群里，关于“该学多少门语言”的争论从未停止。&lt;br&gt;有人说：“语言只是工具，精通一门就够了！”&lt;br&gt;也有人反驳：“不懂多语言，永远成不了架构师！”&lt;br&gt;&lt;strong&gt;事实究竟如何？&lt;/strong&gt; 本文用 3000 字深度解析这个问题，帮你找到最适合自己的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用 HTML、CSS 和 JavaScript 实现可拖拽内部框</title>
    <link href="https://promptonce.github.io/2025/03/04/%E4%BD%BF%E7%94%A8-HTML%E3%80%81CSS-%E5%92%8C-JavaScript-%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8B%96%E6%8B%BD%E5%86%85%E9%83%A8%E6%A1%86/"/>
    <id>https://promptonce.github.io/2025/03/04/%E4%BD%BF%E7%94%A8-HTML%E3%80%81CSS-%E5%92%8C-JavaScript-%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8B%96%E6%8B%BD%E5%86%85%E9%83%A8%E6%A1%86/</id>
    <published>2025-03-04T04:38:25.000Z</published>
    <updated>2025-03-04T04:39:20.847Z</updated>
    
    <content type="html"><![CDATA[<p>在 Web 开发中，实现拖拽功能是一个常见需求，例如可拖拽对话框、图像排版等。本篇博客将介绍如何使用 HTML、CSS 和 JavaScript 实现一个可拖拽的内部框，并确保它不会超出外框的范围。</p><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h2><p>我们希望实现如下效果：</p><ul><li>页面中有一个固定大小的外框 (<code>.outer-box</code>)。</li><li>内部框 (<code>.inner-box</code>) 可以在外框内自由拖拽。</li><li>鼠标按下时开始拖动，松开后固定在新位置。</li><li>内部框的拖拽范围不会超出外框。</li></ul><h2 id="2-HTML-结构"><a href="#2-HTML-结构" class="headerlink" title="2. HTML 结构"></a>2. HTML 结构</h2><p>我们使用 HTML 结构定义外框和内部框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer-box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner-box&quot;</span> <span class="attr">id</span>=<span class="string">&quot;draggable&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-CSS-样式"><a href="#3-CSS-样式" class="headerlink" title="3. CSS 样式"></a>3. CSS 样式</h2><p>通过 CSS 进行基本样式设置：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.outer-box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid black;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner-box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: grab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-JavaScript-逻辑"><a href="#4-JavaScript-逻辑" class="headerlink" title="4. JavaScript 逻辑"></a>4. JavaScript 逻辑</h2><p>我们使用 JavaScript 监听鼠标事件，实现拖拽逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> innerBox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;draggable&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> offsetX, offsetY, isDragging = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">innerBox.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousedown&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    isDragging = <span class="literal">true</span>;</span><br><span class="line">    offsetX = e.<span class="property">clientX</span> - innerBox.<span class="property">offsetLeft</span>;</span><br><span class="line">    offsetY = e.<span class="property">clientY</span> - innerBox.<span class="property">offsetTop</span>;</span><br><span class="line">    innerBox.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&quot;grabbing&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDragging) &#123;</span><br><span class="line">        <span class="keyword">let</span> newX = e.<span class="property">clientX</span> - offsetX;</span><br><span class="line">        <span class="keyword">let</span> newY = e.<span class="property">clientY</span> - offsetY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制内部框不能拖出外框</span></span><br><span class="line">        <span class="keyword">const</span> outerBox = innerBox.<span class="property">parentElement</span>;</span><br><span class="line">        newX = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(outerBox.<span class="property">clientWidth</span> - innerBox.<span class="property">clientWidth</span>, newX));</span><br><span class="line">        newY = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(outerBox.<span class="property">clientHeight</span> - innerBox.<span class="property">clientHeight</span>, newY));</span><br><span class="line"></span><br><span class="line">        innerBox.<span class="property">style</span>.<span class="property">left</span> = <span class="string">`<span class="subst">$&#123;newX&#125;</span>px`</span>;</span><br><span class="line">        innerBox.<span class="property">style</span>.<span class="property">top</span> = <span class="string">`<span class="subst">$&#123;newY&#125;</span>px`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;mouseup&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    isDragging = <span class="literal">false</span>;</span><br><span class="line">    innerBox.<span class="property">style</span>.<span class="property">cursor</span> = <span class="string">&quot;grab&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="5-代码解析"><a href="#5-代码解析" class="headerlink" title="5. 代码解析"></a>5. 代码解析</h2><h3 id="5-1-监听-mousedown-事件"><a href="#5-1-监听-mousedown-事件" class="headerlink" title="5.1 监听 mousedown 事件"></a>5.1 监听 <code>mousedown</code> 事件</h3><p>当用户按下鼠标，我们记录鼠标相对于内部框的偏移量 (<code>offsetX</code>, <code>offsetY</code>)，并标记 <code>isDragging = true</code>。</p><h3 id="5-2-监听-mousemove-事件"><a href="#5-2-监听-mousemove-事件" class="headerlink" title="5.2 监听 mousemove 事件"></a>5.2 监听 <code>mousemove</code> 事件</h3><p>当鼠标移动时，如果 <code>isDragging</code> 为 <code>true</code>，我们计算内部框的新位置，并确保它不会超出外框范围。</p><h3 id="5-3-监听-mouseup-事件"><a href="#5-3-监听-mouseup-事件" class="headerlink" title="5.3 监听 mouseup 事件"></a>5.3 监听 <code>mouseup</code> 事件</h3><p>当鼠标松开时，停止拖拽并恢复鼠标样式。</p><h2 id="6-运行效果"><a href="#6-运行效果" class="headerlink" title="6. 运行效果"></a>6. 运行效果</h2><p>实现后，内部框可以在外框内自由拖动，并在释放鼠标后固定。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>本文介绍了如何使用 HTML、CSS 和 JavaScript 实现一个可拖拽的内部框，同时限制其移动范围。该方法适用于各种拖拽交互，如窗口拖拽、滑块等。</p><p>如果你对前端开发感兴趣，可以尝试在此基础上增加动画效果或者触摸事件支持，以适应移动端需求！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Web 开发中，实现拖拽功能是一个常见需求，例如可拖拽对话框、图像排版等。本篇博客将介绍如何使用 HTML、CSS 和 JavaScript 实现一个可拖拽的内部框，并确保它不会超出外框的范围。&lt;/p&gt;
&lt;h2 id=&quot;1-需求分析&quot;&gt;&lt;a href=&quot;#1-需求分析&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>掌握Linux中的tar命令：打包、压缩与归档的终极指南</title>
    <link href="https://promptonce.github.io/2025/02/16/%E6%8E%8C%E6%8F%A1Linux%E4%B8%AD%E7%9A%84tar%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%89%93%E5%8C%85%E3%80%81%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%BD%92%E6%A1%A3%E7%9A%84%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/"/>
    <id>https://promptonce.github.io/2025/02/16/%E6%8E%8C%E6%8F%A1Linux%E4%B8%AD%E7%9A%84tar%E5%91%BD%E4%BB%A4%EF%BC%9A%E6%89%93%E5%8C%85%E3%80%81%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%BD%92%E6%A1%A3%E7%9A%84%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97/</id>
    <published>2025-02-16T03:08:20.000Z</published>
    <updated>2025-02-16T03:09:21.295Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="引言：为什么需要tar？"><a href="#引言：为什么需要tar？" class="headerlink" title="引言：为什么需要tar？"></a>引言：为什么需要tar？</h2><p>在Linux世界中，文件归档和压缩是每个用户必备的技能。无论是备份关键数据、迁移服务器文件，还是批量传输多个文档，<code>tar</code>命令始终是系统管理员和开发者的得力工具。作为Unix哲学的经典实践，这个诞生于1979年的工具通过简单的命令组合，即可实现强大的文件管理功能。</p><hr><h2 id="一、tar命令核心解析"><a href="#一、tar命令核心解析" class="headerlink" title="一、tar命令核心解析"></a>一、tar命令核心解析</h2><h3 id="1-基础语法结构"><a href="#1-基础语法结构" class="headerlink" title="1. 基础语法结构"></a>1. 基础语法结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [操作模式] [选项] [文件/目录]</span><br></pre></td></tr></table></figure><h3 id="2-关键操作模式"><a href="#2-关键操作模式" class="headerlink" title="2. 关键操作模式"></a>2. 关键操作模式</h3><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>创建新归档文件</td></tr><tr><td>-x</td><td>解压归档文件</td></tr><tr><td>-t</td><td>查看归档内容列表</td></tr><tr><td>-r</td><td>追加文件到归档末尾</td></tr><tr><td>-u</td><td>仅添加更新的文件</td></tr></tbody></table><h3 id="3-常用功能选项"><a href="#3-常用功能选项" class="headerlink" title="3. 常用功能选项"></a>3. 常用功能选项</h3><ul><li><strong>-v</strong>：显示详细处理过程（verbose）</li><li><strong>-f</strong>：指定归档文件名（必须为最后一个选项）</li><li><strong>-C</strong>：指定解压目录（change directory）</li><li><strong>-p</strong>：保留文件权限属性</li><li><strong>–exclude</strong>：排除指定模式的文件</li></ul><hr><h2 id="二、实战场景演示"><a href="#二、实战场景演示" class="headerlink" title="二、实战场景演示"></a>二、实战场景演示</h2><h3 id="1-基础文件打包与解压"><a href="#1-基础文件打包与解压" class="headerlink" title="1. 基础文件打包与解压"></a>1. 基础文件打包与解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建归档（保留目录结构）</span></span><br><span class="line">tar -cvf project_backup.tar /home/user/project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看归档内容</span></span><br><span class="line">tar -tvf project_backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压到当前目录</span></span><br><span class="line">tar -xvf project_backup.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压到指定目录</span></span><br><span class="line">tar -xvf project_backup.tar -C /opt/backups/</span><br></pre></td></tr></table></figure><h3 id="2-智能压缩方案选择"><a href="#2-智能压缩方案选择" class="headerlink" title="2. 智能压缩方案选择"></a>2. 智能压缩方案选择</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gzip压缩（*.tar.gz）</span></span><br><span class="line">tar -czvf photos.tar.gz /var/www/photos</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bzip2高压缩比（*.tar.bz2）</span></span><br><span class="line">tar -cjvf database.tar.bz2 /data/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># XZ极致压缩（*.tar.xz）</span></span><br><span class="line">tar -cJvf archive.tar.xz important_docs/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动识别解压格式</span></span><br><span class="line">tar -xvf compressed_file.tar.gz</span><br></pre></td></tr></table></figure><h3 id="3-高级管理技巧"><a href="#3-高级管理技巧" class="headerlink" title="3. 高级管理技巧"></a>3. 高级管理技巧</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增量备份（仅新于timestamp的文件）</span></span><br><span class="line">tar -cvf incremental.tar --newer-mtime=<span class="string">&#x27;2023-01-01&#x27;</span> /data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排除缓存文件和日志</span></span><br><span class="line">tar --exclude=<span class="string">&#x27;*.tmp&#x27;</span> --exclude=<span class="string">&#x27;*.log&#x27;</span> -czvf clean_backup.tar.gz /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分卷压缩（适合大文件传输）</span></span><br><span class="line">tar -czvf - big_file.iso | <span class="built_in">split</span> -b 2G - big_file_part</span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程备份（通过SSH管道）</span></span><br><span class="line">tar -czf - /srv/files | ssh user@backup-server <span class="string">&quot;cat &gt; /backups/remote.tar.gz&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="三、典型问题排错指南"><a href="#三、典型问题排错指南" class="headerlink" title="三、典型问题排错指南"></a>三、典型问题排错指南</h2><ol><li><p><strong>权限错误处理</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留SELinux上下文</span></span><br><span class="line">tar --selinux -czvf secure_backup.tar.gz /etc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解决解压后权限丢失</span></span><br><span class="line">tar -pxzvf backup.tar.gz</span><br></pre></td></tr></table></figure></li><li><p><strong>路径控制技巧</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建相对路径归档</span></span><br><span class="line">(<span class="built_in">cd</span> /var/log &amp;&amp; tar -czvf ~/logs_backup.tar.gz apache/ nginx/)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除绝对路径前缀</span></span><br><span class="line">tar -czvf safe_backup.tar.gz -C /etc/nginx sites-available/</span><br></pre></td></tr></table></figure></li><li><p><strong>空间不足预警</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预估归档大小</span></span><br><span class="line">tar -czf - /target_dir | <span class="built_in">wc</span> -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查磁盘剩余空间</span></span><br><span class="line"><span class="built_in">df</span> -h /destination_mount</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="四、效率优化建议"><a href="#四、效率优化建议" class="headerlink" title="四、效率优化建议"></a>四、效率优化建议</h2><ol><li><p><strong>压缩算法选择指南</strong></p><ul><li>gzip：快速压缩（默认-6压缩级别）</li><li>bzip2：高压缩率但较慢</li><li>xz：最高压缩率（适合网络传输）</li><li>zstd：新一代快速算法（需安装）</li></ul></li><li><p><strong>并行压缩加速</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用pigz多线程压缩（兼容gzip）</span></span><br><span class="line">tar -cvf - big_dir | pigz -9 -p 8 &gt; archive.tar.gz</span><br></pre></td></tr></table></figure></li><li><p><strong>加密敏感数据</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用GPG加密归档</span></span><br><span class="line">tar -czvf - secret_files | gpg -c &gt; backup.tar.gz.gpg</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="结语：成为tar高手的关键"><a href="#结语：成为tar高手的关键" class="headerlink" title="结语：成为tar高手的关键"></a>结语：成为tar高手的关键</h2><p>通过本文的30多个实用示例，您已经掌握了tar命令的核心用法。要真正精通这个工具，还需要：</p><ol><li>熟记常用选项组合（如<code>-cvzf</code>&#x2F;<code>-xzvf</code>）</li><li>理解不同压缩算法的适用场景</li><li>在脚本中合理使用tar进行自动化操作</li><li>定期使用<code>--verify</code>验证重要归档的完整性</li></ol><p>下次当您需要处理文件归档时，不妨尝试本文介绍的高级技巧。这个看似古老的工具，配合现代压缩算法，依然能在SSD时代大放异彩。</p><p><strong>小挑战</strong>：尝试用tar命令打包时实时显示进度条（提示：使用pv工具）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;引言：为什么需要tar？&quot;&gt;&lt;a href=&quot;#引言：为什么需要tar？&quot; class=&quot;headerlink&quot; title=&quot;引言：为什么需要tar？&quot;&gt;&lt;/a&gt;引言：为什么需要tar？&lt;/h2&gt;&lt;p&gt;在Linux世界中，文件归档和压缩是每个用户必备的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>理解 pip install -v -e 与普通 pip install 的核心区别</title>
    <link href="https://promptonce.github.io/2025/02/15/%E7%90%86%E8%A7%A3-pip-install-v-e-%E4%B8%8E%E6%99%AE%E9%80%9A-pip-install-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB/"/>
    <id>https://promptonce.github.io/2025/02/15/%E7%90%86%E8%A7%A3-pip-install-v-e-%E4%B8%8E%E6%99%AE%E9%80%9A-pip-install-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB/</id>
    <published>2025-02-15T14:22:29.000Z</published>
    <updated>2025-02-15T14:23:52.693Z</updated>
    
    <content type="html"><![CDATA[<p>在 Python 开发中，<code>pip</code> 是管理依赖的核心工具。但你是否遇到过以下困惑？  </p><ul><li>为什么修改本地代码后，需要重新 <code>pip install</code> 才能生效？  </li><li>如何实时调试自己开发的 Python 包？  </li><li>安装失败时如何查看详细日志？</li></ul><p>本文将深入对比 <code>pip install -v -e</code> 和普通 <code>pip install</code> 的区别，帮助你高效管理 Python 项目。</p><hr><h2 id="一、普通-pip-install：生产环境的默认选择"><a href="#一、普通-pip-install：生产环境的默认选择" class="headerlink" title="一、普通 pip install：生产环境的默认选择"></a>一、普通 <code>pip install</code>：生产环境的默认选择</h2><h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><ul><li><strong>安装位置</strong><br>将包下载并<strong>复制到 Python 的 <code>site-packages</code> 目录</strong>，例如：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/python3.9/site-packages/requests</span><br></pre></td></tr></table></figure></li><li><strong>代码行为</strong><br>安装的是<strong>静态文件</strong>（如 <code>.whl</code> 或 <code>.egg</code>），修改源码后必须重新安装才能生效。</li><li><strong>适用场景</strong><br>安装第三方稳定库（如 <code>requests</code>、<code>numpy</code>）到生产环境。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests  <span class="comment"># 从 PyPI 安装最新稳定版</span></span><br></pre></td></tr></table></figure><hr><h2 id="二、pip-install-v-e：开发者的利器"><a href="#二、pip-install-v-e：开发者的利器" class="headerlink" title="二、pip install -v -e：开发者的利器"></a>二、<code>pip install -v -e</code>：开发者的利器</h2><p>这是两个选项的组合：  </p><ul><li><strong><code>-v</code> (Verbose 模式)<strong>：打印</strong>详细安装日志</strong>，用于调试。  </li><li><strong><code>-e</code> (Editable 模式)<strong>：以“可编辑”模式安装，</strong>直接链接到本地源码</strong>。</li></ul><h3 id="核心区别"><a href="#核心区别" class="headerlink" title="核心区别"></a>核心区别</h3><table><thead><tr><th>特性</th><th>普通 <code>pip install</code></th><th><code>pip install -e</code></th></tr></thead><tbody><tr><td><strong>安装位置</strong></td><td><code>site-packages</code> 静态文件</td><td>通过符号链接指向源码目录</td></tr><tr><td><strong>代码修改生效</strong></td><td>需重新安装</td><td>实时生效</td></tr><tr><td><strong>适用场景</strong></td><td>生产环境</td><td>本地开发、调试</td></tr><tr><td><strong>依赖文件</strong></td><td>无需特殊配置</td><td>需 <code>setup.py</code> 或 <code>pyproject.toml</code></td></tr></tbody></table><hr><h3 id="Editable-模式（-e）详解"><a href="#Editable-模式（-e）详解" class="headerlink" title="Editable 模式（-e）详解"></a>Editable 模式（<code>-e</code>）详解</h3><h4 id="1-作用原理"><a href="#1-作用原理" class="headerlink" title="1. 作用原理"></a>1. 作用原理</h4><ul><li>在 <code>site-packages</code> 中生成一个 <strong><code>.egg-link</code> 文件</strong>，指向本地项目目录（而非复制代码）。  </li><li>Python 解释器运行时，会直接读取链接的源码。</li></ul><h4 id="2-使用条件"><a href="#2-使用条件" class="headerlink" title="2. 使用条件"></a>2. 使用条件</h4><p>项目目录需包含包配置（二者至少其一）：  </p><ul><li><code>setup.py</code>（传统方式）  </li><li><code>pyproject.toml</code>（PEP 621 现代标准）</li></ul><h4 id="3-典型用法"><a href="#3-典型用法" class="headerlink" title="3. 典型用法"></a>3. 典型用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目根目录（包含 setup.py）</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/my_package</span><br><span class="line">pip install -e .  <span class="comment"># 安装当前目录为可编辑模式</span></span><br></pre></td></tr></table></figure><h4 id="4-验证安装"><a href="#4-验证安装" class="headerlink" title="4. 验证安装"></a>4. 验证安装</h4><p>检查 <code>site-packages</code> 目录，会发现一个 <code>.egg-link</code> 文件：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /path/to/site-packages/my_package.egg-link</span><br><span class="line"><span class="comment"># 输出内容示例：/Users/me/dev/my_package</span></span><br></pre></td></tr></table></figure><hr><h3 id="Verbose-模式（-v）详解"><a href="#Verbose-模式（-v）详解" class="headerlink" title="Verbose 模式（-v）详解"></a>Verbose 模式（<code>-v</code>）详解</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>显示安装过程的<strong>完整日志</strong>，包括：  </p><ul><li>依赖解析步骤  </li><li>文件下载与解压  </li><li>编译过程（如 C 扩展）</li></ul><h4 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h4><ul><li>调试安装失败（如版本冲突、缺失依赖）  </li><li>查看隐式安装的依赖项</li></ul><h4 id="3-示例输出"><a href="#3-示例输出" class="headerlink" title="3. 示例输出"></a>3. 示例输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Using pip 23.1.2 from /usr/local/lib/python3.9/site-packages/pip (python 3.9)</span><br><span class="line">Processing /path/to/my_package</span><br><span class="line">  Running <span class="built_in">command</span> python setup.py egg_info</span><br><span class="line">  ...</span><br><span class="line">Successfully installed my_package-0.1.0</span><br></pre></td></tr></table></figure><hr><h2 id="三、何时使用哪种模式？"><a href="#三、何时使用哪种模式？" class="headerlink" title="三、何时使用哪种模式？"></a>三、何时使用哪种模式？</h2><h3 id="1-使用普通-pip-install-的情况"><a href="#1-使用普通-pip-install-的情况" class="headerlink" title="1. 使用普通 pip install 的情况"></a>1. 使用普通 <code>pip install</code> 的情况</h3><ul><li>部署生产环境  </li><li>安装不需要修改的第三方库  </li><li>需要明确的版本控制（如 <code>pip install package==1.4.0</code>）</li></ul><h3 id="2-使用-pip-install-e-的情况"><a href="#2-使用-pip-install-e-的情况" class="headerlink" title="2. 使用 pip install -e 的情况"></a>2. 使用 <code>pip install -e</code> 的情况</h3><ul><li><strong>开发自己的 Python 包</strong><br>修改代码后立即测试，无需重复安装。</li><li><strong>协作开发</strong><br>在 <code>requirements.txt</code> 中指定本地路径或 Git 仓库：  <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-e git+https://github.com/user/repo.git#egg=package</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-使用-v-的情况"><a href="#3-使用-v-的情况" class="headerlink" title="3. 使用 -v 的情况"></a>3. 使用 <code>-v</code> 的情况</h3><ul><li>安装过程报错时查看详细原因  </li><li>分析依赖树和安装流程</li></ul><hr><h2 id="四、实战示例"><a href="#四、实战示例" class="headerlink" title="四、实战示例"></a>四、实战示例</h2><h3 id="场景：开发一个本地工具包"><a href="#场景：开发一个本地工具包" class="headerlink" title="场景：开发一个本地工具包"></a>场景：开发一个本地工具包</h3><ol><li><p>项目结构  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_tools/</span><br><span class="line">├── setup.py</span><br><span class="line">└── my_tools/</span><br><span class="line">    └── __init__.py</span><br></pre></td></tr></table></figure></li><li><p>安装为可编辑模式  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my_tools</span><br><span class="line">pip install -e .  <span class="comment"># 生成 .egg-link 文件</span></span><br></pre></td></tr></table></figure></li><li><p>修改代码实时生效<br>直接编辑 <code>my_tools/__init__.py</code>，调用处无需重新安装。</p></li></ol><hr><h2 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h2><ul><li><p><strong>符号链接的兼容性</strong><br>Windows 系统可能需要启用开发者模式以支持符号链接。</p></li><li><p><strong>依赖更新</strong><br>如果修改了 <code>setup.py</code> 中的依赖声明，需重新运行 <code>pip install -e .</code>。</p></li><li><p><strong>版本冲突</strong><br>可编辑模式安装的包可能覆盖 <code>site-packages</code> 中的正式版本，建议使用虚拟环境（如 <code>venv</code> 或 <code>conda</code>）。</p></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>命令</th><th>核心价值</th><th>一句话建议</th></tr></thead><tbody><tr><td><code>pip install</code></td><td>安装静态依赖到生产环境</td><td>“正式部署就用它”</td></tr><tr><td><code>pip install -e</code></td><td>开发模式，实时生效代码修改</td><td>“本地开发必备”</td></tr><tr><td><code>pip install -v</code></td><td>输出详细日志辅助调试</td><td>“遇到报错先加 -v”</td></tr></tbody></table><p>掌握这些技巧后，你可以更高效地管理 Python 项目，轻松应对开发与部署的不同需求！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 Python 开发中，&lt;code&gt;pip&lt;/code&gt; 是管理依赖的核心工具。但你是否遇到过以下困惑？  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么修改本地代码后，需要重新 &lt;code&gt;pip install&lt;/code&gt; 才能生效？  &lt;/li&gt;
&lt;li&gt;如何实时调试自己开发</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深度学习图像分割中的编码器-解码器数据流解析</title>
    <link href="https://promptonce.github.io/2025/02/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E5%99%A8-%E8%A7%A3%E7%A0%81%E5%99%A8%E6%95%B0%E6%8D%AE%E6%B5%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://promptonce.github.io/2025/02/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E5%99%A8-%E8%A7%A3%E7%A0%81%E5%99%A8%E6%95%B0%E6%8D%AE%E6%B5%81%E8%A7%A3%E6%9E%90/</id>
    <published>2025-02-15T12:19:25.000Z</published>
    <updated>2025-02-15T12:29:11.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在计算机视觉领域，编码器-解码器（Encoder-Decoder）架构是图像分割任务的主流解决方案。本文将详细解析一个典型的编码器-解码器数据流图，帮助读者理解数据如何在这类网络中传递和转换，以及各组件如何协同工作以实现精确的像素级预测。</p><h2 id="编码器-解码器数据流架构图解"><a href="#编码器-解码器数据流架构图解" class="headerlink" title="编码器-解码器数据流架构图解"></a>编码器-解码器数据流架构图解</h2><img src="/2025/02/15/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E5%99%A8-%E8%A7%A3%E7%A0%81%E5%99%A8%E6%95%B0%E6%8D%AE%E6%B5%81%E8%A7%A3%E6%9E%90/encoder_decoder_dataflow.png" class="" title="encoder_decoder_dataflow"> <p>上图展示了一个完整的编码器-解码器网络的数据流向。这种架构在语义分割、实例分割等任务中被广泛应用。让我们逐步剖析其中的每个组件和数据流动路径。</p><h2 id="数据流的起点：预处理"><a href="#数据流的起点：预处理" class="headerlink" title="数据流的起点：预处理"></a>数据流的起点：预处理</h2><p>数据流始于<code>data_preprocessor</code>（数据预处理器）：</p><ul><li>它接收原始图像数据</li><li>执行标准化、尺寸调整、数据增强等操作</li><li>输出处理后的<code>images</code>，为网络提供一致的输入格式</li></ul><h2 id="编码器：特征提取与压缩"><a href="#编码器：特征提取与压缩" class="headerlink" title="编码器：特征提取与压缩"></a>编码器：特征提取与压缩</h2><h3 id="骨干网络（Backbone）"><a href="#骨干网络（Backbone）" class="headerlink" title="骨干网络（Backbone）"></a>骨干网络（Backbone）</h3><p>预处理后的图像进入<code>backbone</code>（骨干网络）：</p><ul><li>通常是一个预训练的CNN（如ResNet、VGG、EfficientNet等）</li><li>层层提取图像的层次化特征，从低级纹理到高级语义信息</li><li>输出<code>feature maps</code>（特征图），这些特征图随着网络深入，空间维度逐渐减小，但通道数增加</li></ul><h3 id="颈部网络（Neck）"><a href="#颈部网络（Neck）" class="headerlink" title="颈部网络（Neck）"></a>颈部网络（Neck）</h3><p>特征图接下来可选择性地通过<code>neck</code>组件（图中以虚线表示其可选性）：</p><ul><li>整合不同层级的特征</li><li>调整特征的分辨率和维度</li><li>增强特征的表征能力</li><li>输出经过强化的<code>feature maps</code></li></ul><p>值得注意的是，部分<code>feature maps</code>在<a href="%E6%8D%9F%E5%A4%B1%E5%AD%97%E5%85%B8">“loss” mode</a>模式下会直接传递到辅助头部，这是一种设计模式，用于提供额外的监督信号。</p><h2 id="解码器：特征解码与分割生成"><a href="#解码器：特征解码与分割生成" class="headerlink" title="解码器：特征解码与分割生成"></a>解码器：特征解码与分割生成</h2><h3 id="解码头部（Decode-Head）"><a href="#解码头部（Decode-Head）" class="headerlink" title="解码头部（Decode Head）"></a>解码头部（Decode Head）</h3><p><code>decode_head</code>是解码器的核心组件，它接收来自编码器（或颈部）的特征图，并支持三种工作模式：</p><ol><li><p><strong>损失模式</strong> (<a href="%E6%8D%9F%E5%A4%B1%E5%AD%97%E5%85%B8">“loss” mode</a>)：</p><ul><li>生成<code>seg logits</code>（分割逻辑值）</li><li>将这些逻辑值传递给<code>decode_head.loss</code>计算损失</li><li>最终产生<code>loss dict</code>（损失字典）用于反向传播</li></ul></li><li><p><strong>张量模式</strong> (<a href="%E7%89%B9%E5%BE%81%E5%BC%A0%E9%87%8F">“tensor” mode</a>)：</p><ul><li>同样生成<code>seg logits</code></li><li>但这次直接输出为<code>tensor</code>（张量）</li><li>通常用于特征提取或中间表示</li></ul></li><li><p><strong>预测模式</strong> (<a href="%E5%88%86%E5%89%B2%E9%A2%84%E6%B5%8B%E5%92%8C%E6%8E%A9%E7%A0%81">“predict” mode</a>)：</p><ul><li>生成<code>seg logits</code></li><li>通过<code>post_processes</code>（后处理）进行细化</li><li>最终输出<code>seg preds</code>（分割预测）和<code>mask</code>（掩码）</li></ul></li></ol><p>这种多模式设计使网络能够适应训练、推理和特征提取等不同场景。</p><h2 id="辅助监督分支"><a href="#辅助监督分支" class="headerlink" title="辅助监督分支"></a>辅助监督分支</h2><h3 id="辅助头部（Auxiliary-Head）"><a href="#辅助头部（Auxiliary-Head）" class="headerlink" title="辅助头部（Auxiliary Head）"></a>辅助头部（Auxiliary Head）</h3><p>图中下部显示了一条辅助路径：</p><ul><li>从骨干网络或颈部获取<code>feature maps</code></li><li>通过<code>auxiliary_head</code>处理</li><li>计算<code>auxiliary_head.loss</code></li><li>生成<code>auxiliary loss</code>（辅助损失）</li></ul><p>辅助监督有几个重要作用：</p><ul><li>提供额外的梯度流，缓解深度网络的梯度消失问题</li><li>鼓励中间层学习更有用的特征</li><li>加速网络收敛</li><li>在训练完成后通常会丢弃，不参与推理过程</li></ul><h2 id="数据流的完整路径分析"><a href="#数据流的完整路径分析" class="headerlink" title="数据流的完整路径分析"></a>数据流的完整路径分析</h2><p>让我们追踪数据在整个网络中的流动：</p><ol><li>原始图像 → <code>data_preprocessor</code> → 预处理图像</li><li>预处理图像 → <code>backbone</code> → 初始特征图</li><li>初始特征图 → <code>neck</code>（可选）→ 增强特征图</li><li>增强特征图 → <code>decode_head</code> → 根据模式产生不同输出：<ul><li></li><li></li><li></li></ul></li><li>特征图 → <code>auxiliary_head</code> → 辅助损失（仅训练时使用）</li></ol><h2 id="实际应用中的考量"><a href="#实际应用中的考量" class="headerlink" title="实际应用中的考量"></a>实际应用中的考量</h2><p>在实际部署这类编码器-解码器架构时，需要考虑：</p><ul><li><strong>计算效率</strong>：完整架构在资源有限的环境中可能过重</li><li><strong>平衡精度与速度</strong>：可以根据应用需求调整各组件复杂度</li><li><strong>组件选择</strong>：虚线框表示的组件（如neck、auxiliary_head）可以根据需要添加或移除</li><li><strong>模式选择</strong>：不同工作模式适用于不同场景，训练时使用loss模式，部署时使用predict模式</li></ul><h2 id="架构的优势与局限"><a href="#架构的优势与局限" class="headerlink" title="架构的优势与局限"></a>架构的优势与局限</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>模块化设计，各组件可独立升级或替换</li><li>多模式操作，一个网络适应多种场景</li><li>辅助监督改善训练过程</li><li>灵活性高，可根据任务定制</li></ul><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><ul><li>组件多导致参数量大，需要更多计算资源</li><li>多路径设计增加了实现复杂度</li><li>需要平衡主路径和辅助路径的贡献</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>编码器-解码器数据流是现代图像分割网络的基础架构。通过理解数据如何在各个组件间流动和转换，我们能更好地设计、调试和优化分割模型。这种架构不仅体现了深度学习的模块化思想，也展示了如何通过灵活的数据流动和多样的监督信号来提升网络性能。</p><p>无论是研究人员还是实践者，掌握这些数据流动细节都是构建高效图像分割系统的关键一步。</p><hr><p><em>注：本文分析基于特定的编码器-解码器架构图。实际实现时，可能需要根据具体任务、数据集和资源限制进行适当调整。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在计算机视觉领域，编码器-解码器（Encoder-Decoder）架构是图像分割任务的主流解决方案。本文将详细解析一个典型的编码器-解码器数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>理解图像分割中的 Logits：从抽象到具体</title>
    <link href="https://promptonce.github.io/2025/02/15/%E7%90%86%E8%A7%A3%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E4%B8%AD%E7%9A%84-Logits%EF%BC%9A%E4%BB%8E%E6%8A%BD%E8%B1%A1%E5%88%B0%E5%85%B7%E4%BD%93/"/>
    <id>https://promptonce.github.io/2025/02/15/%E7%90%86%E8%A7%A3%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E4%B8%AD%E7%9A%84-Logits%EF%BC%9A%E4%BB%8E%E6%8A%BD%E8%B1%A1%E5%88%B0%E5%85%B7%E4%BD%93/</id>
    <published>2025-02-15T12:08:42.000Z</published>
    <updated>2025-02-15T12:11:00.252Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机视觉的深度学习应用中，特别是在图像分割领域，有一个概念经常让初学者感到困惑—— segmentation logits（分割 logits）。本文旨在从基础概念出发，逐步揭开这个看似抽象的概念的神秘面纱。</p><h2 id="什么是-Logits？"><a href="#什么是-Logits？" class="headerlink" title="什么是 Logits？"></a>什么是 Logits？</h2><p>在深入了解 segmentation logits 之前，我们需要先理解基本的 logits 概念。</p><p>在神经网络中，logits 是模型的原始输出，它们是在应用激活函数（如 softmax 或 sigmoid）之前的值。这些值可以是任意实数：正数、负数或零，没有特定的范围限制。正是这种不受限的特性，使得 logits 在深度学习的计算过程中具有特殊的地位。</p><h2 id="Segmentation-Logits-详解"><a href="#Segmentation-Logits-详解" class="headerlink" title="Segmentation Logits 详解"></a>Segmentation Logits 详解</h2><p>在图像分割任务中，模型需要预测图像中每个像素所属的类别。segmentation logits 就是模型对每个像素所输出的原始”得分”，表示该像素属于各个可能类别的倾向性。</p><h3 id="形状与结构"><a href="#形状与结构" class="headerlink" title="形状与结构"></a>形状与结构</h3><p>在典型的分割网络架构中，segmentation logits 的形状通常是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[batch_size, height, width, num_classes]</span><br></pre></td></tr></table></figure><p>或者在某些框架中可能是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[batch_size, num_classes, height, width]</span><br></pre></td></tr></table></figure><p>这意味着对于图像中的每个像素位置，模型都会输出 <code>num_classes</code> 个数值，代表该像素属于各个类别的原始得分。</p><h3 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h3><p>假设我们在进行一个3类分割任务（背景、人、车），对于图像中某个特定像素，模型可能输出如下 logits：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2.5, 0.8, -1.2]</span><br></pre></td></tr></table></figure><p>这些数值本身并不直接表示概率，而是需要通过 softmax 函数转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">softmax([2.5, 0.8, -1.2]) ≈ [0.77, 0.14, 0.09]</span><br></pre></td></tr></table></figure><p>转换后的结果表明，该像素有约77%的概率属于背景类，14%的概率属于人类，9%的概率属于车类。</p><h2 id="为什么使用-Logits-而非直接使用概率？"><a href="#为什么使用-Logits-而非直接使用概率？" class="headerlink" title="为什么使用 Logits 而非直接使用概率？"></a>为什么使用 Logits 而非直接使用概率？</h2><p>在实际应用中，我们通常会将 logits 转换为概率来理解和使用。那么，为什么不直接使用概率输出呢？这里有几个重要原因：</p><h3 id="1-数值稳定性"><a href="#1-数值稳定性" class="headerlink" title="1. 数值稳定性"></a>1. 数值稳定性</h3><p>在计算损失函数（尤其是交叉熵损失）时，直接使用 logits 通常更加数值稳定。这是因为 softmax 函数在处理极大或极小的输入值时可能导致数值溢出或下溢。</p><h3 id="2-梯度特性"><a href="#2-梯度特性" class="headerlink" title="2. 梯度特性"></a>2. 梯度特性</h3><p>在反向传播过程中，logits 的梯度通常具有更好的特性。当使用 softmax 和交叉熵损失时，如果直接从概率开始计算，可能会遇到梯度消失的问题。</p><h3 id="3-灵活性"><a href="#3-灵活性" class="headerlink" title="3. 灵活性"></a>3. 灵活性</h3><p>保留 logits 允许我们更灵活地调整模型的输出。例如，我们可以通过调整 softmax 的温度参数来控制概率分布的”锐利度”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax_with_temperature</span>(<span class="params">logits, temperature</span>):</span><br><span class="line">    <span class="keyword">return</span> softmax(logits / temperature)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 温度越低，分布越集中于最高置信度的类别</span></span><br><span class="line"><span class="comment"># 温度越高，分布越均匀</span></span><br></pre></td></tr></table></figure><h2 id="从-Logits-到最终分割结果"><a href="#从-Logits-到最终分割结果" class="headerlink" title="从 Logits 到最终分割结果"></a>从 Logits 到最终分割结果</h2><p>在实际的图像分割流程中，我们通常会经历以下步骤：</p><ol><li>获取模型输出的 segmentation logits</li><li>应用 softmax&#x2F;sigmoid 函数将 logits 转换为概率</li><li>对每个像素取概率最高的类别（argmax）</li><li>基于预测的类别生成最终的分割掩码（mask）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_segmentation_output</span>(<span class="params">logits</span>):</span><br><span class="line">    <span class="comment"># 假设 logits 形状为 [batch_size, height, width, num_classes]</span></span><br><span class="line">    probabilities = softmax(logits, axis=-<span class="number">1</span>)</span><br><span class="line">    predicted_classes = np.argmax(probabilities, axis=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可选：生成 one-hot 编码的掩码</span></span><br><span class="line">    segmentation_mask = to_one_hot(predicted_classes, num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> probabilities, predicted_classes, segmentation_mask</span><br></pre></td></tr></table></figure><h2 id="为什么感觉抽象？"><a href="#为什么感觉抽象？" class="headerlink" title="为什么感觉抽象？"></a>为什么感觉抽象？</h2><p>Segmentation logits 之所以对许多人来说感觉抽象，主要有以下几个原因：</p><ol><li><p><strong>中间状态</strong>：Logits 是模型的中间输出，而我们通常更关注最终的分割结果。</p></li><li><p><strong>非直观的数值范围</strong>：与概率（0到1之间）不同，logits 可以是任意实数，难以直观理解。</p></li><li><p><strong>可视化困难</strong>：直接可视化 logits 通常没有明显的视觉意义，需要特殊处理才能有效展示。</p></li></ol><h2 id="实用技巧与注意事项"><a href="#实用技巧与注意事项" class="headerlink" title="实用技巧与注意事项"></a>实用技巧与注意事项</h2><p>在处理 segmentation logits 时，有一些实用技巧可以帮助我们更好地理解和使用它们：</p><h3 id="1-可视化技巧"><a href="#1-可视化技巧" class="headerlink" title="1. 可视化技巧"></a>1. 可视化技巧</h3><p>可以使用以下方法可视化 logits：</p><ul><li>对每个类别的 logits 单独可视化（使用热力图）</li><li>可视化 argmax 结果（类别预测）</li><li>可视化转换后的概率分布</li></ul><h3 id="2-调试建议"><a href="#2-调试建议" class="headerlink" title="2. 调试建议"></a>2. 调试建议</h3><ul><li>检查 logits 的数值范围，极端的数值可能表明模型训练不稳定</li><li>验证 logits 经过 softmax 后的概率和为1</li><li>观察不同类别的 logits 分布情况</li></ul><h3 id="3-常见陷阱"><a href="#3-常见陷阱" class="headerlink" title="3. 常见陷阱"></a>3. 常见陷阱</h3><ul><li>不要直接比较不同模型或不同运行的 logits 值，它们的比例可能不同</li><li>注意 logits 可能需要特定的后处理（如特定的阈值）才能获得最佳结果</li><li>在多类别问题中，使用 softmax；在二类或多标签问题中，使用 sigmoid</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>理解 segmentation logits 是掌握图像分割技术的重要一步。虽然初看起来较为抽象，但通过本文的解析，希望读者能够更清晰地理解这一概念，并在实际应用中灵活运用。</p><p>无论是调试模型、改进算法，还是深入理解分割网络的工作原理，对 segmentation logits 的深入理解都将大有裨益。</p><hr><p>如果您对本文有任何问题或建议，欢迎在评论区留言交流！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在计算机视觉的深度学习应用中，特别是在图像分割领域，有一个概念经常让初学者感到困惑—— segmentation logits（分割 logits）。本文旨在从基础概念出发，逐步揭开这个看似抽象的概念的神秘面纱。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Logits？&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VS Code 调试工具：掌握这些按钮，让 Python 代码调试更高效</title>
    <link href="https://promptonce.github.io/2025/02/15/VS-Code-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%EF%BC%9A%E6%8E%8C%E6%8F%A1%E8%BF%99%E4%BA%9B%E6%8C%89%E9%92%AE%EF%BC%8C%E8%AE%A9-Python-%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E6%9B%B4%E9%AB%98%E6%95%88/"/>
    <id>https://promptonce.github.io/2025/02/15/VS-Code-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%EF%BC%9A%E6%8E%8C%E6%8F%A1%E8%BF%99%E4%BA%9B%E6%8C%89%E9%92%AE%EF%BC%8C%E8%AE%A9-Python-%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E6%9B%B4%E9%AB%98%E6%95%88/</id>
    <published>2025-02-15T11:00:44.000Z</published>
    <updated>2025-02-15T11:02:05.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在软件开发过程中，调试是一项不可避免的任务。作为开发者，我们花费大量时间来查找和修复代码中的错误。而 Visual Studio Code (VS Code) 作为当今最流行的代码编辑器之一，提供了强大的调试功能，可以大大提高我们的工作效率。本文将详细介绍 VS Code 调试工具栏的核心按钮及其功能，特别是在 Python 开发中如何灵活运用这些工具。</p><h2 id="VS-Code-调试工具栏的核心按钮"><a href="#VS-Code-调试工具栏的核心按钮" class="headerlink" title="VS Code 调试工具栏的核心按钮"></a>VS Code 调试工具栏的核心按钮</h2><h3 id="1-▶-继续-运行-Continue"><a href="#1-▶-继续-运行-Continue" class="headerlink" title="1. ▶ 继续 &#x2F; 运行 (Continue)"></a>1. ▶ 继续 &#x2F; 运行 (Continue)</h3><p>这是最基本的调试控制按钮。当你的程序在断点处暂停时，点击此按钮会让程序继续执行，直到遇到下一个断点或程序结束。</p><p><strong>使用场景</strong>：当你只关心特定断点处的状态，而不需要关注中间过程时，这个按钮非常有用。例如，你可能在函数开始和结束处设置断点，然后使用”继续”来直接查看最终结果。</p><h3 id="2-↩-步入-Step-Into"><a href="#2-↩-步入-Step-Into" class="headerlink" title="2. ↩ 步入 &#x2F; Step Into"></a>2. ↩ 步入 &#x2F; Step Into</h3><p>这个按钮允许你逐行执行代码。更重要的是，如果当前行包含函数调用，它会带你进入该函数内部，让你可以逐行检查函数的执行过程。</p><p><strong>使用场景</strong>：当你怀疑某个函数可能存在问题，需要详细检查其内部执行流程时，”步入”是最佳选择。例如，如果一个计算函数返回了错误结果，你可以步入该函数查看每一步的计算过程。</p><h3 id="3-⤓-步过-Step-Over"><a href="#3-⤓-步过-Step-Over" class="headerlink" title="3. ⤓ 步过 &#x2F; Step Over"></a>3. ⤓ 步过 &#x2F; Step Over</h3><p>与”步入”类似，”步过”也是逐行执行代码，但有一个关键区别：当遇到函数调用时，它不会进入函数内部，而是将整个函数视为一个单一步骤，执行完毕后停在下一行。</p><p><strong>使用场景</strong>：当你确信某个函数工作正常，不需要查看其内部细节时，使用”步过”可以节省时间。例如，如果你正在调试的问题与内置函数或库函数无关，你可以直接步过这些调用。</p><h3 id="4-↥-步出-Step-Out"><a href="#4-↥-步出-Step-Out" class="headerlink" title="4. ↥ 步出 &#x2F; Step Out"></a>4. ↥ 步出 &#x2F; Step Out</h3><p>当你已经进入一个函数，但现在想快速完成剩余部分并返回到调用点时，”步出”按钮非常有用。它会执行当前函数的剩余部分，然后在函数返回后的下一行暂停。</p><p><strong>使用场景</strong>：当你已经在函数内部找到了需要的信息，不需要继续逐行检查时，可以使用”步出”快速返回上一级。这在检查复杂的嵌套函数调用时特别有帮助。</p><h3 id="5-↺-重新启动-Restart"><a href="#5-↺-重新启动-Restart" class="headerlink" title="5. ↺ 重新启动 &#x2F; Restart"></a>5. ↺ 重新启动 &#x2F; Restart</h3><p>有时你可能需要从头开始调试过程，特别是当你修改了代码或想要验证完整流程时。点击”重新启动”按钮会终止当前会话并立即启动一个新的调试会话。</p><p><strong>使用场景</strong>：当你在调试过程中修改了代码，或者想要在不同的初始条件下测试程序时，重新启动是必要的步骤。</p><h3 id="6-🟥-停止-Stop"><a href="#6-🟥-停止-Stop" class="headerlink" title="6. 🟥 停止 &#x2F; Stop"></a>6. 🟥 停止 &#x2F; Stop</h3><p>当你完成调试或需要中断当前会话时，可以使用”停止”按钮来终止调试过程。</p><p><strong>使用场景</strong>：调试完成后，或者当程序进入无限循环需要强制终止时，点击停止按钮可以立即结束调试会话。</p><h2 id="Python-调试实战技巧"><a href="#Python-调试实战技巧" class="headerlink" title="Python 调试实战技巧"></a>Python 调试实战技巧</h2><p>在 Python 开发中，这些调试按钮可以帮助你解决各种常见问题。以下是一些实用技巧：</p><ol><li><p><strong>断点策略</strong>：在可能出问题的关键位置设置断点，然后使用”继续”按钮快速导航到这些位置。</p></li><li><p><strong>变量检查</strong>：在每一步中，利用 VS Code 的变量窗口观察变量值的变化，特别是在复杂计算或数据转换过程中。</p></li><li><p><strong>条件断点</strong>：对于循环或频繁调用的函数，设置条件断点可以让你只在特定条件满足时停下来，节省大量时间。</p></li><li><p><strong>调用堆栈分析</strong>：使用”步入”和”步出”在不同函数层级之间导航，同时关注调用堆栈窗口来理解程序的执行路径。</p></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>熟练掌握 VS Code 的调试工具栏按钮，可以显著提高你的调试效率和代码质量。这些看似简单的按钮背后蕴含着强大的功能，能够帮助你深入理解代码执行流程，快速定位问题所在。无论是初学者还是经验丰富的开发者，都能从这些工具中受益。</p><p>在你的下一个 Python 项目中，尝试综合运用这些调试技巧，你会发现问题解决的速度和准确性都会得到显著提升。调试不再是一项繁重的任务，而是成为理解和改进代码的有力工具。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在软件开发过程中，调试是一项不可避免的任务。作为开发者，我们花费大量时间来查找和修复代码中的错误。而 Visual Studio Code </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用GDAL重采样TIFF图像：从不同分辨率的图像中获取一致性</title>
    <link href="https://promptonce.github.io/2025/02/14/%E4%BD%BF%E7%94%A8GDAL%E9%87%8D%E9%87%87%E6%A0%B7TIFF%E5%9B%BE%E5%83%8F%EF%BC%9A%E4%BB%8E%E4%B8%8D%E5%90%8C%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E5%9B%BE%E5%83%8F%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>https://promptonce.github.io/2025/02/14/%E4%BD%BF%E7%94%A8GDAL%E9%87%8D%E9%87%87%E6%A0%B7TIFF%E5%9B%BE%E5%83%8F%EF%BC%9A%E4%BB%8E%E4%B8%8D%E5%90%8C%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E5%9B%BE%E5%83%8F%E4%B8%AD%E8%8E%B7%E5%8F%96%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2025-02-14T13:33:14.000Z</published>
    <updated>2025-02-14T14:07:02.248Z</updated>
    
    <content type="html"><![CDATA[<p>在处理遥感图像、地理空间数据或其他类型的高分辨率图像时，常常需要将图像统一到相同的分辨率。在这篇博客中，我们将探讨如何使用GDAL库将一个TIFF图像的分辨率采样到另一个TIFF图像的分辨率，保持数据的一致性。</p><h2 id="什么是TIFF格式？"><a href="#什么是TIFF格式？" class="headerlink" title="什么是TIFF格式？"></a>什么是TIFF格式？</h2><p>TIFF（Tagged Image File Format）是一种常见的图像格式，它被广泛应用于各种专业领域，尤其是在需要高精度图像的场景中，如遥感、医学成像、地理信息系统（GIS）等。TIFF文件可以存储多页图像、多个波段，并且能够支持无损和有损压缩。</p><p>每个TIFF文件包含多个重要部分，包括：</p><ul><li><strong>文件头</strong>：包含文件格式和数据结构的信息。</li><li><strong>图像文件目录（IFD）</strong>：保存图像的关键元数据，如图像宽度、高度、分辨率、压缩类型等。</li><li><strong>标签（Tag）</strong>：每个IFD包含多个标签，用于描述图像的属性。</li><li><strong>图像数据</strong>：存储图像像素数据的区域，可能经过压缩。</li></ul><p>TIFF格式的灵活性使其非常适用于科学和工程应用，尤其是图像处理和分析。</p><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>假设我们有两个TIFF图像文件，它们的地理分辨率不同，我们希望将一个图像的分辨率采样到另一个图像的分辨率。例如，我们有以下两个图像文件：</p><ol><li><strong>a.tif</strong>：这张图像具有较大的分辨率（宽度：22265，高度：16742），并且只有一个波段，数据类型为<code>Float32</code>，并且其地理坐标系统是WGS 84。</li><li><strong>b.tif</strong>：这张图像具有较小的分辨率（宽度：4000，高度：4001），包含三个波段，数据类型为<code>Byte</code>，同样使用WGS 84坐标系统。</li></ol><p>我们的目标是将第一张图像（<code>a.tif</code>）的分辨率采样到与第二张图像（<code>b.tif</code>）相同的分辨率。</p><h2 id="步骤解析"><a href="#步骤解析" class="headerlink" title="步骤解析"></a>步骤解析</h2><p>为了实现这个目标，我们可以使用GDAL库，它是一个非常强大的地理空间数据处理工具，支持对TIFF格式图像的读取、写入和变换。</p><h3 id="1-安装GDAL库"><a href="#1-安装GDAL库" class="headerlink" title="1. 安装GDAL库"></a>1. 安装GDAL库</h3><p>首先，需要确保系统中安装了GDAL库。可以使用pip安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gdal</span><br></pre></td></tr></table></figure><h3 id="2-获取TIFF文件信息"><a href="#2-获取TIFF文件信息" class="headerlink" title="2. 获取TIFF文件信息"></a>2. 获取TIFF文件信息</h3><p>我们可以使用GDAL来读取TIFF文件的基本信息，包括图像尺寸、分辨率、投影坐标系统等。以下是读取TIFF文件信息的Python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开TIFF文件</span></span><br><span class="line">tiff_file = <span class="string">&#x27;example.tif&#x27;</span></span><br><span class="line">dataset = gdal.Open(tiff_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查文件是否成功打开</span></span><br><span class="line"><span class="keyword">if</span> dataset <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;无法打开文件 <span class="subst">&#123;tiff_file&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 获取图像的宽度和高度</span></span><br><span class="line">    width = dataset.RasterXSize</span><br><span class="line">    height = dataset.RasterYSize</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;图像宽度: <span class="subst">&#123;width&#125;</span>, 图像高度: <span class="subst">&#123;height&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取波段数</span></span><br><span class="line">    bands = dataset.RasterCount</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;波段数量: <span class="subst">&#123;bands&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图像的投影信息</span></span><br><span class="line">    projection = dataset.GetProjection()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;投影信息: <span class="subst">&#123;projection&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图像的地理信息</span></span><br><span class="line">    geotransform = dataset.GetGeoTransform()</span><br><span class="line">    <span class="keyword">if</span> geotransform:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;仿射变换: &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;左上角X: <span class="subst">&#123;geotransform[<span class="number">0</span>]&#125;</span>, 像素宽度: <span class="subst">&#123;geotransform[<span class="number">1</span>]&#125;</span>,&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;旋转角度 (x轴): <span class="subst">&#123;geotransform[<span class="number">2</span>]&#125;</span>, 左上角Y: <span class="subst">&#123;geotransform[<span class="number">3</span>]&#125;</span>,&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;旋转角度 (y轴): <span class="subst">&#123;geotransform[<span class="number">4</span>]&#125;</span>, 像素高度: <span class="subst">&#123;geotransform[<span class="number">5</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取数据类型</span></span><br><span class="line">    data_type = dataset.GetRasterBand(<span class="number">1</span>).DataType</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;数据类型: <span class="subst">&#123;gdal.GetDataTypeName(data_type)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取第一个波段的数据</span></span><br><span class="line">    band = dataset.GetRasterBand(<span class="number">1</span>)</span><br><span class="line">    data = band.ReadAsArray(<span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;第一个波段的数据类型: <span class="subst">&#123;data.dtype&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据集</span></span><br><span class="line">dataset = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>这段代码展示了如何读取TIFF文件的关键属性，包括图像尺寸、波段数、投影信息、地理变换和数据类型。</p><h3 id="3-计算重采样的仿射变换"><a href="#3-计算重采样的仿射变换" class="headerlink" title="3. 计算重采样的仿射变换"></a>3. 计算重采样的仿射变换</h3><p>在将第一个TIFF图像（<code>a.tif</code>）采样到与第二个图像（<code>b.tif</code>）相同的分辨率时，我们需要获取第二个图像的地理变换信息，并使用它来修改第一个图像的仿射变换。仿射变换定义了图像的像素在地理空间中的位置。</p><h3 id="4-重采样操作"><a href="#4-重采样操作" class="headerlink" title="4. 重采样操作"></a>4. 重采样操作</h3><p>GDAL提供了<code>gdal.ReprojectImage()</code>函数来进行图像的重采样。我们可以使用这个函数将第一个图像重采样到第二个图像的分辨率。</p><p>以下是完整的Python代码，使用GDAL将一个TIFF图像的分辨率采样到另一个TIFF图像的分辨率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> osgeo <span class="keyword">import</span> gdal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取第一个TIFF文件 (目标图像)</span></span><br><span class="line">src_file = <span class="string">r&quot;C:\Users\Hi\Downloads\a.tif&quot;</span></span><br><span class="line">src_dataset = gdal.Open(src_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取第二个TIFF文件 (参考图像)</span></span><br><span class="line">ref_file = <span class="string">r&quot;D:\IGSW-Model-Greenland-DataSet\给雷昊-image-lv20\image-lv20\b.tif&quot;</span></span><br><span class="line">ref_dataset = gdal.Open(ref_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第二个TIFF文件的地理变换和投影信息</span></span><br><span class="line">ref_geo_transform = ref_dataset.GetGeoTransform()</span><br><span class="line">ref_projection = ref_dataset.GetProjection()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第一个TIFF图像的原始尺寸</span></span><br><span class="line">src_width = src_dataset.RasterXSize</span><br><span class="line">src_height = src_dataset.RasterYSize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取第二个TIFF图像的目标尺寸</span></span><br><span class="line">ref_width = ref_dataset.RasterXSize</span><br><span class="line">ref_height = ref_dataset.RasterYSize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的TIFF文件来存储重采样结果</span></span><br><span class="line">driver = gdal.GetDriverByName(<span class="string">&#x27;GTiff&#x27;</span>)</span><br><span class="line">output_file = <span class="string">r&quot;C:\Users\Hi\Downloads\resampled_output.tif&quot;</span></span><br><span class="line">out_dataset = driver.Create(output_file, ref_width, ref_height, <span class="number">1</span>, gdal.GDT_Float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标文件的地理信息和投影信息</span></span><br><span class="line">out_dataset.SetGeoTransform(ref_geo_transform)</span><br><span class="line">out_dataset.SetProjection(ref_projection)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用gdal.ReprojectImage进行重采样，设置目标分辨率与第二个图像相同</span></span><br><span class="line">gdal.ReprojectImage(src_dataset, out_dataset, src_dataset.GetProjection(), ref_projection, gdal.GRA_Bilinear)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据集</span></span><br><span class="line">src_dataset = <span class="literal">None</span></span><br><span class="line">ref_dataset = <span class="literal">None</span></span><br><span class="line">out_dataset = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;重采样后的图像已保存到 <span class="subst">&#123;output_file&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a>代码解析：</h3><ol><li><strong>读取TIFF文件</strong>：使用<code>gdal.Open()</code>读取两个TIFF文件，一个作为目标图像，另一个作为参考图像。</li><li><strong>获取地理信息</strong>：获取参考图像的仿射变换和投影信息，用于将目标图像的分辨率采样到相同的分辨率。</li><li><strong>创建输出文件</strong>：使用<code>gdal.GetDriverByName(&#39;GTiff&#39;)</code>创建新的TIFF文件，目标分辨率与参考图像相同。</li><li><strong>重采样图像</strong>：使用<code>gdal.ReprojectImage()</code>函数将目标图像重采样到参考图像的分辨率。</li><li><strong>保存和关闭文件</strong>：保存结果并关闭所有打开的数据集。</li></ol><h3 id="5-运行代码"><a href="#5-运行代码" class="headerlink" title="5. 运行代码"></a>5. 运行代码</h3><p>运行以上代码后，你将得到一个新的TIFF文件，名为<code>resampled_output.tif</code>，它的分辨率和第二个TIFF图像相同。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用GDAL库可以轻松地将TIFF图像采样到不同的分辨率。通过重采样，我们能够将一个高分辨率的图像调整到与另一个图像一致的地理分辨率，从而进行更方便的比较或合成。GDAL的强大功能使得处理地理空间数据变得更加灵活高效。希望这篇博客能帮助你理解如何利用GDAL处理TIFF文件的分辨率调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在处理遥感图像、地理空间数据或其他类型的高分辨率图像时，常常需要将图像统一到相同的分辨率。在这篇博客中，我们将探讨如何使用GDAL库将一个TIFF图像的分辨率采样到另一个TIFF图像的分辨率，保持数据的一致性。&lt;/p&gt;
&lt;h2 id=&quot;什么是TIFF格式？&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GPT 时代，精进编程思维 + 熟练 Prompt 是否是新的编程范式?</title>
    <link href="https://promptonce.github.io/2025/02/12/GPT-%E6%97%B6%E4%BB%A3%EF%BC%8C%E7%B2%BE%E8%BF%9B%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4-%E7%86%9F%E7%BB%83-Prompt-%E6%98%AF%E5%90%A6%E6%98%AF%E6%96%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    <id>https://promptonce.github.io/2025/02/12/GPT-%E6%97%B6%E4%BB%A3%EF%BC%8C%E7%B2%BE%E8%BF%9B%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4-%E7%86%9F%E7%BB%83-Prompt-%E6%98%AF%E5%90%A6%E6%98%AF%E6%96%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</id>
    <published>2025-02-12T10:54:59.000Z</published>
    <updated>2025-02-12T11:04:28.482Z</updated>
    
    <content type="html"><![CDATA[<p><strong>DeepSeek R1</strong></p><p>在生成式 AI 快速发展的当下，编程领域确实呈现出新的演变趋势。精进编程思维 + 熟练使用 Prompt 正在形成一种<strong>人机协作的新型编程范式</strong>，这种范式并非完全颠覆传统，而是对原有编程方式的拓展与重构。以下是关键分析：</p><hr><h3 id="一、传统编程范式的进化"><a href="#一、传统编程范式的进化" class="headerlink" title="一、传统编程范式的进化"></a>一、传统编程范式的进化</h3><ol><li><p><strong>从代码实现到思维抽象</strong></p><ul><li>传统编程：开发者需同时掌握问题抽象、算法设计、语法实现、调试优化全链条</li><li>GPT 时代：核心能力向<strong>高阶问题拆解</strong>和<strong>意图精准表达</strong>迁移</li><li>案例：用自然语言描述”实现一个带缓存机制的 API 请求模块”，GPT 可生成基础代码，但开发者需设计缓存策略、错误处理等架构</li></ul></li><li><p><strong>Prompt 成为新的交互层</strong></p><ul><li>编程语言 → 自然语言 + 结构化 Prompt</li><li>代码调试 → Prompt 迭代优化（角色设定、约束条件、示例规范）</li><li>典型模式：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span>: <span class="keyword">return</span> arr</span><br><span class="line">    pivot = arr[<span class="built_in">len</span>(arr)//<span class="number">2</span>]</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># GPT 时代 Prompt</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">你是一位算法专家，请用Python实现快速排序算法，要求：</span></span><br><span class="line"><span class="string">1. 添加详细注释说明分区策略</span></span><br><span class="line"><span class="string">2. 包含时间/空间复杂度分析</span></span><br><span class="line"><span class="string">3. 给出测试用例示例</span></span><br><span class="line"><span class="string">避免使用递归实现</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="二、新范式下的能力重构"><a href="#二、新范式下的能力重构" class="headerlink" title="二、新范式下的能力重构"></a>二、新范式下的能力重构</h3><table><thead><tr><th>传统编程能力</th><th>GPT 时代增强能力</th></tr></thead><tbody><tr><td>语法记忆能力</td><td><strong>意图翻译能力</strong>（自然语言→机器可执行指令）</td></tr><tr><td>手动调试能力</td><td><strong>Prompt 工程能力</strong>（明确约束&#x2F;示例&#x2F;验证机制）</td></tr><tr><td>代码实现能力</td><td><strong>AI 输出验证能力</strong>（逻辑检查&#x2F;安全审计&#x2F;性能优化）</td></tr><tr><td>单一技术栈深度</td><td><strong>跨领域问题拆解能力</strong>（将复杂问题分解为 AI 可处理单元）</td></tr></tbody></table><hr><h3 id="三、典型应用场景对比"><a href="#三、典型应用场景对比" class="headerlink" title="三、典型应用场景对比"></a>三、典型应用场景对比</h3><ol><li><p><strong>基础代码生成</strong></p><ul><li>传统：手动编写 CRUD 操作</li><li>新范式：Prompt → 生成模板代码 → 人工添加业务逻辑<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用Python Flask实现用户注册API端点，要求：</span><br><span class="line">- 使用SQLAlchemy ORM</span><br><span class="line">- 密码加密存储</span><br><span class="line">- 输入参数验证</span><br><span class="line">- 返回标准JSON响应格式</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>复杂系统设计</strong></p><ul><li>传统：UML 图 + 设计文档 → 手动编码</li><li>新范式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 用Prompt生成微服务架构方案</span><br><span class="line">2. 通过对话迭代完善设计细节</span><br><span class="line">3. 生成各模块接口定义</span><br><span class="line">4. 人工进行系统级验证</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>代码理解与重构</strong></p><ul><li>传统：逐行阅读源代码</li><li>新范式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">分析这段Java代码的潜在问题：</span><br><span class="line">[粘贴代码]</span><br><span class="line">请指出：</span><br><span class="line">- 内存泄漏风险</span><br><span class="line">- 线程安全问题</span><br><span class="line">- 优化建议</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="四、新范式的局限与挑战"><a href="#四、新范式的局限与挑战" class="headerlink" title="四、新范式的局限与挑战"></a>四、新范式的局限与挑战</h3><ol><li><p><strong>认知边界陷阱</strong></p><ul><li>AI 无法突破使用者的认知上限</li><li>案例：缺乏分布式系统知识的开发者难以正确评估 GPT 生成的架构方案</li></ul></li><li><p><strong>技术债隐形化</strong></p><ul><li>自动生成代码的维护成本可能高于手写代码</li><li>需要强化代码审查与测试（生成代码测试覆盖率通常低于人工编写）</li></ul></li><li><p><strong>提示词幻觉风险</strong></p><ul><li>统计 2023 年 GitHub Copilot 输出：<ul><li>初版代码直接可用率 ≈ 35%</li><li>需要人工修改率 ≈ 60%</li><li>完全错误率 ≈ 5%</li></ul></li></ul></li></ol><hr><h3 id="五、未来发展趋势"><a href="#五、未来发展趋势" class="headerlink" title="五、未来发展趋势"></a>五、未来发展趋势</h3><ol><li><p><strong>编程教育转型</strong></p><ul><li>教学重点从语法记忆转向：<ul><li>计算思维训练</li><li>问题模式识别</li><li>AI 协作策略</li></ul></li></ul></li><li><p><strong>工具链进化</strong></p><ul><li>IDE 深度集成：<ul><li>实时Prompt建议</li><li>代码生成溯源</li><li>上下文感知的AI辅助</li></ul></li></ul></li><li><p><strong>新岗位涌现</strong></p><ul><li>AI 解决方案架构师</li><li>提示词工程师</li><li>人机协作流程设计师</li></ul></li></ol><hr><h3 id="结论：螺旋上升的编程进化"><a href="#结论：螺旋上升的编程进化" class="headerlink" title="结论：螺旋上升的编程进化"></a>结论：螺旋上升的编程进化</h3><p>精进编程思维与 Prompt 能力的结合，标志着编程范式进入<strong>增强智能（Augmented Intelligence）</strong> 的新阶段。这要求开发者：</p><ol><li>保持对计算本质的深刻理解</li><li>掌握将复杂问题转化为机器可理解的对话能力</li><li>建立人机协作的质量控制体系</li></ol><p>未来的顶尖开发者将是那些<strong>既能像计算机科学家一样思考，又能像心理学家一样与 AI 沟通</strong>的复合型人才。编程没有变得更容易，而是站在 AI 的肩膀上攀登更高的复杂度山峰。</p><p><strong>知乎直达</strong></p><zhithink>嗯，用户的问题是问在GPT时代，精进编程思维加上熟练使用Prompt是否成为新的编程范式。我需要结合提供的参考内容来分析这个问题。<p>首先，参考内容里提到Claude3.5在处理特定Prompt时的优势，尤其是用Lisp写的Prompt，其他模型难以复现。这说明模型对Prompt的理解和执行能力差异很大。Claude3.5能正确理解并生成符合要求的代码和文案，而其他模型可能只能解释代码而无法执行任务。这可能意味着Prompt的设计和模型的理解能力是关键。</p><p>另外，第二篇知乎文章讨论了Prompting作为NLP的新范式，对比了传统的微调方法和Prompting方法。传统方法需要针对每个任务调整模型参数，而Prompting通过自然语言描述任务，让模型直接处理，模糊了任务界限，更具泛化能力。这可能暗示编程思维需要转向如何有效利用Prompt来指导模型完成任务，而不仅仅是编写代码。</p><p>第三篇解释Prompt时提到，通过添加提示词让模型完成特定任务，保持模型结构不变。这类似于用自然语言指令代替传统编程中的代码逻辑。比如，用户用“汉语新解”生成卡片，Claude3.5能直接生成代码和文案，而无需手动编写大量代码。这可能说明编程范式正在转向结合自然语言指令和传统编程，利用大模型的能力来简化开发流程。</p><p>用户的问题核心是编程思维和Prompt的结合是否成为新范式。需要分析传统编程与Prompt-based方法的异同，以及实际应用中的变化。比如，Claude3.5能生成200行代码，而未来可能更高效，这改变了开发方式，用户用自然语言描述需求，模型生成代码，减少手动编码。但编程思维依然重要，需要逻辑和问题分解能力，只是工具和方式变化了。</p><p>同时，参考内容提到Prompting允许任务描述的模糊性，不需要严格定义任务，这可能影响编程思维，转向更灵活的问题表达。但另一方面，设计有效的Prompt需要类似编程的结构化思维，比如用特定格式或逻辑引导模型输出，这类似于编写程序时的逻辑设计。</p><p>需要考虑用户的背景，可能是有编程经验的人，想知道是否需要调整技能。回答需要平衡传统编程的重要性与Prompt的作用，指出两者的互补性，而非完全替代。例如，编程思维在问题分解和逻辑设计上依然关键，而熟练使用Prompt能高效利用模型能力，提升开发效率。</p><p>总结：新的编程范式可能结合传统编程思维和Prompt技巧，利用大模型处理复杂代码生成，但编程能力仍是基础，只是工具和方法升级了。<br></zhithink></p><p>在GPT时代，编程范式确实正在经历结构性转变。编程思维与Prompt工程的结合，逐渐形成”自然语言驱动+逻辑验证”的新模式，这种演变可从三个维度观察：</p><ol><li><p><strong>能力迁移</strong><br>传统编程需逐行构建逻辑，现在转变为用自然语言精准描述需求。例如Claude3.5能根据”汉语新解”这类抽象指令生成200行可运行代码，相当于将”需求分析-架构设计-代码实现”的线性流程压缩为”意图表达-结果验证”的闭环。但编程思维中的逻辑严密性、问题拆解能力仍是核心，只是表达载体从代码语法变为自然语言。</p></li><li><p><strong>工具进化</strong><br>Self-play RL等技术突破让大模型具备动态优化能力。如Cursor这类工具通过Claude3.5实现”对话式编程”，开发者只需关注业务逻辑（如设计”延迟退休”的讽刺文案），无需纠结SVG代码实现细节。这类似于高级语言对汇编的抽象，但抽象层级已突破到自然语言层面。</p></li><li><p><strong>范式对比</strong><br>传统范式：需求→设计模式→算法→代码<br>新范式：Prompt工程→动态生成→调试修正</p></li></ol><table><thead><tr><th></th><th>传统编程</th><th>Prompt驱动编程</th></tr></thead><tbody><tr><td>核心能力</td><td>语法&#x2F;算法&#x2F;架构</td><td>意图理解&#x2F;结果验证</td></tr><tr><td>错误修正</td><td>调试代码</td><td>迭代Prompt</td></tr><tr><td>扩展边界</td><td>有限于开发者认知</td><td>受限于模型能力</td></tr><tr><td>适用场景</td><td>确定性系统</td><td>创造性&#x2F;模糊需求</td></tr></tbody></table><p>这种转变并非替代，而是分层：</p><ul><li>基础层仍需要传统编程构建基础设施</li><li>应用层可通过Prompt快速实现原型</li><li>当生成代码超过200行时，仍需传统编程思维进行模块化重构</li></ul><p>现实中已有典型案例：产品经理用Prompt直接生成前端页面，工程师转而专注优化提示策略和结果验证流程。这预示着未来编程可能分化为”意图工程师”和”系统架构师”两类角色，前者负责与AI协同创造，后者确保生成结果的工程化落地。</p><p>因此，精进编程思维转化为培养”机器可理解的逻辑表达能力”，而熟练Prompt则是掌握新的人机交互语言。二者融合形成的”元编程能力”，正在成为数字时代的基础素养。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;DeepSeek R1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在生成式 AI 快速发展的当下，编程领域确实呈现出新的演变趋势。精进编程思维 + 熟练使用 Prompt 正在形成一种&lt;strong&gt;人机协作的新型编程范式&lt;/strong&gt;，这种范式并非完全颠覆传统，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>自己在家理寸头，全网最详细教程！</title>
    <link href="https://promptonce.github.io/2025/02/09/%E8%87%AA%E5%B7%B1%E5%9C%A8%E5%AE%B6%E7%90%86%E5%AF%B8%E5%A4%B4%EF%BC%8C%E5%85%A8%E7%BD%91%E6%9C%80%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%EF%BC%81/"/>
    <id>https://promptonce.github.io/2025/02/09/%E8%87%AA%E5%B7%B1%E5%9C%A8%E5%AE%B6%E7%90%86%E5%AF%B8%E5%A4%B4%EF%BC%8C%E5%85%A8%E7%BD%91%E6%9C%80%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%EF%BC%81/</id>
    <published>2025-02-09T12:33:40.000Z</published>
    <updated>2025-02-09T13:10:17.336Z</updated>
    
    <content type="html"><![CDATA[<p>来源: <a href="https://zhuanlan.zhihu.com/p/560406000">https://zhuanlan.zhihu.com/p/560406000</a></p><p>寸头象征着阳刚与正气，是许多男性的理想发型。然而，理发店的师傅往往不按要求剪，导致最终效果令人失望。因此，自己在家理寸头成为一个不错的选择。本文将为你提供一份详尽的DIY寸头教程，助你轻松掌握这项技能。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h2><p>在开始前，你需要准备以下工具：</p><ul><li><strong>一面可立镜子</strong>（最好是全身镜）</li><li><strong>一面手持小镜子</strong>（方便检查后脑勺）</li><li><strong>一把推子</strong>（电动理发器）</li><li><strong>一副和推子配套的卡尺</strong>（3mm—21mm，限位开关梳）</li></ul><h3 id="关于卡尺的重要性"><a href="#关于卡尺的重要性" class="headerlink" title="关于卡尺的重要性"></a><strong>关于卡尺的重要性</strong></h3><p>卡尺（限位梳）的作用是<strong>提高容错率</strong>。有了卡尺的毫米级限制，无论你如何推，都不会翻车。只需设置好长度，放心推即可。</p><hr><h2 id="理寸头的步骤"><a href="#理寸头的步骤" class="headerlink" title="理寸头的步骤"></a><strong>理寸头的步骤</strong></h2><h3 id="第一步：理后脑勺"><a href="#第一步：理后脑勺" class="headerlink" title="第一步：理后脑勺"></a><strong>第一步：理后脑勺</strong></h3><ul><li><strong>12mm</strong>：推全面积的后脑勺。</li><li><strong>9mm</strong>：推6&#x2F;8的面积。</li><li><strong>6mm</strong>：推4&#x2F;8的面积。</li><li><strong>5mm</strong>：推3&#x2F;8的面积。</li><li><strong>3mm</strong>：推最下面的部分。</li></ul><blockquote><p><strong>小技巧</strong>：选用较大的卡尺可以增加后脑勺的丰满度，使扁头显得更圆润。如果你的头型本来就很好，可以直接从9mm开始递减。</p></blockquote><h3 id="第二步：推正中间"><a href="#第二步：推正中间" class="headerlink" title="第二步：推正中间"></a><strong>第二步：推正中间</strong></h3><ul><li><strong>需要头型修饰的人</strong>：推荐<strong>18mm</strong>，全推完，仅推正中间。</li><li><strong>头型较好的人</strong>：推荐<strong>12mm</strong>（仅适用于头小、头圆的人，宽头、扁头慎选）。</li></ul><blockquote><p><strong>推法</strong>：贴着头皮推，均匀操作。</p></blockquote><h3 id="第三步：理两侧"><a href="#第三步：理两侧" class="headerlink" title="第三步：理两侧"></a><strong>第三步：理两侧</strong></h3><p>两侧的头发决定了整体脸型的观感，因此需要谨慎操作。</p><ul><li><strong>9mm</strong>：先全推一遍，随时照镜子确认。</li><li><strong>6mm</strong>：推下面2&#x2F;3的面积（上方暂时不动）。</li><li><strong>3mm</strong>：理最下面的部分，确保干净、工整。</li><li><strong>1.5mm</strong>：修饰轮廓，剔除杂毛（务必小心）。</li></ul><blockquote><p><strong>针对太阳穴凹陷型头型</strong>：建议选用较大的卡尺，使头型更显丰满。</p></blockquote><h3 id="第四步：处理交界处"><a href="#第四步：处理交界处" class="headerlink" title="第四步：处理交界处"></a><strong>第四步：处理交界处</strong></h3><p>交界处的处理决定了整体发型的层次感。</p><ul><li>若中间留<strong>18mm</strong>，后脑勺<strong>12mm</strong>，则用<strong>15mm</strong>过渡。</li><li>若两侧最上方留<strong>9mm</strong>，中间<strong>18mm</strong>，则用<strong>13mm</strong>推交界处。</li></ul><blockquote><p><strong>推法</strong>：推交界处时，要<strong>沿着切线推</strong>，不能顺着头皮直接推。</p></blockquote><hr><h2 id="收尾及注意事项"><a href="#收尾及注意事项" class="headerlink" title="收尾及注意事项"></a><strong>收尾及注意事项</strong></h2><p>多拍视频确认剪的效果如何，理两侧的时候注意不要剪到交界处，卡尺设置的越小的时候需要越谨慎。</p><p>整个过程初学者可能需要<strong>40分钟左右</strong>，但务必保证推干净、整齐，避免出现“狗啃”效果。每个区域都可以多推几次，以确保均匀。</p><p>希望这份教程能帮助到想自己理寸头的朋友们，祝你成功剪出满意的发型！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来源: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/560406000&quot;&gt;https://zhuanlan.zhihu.com/p/560406000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;寸头象征着阳刚与正气，是许多男性的理想发型。然而，理发店的师傅往往不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计数排序（Counting Sort）详解</title>
    <link href="https://promptonce.github.io/2025/02/08/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Counting-Sort%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
    <id>https://promptonce.github.io/2025/02/08/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Counting-Sort%EF%BC%89%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-02-08T09:14:19.000Z</published>
    <updated>2025-02-08T13:32:52.699Z</updated>
    
    <content type="html"><![CDATA[<p>计数排序是一种<strong>非比较排序算法</strong>，它的基本思想是利用数组下标来确定元素的位置，从而实现排序。它适合于排序范围较小的<strong>正整数集合</strong>，在某些特定场景中可以达到线性时间复杂度。</p><hr><h2 id="一、计数排序的基本原理"><a href="#一、计数排序的基本原理" class="headerlink" title="一、计数排序的基本原理"></a>一、计数排序的基本原理</h2><p>计数排序通过以下步骤实现排序：</p><ol><li><strong>统计频次：</strong> 创建一个额外的计数数组 <code>count</code>，用于存储每个元素的出现次数。计数数组的下标表示输入数据的值。</li><li><strong>累积计数：</strong> 将计数数组变成累积计数数组，用于确定每个元素的最终位置。</li><li><strong>填充输出数组：</strong> 根据累积计数数组，将原数组的元素放入正确的位置，从而构建有序数组。</li></ol><hr><h2 id="二、计数排序的特点"><a href="#二、计数排序的特点" class="headerlink" title="二、计数排序的特点"></a>二、计数排序的特点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h3><ul><li>时间复杂度为 **O(n + k)**，其中 <code>n</code> 是待排序数组的长度，<code>k</code> 是数据的范围（最大值与最小值之间的差值）。</li><li>适合于整数范围较小的数据集。</li><li>是一种稳定排序算法（相同值的元素在排序后保持原有位置）。</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点：</strong></h3><ul><li>需要额外的计数数组和输出数组，占用 <strong>O(n + k)</strong> 的额外空间。</li><li>不适用于元素范围较大的数据集（如浮点数或负数），因为会导致计数数组空间浪费。</li><li>只能处理非负整数。如果需要支持负数或浮点数，需要额外的改进。</li></ul><hr><h2 id="三、计数排序的实现步骤"><a href="#三、计数排序的实现步骤" class="headerlink" title="三、计数排序的实现步骤"></a>三、计数排序的实现步骤</h2><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤：</strong></h3><ol><li>找出数组中的最大值和最小值，确定计数数组的大小。</li><li>初始化计数数组，将所有元素的计数置为 0。</li><li>遍历原数组，统计每个元素的出现次数。</li><li>计算计数数组的累积和，用于确定每个元素在结果数组中的位置。</li><li>倒序遍历原数组，将每个元素放到结果数组的正确位置，同时更新计数数组。</li><li>返回结果数组。</li></ol><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a><strong>关键点：</strong></h3><ul><li><strong>倒序遍历</strong>：确保算法的稳定性。</li><li><strong>累积计数</strong>：累积计数数组用于确定元素的最终位置。</li></ul><hr><h2 id="四、计数排序代码实现（Python）"><a href="#四、计数排序代码实现（Python）" class="headerlink" title="四、计数排序代码实现（Python）"></a>四、计数排序代码实现（Python）</h2><p>下面是计数排序的完整实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 1. 找到最大值和最小值</span></span><br><span class="line">    max_val = <span class="built_in">max</span>(arr)</span><br><span class="line">    min_val = <span class="built_in">min</span>(arr)</span><br><span class="line">    range_of_elements = max_val - min_val + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 创建计数数组并初始化为 0</span></span><br><span class="line">    count = [<span class="number">0</span>] * range_of_elements</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 统计每个元素的出现频率</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">        count[num - min_val] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 累积计数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(count)):</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 倒序遍历原数组，填充输出数组</span></span><br><span class="line">    output = [<span class="number">0</span>] * <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">reversed</span>(arr):</span><br><span class="line">        count[num - min_val] -= <span class="number">1</span></span><br><span class="line">        output[count[num - min_val]] = num</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数组</span></span><br><span class="line">arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">sorted_arr = counting_sort(arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;排序后的数组：&quot;</span>, sorted_arr)</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a><strong>运行结果：</strong></h3><p>输入：<code>[4, 2, 2, 8, 3, 3, 1]</code><br>输出：<code>[1, 2, 2, 3, 3, 4, 8]</code></p><hr><h2 id="五、计数排序的可视化讲解"><a href="#五、计数排序的可视化讲解" class="headerlink" title="五、计数排序的可视化讲解"></a>五、计数排序的可视化讲解</h2><p>假设我们有一个数组：<code>[4, 2, 2, 8, 3, 3, 1]</code>，对其进行计数排序：</p><h3 id="步骤-1：统计频次"><a href="#步骤-1：统计频次" class="headerlink" title="步骤 1：统计频次"></a><strong>步骤 1：统计频次</strong></h3><p>找到数组的最小值为 <code>1</code>，最大值为 <code>8</code>，构造计数数组 <code>count</code>，初始为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = [0, 0, 0, 0, 0, 0, 0, 0]  （长度为 8）</span><br></pre></td></tr></table></figure><p>遍历数组，统计每个元素的频次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = [4, 2, 2, 8, 3, 3, 1]</span><br><span class="line">count = [1, 0, 2, 2, 1, 0, 0, 1]</span><br></pre></td></tr></table></figure><h3 id="步骤-2：累积计数"><a href="#步骤-2：累积计数" class="headerlink" title="步骤 2：累积计数"></a><strong>步骤 2：累积计数</strong></h3><p>将计数数组变为累积计数数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = [1, 1, 3, 5, 6, 6, 6, 7]</span><br></pre></td></tr></table></figure><h3 id="步骤-3：倒序填充输出数组"><a href="#步骤-3：倒序填充输出数组" class="headerlink" title="步骤 3：倒序填充输出数组"></a><strong>步骤 3：倒序填充输出数组</strong></h3><p>根据累积计数数组，倒序遍历原数组，将元素放入正确位置：</p><ul><li>倒序遍历 <code>arr = [4, 2, 2, 8, 3, 3, 1]</code></li><li>每次将元素放入 <code>output</code> 数组，并更新 <code>count</code>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output = [1, 2, 2, 3, 3, 4, 8]</span><br></pre></td></tr></table></figure><p>最终得到排序后的数组。</p><hr><h2 id="六、计数排序的改进"><a href="#六、计数排序的改进" class="headerlink" title="六、计数排序的改进"></a>六、计数排序的改进</h2><h3 id="1-支持负数"><a href="#1-支持负数" class="headerlink" title="1. 支持负数"></a><strong>1. 支持负数</strong></h3><p>计数排序可以通过调整偏移量来支持负数。例如，如果数组的最小值为 <code>-5</code>，最大值为 <code>5</code>，则偏移量为 <code>5</code>，即所有元素加 <code>5</code> 后再进行计数。</p><h3 id="2-多关键字排序"><a href="#2-多关键字排序" class="headerlink" title="2. 多关键字排序"></a><strong>2. 多关键字排序</strong></h3><p>计数排序可以用于多关键字排序（如基数排序中的每位排序）。</p><hr><h2 id="七、计数排序的应用场景"><a href="#七、计数排序的应用场景" class="headerlink" title="七、计数排序的应用场景"></a>七、计数排序的应用场景</h2><p>计数排序适合以下场景：</p><ul><li>数据范围较小（如考试成绩排序）。</li><li>数据是整数（或可以映射为整数）。</li><li>对排序稳定性有要求。</li></ul><hr><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>计数排序是一种高效且简单的非比较排序算法，尤其在数据范围较小时，性能优于许多复杂的排序算法。它的时间复杂度为 **O(n + k)**，空间复杂度也为 **O(n + k)**，但由于额外的空间需求，不适用于非常大的数据范围。通过适当改进，计数排序可以支持负数和多关键字排序，在实际中具有广泛的应用价值。</p><p><strong>关键点复习：</strong></p><ul><li>计数排序是稳定排序。</li><li>时间复杂度为线性，但空间复杂度较高。</li><li>核心在于“统计”和“累积”两个步骤。</li></ul><p>希望这篇文章能帮助你掌握计数排序！ 😊</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计数排序是一种&lt;strong&gt;非比较排序算法&lt;/strong&gt;，它的基本思想是利用数组下标来确定元素的位置，从而实现排序。它适合于排序范围较小的&lt;strong&gt;正整数集合&lt;/strong&gt;，在某些特定场景中可以达到线性时间复杂度。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、计数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript 常用 API 总结</title>
    <link href="https://promptonce.github.io/2025/02/08/JavaScript-%E5%B8%B8%E7%94%A8-API-%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2025/02/08/JavaScript-%E5%B8%B8%E7%94%A8-API-%E6%80%BB%E7%BB%93/</id>
    <published>2025-02-08T05:53:31.000Z</published>
    <updated>2025-02-08T05:54:30.347Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 开发中，掌握一些常用的 API 可以极大地提高代码的效率和可读性。今天我们来总结两个非常实用的方法：<code>includes</code> 和 <code>toFixed</code>。这两个方法分别用于字符串&#x2F;数组的检查和数字格式化，是日常开发中的高频工具。</p><hr><h4 id="1-includes-方法"><a href="#1-includes-方法" class="headerlink" title="1. includes 方法"></a>1. <code>includes</code> 方法</h4><p><code>includes</code> 是 JavaScript 中用于检查字符串或数组是否包含某个元素的方法。它返回一个布尔值（<code>true</code> 或 <code>false</code>），表示目标是否存在于字符串或数组中。</p><h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">str.<span class="title function_">includes</span>(searchValue, startIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">arr.<span class="title function_">includes</span>(searchElement, fromIndex);</span><br></pre></td></tr></table></figure><h5 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h5><ul><li><code>searchValue</code> &#x2F; <code>searchElement</code>：需要查找的值或元素。</li><li><code>startIndex</code> &#x2F; <code>fromIndex</code>（可选）：从哪个位置开始查找，默认为 0。</li></ul><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">includes</span>(<span class="string">&quot;world&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">includes</span>(<span class="string">&quot;JavaScript&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">includes</span>(<span class="number">3</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">includes</span>(<span class="number">10</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul><li>区分大小写。</li><li>适用于字符串和数组。</li><li>可以指定起始查找位置。</li></ul><hr><h4 id="2-toFixed-方法"><a href="#2-toFixed-方法" class="headerlink" title="2. toFixed 方法"></a>2. <code>toFixed</code> 方法</h4><p><code>toFixed</code> 是 JavaScript 中用于格式化数字的方法，可以将数字保留指定的小数位数，并返回一个字符串。</p><h5 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num.<span class="title function_">toFixed</span>(digits);</span><br></pre></td></tr></table></figure><h5 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h5><ul><li><code>digits</code>：需要保留的小数位数，范围是 0 到 20。</li></ul><h5 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">123.456789</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// &quot;123.46&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">0</span>)); <span class="comment">// &quot;123&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">5</span>)); <span class="comment">// &quot;123.45679&quot;</span></span><br></pre></td></tr></table></figure><h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><ul><li>返回的结果是字符串类型。</li><li>如果小数位数不足，会自动补零。</li><li>如果小数位数超过指定值，会进行四舍五入。</li></ul><hr><h3 id="JavaScript-常用-API-列表"><a href="#JavaScript-常用-API-列表" class="headerlink" title="JavaScript 常用 API 列表"></a>JavaScript 常用 API 列表</h3><p>除了 <code>includes</code> 和 <code>toFixed</code>，JavaScript 还有许多其他常用的 API，以下是一些高频使用的工具：</p><h4 id="字符串相关："><a href="#字符串相关：" class="headerlink" title="字符串相关："></a>字符串相关：</h4><ul><li><code>split()</code>：将字符串按指定分隔符拆分为数组。</li><li><code>substring()</code>：提取字符串的子串。</li><li><code>replace()</code>：替换字符串中的内容。</li><li><code>trim()</code>：去除字符串两端的空白字符。</li></ul><h4 id="数组相关："><a href="#数组相关：" class="headerlink" title="数组相关："></a>数组相关：</h4><ul><li><code>map()</code>：对数组中的每个元素执行操作，并返回新数组。</li><li><code>filter()</code>：过滤数组中的元素，返回符合条件的元素组成的新数组。</li><li><code>reduce()</code>：将数组中的元素累积为一个值。</li><li><code>slice()</code>：提取数组的一部分，返回新数组。</li></ul><h4 id="数字相关："><a href="#数字相关：" class="headerlink" title="数字相关："></a>数字相关：</h4><ul><li><code>parseInt()</code>：将字符串解析为整数。</li><li><code>parseFloat()</code>：将字符串解析为浮点数。</li><li><code>Math.round()</code>：四舍五入。</li><li><code>Math.random()</code>：生成随机数。</li></ul><h4 id="其他常用-API："><a href="#其他常用-API：" class="headerlink" title="其他常用 API："></a>其他常用 API：</h4><ul><li><code>JSON.parse()</code>：将 JSON 字符串解析为对象。</li><li><code>JSON.stringify()</code>：将对象转换为 JSON 字符串。</li><li><code>setTimeout()</code>：延迟执行函数。</li><li><code>setInterval()</code>：定时执行函数。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>includes</code> 和 <code>toFixed</code> 是 JavaScript 中非常实用的方法，分别用于检查元素是否存在和格式化数字。掌握这些 API 可以让你的代码更加简洁高效。除此之外，JavaScript 还提供了丰富的内置方法，熟练使用它们可以极大地提升开发效率。希望这篇博客能帮助你更好地理解和使用这些工具！ 🚀</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 JavaScript 开发中，掌握一些常用的 API 可以极大地提高代码的效率和可读性。今天我们来总结两个非常实用的方法：&lt;code&gt;includes&lt;/code&gt; 和 &lt;code&gt;toFixed&lt;/code&gt;。这两个方法分别用于字符串&amp;#x2F;数组的检查和数字格式化</summary>
      
    
    
    
    
  </entry>
  
</feed>
