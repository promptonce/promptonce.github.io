<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PromptOnce</title>
  
  
  <link href="https://promptonce.github.io/atom.xml" rel="self"/>
  
  <link href="https://promptonce.github.io/"/>
  <updated>2024-10-22T08:01:11.838Z</updated>
  <id>https://promptonce.github.io/</id>
  
  <author>
    <name>penggan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划算法</title>
    <link href="https://promptonce.github.io/2024/10/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
    <id>https://promptonce.github.io/2024/10/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</id>
    <published>2024-10-22T07:59:58.000Z</published>
    <updated>2024-10-22T08:01:11.838Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划是一种将复杂问题分解为更小的子问题并通过缓存子问题的解来避免重复计算的算法设计方法。它适用于具有<strong>重叠子问题</strong>和<strong>最优子结构</strong>性质的问题。动态规划通常用于优化问题，目的是通过构建递归关系和记忆化中间结果，找到全局最优解。</p><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>动态规划的核心思想是将一个复杂的问题分解为若干个子问题，然后通过递推的方式逐步解决这些子问题。它的基本步骤如下：</p><ol><li><strong>定义状态</strong>：确定问题的状态，也就是用哪些变量来描述当前子问题的状态。</li><li><strong>状态转移方程</strong>：找到子问题之间的递推关系（即状态转移方程），描述如何从已解决的子问题得到当前问题的解。</li><li><strong>边界条件</strong>：确定初始状态的值，通常是最小规模的问题的解。</li><li><strong>计算顺序</strong>：根据状态转移方程的依赖关系，从小到大计算每个子问题的解。</li></ol><p>动态规划常用来解决最优化问题，如最短路径问题、最大子序列和问题、背包问题等。</p><h4 id="动态规划的特性"><a href="#动态规划的特性" class="headerlink" title="动态规划的特性"></a>动态规划的特性</h4><ol><li><p><strong>重叠子问题</strong>：动态规划问题通常具有重叠子问题，即原问题可以分解成若干个相同的子问题。不同的子问题可能会在递归求解中被重复计算。如果使用简单的递归方法，会导致大量的重复计算，因此通过记忆化技术（如数组或表）存储子问题的解，可以避免重复计算。</p></li><li><p><strong>最优子结构</strong>：如果问题的最优解可以由其子问题的最优解构造而成，称为最优子结构。例如，求解最短路径时，如果最短路径经过某个点，那么从该点到终点的子路径也一定是最短路径。</p></li></ol><h4 id="动态规划的两种实现方式"><a href="#动态规划的两种实现方式" class="headerlink" title="动态规划的两种实现方式"></a>动态规划的两种实现方式</h4><ol><li><p><strong>自顶向下（记忆化搜索）</strong>：使用递归的方式自顶向下解决问题，同时将子问题的解存储在数组或哈希表中（称为“记忆化”），以便下次遇到相同的子问题时直接返回之前计算的结果，而不是重新计算。</p></li><li><p><strong>自底向上（迭代法）</strong>：先解决最简单的子问题，然后通过迭代的方式解决规模逐渐增大的问题。自底向上通常表现为使用一个数组或表，按照状态转移方程逐步填充表中的值。</p></li></ol><h4 id="动态规划的经典例题"><a href="#动态规划的经典例题" class="headerlink" title="动态规划的经典例题"></a>动态规划的经典例题</h4><h5 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1. 斐波那契数列"></a>1. 斐波那契数列</h5><p>这是动态规划最简单的例子，斐波那契数列的递归公式为：<br>[<br>F(n) &#x3D; F(n-1) + F(n-2)<br>]<br>使用动态规划，可以避免递归的重复计算。</p><p><strong>状态定义</strong>：令 <code>dp[i]</code> 表示斐波那契数列第 <code>i</code> 项的值。</p><p><strong>状态转移方程</strong>：<br>[<br>dp[i] &#x3D; dp[i-1] + dp[i-2]<br>]</p><p><strong>边界条件</strong>：<br>[<br>dp[0] &#x3D; 0, \ dp[1] &#x3D; 1<br>]</p><p><strong>自底向上代码实现</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h5 id="2-背包问题"><a href="#2-背包问题" class="headerlink" title="2. 背包问题"></a>2. 背包问题</h5><p>背包问题是经典的动态规划问题，描述如下：有一个背包容量为 <code>W</code>，有 <code>n</code> 个物品，每个物品有重量 <code>w_i</code> 和价值 <code>v_i</code>，问如何选择物品装入背包，使得装入背包的物品总价值最大。</p><p><strong>状态定义</strong>：<code>dp[i][j]</code> 表示前 <code>i</code> 个物品在背包容量为 <code>j</code> 时的最大价值。</p><p><strong>状态转移方程</strong>：<br>[<br>dp[i][j] &#x3D; \max(dp[i-1][j], dp[i-1][j-w_i] + v_i)<br>]<br>如果不选择第 <code>i</code> 个物品，则 <code>dp[i][j] = dp[i-1][j]</code>；如果选择，则 <code>dp[i][j] = dp[i-1][j-w_i] + v_i</code>。</p><p><strong>边界条件</strong>：<code>dp[0][j] = 0</code>（没有物品时最大价值为0）。</p><h5 id="3-最长公共子序列（LCS）"><a href="#3-最长公共子序列（LCS）" class="headerlink" title="3. 最长公共子序列（LCS）"></a>3. 最长公共子序列（LCS）</h5><p>给定两个序列，求它们的最长公共子序列。其状态转移方程为：</p><p>[<br>dp[i][j] &#x3D;<br>\begin{cases}<br>dp[i-1][j-1] + 1, &amp; \text{if } s1[i] &#x3D; s2[j] \<br>\max(dp[i-1][j], dp[i][j-1]), &amp; \text{if } s1[i] \neq s2[j]<br>\end{cases}<br>]</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>动态规划通过记忆化子问题的解，可以极大地提高算法的效率。掌握动态规划的关键在于能识别问题的<strong>重叠子问题</strong>和<strong>最优子结构</strong>，并合理地定义状态和状态转移方程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;动态规划是一种将复杂问题分解为更小的子问题并通过缓存子问题的解来避免重复计算的算法设计方法。它适用于具有&lt;strong&gt;重叠子问题&lt;/strong&gt;和&lt;strong&gt;最优子结构&lt;/strong&gt;性质的问题。动态规划通常用于优化问题，目的是通过构建递归关系和记忆化中间结果，找</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>tomcat和nginx总结</title>
    <link href="https://promptonce.github.io/2024/10/20/nginx%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/10/20/nginx%E6%80%BB%E7%BB%93/</id>
    <published>2024-10-20T10:13:54.000Z</published>
    <updated>2024-10-20T11:31:03.667Z</updated>
    
    <content type="html"><![CDATA[<p>nginx是一个高效的静态内容 Web 服务器，同时也是反向代理服务器，擅长处理静态资源、负载均衡和反向代理功能。</p><h2 id="vue发布的网站非根域名刷新404的错误"><a href="#vue发布的网站非根域名刷新404的错误" class="headerlink" title="vue发布的网站非根域名刷新404的错误"></a>vue发布的网站非根域名刷新404的错误</h2><p>*<em>解决方法：配置一个重定向规则，使得所有请求都指向Vue应用的入口文件 <code>index.html</code>。</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name your_domain.com;  <span class="comment"># 替换为你的域名或IP地址</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root /path/to/your/vue/app;  <span class="comment"># Vue应用打包后的文件存放目录</span></span><br><span class="line">        try_files $uri $uri/ /index.html;  <span class="comment"># 如果找不到文件，则返回index.html</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;nginx是一个高效的静态内容 Web 服务器，同时也是反向代理服务器，擅长处理静态资源、负载均衡和反向代理功能。&lt;/p&gt;
&lt;h2 id=&quot;vue发布的网站非根域名刷新404的错误&quot;&gt;&lt;a href=&quot;#vue发布的网站非根域名刷新404的错误&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript 标记清除法总结</title>
    <link href="https://promptonce.github.io/2024/10/17/JavaScript-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/10/17/JavaScript-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2024-10-17T15:48:35.000Z</published>
    <updated>2024-10-17T16:22:47.720Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVariable = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;I&#x27;m a global variable&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="string">&quot;codereasy&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">globalVariable</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">xiaoming</span>);</span><br><span class="line"><span class="comment">//(1) &#123;name: &quot;I&#x27;m a global variable&quot;&#125;</span></span><br><span class="line"><span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量可以被视为根， 因此他们是可达的</span></span><br><span class="line"><span class="keyword">let</span> globalVariable = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;I&#x27;m a global variable&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的参数和内部变量也是可达的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">someFunction</span>(<span class="params">someArgument</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> functionVariable = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;I&#x27;m a variable inside of a function&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(someArgument, functionVariable)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someFunction</span>(globalVariable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objectA = &#123;</span><br><span class="line"><span class="attr">objectProperty</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;I&#x27;m a property of an object&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objectA.<span class="property">objectProperty</span>);</span><br><span class="line"><span class="comment">// (1) &#123;name: &quot;I&#x27;m a global variable&quot;&#125;  </span></span><br><span class="line"><span class="comment">// (1) &#123;name: &quot;I&#x27;m a variable inside of a f...&#125;</span></span><br></pre></td></tr></table></figure><p>优点：标记清除法解决了循环依赖的问题<br>缺点：标记清除法会出现内存碎片</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>flask总结</title>
    <link href="https://promptonce.github.io/2024/10/17/flask%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/10/17/flask%E6%80%BB%E7%BB%93/</id>
    <published>2024-10-16T16:56:07.000Z</published>
    <updated>2024-10-17T16:24:37.997Z</updated>
    
    <content type="html"><![CDATA[<p>服务器运行flask绑定所有端口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask run --host <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;服务器运行flask绑定所有端口&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript垃圾回收-引用计数法</title>
    <link href="https://promptonce.github.io/2024/10/16/JavaScript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95/"/>
    <id>https://promptonce.github.io/2024/10/16/JavaScript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95/</id>
    <published>2024-10-16T09:34:55.000Z</published>
    <updated>2024-10-16T09:37:08.517Z</updated>
    
    <content type="html"><![CDATA[<p>引用计数法进行垃圾回收内存泄露的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> objectA = &#123;<span class="attr">name</span>: <span class="string">&quot;Object A&quot;</span>&#125;;</span><br><span class="line">  <span class="keyword">let</span> objectB = &#123;<span class="attr">name</span>: <span class="string">&quot;Object B&quot;</span>&#125;;</span><br><span class="line">  objectA.<span class="property">otherObject</span> = objectB;</span><br><span class="line">  objectB.<span class="property">otherObject</span> = objectA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;引用计数法进行垃圾回收内存泄露的例子&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>this绑定相关面试题</title>
    <link href="https://promptonce.github.io/2024/10/16/this%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://promptonce.github.io/2024/10/16/this%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2024-10-16T09:06:22.000Z</published>
    <updated>2024-10-16T09:23:00.061Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj1&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(obj2.<span class="property">foo</span> = obj1.<span class="property">foo</span>)();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;全局window&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> fun = person.<span class="property">sayName</span>;</span><br><span class="line">  <span class="title function_">fun</span>();<span class="comment">// 全局window</span></span><br><span class="line">  person.<span class="title function_">sayName</span>(); <span class="comment">//person</span></span><br><span class="line">  (b = person.<span class="property">sayName</span>)();<span class="comment">// 全局window对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="https://promptonce.github.io/2024/10/16/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>https://promptonce.github.io/2024/10/16/%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2024-10-16T06:48:09.000Z</published>
    <updated>2024-10-16T07:12:25.248Z</updated>
    
    <content type="html"><![CDATA[<p>有序并不是双指针使用的必要前提，但在某些情况下，<strong>有序数组</strong>确实可以帮助我们充分发挥双指针的优势，特别是在减少搜索空间和提高效率方面。双指针是一种灵活的算法技巧，可以根据具体场景应用于有序或无序的场景。下面将详细讨论。</p><h3 id="1-有序数组中的双指针"><a href="#1-有序数组中的双指针" class="headerlink" title="1. 有序数组中的双指针"></a>1. <strong>有序数组中的双指针</strong></h3><p>在有序数组或序列中使用双指针，可以利用排序的特性来快速定位解。这类问题通常依赖于数据的有序性来实现更高效的算法。例如，前面提到的 <strong>“Two Sum II”</strong> 问题，因为数组是有序的，双指针可以通过移动指针快速缩小搜索范围。如果数组是无序的，那么双指针这种方式在查找和筛选时会失去优势。</p><ul><li><strong>例子</strong>：<ul><li><strong>查找两数之和问题</strong>：利用双指针，从两端向中间靠拢，根据和与目标值的比较，决定移动哪一个指针。</li></ul></li></ul><h3 id="2-无序数组中的双指针"><a href="#2-无序数组中的双指针" class="headerlink" title="2. 无序数组中的双指针"></a>2. <strong>无序数组中的双指针</strong></h3><p>虽然有序数组能让双指针更高效，但双指针同样可以在<strong>无序数组</strong>中使用。常见的应用场景包括处理<strong>特定条件的子数组</strong>、<strong>滑动窗口问题</strong>、<strong>快慢指针遍历链表</strong>等。这些问题不依赖有序性，而是基于特定的逻辑条件来移动指针。</p><ul><li><strong>例子</strong>：<ul><li><strong>快慢指针（Floyd’s Tortoise and Hare Algorithm）</strong>：该算法常用于检测链表中的环，并且链表不需要有序。一个指针每次走一步（慢指针），另一个指针每次走两步（快指针），最终两个指针会相遇。</li><li><strong>滑动窗口</strong>：在处理动态长度的子数组问题时，双指针可以用来动态调整窗口的大小，维护窗口的边界。</li></ul></li></ul><h3 id="3-滑动窗口问题"><a href="#3-滑动窗口问题" class="headerlink" title="3. 滑动窗口问题"></a>3. <strong>滑动窗口问题</strong></h3><p>滑动窗口（Sliding Window）是一类经典的双指针应用，通常用于处理<strong>无序数组</strong>或字符串。在这些问题中，一个指针（左指针）固定窗口的起点，另一个指针（右指针）扩展窗口或收缩窗口，直到满足某个条件。</p><ul><li><strong>例子</strong>：<ul><li><strong>最长子数组问题</strong>：寻找一个数组中满足某些条件的最长子数组。双指针可以用来动态调整子数组的起始和结束位置，以优化解的查找。</li></ul></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>双指针并不依赖数据有序与否，而是依赖问题的具体要求和性质。在有序数组中，双指针通常可以更加高效地解决问题，因为排序提供了一个明确的规则（例如大小关系）来指导指针的移动；在无序数组或其他数据结构中，双指针也可以用于解决子数组、链表问题等。主要的前提是问题能够通过调整两个位置来逐步缩小搜索范围或满足特定条件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有序并不是双指针使用的必要前提，但在某些情况下，&lt;strong&gt;有序数组&lt;/strong&gt;确实可以帮助我们充分发挥双指针的优势，特别是在减少搜索空间和提高效率方面。双指针是一种灵活的算法技巧，可以根据具体场景应用于有序或无序的场景。下面将详细讨论。&lt;/p&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript正则表达式</title>
    <link href="https://promptonce.github.io/2024/10/16/JavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://promptonce.github.io/2024/10/16/JavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2024-10-16T06:36:10.000Z</published>
    <updated>2024-10-16T06:36:50.776Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isCharacter</span>(<span class="params">c</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/[a-zA-Z0-9]/</span>.<span class="title function_">test</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>npm配置代理</title>
    <link href="https://promptonce.github.io/2024/10/16/npm%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <id>https://promptonce.github.io/2024/10/16/npm%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</id>
    <published>2024-10-15T17:35:00.000Z</published>
    <updated>2024-10-15T17:36:58.078Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="keyword">delete</span> proxy</span><br><span class="line">npm config set proxy <span class="attr">http</span>:<span class="comment">//proxy-server:port</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>显示绑定、隐式绑定、new绑定的优点</title>
    <link href="https://promptonce.github.io/2024/10/15/%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A%E3%80%81%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A%E3%80%81new%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BC%98%E7%82%B9/"/>
    <id>https://promptonce.github.io/2024/10/15/%E6%98%BE%E7%A4%BA%E7%BB%91%E5%AE%9A%E3%80%81%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A%E3%80%81new%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BC%98%E7%82%B9/</id>
    <published>2024-10-15T15:53:02.000Z</published>
    <updated>2024-10-15T16:09:45.746Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj1&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">obj1.<span class="title function_">foo</span>(); <span class="comment">// obj1</span></span><br><span class="line">obj2.<span class="title function_">foo</span>(); <span class="comment">// obj2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定和显式绑定</span></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2); <span class="comment">//obj2, 说明显式绑定优先级更高</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>new关键字绑定</title>
    <link href="https://promptonce.github.io/2024/10/15/new%E5%85%B3%E9%94%AE%E5%AD%97%E7%BB%91%E5%AE%9A/"/>
    <id>https://promptonce.github.io/2024/10/15/new%E5%85%B3%E9%94%AE%E5%AD%97%E7%BB%91%E5%AE%9A/</id>
    <published>2024-10-15T15:06:50.000Z</published>
    <updated>2024-10-15T15:22:09.111Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Student &#123;&#125;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// Student &#123;name : &quot;codereasy&quot;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过new关键字创建一个新对象的步骤是什么、构造函数是如何创建新对象的？</span></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;codereasy&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(xiaoming);</span><br></pre></td></tr></table></figure><p>在构造函数中添加return，如果return的是对象，则直接返回该对象，如果return的是基本类型，则return语句无效，仍然返回我们创建的新对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>显式绑定</title>
    <link href="https://promptonce.github.io/2024/10/15/%E6%98%BE%E5%BC%8F%E7%BB%91%E5%AE%9A/"/>
    <id>https://promptonce.github.io/2024/10/15/%E6%98%BE%E5%BC%8F%E7%BB%91%E5%AE%9A/</id>
    <published>2024-10-15T08:34:18.000Z</published>
    <updated>2024-10-15T13:14:48.119Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="variable language_">window</span>); <span class="comment">// window</span></span><br><span class="line">foo.<span class="title function_">call</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;codereasy&quot;</span>&#125;); <span class="comment">// &#123;name: &quot;codereasy&quot;&#125;</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="number">666</span>); <span class="comment">// Object( empty )</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;codereasy&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// obj对象</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>隐式绑定</title>
    <link href="https://promptonce.github.io/2024/10/15/%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A/"/>
    <id>https://promptonce.github.io/2024/10/15/%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A/</id>
    <published>2024-10-15T08:11:12.000Z</published>
    <updated>2024-10-15T08:16:13.132Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj1&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span>,</span><br><span class="line">  <span class="attr">obj1</span>: obj1,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">obj1</span>.<span class="title function_">foo</span>();<span class="comment">// &#123;name: &quot;obj1&quot;, foo: foo()&#125;</span></span><br></pre></td></tr></table></figure><p>谁直接调用foo（换而言之，谁离foo更近），那么foo()中的this就指向谁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>this在运行时绑定还是编译时绑定</title>
    <link href="https://promptonce.github.io/2024/10/15/this%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E6%97%B6%E7%BB%91%E5%AE%9A/"/>
    <id>https://promptonce.github.io/2024/10/15/this%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E6%97%B6%E7%BB%91%E5%AE%9A/</id>
    <published>2024-10-15T07:49:31.000Z</published>
    <updated>2024-10-15T08:05:17.065Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.调用方式一： 直接调用</span></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用方式二：将foo放到一个对象中，再调用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;codereasy&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>();<span class="comment">// object对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.调用方式三： 通过call或者apply调用</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="string">&quot;ctgu&quot;</span>);<span class="comment">// string &#123;ctgu对象&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript寄生组合继承</title>
    <link href="https://promptonce.github.io/2024/10/14/JavaScript%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF/"/>
    <id>https://promptonce.github.io/2024/10/14/JavaScript%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF/</id>
    <published>2024-10-14T05:34:20.000Z</published>
    <updated>2024-10-14T05:49:10.115Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&quot;我是父类prototype上的属性&quot;</span>;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个没有实例方法的父类实例作为子类的原型</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 修复构造函数的指向</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个Child实例</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">sayHello</span> === child2.<span class="property">sayHello</span>);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parentObj = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parentObj.<span class="property">a</span>);<span class="comment">//我是父类prototype上的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">a</span>)<span class="comment">//我是父类prototype上的属性</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&quot;我是父类prototype上的属性&quot;</span>;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">childFunction</span> = <span class="function">()=&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是child方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个没有实例方法的父类实例作为子类的原型</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 修复构造函数的指向</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个Child实例</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">child1.<span class="title function_">childFunction</span>();</span><br><span class="line"><span class="comment">// TypeError: child1.childFunction is not a function</span></span><br><span class="line"><span class="comment">//     at &lt;anonymous&gt;:25:8</span></span><br><span class="line"><span class="comment">//     at mn (&lt;anonymous&gt;:16:5455)</span></span><br></pre></td></tr></table></figure><p>优点：<br>1 ，原型属性不会被共享<br>2 ，可以继承父类的原型链上的属性和方法<br>3 ．只调用了 1 次 Parent(), 因此，它不会在 Child 的prototype 上添加 Parent 的属性和方法。<br>缺点：<br> Child.prototype的原始属性和方法会丢失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript组合继承</title>
    <link href="https://promptonce.github.io/2024/10/14/JavaScript%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF/"/>
    <id>https://promptonce.github.io/2024/10/14/JavaScript%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF/</id>
    <published>2024-10-14T05:26:21.000Z</published>
    <updated>2024-10-14T05:32:14.372Z</updated>
    
    <content type="html"><![CDATA[<hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&quot;我是父类prototype上的属性&quot;</span>;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个Child实例</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">sayHello</span> === child2.<span class="property">sayHello</span>);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parentObj = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parentObj.<span class="property">a</span>);<span class="comment">//我是父类prototype上的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">a</span>)<span class="comment">//我是父类prototype上的属性</span></span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>原型属性不会被共享。</li><li>可以继承父类的原型链上的属性和方法。<br>缺点：</li><li>调用了 2 次 Parent()。</li><li>它在 child 的 prototype 上添加了父类的属性和方法。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript构造函数继承</title>
    <link href="https://promptonce.github.io/2024/10/14/JavaScript%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF/"/>
    <id>https://promptonce.github.io/2024/10/14/JavaScript%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF/</id>
    <published>2024-10-14T05:11:32.000Z</published>
    <updated>2024-10-14T05:22:54.129Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="string">&quot;我是父类prototype上的属性&quot;</span>;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个Child实例</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">sayHello</span> === child2.<span class="property">sayHello</span>);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parentObj = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parentObj.<span class="property">a</span>);<span class="comment">//我是父类prototype上的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">a</span>)<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>优点：这种继承方式的好处是，原型属性不会被共享。<br>缺点：它不能继承父类prototype上的属性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>原型链继承</title>
    <link href="https://promptonce.github.io/2024/10/14/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/"/>
    <id>https://promptonce.github.io/2024/10/14/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/</id>
    <published>2024-10-14T04:58:43.000Z</published>
    <updated>2024-10-14T05:18:47.604Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>)  &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;child&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="title function_">getName</span>());<span class="comment">// &quot;child&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">arr</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类继承父类，这里是关键，实现原型链继承</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化子类</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> <span class="title function_">child</span>();</span><br><span class="line"></span><br><span class="line">child1.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child1.<span class="property">arr</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(child2.<span class="property">arr</span>)</span><br></pre></td></tr></table></figure><p>原型链继承的一个主要问题是包含引用类型值的原型属性会被所有实例共享。换而言之，如果一个实例改变了该属性，那么其他实例的该属性也会被改变</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文参考文献总结</title>
    <link href="https://promptonce.github.io/2024/10/14/%E8%AE%BA%E6%96%87%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%80%BB%E7%BB%93/"/>
    <id>https://promptonce.github.io/2024/10/14/%E8%AE%BA%E6%96%87%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%80%BB%E7%BB%93/</id>
    <published>2024-10-14T02:56:30.000Z</published>
    <updated>2024-10-14T02:59:38.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="论文参考文献的主要格式"><a href="#论文参考文献的主要格式" class="headerlink" title="论文参考文献的主要格式"></a>论文参考文献的主要格式</h3><p>在学术写作中，最常用的参考文献格式包括APA（美国心理学会）、MLA（现代语言协会）、Chicago（芝加哥格式）和IEEE（主要用于工程和计算机科学）。以下是这几种常见格式的说明和示例。</p><hr><h3 id="1-APA格式-American-Psychological-Association"><a href="#1-APA格式-American-Psychological-Association" class="headerlink" title="1. APA格式 (American Psychological Association)"></a>1. <strong>APA格式 (American Psychological Association)</strong></h3><p>通常用于社会科学和心理学领域。它的特点是以作者的姓氏和出版年份为主。</p><h4 id="书籍示例："><a href="#书籍示例：" class="headerlink" title="书籍示例："></a>书籍示例：</h4><p><strong>格式</strong>:<br>作者姓氏, 姓名首字母. (出版年份). <em>书名</em>. 出版地: 出版商.</p><p><strong>示例</strong>:<br>Smith, J. (2020). <em>Cognitive Psychology</em>. New York: Academic Press.</p><h4 id="期刊文章示例："><a href="#期刊文章示例：" class="headerlink" title="期刊文章示例："></a>期刊文章示例：</h4><p><strong>格式</strong>:<br>作者姓氏, 姓名首字母. (出版年份). 文章标题. <em>期刊名称</em>, 卷号(期号), 页码.</p><p><strong>示例</strong>:<br>Brown, L. (2019). The impact of stress on memory. <em>Journal of Experimental Psychology</em>, 45(3), 123-145.</p><hr><h3 id="2-MLA格式-Modern-Language-Association"><a href="#2-MLA格式-Modern-Language-Association" class="headerlink" title="2. MLA格式 (Modern Language Association)"></a>2. <strong>MLA格式 (Modern Language Association)</strong></h3><p>通常用于人文学科，尤其是文学、语言学等。MLA格式更注重作者和作品的标题。</p><h4 id="书籍示例：-1"><a href="#书籍示例：-1" class="headerlink" title="书籍示例："></a>书籍示例：</h4><p><strong>格式</strong>:<br>作者姓氏, 名字. <em>书名</em>. 出版社, 出版年份.</p><p><strong>示例</strong>:<br>Smith, John. <em>Understanding Poetry</em>. Oxford University Press, 2018.</p><h4 id="期刊文章示例：-1"><a href="#期刊文章示例：-1" class="headerlink" title="期刊文章示例："></a>期刊文章示例：</h4><p><strong>格式</strong>:<br>作者姓氏, 名字. “文章标题.” <em>期刊名称</em>, 卷号, 期号, 出版年份, 页码.</p><p><strong>示例</strong>:<br>Brown, Lisa. “Cultural Approaches to Modern Poetry.” <em>Literary Review</em>, vol. 45, no. 2, 2020, pp. 34-56.</p><hr><h3 id="3-Chicago格式-芝加哥格式"><a href="#3-Chicago格式-芝加哥格式" class="headerlink" title="3. Chicago格式 (芝加哥格式)"></a>3. <strong>Chicago格式 (芝加哥格式)</strong></h3><p>适用于历史学和一些人文学科，有两种主要风格：注释-书目制和作者-日期制。这里介绍的是注释-书目制。</p><h4 id="书籍示例：-2"><a href="#书籍示例：-2" class="headerlink" title="书籍示例："></a>书籍示例：</h4><p><strong>格式</strong>:<br>作者姓氏, 名字. <em>书名</em>. 出版地: 出版社, 出版年份.</p><p><strong>示例</strong>:<br>Smith, John. <em>History of the Roman Empire</em>. Chicago: University of Chicago Press, 2017.</p><h4 id="期刊文章示例：-2"><a href="#期刊文章示例：-2" class="headerlink" title="期刊文章示例："></a>期刊文章示例：</h4><p><strong>格式</strong>:<br>作者姓氏, 名字. “文章标题.” <em>期刊名称</em> 卷号, 期号 (出版年份): 页码.</p><p><strong>示例</strong>:<br>Brown, Lisa. “The Role of Women in Roman Politics.” <em>Classical Studies Journal</em> 35, no. 4 (2019): 45-67.</p><hr><h3 id="4-IEEE格式"><a href="#4-IEEE格式" class="headerlink" title="4. IEEE格式"></a>4. <strong>IEEE格式</strong></h3><p>主要用于工程、计算机科学等技术领域。IEEE采用编号系统来标示参考文献。</p><h4 id="书籍示例：-3"><a href="#书籍示例：-3" class="headerlink" title="书籍示例："></a>书籍示例：</h4><p><strong>格式</strong>:<br>[编号] 作者姓名, <em>书名</em>, 版本 (如果有). 出版地: 出版社, 出版年份, 页码.</p><p><strong>示例</strong>:<br>[1] J. Smith, <em>Introduction to Robotics</em>, 2nd ed. New York: McGraw-Hill, 2019, pp. 100-120.</p><h4 id="期刊文章示例：-3"><a href="#期刊文章示例：-3" class="headerlink" title="期刊文章示例："></a>期刊文章示例：</h4><p><strong>格式</strong>:<br>[编号] 作者姓名, “文章标题,” <em>期刊名称</em>, 卷号, 期号, 页码, 出版年份.</p><p><strong>示例</strong>:<br>[2] L. Brown, “Network security challenges,” <em>IEEE Transactions on Computers</em>, vol. 68, no. 3, pp. 45-58, 2018.</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;论文参考文献的主要格式&quot;&gt;&lt;a href=&quot;#论文参考文献的主要格式&quot; class=&quot;headerlink&quot; title=&quot;论文参考文献的主要格式&quot;&gt;&lt;/a&gt;论文参考文献的主要格式&lt;/h3&gt;&lt;p&gt;在学术写作中，最常用的参考文献格式包括APA（美国心理学会）、MLA</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端防抖</title>
    <link href="https://promptonce.github.io/2024/10/13/%E5%89%8D%E7%AB%AF%E9%98%B2%E6%8A%96/"/>
    <id>https://promptonce.github.io/2024/10/13/%E5%89%8D%E7%AB%AF%E9%98%B2%E6%8A%96/</id>
    <published>2024-10-13T08:38:38.000Z</published>
    <updated>2024-10-13T08:46:48.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端防抖（Debounce）详解及应用"><a href="#前端防抖（Debounce）详解及应用" class="headerlink" title="前端防抖（Debounce）详解及应用"></a>前端防抖（Debounce）详解及应用</h3><p>在前端开发中，用户的操作可能会频繁触发事件，如输入框输入、窗口大小调整、按钮点击等。如果每次事件都立即触发相应的处理逻辑，可能会导致性能问题，甚至让用户体验变差。为了解决这些问题，我们可以使用<strong>防抖（Debounce）</strong>技术。防抖可以有效减少高频事件的处理次数，提高页面性能。</p><p>本文将从防抖的定义、实现、应用场景等多个方面进行详细讲解。</p><hr><h3 id="一、什么是防抖？"><a href="#一、什么是防抖？" class="headerlink" title="一、什么是防抖？"></a>一、什么是防抖？</h3><p><strong>防抖</strong>的基本概念是：<strong>在事件触发后，等待一定时间才执行回调函数，如果在等待时间内事件再次触发，则重新计时</strong>。防抖的主要目的在于减少不必要的高频触发，确保函数仅在一段时间后且没有其他触发事件时才执行。</p><h4 id="防抖的典型例子："><a href="#防抖的典型例子：" class="headerlink" title="防抖的典型例子："></a>防抖的典型例子：</h4><p>用户在搜索框中输入时，可能每个字符输入都会触发搜索请求。如果用户连续输入多个字符，就会发起多次请求。但实际上我们只希望用户停止输入时，再触发一次搜索。这时候，防抖就可以派上用场了。</p><h3 id="二、防抖的原理及实现"><a href="#二、防抖的原理及实现" class="headerlink" title="二、防抖的原理及实现"></a>二、防抖的原理及实现</h3><h4 id="1-核心原理"><a href="#1-核心原理" class="headerlink" title="1. 核心原理"></a>1. 核心原理</h4><p>防抖的核心原理是利用<strong>定时器</strong>，在事件触发时，不立即执行回调函数，而是延迟执行。如果在延迟期间事件再次触发，则清除之前的定时器，重新开始计时。只有当设定的延迟时间结束且没有新事件触发时，才会执行回调函数。</p><h4 id="2-防抖的基本实现"><a href="#2-防抖的基本实现" class="headerlink" title="2. 防抖的基本实现"></a>2. 防抖的基本实现</h4><p>我们可以通过 <code>setTimeout</code> 和 <code>clearTimeout</code> 来实现防抖功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;  <span class="comment">// 用于保存定时器的ID</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);  <span class="comment">// 如果定时器存在，先清除</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);        <span class="comment">// 在指定延迟后执行函数</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>debounce</code> 函数接受两个参数：</p><ul><li><code>fn</code>：需要防抖的函数。</li><li><code>delay</code>：延迟时间（毫秒）。</li></ul><p><strong>关键点</strong>在于：每次调用返回的函数时，都会重置定时器，只有在最后一次触发后的延迟时间过去，才会执行传入的函数。</p><h4 id="3-防抖函数的使用"><a href="#3-防抖函数的使用" class="headerlink" title="3. 防抖函数的使用"></a>3. 防抖函数的使用</h4><p>我们可以将防抖应用在用户的输入事件中，比如搜索框：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">search</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;搜索请求发起&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debouncedSearch = <span class="title function_">debounce</span>(search, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, debouncedSearch);</span><br></pre></td></tr></table></figure><p>在上面的例子中，每次用户在输入框中输入字符时，都会触发 <code>input</code> 事件。由于 <code>search</code> 函数被防抖处理，只有用户停止输入并且超过300毫秒后，搜索请求才会真正发出。</p><h3 id="三、防抖的应用场景"><a href="#三、防抖的应用场景" class="headerlink" title="三、防抖的应用场景"></a>三、防抖的应用场景</h3><h4 id="1-搜索框输入"><a href="#1-搜索框输入" class="headerlink" title="1. 搜索框输入"></a>1. <strong>搜索框输入</strong></h4><p>在用户输入时，避免每次字符变化都发起请求。防抖可以确保只在用户停止输入后的一段时间触发搜索请求。</p><h4 id="2-窗口调整大小"><a href="#2-窗口调整大小" class="headerlink" title="2. 窗口调整大小"></a>2. <strong>窗口调整大小</strong></h4><p>当用户调整浏览器窗口大小时，频繁触发 <code>resize</code> 事件，可能会导致页面性能下降。防抖可以保证在用户停止调整窗口大小后一段时间再执行相关操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;窗口大小调整后处理逻辑&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">300</span>));</span><br></pre></td></tr></table></figure><h4 id="3-按钮点击"><a href="#3-按钮点击" class="headerlink" title="3. 按钮点击"></a>3. <strong>按钮点击</strong></h4><p>有时我们需要防止按钮被短时间内重复点击，如避免表单多次提交。通过防抖，可以防止按钮被频繁点击触发事件。</p><h4 id="4-滚动事件"><a href="#4-滚动事件" class="headerlink" title="4. 滚动事件"></a>4. <strong>滚动事件</strong></h4><p>滚动页面时，会触发 <code>scroll</code> 事件，如果绑定了复杂的处理逻辑，可能会导致性能问题。防抖可以减少滚动时触发处理函数的频率。</p><h3 id="四、防抖和节流的区别"><a href="#四、防抖和节流的区别" class="headerlink" title="四、防抖和节流的区别"></a>四、防抖和节流的区别</h3><p>在前端优化中，防抖（Debounce）和节流（Throttle）是常用的两种技术。虽然它们都用于限制函数的触发频率，但原理和应用场景有所不同。</p><ul><li><strong>防抖（Debounce）</strong>：在连续事件触发的情况下，只执行最后一次触发后的函数。例如：用户输入完成后的搜索请求。</li><li><strong>节流（Throttle）</strong>：确保在一定时间间隔内，函数只执行一次。例如：滚动条滚动时，控制每100ms执行一次滚动逻辑。</li></ul><p>两者的区别可以简单理解为：</p><ul><li><strong>防抖</strong>：电梯等人，如果有新乘客进入，电梯门重新打开，直到没有人进入才开始运行。</li><li><strong>节流</strong>：定时发车，公交车无论人是否已到齐，每隔固定时间发车一次。</li></ul><h3 id="五、带立即执行的防抖"><a href="#五、带立即执行的防抖" class="headerlink" title="五、带立即执行的防抖"></a>五、带立即执行的防抖</h3><p>在某些情况下，我们可能希望函数在首次触发时立即执行，而不是等到延迟结束后才执行。例如：在用户开始输入时立即发起一个搜索请求，然后在后续输入时使用防抖。</p><p>为此，我们可以在防抖函数中增加一个<code>immediate</code>参数来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay, immediate = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> callNow = immediate &amp;&amp; !timer;  <span class="comment">// 判断是否立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!immediate) fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">        <span class="keyword">if</span> (callNow) fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);  <span class="comment">// 立即执行</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种实现中，如果 <code>immediate</code> 参数为 <code>true</code>，则函数在第一次事件触发时立即执行，然后在延迟时间内不会再次触发。</p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>防抖（Debounce）是一种常用的前端优化手段，用于处理高频事件，通过延迟执行回调函数来减少不必要的操作，提升性能。它适用于输入框搜索、窗口调整、按钮点击等场景。</p><p>通过本文的讲解，相信你已经掌握了防抖的概念、原理以及实际应用。防抖技术简单而高效，合理使用防抖可以显著提升页面性能并改善用户体验。在开发中根据不同的场景选择合适的优化方式（防抖或节流），能让应用更加高效和顺畅。</p><hr><p><strong>最后一点小建议</strong>：在复杂应用中，防抖技术需要和业务逻辑合理搭配。例如，在输入框防抖的场景中，可能还需要考虑到用户的快速输入与响应速度间的平衡。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前端防抖（Debounce）详解及应用&quot;&gt;&lt;a href=&quot;#前端防抖（Debounce）详解及应用&quot; class=&quot;headerlink&quot; title=&quot;前端防抖（Debounce）详解及应用&quot;&gt;&lt;/a&gt;前端防抖（Debounce）详解及应用&lt;/h3&gt;&lt;p&gt;在前</summary>
      
    
    
    
    
  </entry>
  
</feed>
